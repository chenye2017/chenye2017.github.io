<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="PHP,interview," />





  <link rel="alternate" href="/atom.xml" title="语法糖的博客" type="application/atom+xml" />






<meta name="description" content="收集一些总是考的面试题">
<meta name="keywords" content="PHP,interview">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP面试题">
<meta property="og:url" content="http://yoursite.com/2019/02/21/PHP面试题/index.html">
<meta property="og:site_name" content="语法糖的博客">
<meta property="og:description" content="收集一些总是考的面试题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190901201717.png">
<meta property="og:image" content="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190718195208.png">
<meta property="og:updated_time" content="2019-09-08T16:30:17.813Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP面试题">
<meta name="twitter:description" content="收集一些总是考的面试题">
<meta name="twitter:image" content="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190901201717.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/21/PHP面试题/"/>





  <title>PHP面试题 | 语法糖的博客</title>
  








</head>


    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="150" height="300" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: -40px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/wanko/wanko.model.json",0.5)</script>
  

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">语法糖的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">爱动漫，热爱LOL</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    




  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/21/PHP面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenye2017">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="语法糖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">PHP面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-21T10:50:35+08:00">
                2019-02-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index">
                    <span itemprop="name">PHP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>收集一些总是考的面试题</p>
<a id="more"></a>
<h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">怎么会导致跨域，为什么会出现跨域</span><br><span class="line">schema，或者ip地址，或者端口号 不同都会出现跨域。为了防止前端随意调用别人的后端接口，比如获取别人的某个邮箱文件内容（如果该邮箱网站用的cookie 存储登陆信息，而前端发送请求的时候会自动携带cookie 信息，如果不加以限制，cookie的使用会遭到恶意的攻击，csrf 攻击就是基于这一点，为了防止，让前端主动添加token 作为登陆凭证，调用后端接口）</span><br><span class="line"></span><br><span class="line">怎么解决跨域</span><br><span class="line">jsonp(用的比较少,好像是通过拼凑返回内容,让前端主动调用某个申明好的js文件), cors(通过在返回头中添加header信息,比如允许的域名,允许的调用方法，允许的自定义header参数，是否允许携带cookie (按理说cookie 应该在header 参数之中，但因为特殊，所以单独拿了出来))。</span><br><span class="line"></span><br><span class="line">什么是简单请求，什么是非简单请求</span><br><span class="line">好像是除了get post 之外的跨域请求都属于非简单请求，除此之外携带额外的参数也属于非简单请求。在发送非简单请求之前都会发送一个options请求，options请求没有请求体内容，你只需要把预定的header信息返回就好了，如果返回的header请求信息做了跨域处理，那么后面浏览器就不会屏蔽掉返回内容</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get post 区别</span><br><span class="line">get 可以浏览器收藏，参数会被缓存，post 不可以 ，</span><br><span class="line">get 参数只能被url 编码， post 支持多种方式编码 （比如 application/x-www-form-urlencoded， 比如json 格式）</span><br><span class="line">get 长度一般由浏览器决定，比较短 ， post 比较长</span><br><span class="line">get 传递的参数一般直接显示在url 地址栏， 相比较的话，post会比较安全，get不要放敏感信息， get 参数放在url 中，post参数放在request body 中</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">正则</span><br><span class="line">\d 数字</span><br><span class="line">\w 字符，字母数字下划线</span><br><span class="line">. * ? 组合匹配所有</span><br><span class="line">* 匹配0个或者很多歌</span><br><span class="line">? 匹配0个或者1个</span><br><span class="line">+ 匹配1个或者多个</span><br><span class="line"></span><br><span class="line">匹配电话号码</span><br><span class="line">preg_match_all(&apos;/1[23456]\d&#123;9&#125;/&apos;， 15618014759, $res1);</span><br><span class="line">匹配邮箱</span><br><span class="line">preg_match_all(&apos;/[a-zA-Z0-9]+[-_.]?[a-zA-Z]@[A-Za-z0-9]+\.[a-zA-Z]+/&apos;, &apos;1967196678@qq.com&apos;, $res2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http请求过程</span><br><span class="line">浏览器开始在host文件中查找对应网址的ip地址，找不到的话再在本地浏览器缓存中查找，再找不到去dns解析中查找，找到服务器ip地址之后，一般会先去监听的web服务器上，比如nginx，nginx对于静态文件直接返回，对于php类似文件有转发作用，比如转发给9000端口的php-fpm, 或者swoole， 然后他们再交给单个的工作进程中的php处理</span><br><span class="line"></span><br><span class="line">为什么http请求需要三次握手4次挥手</span><br><span class="line">第一次握手，验证cli 可以发消息到 server， server确定cli 可以推送消息，</span><br><span class="line">第二次握手，server验证自己可以推送消息，cli知道自己能推送消息并能收到返回消息，此时已经可以发送消息</span><br><span class="line">第三次握手，server知道自己可以同送消息，也能接收到消息，于是握手结束</span><br><span class="line"></span><br><span class="line">第一次挥手，通知sever 我要关闭了</span><br><span class="line">第二次挥手，server 通知cli， 好的，你关闭吧</span><br><span class="line">第三次挥手，server通知cli</span><br><span class="line">第四次挥手，cli告知server， 收到</span><br><span class="line">（通过netstat -antp 可以查看tcp 连接（第一个ip端口代表host机器，第二个代表客户端），最好是在同一台服务器上客户端curl ，就能看到两条连接）</span><br><span class="line">（tcpdump 可以看到抓包过程）</span><br></pre></td></tr></table></figure>
<p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190901201717.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用的http状态码</span><br><span class="line">200 成功</span><br><span class="line">300 重定向， 301 永久重定向，302 临时重定向， 304 未修改</span><br><span class="line">400 客户端错误，401 未授权（可能是未登录）， 403 禁止访问（没有权限），404 not found </span><br><span class="line">500 服务端错误，502 网关挂掉了, 504 超时</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https 和 http的区别</span><br><span class="line">https基于http， 有个ssl 包裹住用户信息</span><br><span class="line">https加密原理：因为非对称加解密很消耗cpu资源，所以利用对称加解密。怎么传输这个共同的密钥呢，肯定不能直接传输，一般是服务端生成一个公钥和私钥，公钥传输给客户端，客户端拿着公钥加密一个字符，服务端私钥解密这个字符，得到这个传输过程中加密数据的对称密钥，为了防止传输给客户端的公钥被修改。通过拉入第三方机构，第三方机构对（服务端信息 + 服务端产生的公钥） hash 成一个字符串 （相当于签名），然后利用第三方机构的私钥进行加密生成签名，因为不知道ca 的私钥，所以这个hash 不可能被改变，得到hash 值之后，对于证书中包含的 （服务端信息 + 服务端产生的密钥） + hash 算法 是否等于 hash 值进行比对，如果不一致说明公钥被修改了。</span><br><span class="line">简单点：</span><br><span class="line">1. 对称加密传输数据，需要获得一个别人获取不到的对称密钥？</span><br><span class="line">2. 通过非对称加密，由客户端的公钥加密字符，服务端私钥解密字符，这个字符就是对称密钥。客户端怎么获取一个非对称的公钥？</span><br><span class="line">3。 ca 证书包含公钥 + ca 私钥 生成的签名，无法修改， ca公钥（每个浏览器或者os 都已经包含了）解密获取签名前的hash， 验证证书内容是否改变，也就是保证公钥的正确性。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">什么是socket编程</span><br><span class="line">Socket 又称网络套接字，是一种操作系统提供的进程间通信机制。</span><br><span class="line"></span><br><span class="line">工作流程：</span><br><span class="line">1. 服务端先用 socket 函数来建立一个套接字，并调用 listen 函数，使服务端的这个端口和 IP 处于监听状态，等待客户端的连接</span><br><span class="line">2. 客户端用 socket 函数建立一个套接字，设定远程 IP 和端口，并调用 connect 函数</span><br><span class="line">3. 服务端用 accept 函数来接受远程计算机的连接，建立起与客户端之间的通信</span><br><span class="line">4. 完成通信以后，最后使用 close 函数关闭 socket 连接。</span><br><span class="line"></span><br><span class="line">感觉类似swoole, swoole 先开启监听，new 一个server</span><br><span class="line">然后写监听事件，用于cli的请求的接受</span><br><span class="line">请求处理完，关闭</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OAuth(Open Authorization) 协议为用户资源的授权提供了一个安全的、开放而又简易的标准，第三方无需使用用户的用户名与密码，就可以申请获得该用户资源的授权。</span><br><span class="line"></span><br><span class="line">运行流程：</span><br><span class="line"></span><br><span class="line">1. 用户打开客户端以后，客户端要求用户给予授权。</span><br><span class="line">2. 用户同意给予客户端授权</span><br><span class="line">3. 客户端使用上一步获得的授权，向认证服务器申请令牌。</span><br><span class="line">4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</span><br><span class="line">5. 客户端使用令牌，向资源服务器申请获取资源。</span><br><span class="line">6. 资源服务器确认令牌无误，同意向客户端开放资源</span><br><span class="line"></span><br><span class="line">OAuth 2.0 定义了四种授权方式，授权码模式、简化模式、密码模式、客户端模式，具体的授权流程，请看阮一峰老师的文章理解OAuth 2.0。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csrf 攻击</span><br><span class="line">防止因为浏览器请求本域名接口自动携带着cookie， 在第三方者在用户没有感知的情况下，调用api。解决办法是携带参数token</span><br><span class="line">xss 攻击</span><br><span class="line">用户输入信息没有做合理过滤，导致让前端页面调用非法的js等内容。用户信息过滤 </span><br><span class="line">sql 注入</span><br><span class="line">用户输入信息不合法, 导致sql执行用户命令。 用pdo，sql语句预处理功能，或者用户输入过滤。</span><br></pre></td></tr></table></figure>
<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP 位运算符 </span><br><span class="line">| 半个或</span><br><span class="line">&amp; 同或</span><br><span class="line">^ 异或</span><br><span class="line">~ 取反 （其实最常见的就是error_reporting(E_ALL ~E_NOTICE)）</span><br><span class="line">3 | 5 7</span><br><span class="line">3 &amp; 5 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">常用string ,arr 函数</span><br><span class="line">array:</span><br><span class="line">array_merge</span><br><span class="line">array_slice</span><br><span class="line">array_values</span><br><span class="line">array_keys</span><br><span class="line">array_columns</span><br><span class="line">is_array</span><br><span class="line">array_key_exists</span><br><span class="line">array_change_key_case</span><br><span class="line">array_diff</span><br><span class="line">array_intersect</span><br><span class="line">array_fill</span><br><span class="line">array_sum</span><br><span class="line">array_map</span><br><span class="line">array_reduce</span><br><span class="line">array_reverse</span><br><span class="line">key</span><br><span class="line">current</span><br><span class="line">next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string:</span><br><span class="line">explode</span><br><span class="line">substr</span><br><span class="line">strpos</span><br><span class="line">preg_split</span><br><span class="line">preg_match</span><br><span class="line">strstr</span><br><span class="line">sort</span><br><span class="line">rsort</span><br><span class="line">asort</span><br><span class="line">arsort</span><br><span class="line">ksort</span><br><span class="line">krsort</span><br><span class="line">usrot</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_merge 和 +  的区别</span><br><span class="line">+ 同key, 前面覆盖后面 （index 或者 关联）</span><br><span class="line">merge 关联后面覆盖前面，数字索引直接扩展开了 // $a = [1 =&gt;2]; $v = [1 =&gt; 3]; array_merge($a,$v); 输出 [2, 3]; 重新排序</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">php7新特性</span><br><span class="line"></span><br><span class="line">1.throwable 分成 error 和 exception，都可以被捕获</span><br><span class="line">2.太空舱运算符， 一般usort 里面排序</span><br><span class="line">3.三目运算符的缩写， ??</span><br><span class="line">4.define可以定义常量数组 (以前好像只有const 可以，const) //  const 和 define 的区别，但感觉实际还是define 用的比较多 https://www.jianshu.com/p/a38b81433183</span><br><span class="line">5.返回值也能严格要求返回类型</span><br><span class="line">6.传入参数类型声明的扩展，比如int</span><br><span class="line">7.命名空间合并</span><br><span class="line">8.closure call 替代bindTo 更加的方便</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php7为什么相较于php5性能有很大提升？</span><br><span class="line">减少内存分配次数，优化底层zval 数据结构(64 位减少到24 位)，字符串解析的优化，缓存hash</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php垃圾回收机制</span><br><span class="line">1、以php的引用计数机制为基础（php5.3以前只有该机制）（refcount 是1 的时候就删除， is_ref 是否是引用类型）</span><br><span class="line">2、同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题（php5.3开始引入该机制）（为了防止子变量中引用父变量，父变量unset 之后refcount 到不了0 一直得不到回收）</span><br><span class="line">其实最简单的防止那种慢性内存溢出的方式就是php-fpm 的连接重启(当然你要是一次性消耗了太多内存，还是会内存溢出的)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何解决php内存溢出问题（phpexcel中经常出现，第二个很管用）</span><br><span class="line">1. 增大 PHP 脚本的内存分配（这个不能一劳永逸）</span><br><span class="line">2. 变量引用之后及时销毁</span><br><span class="line">3. 将数据分批处理</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$z = 0.58;</span><br><span class="line">var_dump(intval($z * 100));</span><br></pre></td></tr></table></figure>
<p>答案是 57，所有语言对于小数的存取都是不精确的， 0.58其实是0.57999999，而且intval() 总是从遇到第一个不是数字开始截取，导致了0.57，比较通用的方法是转成别用intval, 或者用数学函数，bcmath扩展计算</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie 和 session 的 区别</span><br><span class="line">cookie 更像一个钥匙，因为没有加密，所以客户端可以查看和随意更改cookie的数据，cookie 对应的 session 才是服务端真正存储的序列化数据，</span><br><span class="line">php 中 cookie 默认名称是 phpsessid , 通过这个值，服务端php能识别客户端对应的用户</span><br><span class="line"></span><br><span class="line">什么是jwt， jwt 和 cookie, session 的区别</span><br><span class="line">jwt 是一种token 的实现方式，由base64 处理过，因为base64可以放解码，所以不要存储重要信息，存放一些基本的辨识用户的信息就好了。</span><br><span class="line">他是三段组成的，第一段是签名的加密算法，第二段是用户数据（载体）, 第三段是前面数据的签名，防止用户数据被修改。</span><br><span class="line">jwt相较于cookie 和session ,不需要服务端存储用户的基本信息，token下发到client ,完全由客户端保存, 可以防止csrf 攻击。但是jwt 下发之后除非做特殊处理比如服务端，否则不能失效，蛮尴尬的。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register和 _autoload 的区别</span><br><span class="line">现在的自动加载已经不用_autoload 了，这个只支持一个方法，现在一般用spl_autoload_register, 或者全部用composer， 但composer本质上还是spl_autload_register,他可以支持多个函数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">判断一个日期是否合法</span><br><span class="line">// 思路</span><br><span class="line">把一个日期转用strtotime 转换成时间戳再通过 date(), 转换成标准时间，和原先的日期比对是否相同，相同就合法，不同不合法</span><br><span class="line">// 注意：错误的时间date 也能转换，只是可能转换成1970 这样的时间</span><br><span class="line">// 字符串的比对比较耗时</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单引号，双引号区别</span><br><span class="line">单引号解析变量</span><br><span class="line">双引号不解析变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include require 区别</span><br><span class="line">include 包含文件不存在 warning</span><br><span class="line">require 错误</span><br><span class="line">required_once</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中文截取字符串</span><br><span class="line">mb_substr</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">平时开发用的设计模式</span><br><span class="line"></span><br><span class="line">单例  保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个，同时这个类还必须提供一个访问该类的全局访问点。（getInstance）</span><br><span class="line"></span><br><span class="line">工厂 定义一个创建对象的接口，但是让子类去实例化具体类。工厂方法模式让类的实例化延迟到子类中。tp中对于config文件的不同处理，有三个驱动比如 ini,yaml, php, 当我们想读取ini文件的时候，factory 方法中传入的是ini,然后拼凑命名空间，交给 Ini 类处理，方便扩展。还有日志的驱动，用文件还是 socket，cookie 的驱动用文件还是redis</span><br><span class="line"></span><br><span class="line">注册树  用一个属性保存各个类的实例，需要的时候就从这个属性中取，容器用的就是这种思想</span><br><span class="line"></span><br><span class="line">门面  方便静态调用. 实际调用的是别的类（感觉主要是这些方法中不需要实例，所以可以静态调用）（如果是多进程，对于那些连接的操作，感觉通过门面不行，因为单个连接实例可能不能用了，得还连接池中别的实例）</span><br><span class="line"></span><br><span class="line">依赖注入 通过对类中需要以来的对象，直接以参数的形式传入（需要携带参数类型，也就是类名），让容器通过反射自己去实例化，解耦了各个类的依赖，下次以来的类修改的时候，不用我们修改生成依赖类的代码</span><br><span class="line"></span><br><span class="line">生产者消费者 异步任务或者花费时间多的任务放入队列中,让消费者消费</span><br><span class="line"></span><br><span class="line">订阅发布 主体对象状态发生改变,与之关联的观察者对象会收到通知，并进行相应操作</span><br><span class="line"></span><br><span class="line">装饰模式（laravel 的路由，核心 array_reduce）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">常用的魔术方法</span><br><span class="line">__construct  类初始化</span><br><span class="line">__destruct  对象销毁的时候</span><br><span class="line">__call  调用的方法不能访问 （redis 类封装的时候很好用）</span><br><span class="line">__callStatic  调用的静态方法不能访问</span><br><span class="line">__get  获取的属性不能访问</span><br><span class="line">__set  设置的属性不能访问</span><br><span class="line">__isset  isset empty 不能访问的属性</span><br><span class="line">__unset unset 不能访问的属性</span><br><span class="line">__sleep  序列化一个对象的时候</span><br><span class="line">__wakeup  反序列一个对象的时候</span><br><span class="line">__clone 对象（作为两个实体的存在)</span><br><span class="line">__invoke 调用类实例像调用方法那样自动触发，像closure类自带这个方法，php中所有的匿名函数默认都是closure的实例，所以我们执行保存匿名函数的变量自动执行了这个方法</span><br><span class="line"></span><br><span class="line">魔术变量</span><br><span class="line">__CLASS__  类名</span><br><span class="line">__LINE__  行号</span><br><span class="line">__FILE__  文件名</span><br><span class="line">__METHOD__ 类中方法名</span><br><span class="line">__FUNCTION__ 普通方法名</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php 错误信息控制</span><br><span class="line">error_reporting(E_ALL)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trait Singleton &#123;&#125;</span><br><span class="line">多继承的实现</span><br><span class="line"></span><br><span class="line">class Db</span><br><span class="line">&#123;</span><br><span class="line">  use Singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">抽象类只能继承， extend ，接口可以实现多个，比如我想我这个类拥有foreach, 之类的功能， implement</span><br><span class="line"></span><br><span class="line">abstract 抽象类 （基本很少用）</span><br><span class="line">抽象类不能实例化</span><br><span class="line">抽象类中方法可以有方法体，没有方法体的只能定义abstract</span><br><span class="line"></span><br><span class="line">abstract 介于 class 和 interface 之间</span><br><span class="line"></span><br><span class="line">interface 接口</span><br><span class="line">interface 中不能用变量,但是可以有常量</span><br><span class="line">interface 中方法的访问权限只能是public, 不能是protected或者prviate, 方法不能有方法体，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">抽象类和接口中但凡没有方法体，子类必须去实现</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">static ,延迟静态绑定，</span><br><span class="line">self, parent 调用的方法的时候都是以当前类为标准,</span><br><span class="line">static 根据实际调用对象，每当到了static 的 时候调用的上一个确定了调用类的对象方法 (parent self 都不能改变调用对象)（优先调用自己的，如果自己的不能调用，调用父类的）（注意延迟调用的一定要是静态的static）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function test()</span><br><span class="line">    &#123;</span><br><span class="line">        static::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    protected static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); // 调用不了， 在 a 中调用b的protected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public static function foo()</span><br><span class="line">    &#123;</span><br><span class="line">        static::who();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public static function test()</span><br><span class="line">    &#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        parent::foo();</span><br><span class="line">        self::foo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B &#123;</span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();</span><br><span class="line"></span><br><span class="line">A C C</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">防止sql 注入</span><br><span class="line">sql 注入本质上就是害怕用户拼接sql, 在sql后面携带着用户传入的内容</span><br><span class="line"></span><br><span class="line">select name from user limit 10 offset . $offset;</span><br><span class="line"></span><br><span class="line">$offset = &apos; 0; select * from user&apos;;</span><br><span class="line"></span><br><span class="line">上述代码在pgsql 扩展中可以直接执行， 索然mysqli 中执行不了，</span><br><span class="line"></span><br><span class="line">handle:</span><br><span class="line">最好的方法就是利用预处理语句（那种 绑定??， 不能单纯的理解成嵌套变量进去，如果真的那样那还是防止不了sql注入）</span><br><span class="line"></span><br><span class="line">参数类型限定</span><br><span class="line">我们平时可以通过 转义 str_replace 之类的，但感觉这样很容易误伤，所以干脆还是用pdo的预处理语句吧</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">红包，我能想到比较简单的方法</span><br><span class="line">存在一定可能性死循环，就是后面数字的和已经不够一人一个了，已解决，每次计算剩余的最小值至少是每个1分，如果少于，则重新计算</span><br><span class="line">// mt_rand 只能产生随机整数，对于现实生活中的分，可以通过扩大100倍来解决</span><br><span class="line">// mt_getrandmx() 那个例子产生随机浮点数也是同样的道理</span><br><span class="line">// arr 是目前产生的数组</span><br><span class="line">// num 是剩余的值</span><br><span class="line">function productRand($arr, $num, $leave)</span><br><span class="line">&#123;</span><br><span class="line">    $tmp = mt_rand(0, $num);</span><br><span class="line">    $leveTotal = $num - $tmp; // 剩余的钱不能少于每个红包1分钱</span><br><span class="line">    if ($tmp == 0 || $tmp == $num || $leaveTotal &lt; $leave * 1) &#123;</span><br><span class="line">        return productRand($arr, $num);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $arr[] = $tmp;</span><br><span class="line">        $num -= $tmp;</span><br><span class="line">        return [$arr, $num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// $total 代表总数量</span><br><span class="line">// $count 代表红包个数</span><br><span class="line">function hongbao($total, $count)</span><br><span class="line">&#123;</span><br><span class="line">    $num = $num * 100;</span><br><span class="line">    $arr = [];</span><br><span class="line">    $top = $num;</span><br><span class="line">    for ($i = 0; $i &lt; $cishu - 1; $i++) &#123;</span><br><span class="line">    	$leave = $count - $i - 1; // 剩余红包个数</span><br><span class="line">        $res = productRand($arr, $top, $leave);</span><br><span class="line">        $arr = $res[0];</span><br><span class="line">        $top = $res[1]; </span><br><span class="line">    &#125;</span><br><span class="line">    $arr[] = $num - array_sum($arr);</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(hongbao(11, 4));</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步，异步区别 阻塞非阻塞区别</span><br><span class="line">同步，异步主要是获取返回值内容的时候，同步如果一次性不能获取返回内容，需要不断的轮训获取返回内容，异步返回内容会主动通知（swoole task异步任务， php-fpm模式下同步代码）</span><br><span class="line">阻塞和非阻塞主要是进程方面，阻塞api所在进程会被系统直接挂起，直到完成（sleep， io比如redis mysqli pdo 等），非阻塞的时候所在进程不受影响，可以做别的事情（array, string 函数）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ab 测试</span><br><span class="line">-n  发送的请求总数</span><br><span class="line">-c  并发量</span><br><span class="line">ab -n 5000 -c 200 http://www.baidu.com/ (注意末尾的斜线)</span><br><span class="line">Requests per second  每秒钟完成的请求数量</span><br><span class="line">Time per request  客户端等待时间</span><br><span class="line">Time per request 服务端等待时间</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yield  感觉就类似分页，有效减少内存的消耗（大数据量一次性读入内存吃不消），注意yield 的使用和数组还是有区别的.</span><br><span class="line">就相当于我们值读入部分数据到yield 中，我们还得foreach yield 抛出的数据（iterator 实现了迭代器，所以可以循环），循环去插入 取出yield 中的数据</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">  for($i = 1; $i&lt;5; $i++) &#123;</span><br><span class="line">      yield $i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$data = test();</span><br><span class="line">foreach ($data as $value) &#123;</span><br><span class="line">    var_dump($data-&gt;current(),$value);</span><br><span class="line">&#125; </span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">自带的接口</span><br><span class="line">iterator // 可以循环，下面的那些方法都是为了foreach能正确数据准备的</span><br><span class="line">class test implements Iterator</span><br><span class="line">&#123;</span><br><span class="line">    public $arr = [];</span><br><span class="line">    public $keyArr = [];</span><br><span class="line">    public $keyP = 0;</span><br><span class="line">    </span><br><span class="line">    public function __construct($arr)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;arr = $arr;</span><br><span class="line">        $this-&gt;keyArr = array_keys($arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function rewind()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement rewind() method.</span><br><span class="line">        reset($this-&gt;arr);</span><br><span class="line">        $this-&gt;keyP = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function current()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement current() method.</span><br><span class="line">        return pos($this-&gt;arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function next()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement next() method.</span><br><span class="line">        $this-&gt;keyP++;</span><br><span class="line">        return next($this-&gt;arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function key()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement key() method.</span><br><span class="line">        return $this-&gt;keyArr[$this-&gt;keyP];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function valid()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement valid() method.</span><br><span class="line">        return isset($this-&gt;keyArr[$this-&gt;keyP]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">php 进程间通信的方式</span><br><span class="line"></span><br><span class="line">第三方，比如redis</span><br><span class="line">消息队列， 也可以属于第三方</span><br><span class="line">共享内存， 不如swoole_table</span><br><span class="line">socket 文件</span><br><span class="line">管道 （应该类似 grep ）</span><br><span class="line">信号  字进程结束给父进程结束信号，请求回收</span><br><span class="line">tcp</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">几个预定义接口 spl标准类库</span><br><span class="line">ArrayAccess , 让类可以类似数组方式访问</span><br><span class="line">Countab  , 让类可以被 count()</span><br><span class="line">iterator  让对象能循环，几个必须实现的方法（current, 当前key, key, 就是 key 的名称， next 往下走， rewind, 重置，valid 是否有效，本身php 的数组就包含上述的实现，$arr[$key], key,next, reset, isset）</span><br><span class="line">iteratorAggregate 感觉就是方便的创造一个迭代器比较方便（官网上直接调用spl 的一个标准库, ArrayIterator(这是类，不是预定义接口), 数组对象转成 Iterator 方便）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">php 多进程写入同一个文件</span><br><span class="line">file_put_contents() // 添加第三个参数ex_lock</span><br><span class="line"></span><br><span class="line">对文件加锁，并对锁设置超时时间（类似给redis 那种锁 sex 锁， setnx 不能同时设置锁的时间，不具有原子性，这里面的锁，其实就是一个key-value）</span><br><span class="line"></span><br><span class="line">$resource = fopen(&apos;./tmp.log&apos;);</span><br><span class="line">$try = 0;</span><br><span class="line">while(!flock($resource, LOCK_EX) &amp;&amp; $try != 100)</span><br><span class="line"> &#123;</span><br><span class="line">	$try++;</span><br><span class="line">&#125; </span><br><span class="line">if ($try == 100) &#123;</span><br><span class="line">  return false; // 测试太多失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fwrite($res, &apos;ceshi&apos;);</span><br><span class="line">fclose($res); // 一般就能删除锁， 或者 flock($resource, UN_LOCK);</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">关于php这种锁，进程结束了就自动消失了，文档上说是脚本结束了，其实是一个意思（想一下我们用redis实现的锁，也是这样的，redis要是挂了，锁是不是没了）</span><br><span class="line">（当我用用了排它锁，我们再打开文件就是空的）</span><br><span class="line">(感觉写文件也不是直接往磁盘文件中写，而是写入一个缓存中，之后合并，因为当我用排它锁锁定一个文件的时候，fwrite 能立刻写入成功，虽然此时文件还没有修改)</span><br></pre></td></tr></table></figure>
<h1 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">laravel 调优</span><br><span class="line">1. 开启Opcache</span><br><span class="line">   2.关闭debug</span><br><span class="line">   3.缓存配置 php artisan config:cache</span><br><span class="line">   4.缓存路由 php artisan router:cache</span><br><span class="line">   5.类映射加载优化 php artisan optimize</span><br><span class="line">   6.根据需要只加载必要的中间件</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel 生命周期</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loc ,facade, contract, 服务提供者是什么</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel 和 其他框架的区别</span><br></pre></td></tr></table></figure>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql 性能优化</span><br><span class="line">1. 建立索引，优化索引 (最左前缀，覆盖索引，联合索引)</span><br><span class="line">2. 读写分离 （怎么保证一致性）（先删缓存，再插入数据，容易读到旧的内容，因为插入数据比较慢，中间容易被介入，可以插入数据之后，暂停几ms 删除缓存，这个ms 是根绝自身写入缓存的逻辑时间）（或者先插入数据，再删除缓存，因为插入数据比较慢，所以插入数据和删除缓存之间很难有空隙介入）</span><br><span class="line">3. 保证单表数据量，分库分表</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql 乐观锁，悲观锁，共享锁，排它锁，行锁，表锁</span><br><span class="line">乐观锁自己实现：每条数据后面都有个version, 读取version的内容，更新的时候观察这个version 是否改变，可以通过where 中加version 条件，如果version 改变了，则修改失败，如果version 没改变，则修改成功</span><br><span class="line">悲观锁 ，数据库自带。悲观锁又分为共享锁 lock in share mode 和排它锁 for update。共享锁锁住，不能更新，只能读取。排他锁锁住，也是不能更新，但是能读取</span><br><span class="line">行锁：innodb 引擎</span><br><span class="line">表锁： myisam 引擎</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql 的隔离级别</span><br><span class="line">读未提交</span><br><span class="line">读已提交</span><br><span class="line">可重复读</span><br><span class="line">可串行化</span><br><span class="line">默认的可重复读。</span><br><span class="line">并发事务中容易出现的问题，脏写(当前事务中写的内容被另一个事务回滚了)，脏读（读取的内容是一个未提交事务中内容），不可重复读（多次读取获取的内容不一致），幻读（后读取的内容多读了之前不存在的）。</span><br><span class="line">脏写大家都能防止，读未提交不能防止脏读，读已提交可以防止脏读，但不能防止不可重复读，幻读，因为他在一个事务中获取的视图可以是不一样的，但凡事务提交了，他就能获取该事物产生的新的试图，可重复读在事务过程中获取的视图始终唯一</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int(1) 和 int(11)的区别</span><br><span class="line">都是占用 4个字节，1 和 11 代表显示长度，除非添加 zerofill 要不然没区别</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">varchar 和 char 区别 (括号中是字符数)</span><br><span class="line">varchar 会根据内容长度确定大小，最大长度是定义的长度 * 3,varchar 中会存储字符的长度</span><br><span class="line">char 是固定大小，</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hash索引和b+索引的区别</span><br><span class="line">hash 索引只能用来进行等值匹配, 也不能排序，b+索引能用来排序，可以范围取值</span><br><span class="line"></span><br><span class="line">什么是聚簇索引</span><br><span class="line">索引本质上是树，聚簇索引的叶子结点是用户记录</span><br><span class="line">普通索引</span><br><span class="line">普通索引的叶子结点是主键(id), 索引字段， 主键主要是为了回表，通过id 去 聚簇索引中查找用户记录</span><br><span class="line">覆盖索引</span><br><span class="line">因为回表属于不连续的io， 比较耗时，如果不用回表，索引字段包含select 的内容，那就会很快，这种索引就叫覆盖索引</span><br><span class="line">联合索引</span><br><span class="line">给多个字段建立索引，联合索引是最左原则，得在前面的字段是等值的情况下，后面的字段才能符合要求（比如前面的字段是范围索引，那么取出来的数据是无序的，在无序的情况下，联合索引第二个字段是起不到排序的作用的）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb 和 myisam 存储引擎的区别</span><br><span class="line">innodb 是行锁，myisam表锁</span><br><span class="line">innodb 支持事务，myisam不支持</span><br><span class="line">innodb 数据和索引存储文件一样，myisam是分开的 </span><br><span class="line">innodb 中的聚簇索引的叶子结点就是数据记录或者主键，myisam中叶子结点只是数据的存储位置，所以肯定需要回表（感觉可以和第三点合并）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么样的字段适合建立索引 （索引建立的标准）</span><br><span class="line">区分度大的字段，查找起来更容易确定具体的记录，减少回表的内容</span><br><span class="line">对于字符串，需要先确定首部字符串，才能匹配类似字符串</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常见的索引</span><br><span class="line">主键， 唯一索引，复合索引，普通索引</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql_fetch_row, mysql_fetch_assoc, mysql_fetch_array 区别</span><br><span class="line">row 好像是数组，assoc 关联数组， array 是前面二者的结合体</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">limit, left join ,order by ,group by, where , select , from ,having </span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">left join</span><br><span class="line">where </span><br><span class="line">group by </span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">limit</span><br><span class="line"></span><br><span class="line">执行顺序： 先连接，再筛选，再分组，再having, 再select, 最后order by</span><br><span class="line">FROM</span><br><span class="line">ON</span><br><span class="line">JOIN</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">WITH CUBE 或 WITH ROLLUP</span><br><span class="line">HAVING</span><br><span class="line">SELECT</span><br><span class="line">DISTINCT</span><br><span class="line">ORDER BY</span><br><span class="line">TOP</span><br></pre></td></tr></table></figure>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190718195208.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">404   最长匹配原则，但是只能匹配到 a</span><br><span class="line">500   ~* 不区分大小写， 权重比 / 高</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nginx 负载均衡（属于反向代理）upstream prox_pass关键字</span><br><span class="line">轮询（默认）</span><br><span class="line">权重</span><br><span class="line">ip_hash</span><br><span class="line">url_hash</span><br><span class="line"></span><br><span class="line">upstream  test&#123;</span><br><span class="line">   server 127.0.0.1:8081 weight=1;</span><br><span class="line">   server  127.0.0.1:8082 weight=2;</span><br><span class="line">&#125;</span><br><span class="line">prox_pass http://test # 还可以配置back 备胎机器</span><br></pre></td></tr></table></figure>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 和 memecached的区别</span><br><span class="line">1. 更丰富的数据结构，除了缓存，更多的使用场景</span><br><span class="line">2. 单进程，只能利用单核</span><br><span class="line">3. redis 可以持久化 ,memcached 重启数据会丢失</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 怎么持久化</span><br><span class="line">AOF 记录每条命令，后面重新执行一遍</span><br><span class="line">RDB 类似快照，把缓存中数据都存储下来（利用back，防止始终阻塞）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 的常用数据类型</span><br><span class="line">string  key value 形式</span><br><span class="line">hash  数组，关联数组，索引数组</span><br><span class="line">list  队列，</span><br><span class="line">set  集合</span><br><span class="line">sort set  有序集合</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 的使用场景</span><br><span class="line">点赞，利用 incr</span><br><span class="line">排行榜，有序集合，分数sorce 作为排序标准</span><br><span class="line">api 限流（sort set 滑动窗口）</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">linux 常用命令</span><br><span class="line">cd  进入</span><br><span class="line">ls -la  展示</span><br><span class="line">tar 解压缩</span><br><span class="line">mkdir -p 新建文件夹</span><br><span class="line">touch 新建文件</span><br><span class="line">rm -rf  删除文件夹</span><br><span class="line">vim 编辑文件</span><br><span class="line">tail -f  动态查看文件变化</span><br><span class="line">netstat -antp 查看tcp 连接</span><br><span class="line">ps -ef  查看进程</span><br><span class="line">free 查看系统资源</span><br><span class="line">top  查看系统进程消耗资源</span><br><span class="line">df -h 查看系统盘</span><br><span class="line">alias -p 查看取别名</span><br><span class="line">find / -name 查找</span><br><span class="line">locate  查找</span><br><span class="line">chmod  修改权限</span><br><span class="line">chown  修改用户组用户</span><br><span class="line">wc -l 统计行数</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase 变基，比如把当前分支的分叉点移动到主分支最新节点，为的就是log日志中不产生分支</span><br><span class="line">git push origin master:master  推送本地master分支到远程master分支</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk 的使用</span><br><span class="line">awk -F &apos; &apos; &#123;&apos;print $1&apos;&#125; ./access.log |sort|uniq|wc -l   uniq只能合并相邻的不同的，所以要先排序</span><br></pre></td></tr></table></figure>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">4种排序</span><br><span class="line">从小到大</span><br><span class="line">1. 冒泡 (核心：每次一个数据到达最终位置，第一次确定最大的数字)</span><br><span class="line">   $arr = [20, 19, 88, 76, 43, 1];</span><br><span class="line"></span><br><span class="line">function maopao($arr) &#123;</span><br><span class="line">    $count = count($arr); </span><br><span class="line">    for($i=0; $i &lt; $count -1; $i++) &#123; // 最后一个数不用变动，位置自动确定</span><br><span class="line">        for ($j= 0; $j &lt; $count - 1 - $i; $j++) &#123; // 每次上浮的数字都要和没有确定的比较</span><br><span class="line">            if ($arr[$j] &gt; $arr[$j+1]) &#123;</span><br><span class="line">                list($arr[$j+1], $arr[$j]) = [$arr[$j], $arr[$j+1]];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.选择排序 (和冒泡的区别，这个每次选出一个最小的数，和冒泡一样，但是不移动数据，只是最终和确定的数组比较，如果不一致，才会移动)</span><br><span class="line">function xuanze1($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    for($i= 0; $i &lt; $count - 1; $i++) &#123;</span><br><span class="line">        $p = $i;</span><br><span class="line">        for ($j = $i; $j &lt; $count; $j++) &#123;</span><br><span class="line">            if ($arr[$j] &lt; $arr[$p]) &#123;</span><br><span class="line">                $p = $j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ($i != $p) &#123;</span><br><span class="line">            list($arr[$i], $arr[$p]) = [$arr[$p], $arr[$i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">3.插入排序 (核心，前面排好序的字段不断扩展，用来容纳新插入的数据)</span><br><span class="line">function charu($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    for ($i=1; $i &lt; $count; $i++) &#123;</span><br><span class="line">       </span><br><span class="line">        if ($arr[$i-1] &gt; $arr[$i]) &#123;</span><br><span class="line">            $tmp = $arr[$i];</span><br><span class="line">            for($j=$i-1; $j&gt;=0 &amp;&amp; $arr[$j] &gt; $tmp;$j--) &#123;</span><br><span class="line">                $arr[$j+1] = $arr[$j];</span><br><span class="line">            &#125;</span><br><span class="line">            $arr[$j+1] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">       // var_dump($arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">1. 快排：以一个数为基准，分原数组成两列，递归调用</span><br><span class="line">   function quick($arr)</span><br><span class="line">   &#123;</span><br><span class="line">    if (!$arr) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $tmp = $arr[0];</span><br><span class="line">    $left = $right = [];</span><br><span class="line">    $count = count($arr);</span><br><span class="line"></span><br><span class="line">    if ($count &gt; 1) &#123;</span><br><span class="line">        for ($i = 1; $i &lt; $count; $i++) &#123;</span><br><span class="line">            if ($arr[$i] &lt;= $tmp) &#123;</span><br><span class="line">                $left[] = $arr[$i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $right[] = $arr[$i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array_merge(quick($left), [$tmp], quick($right));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return $arr;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">查找 （注意查找的算法都是在排好序的基础上）</span><br><span class="line">1.二分查找</span><br><span class="line">function search1($arr, $num, $min, $max) &#123;</span><br><span class="line"></span><br><span class="line">    if ($min == $max &amp;&amp; $num != $arr[$min]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $tmp = ceil(($min + $max) / 2);</span><br><span class="line">    if ($num == $arr[$tmp]) &#123;</span><br><span class="line">        return $tmp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ($num &lt; $arr[$tmp]) &#123;</span><br><span class="line">            $max = $tmp-1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $min = $tmp + 1;</span><br><span class="line">        &#125;</span><br><span class="line">       return search1($arr, $num, $min, $max);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1000000个数字的整数， 大小是0 到 999999， 找出其中重复的数字.</span><br><span class="line"></span><br><span class="line">1. 最简单的。先排序，排序玩比较相邻数字是否相同，相同就添加进结果集。（二分 nlogn）</span><br><span class="line">2. 利用hash, 时间复杂度n, 空间复杂度n. 我们知道php 的数组就是一个hash, 我们可以遍历这个大的原始数据，然后把其中的数字都往一个预先的hash 里面塞，如果之前有值就代表重复.</span><br><span class="line">3. 因为大小是0 到 99999， 所以我们可以foreach ,然后把对应数据换算到我们要的位置上来，如果最后没有调回来，代表这个数字重复</span><br><span class="line"></span><br><span class="line">$arr = [2,3,1,0,2,5,3];</span><br><span class="line">// 转变过程</span><br><span class="line">// [1,3,2,0,2,5,3]</span><br><span class="line">// [3,1,2,0,2,5,3]</span><br><span class="line">// [0,1,2,3,2,5,3]</span><br><span class="line">// 2, 3 入结果集</span><br><span class="line">// foreach 的时候，如果 &amp;value,可以改变这次遍历的内容，单单$arr[$key] 只能改变下次遍历时候的$arr</span><br><span class="line"> function chongfu($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $chongfu = [];</span><br><span class="line">    foreach ($arr as $key =&gt; &amp;$value) &#123;</span><br><span class="line">        if ($value == $key) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            jiaohuan($arr, $chongfu, $key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return $chongfu;</span><br><span class="line">&#125;</span><br><span class="line">function jiaohuan(&amp;$arr, &amp;$chongfu, $key)</span><br><span class="line">&#123;</span><br><span class="line">    if ($key != $arr[$key]) &#123;</span><br><span class="line">       // var_dump($key, $arr[$key]);</span><br><span class="line">        $value = $arr[$key];</span><br><span class="line">        if ($value == $arr[$value]) &#123;</span><br><span class="line">            $chongfu[] = $value;//var_dump($chongfu, $key, $value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list($arr[$key], $arr[$value]) = [$arr[$value], $arr[$key]];</span><br><span class="line">            //var_dump($arr, $key);</span><br><span class="line">            jiaohuan($arr, $chongfu, $key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(chongfu($arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">广度优先算法</span><br></pre></td></tr></table></figure>
<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单系统</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100件商品高并发，先到先得</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">30w 的ip地址,类似如下</span><br><span class="line">10.23.25.0  10.23.25.255    湖南省 长沙市</span><br><span class="line">请设计出一个实现方式,可以给某个IP找到对应的省和市。要求效率尽可能的高。</span><br><span class="line"></span><br><span class="line">利用redis的zset, 把ip地址变成数字作为score 存储，然后把各个省市的最大ip和最小ip存储，利用 zset 的范围，取到第一个最大的城市就是该城市</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.请设计一个投票系统,满足如下要求</span><br><span class="line">a.一个用户10分钟内对一个投票只能成功完成一次。</span><br><span class="line">b.一个用户每个自然日最多只能成功完成50个不同的投票。</span><br><span class="line"></span><br><span class="line">每次投票成功， 就往set 里面塞入一个投票类型，每次投片前都检测下，有没有超过50</span><br><span class="line">利用redis, userid_投的票  =&gt; 时间，如果 时间 + 10 分钟 &gt;= 现在时间就给投票</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.用php写一个函数，获取一个文本文件最后$n行内容，要求尽可能效率更高，并可以跨平台使用</span><br><span class="line"></span><br><span class="line">利用exec 执行 tail -f , 主要就是tail -f 没有停止，会持续获取，但也没关系，手动停了就好了，注意的是这块没停止的话，进程一直阻塞着，不能去往下执行，打印 exec 执行后的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$filename = &apos;/opt/httpd/logs/access_log&apos;;</span><br><span class="line">$xie = &apos;./xie.log&apos;;</span><br><span class="line"></span><br><span class="line">function kan($line, $file, $xie)</span><br><span class="line">&#123;</span><br><span class="line">    $line = $line -1;</span><br><span class="line">    $x = fopen($xie, &apos;a+&apos;);</span><br><span class="line">    $res = fopen($file, &apos;a+&apos;);</span><br><span class="line">    $postion = -2;</span><br><span class="line">   </span><br><span class="line">    $str = fgets($res);</span><br><span class="line">   </span><br><span class="line">    while ($line) &#123;</span><br><span class="line">        fseek($res, $postion, SEEK_END);</span><br><span class="line">        $tmp = fgetc($res);</span><br><span class="line">        $postion -= 1;</span><br><span class="line">       </span><br><span class="line">        if ($tmp == PHP_EOL) &#123;</span><br><span class="line">            </span><br><span class="line">            $str .= fgets($res);</span><br><span class="line">            $line -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var_dump($str);exit;</span><br><span class="line">    fwrite($x, $str);</span><br><span class="line">&#125;</span><br><span class="line">kan( 5, $filename, $xie);</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">有两个文本文件 A.txt B.txt</span><br><span class="line">A.txt 3000万行，userid唯一，userid和username以空格分隔，如下所示：</span><br><span class="line">userid  username</span><br><span class="line">1       yi</span><br><span class="line">2       er</span><br><span class="line">3       san</span><br><span class="line">...     ...</span><br><span class="line">B.txt 3000万行，userid唯一，userid和realname以空格分隔，如下所示：</span><br><span class="line">userid  realname</span><br><span class="line">1       一</span><br><span class="line">2       二</span><br><span class="line">3       三</span><br><span class="line"></span><br><span class="line">感觉可以把 a读入一个数组中，然后遍历 b ，往b中写入相应数据 。 a可以看做一个hash，所以查找一个数据就是1， 然后遍历 b文件，n， 所以总的复杂度是 n.</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wp.png" alt="chenye2017 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/zp1.png" alt="chenye2017 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

  <div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
  </div>

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/PHP/" rel="tag"><i class="fa fa-tag"></i> PHP</a>
          
            <a href="/tags/interview/" rel="tag"><i class="fa fa-tag"></i> interview</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/03/laravel-核心技术读书笔记/" rel="next" title="laravel 核心技术读书笔记">
                <i class="fa fa-chevron-left"></i> laravel 核心技术读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/21/加密解密/" rel="prev" title="加密解密">
                加密解密 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my.png"
                alt="chenye2017" />
            
              <p class="site-author-name" itemprop="name">chenye2017</p>
              <p class="site-description motion-element" itemprop="description">想用善良改变世界</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">77</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">79</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/chenye2017" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:1967196626@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/3215254425" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-globe"></i>Weibo</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-crosshairs"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/" title="百度" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Web"><span class="nav-number">1.</span> <span class="nav-text">Web</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PHP"><span class="nav-number">2.</span> <span class="nav-text">PHP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Laravel"><span class="nav-number">3.</span> <span class="nav-text">Laravel</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql"><span class="nav-number">4.</span> <span class="nav-text">Mysql</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Nginx"><span class="nav-number">5.</span> <span class="nav-text">Nginx</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">6.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux"><span class="nav-number">7.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#算法"><span class="nav-number">8.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#项目"><span class="nav-number">9.</span> <span class="nav-text">项目</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenye2017</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span> |
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>





  <span class="post-meta-divider">|</span>





  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count"> | 博客全站共126.2k字</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  


  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/src/fireworks.js"></script>



</body>
</html>
