<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="go," />





  <link rel="alternate" href="/atom.xml" title="语法糖的博客" type="application/atom+xml" />






<meta name="description" content="读源码学到的新的语法，补充自己对go的更多了解">
<meta name="keywords" content="go">
<meta property="og:type" content="article">
<meta property="og:title" content="go 小知识点">
<meta property="og:url" content="http://yoursite.com/2020/07/14/go-小知识点/index.html">
<meta property="og:site_name" content="语法糖的博客">
<meta property="og:description" content="读源码学到的新的语法，补充自己对go的更多了解">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/Image.png">
<meta property="og:updated_time" content="2021-01-08T08:46:11.660Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="go 小知识点">
<meta name="twitter:description" content="读源码学到的新的语法，补充自己对go的更多了解">
<meta name="twitter:image" content="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/Image.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/14/go-小知识点/"/>





  <title>go 小知识点 | 语法糖的博客</title>
  








</head>


    <script type="text/javascript" src="/live2d/script.js"></script>
    <canvas id="live2dcanvas" width="150" height="300" class="live2d"></canvas>
    <style>
      #live2dcanvas {
        position: fixed;
        right: 0px;
        z-index: 999;
        pointer-events: none;
        bottom: -40px;
      }
    </style>
    <script>loadlive2d("live2dcanvas" ,"/live2d/assets/wanko/wanko.model.json",0.5)</script>
  

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">语法糖的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">爱动漫，热爱LOL</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    




  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/14/go-小知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="chenye2017">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="语法糖的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">go 小知识点</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-14T17:57:32+08:00">
                2020-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>读源码学到的新的语法，补充自己对go的更多了解</p>
<a id="more"></a>
<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>今天在看别人代码的时候发现了一个 interface.([]int) 新用法，以前不知道，这个其实就是断言 assert， 其实php 中也经常用到</p>
<p>1.go 中目前我接触到断言,取map值的时候 ，a, ok :=  map[“name”],  虽然没有这个ok 也是能正确运行的，比如 a := map[“name”]</p>
<p>2.interface 断言， interface.([]int), 转换成[]int类型</p>
<p>3.断言失败会取断言类型的默认值，如果断言失败还是不知道原因可以用reflect.TypeOf获取断言的真正类型。断言失败的时候经常就是胯类型断言，比如你知道一个类型[]map[string]string, 但你收到这个值的时候不能直接断言interface.([]map[string]string), 而是应该 interface.([]interface{}),  for range 每个值断言map[string]string.<strong> 所以能用结构体就用结构体接受吧，要不然每层断言很辛苦  ，曾经断言60行的代码，用结构体 不到10行 就接受了，还不用处理一堆的断言错误</strong>。</p>
<p>4.关于类型 interface{} 兼容 string， 但不代表 []interface{} 兼容 []string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Can I convert a []T to an []interface&#123;&#125;? ¶</span><br><span class="line">Not directly. It is disallowed by the language specification because the two types do not have the same representation in memory. It is necessary to copy the elements individually to the destination slice. This example converts a slice of int to a slice of interface&#123;&#125;:</span><br><span class="line"></span><br><span class="line">t := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">s := make([]interface&#123;&#125;, len(t))</span><br><span class="line">for i, v := range t &#123;</span><br><span class="line">    s[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有另一种方式实现转换</span><br><span class="line"></span><br><span class="line">[]interface&#123;&#125;&#123;&quot;11&quot;, &quot;112&quot;&#125;</span><br><span class="line"></span><br><span class="line">notice : []interface&#123;&#125;&#123;v...&#125; , 这样不行的，这样转换的interface slice， 数量总是 1</span><br></pre></td></tr></table></figure>
<p>5.今个写代码遇到件事， 对于  int 1, 我用 string(int 1) —–&gt; 想直接得到结果，这样是不行的，还是老老实的用 strconv.Itoa,  string 应该直接用在字符类型，比如 rune  []byte 这类 </p>
<h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><p>奇怪的现象</p>
<p>1.最近用slice 总容易写一个bug， 就是make 的时候给定大小，然后append slice， 这样会导致一直往后面插入slice ，而不是从0 开始修改slice 的值。原因就是 make 的时候 len 和 cap 都是 给定的值，每个位置都有自己的默认值，append 的元素已经没地方放了，只会动态扩容 slice 来容纳给更多的内容。</p>
<p>2.slice 和 map 虽然是地址类型，但是我们 for range 的时候改变值并不会修改自身，原因就是因为for range 的时候是copy 。copy 之后dst 和src 指向的底层 array 不一样，导致指向 dst 和  src 的slice 随意修改都不影响对方。</p>
<p>3.copy 也有需要注意的地方，就是 src 的len &gt; dst 的len ，并不会copy 全，也就是copy的时候并不会动态扩容</p>
<p>4.切片的传递属于引用传递，我们日常使用切片也是引用。所以我们在用切片相互赋值的时候，修改某一个可能会影响两一个。原因就是slice 底层指向了同一个数组</p>
<p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/Image.png" alt=""></p>
<p>5.我们在什么情况下使用切片不会影响到之前赋值的切片呢，就是在切片动态扩容，改变切片地址指向的时候，比如 append 的时候。因为我们一般切片创建用的 make，make slice  len == cap ，当我们append 的时候必然扩容。</p>
<p>6.切片是由3个属性决定， 指针 ，len， cap 一般情况下我们 len 和 cap 都一样， 所以会导致我们觉得 指针改变，切片就变化，指针不变，切片就不变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func m(modify[]int) []int&#123;</span><br><span class="line">	fmt.Printf(&quot;\n %p&quot;, modify)</span><br><span class="line">	modify = append(modify, 13)</span><br><span class="line">	fmt.Printf(&quot;\n %p \n&quot;, modify)</span><br><span class="line">	fmt.Println(len(modify), cap(modify), modify)</span><br><span class="line">	return  modify</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">	a4 := make([]int, 2,10)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;%p \n&quot;, a4)</span><br><span class="line">	m(a4)</span><br><span class="line">	fmt.Printf(&quot;%p&quot;, a4)</span><br><span class="line">	fmt.Println(a4, len(a4), cap(a4))</span><br><span class="line">	&#125;</span><br><span class="line">// 这个例子a4 没有变化，虽然 没有扩容 ，指针没变，一般情况下如果m 方法中我们 m[0] = 12, 这样a4 必然改变、</span><br><span class="line">// 这个例子中 ，虽然没有扩容，但是 cap 和 len 没有通过函数返回，导致即使 a4在 m 方法中没有扩容，指针没改变，m 方法中 append 13 也没有影响 a4 。 仅在m 方法中a4 被影响了一小会,因为受影响的 len 没有返回，所以退出m方法， a4又还原了。这也是 append 必须有接受值的原因才能改变slice</span><br></pre></td></tr></table></figure>
<p>6.我们var 定义 []int 的时候，[]int 是nil， 所以我们不能给他赋值。但是我们make 的时候，虽然此时没有开辟内存空间，但是point 是有值的。！！！所以如果用var 定义的变量赋值会报address 不存在错误，如果用make 就不会。</p>
<p>7.for range 的时候只循环len 的内容，不循环cap 的内容</p>
<h1 id="channel定义"><a href="#channel定义" class="headerlink" title="channel定义"></a>channel定义</h1><p>之前看过对channel 的定义最好不要在全局，之前不知道为啥原因，当时因为想做缓冲channel， 而以为var 没法做，所以一直没用全局channel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var channel = make([]chan task, 10)</span><br><span class="line">// 10 个的缓冲， 然后是 task 组成的chan 的slice</span><br><span class="line"></span><br><span class="line">slice 用make 和 自身 定义的区别</span><br><span class="line">make([]int, 10)  [0 0 0 ..]</span><br><span class="line">[]int&#123;&#125;  就是nil</span><br></pre></td></tr></table></figure>
<h1 id="goroutine的意义"><a href="#goroutine的意义" class="headerlink" title="goroutine的意义"></a>goroutine的意义</h1><p>把一个任务分成很多部分，每个任务完成的周期很短。多个任务中我们可以通过channel 进行通信。如果我们通过单个channel ，在进行io的时候会阻塞的， 所以我们需要多个channel 来配合多个goroutine。多个goroutine消耗多个channel, 取数据的时候，可以把channel 传入goroutine当中，来消耗特定的channel。投递数据的时候咋办？当往特定的channel 中投递任务，因为go不像php 那样可以拼变量名，我们可以先把多个channel 放在一个数组中，然后通过数组index 去取特定的channel。</p>
<p>go  slice 结构， （指向array 的指针，len, cap）</p>
<p>（go 中slice 的改动会及时没有用 &amp; 也会影响自身）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func handle(a []string)  &#123;</span><br><span class="line">	a[0] = &quot;bb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	b := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line">	</span><br><span class="line">	c := make([]string, len(b))</span><br><span class="line">	copy(c, b) // copy 的话就不会影响,注意copy 的时候一定要len 一样，否则会copy不全</span><br><span class="line">	</span><br><span class="line">	// 这种直接赋值的话， c 的改动会直接影响b</span><br><span class="line">	// c := b</span><br><span class="line">	</span><br><span class="line">	handle(c)</span><br><span class="line">	fmt.Println(b, c)</span><br><span class="line"></span><br><span class="line">	a := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line">	sort.Strings(a)</span><br><span class="line"></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(copy 方便数组的拷贝，不影响原始数组的变动)</p>
<p>（arr := […]int{1,2,3,4}, arr[1:2:3], start 1 end 2  len 3, 索引的位置）</p>
<p>// go 中的引用类型</p>
<p>引用类型和原始的基本类型恰恰相反，它的修改可以影响到任何引用到它的变量。在Go语言中，引用类型有切片、map、接口、函数类型以及<code>chan</code>。</p>
<p>引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。</p>
<p>//  go 中经常这样，类型别名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Duration int64</span><br></pre></td></tr></table></figure>
<p>// go 可变参数</p>
<p>可以变参数，可以是任意多个。我们自己也可以定义可以变参数，可变参数的定义，在类型前加上省略号…即可。</p>
<p>// 组合类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	email string</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type admin struct &#123;</span><br><span class="line">	user</span><br><span class="line">	level string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	ad:=admin&#123;user&#123;&quot;张三&quot;,&quot;zhangsan@flysnow.org&quot;&#125;,&quot;管理员&quot;&#125;</span><br><span class="line">	fmt.Println(&quot;可以直接调用,名字为：&quot;,ad.name) // 能运行</span><br><span class="line">	fmt.Println(&quot;也可以通过内部类型调用,名字为：&quot;,ad.user.name) // 能运行</span><br><span class="line">	fmt.Println(&quot;但是新增加的属性只能直接调用，级别为：&quot;,ad.level)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Admin struct &#123;</span><br><span class="line">	user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user 无法被导出，因为 小写，类似严格访问类型</span><br></pre></td></tr></table></figure>
<p>// race 检测对共享变量的修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -race 10.go</span><br><span class="line"></span><br><span class="line">10.exe</span><br></pre></td></tr></table></figure>
<p>// sync 包真的是解决并发问题的一个优点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;runtime&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	count int32</span><br><span class="line">	wg    sync.WaitGroup</span><br><span class="line">	mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	wg.Add(2) // 计数器</span><br><span class="line">	go incCount()</span><br><span class="line">	go incCount()</span><br><span class="line">	wg.Wait() // 如果信号量不到0 main 进程就一直堵塞</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func incCount() &#123;</span><br><span class="line">	defer wg.Done()</span><br><span class="line">	for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">		mutex.Lock() // 只能有一个goroutine 进来</span><br><span class="line">		value := count</span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		value++</span><br><span class="line">		count = value</span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 很经典的一个关于获取三个url 最快速的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func mirroredQuery() string &#123;</span><br><span class="line">    responses := make(chan string, 3)</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;asia.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;europe.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;americas.gopl.io&quot;) &#125;()</span><br><span class="line">    return &lt;-responses // return the quickest response</span><br><span class="line">&#125;</span><br><span class="line">func request(hostname string) (response string) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure>
<h1 id="json-序列化的小问题"><a href="#json-序列化的小问题" class="headerlink" title="json 序列化的小问题"></a>json 序列化的小问题</h1><p>json 协议没有int 类型，只有 number 类型。int 都会被解析成 float64， 注意！！</p>
<p>上面的描述有bug ，今天一个str  json 反序列化的时候很成功，啥时候会出现上面问题，通过 interface{} 断言的时候。</p>
<p>json  序列化的时候如果没有这个值，就不给客户端 （比如我们更倾向于返回空对象，而不是一个完整对象，然后值都是空的），可以使用json tag 中的 omitempty </p>
<p>json 序列化的时候如果不想要这个，可以直接 - （比如密码这类我们不想暴露给客户端，我们只是我们后端struct 使用，并不需要给客户端）</p>
<p>json 我们也可以用 int 接受 string 类型 （需要注意的是 我们再次 json序列化的时候 还是 string ）</p>
<p>今天遇到一个很好用json 方法，<a href="https://medium.com/@xfstart07/go-json-%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81-e689522a1f1f" target="_blank" rel="noopener">就当做json 序列化和 反序列化前的操作</a></p>
<h1 id="url处理"><a href="#url处理" class="headerlink" title="url处理"></a>url处理</h1><p>最近有一个很恶性的需求，就是解析别人填入的url， 再添加一些想要的参数，组成新的url 返回，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">u, err := url.Parse(href)  // 解析成一个url 对象，这个url 对象有个 string() 方法，可以直接输出这个 href</span><br><span class="line">// 获取 query</span><br><span class="line">query := u.RawQuery  </span><br><span class="line">// 解析	query</span><br><span class="line">queryMap, err := url.ParseQuery(query) // 返回一个values 对象，是一个 map[string][]string</span><br><span class="line">// go 中一个参数默认对应一个slice， 如果是单个参数，就是slice 的第一位啦</span><br><span class="line">// 这个values 有很多方法，如果想改参数试试 set， 注意参数是[]string, 否则会整体覆盖哦</span><br><span class="line">// 注意map 赋值是不会被修改的，所以还是调用他的方法吧</span><br><span class="line">queryMap.Encode()</span><br><span class="line">u.RawQuery = queryMap.Encode()</span><br><span class="line">// 组成新的query 参数,再赋值下就能得到新的url</span><br></pre></td></tr></table></figure>
<h1 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>golang 发送http 请求没有 php 那么直接，其实php 也没有那么直接，毕竟curl 那么一大串，只是php 的curl 面向过程，看起来是那么自然，从上而下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">resp, err := http.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line">//</span><br><span class="line">上面的方法编程平时应该用不到，因为我们的请求至少需要一个超时时间吧</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">resp, err := clt.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line">// 不是那么丝滑，需要用客户端发送请求，但又是那么的符合生活，像我们平时请求就应该有个客户端</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 本质</span><br><span class="line">req, err := http.NewRequest(&quot;GET&quot;, &quot;http://www.baidu.com&quot;, nil)</span><br><span class="line"></span><br><span class="line">//然后http.client 结构体的 Do 方法</span><br><span class="line">//http.DefaultClient可以换为另外一个http.client</span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure>
<p>评论 ：Go的get请求面上有好几种请求方式，实则只有一种：</p>
<p>1、使用<code>http.NewRequest</code>函数获得<code>request</code>实体</p>
<p>2、利用<code>http.client</code>结构体的<code>Do</code>方法，将<code>request</code>实体传入<code>Do</code>方法中。</p>
<h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line">resp, err := http.Post(&quot;xxxxxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">注意这个body 是个io.reader. 通过这个strings.NewReader 转变来，显然，这个方法的参数是 strings</span><br><span class="line">// 当我们的content-type 是 application/ json, 我们这块就不能用 data.Encode 了而是应该用 json .Marc</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">var r http.Request</span><br><span class="line">r.ParseForm()</span><br><span class="line">r.Form.Add(&quot;xxx&quot;, &quot;xxx&quot;)</span><br><span class="line">body := strings.NewReader(r.Form.Encode())</span><br><span class="line">http.Post(&quot;xxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">// 这种form 请求之前在js 里面用的很经常，简单哇</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">http.PostForm(&quot;xxxx&quot;, data)</span><br><span class="line"></span><br><span class="line">// golang 封装的postForm</span><br></pre></td></tr></table></figure>
<p>当然上面的方法本质上也是用client 发出来的</p>
<p>然后client 本质也是依靠 newRequest</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">req.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure>
<p>!!!notice</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">添加request header</span><br><span class="line">net/http包没有封装直接使用请求带header的get或者post方法，所以，要想请求中带header，只能使用NewRequest方法。</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">//此处还可以写req.Header.Set(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line">req.Header.Add(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure>
<p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。</p>
<p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。<br>这俩方法是有区别的，Golang底层Header的实现是一个<code>map[string][]string</code>，<code>req.Header.Set</code>方法如果原来Header中没有值，那么是没问题的，如果又值，会将原来的值替换掉。而<code>req.Header.Add</code>的话，是在原来值的基础上，再<code>append</code>一个值，例如，原来header的值是“s”，我后<code>req.Header.Add</code>一个”a”的话，变成了<code>[s a]</code>。但是，获取header值的方法<code>req.Header.Get</code>确只取第一个，所以，如果原来有值，重新<code>req.Header.Add</code>一个新值的话，<code>req.Header.Get</code>得到的值不变。</p>
<p>其实不止是header 会这样，query 参数也会这样。</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">	&quot;net/url&quot;</span><br><span class="line">	&quot;io/ioutil&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">content, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">respBody := string(content)</span><br></pre></td></tr></table></figure>
<p>获取返回值</p>
<h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>go sort 已经有人封装好包了，相比较自己写快排，冒泡的好处就是，这个包会根据效率自动选择合适的排序方式，我们需要做的就是实现sort 中的接口 （<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）" target="_blank" rel="noopener">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Len()  获取要排序的slice 的len</span><br><span class="line">Less() return s[i] &lt; s[j]  默认倒序</span><br><span class="line">Swap(i, j int) 交换  // s[i], s[j] = s[j],s[i]</span><br><span class="line"></span><br><span class="line">sort.Sort([]object)</span><br></pre></td></tr></table></figure>
<p>对于倒序，很简单的实践方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse([]object)) // 帮我们少写了好多代码</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面的用法得写一堆东西，还有简单的方式</span><br><span class="line"></span><br><span class="line">直接调用  sort.Slice() 方法</span><br></pre></td></tr></table></figure>
<h2 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a>runtime.Caller</h2><p>在调用公司组件的时候，发现log 输出信息有问题，错误行号和文件是上一层函数调用，而不是我想输出的地方的调用。问题就出在，runtime.Caller(skip), 这个参数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">for i:=0; i&lt;=4; i++ &#123;</span><br><span class="line">		_, file, line, _ := runtime.Caller(i)</span><br><span class="line">		fmt.Println(file,line,&quot;=====&quot;,i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">// 如果 caller(i)  i 是 0 的时候，就是当前文件的输出，因为这个方法被封装了，所以，不管我在项目  // 中哪个地方调用，每次输出内容都是一样的。</span><br><span class="line">//   试试不调用组件，在单独文件中 runtime.Caller(i) 输出试试，就会发现当i = 0 时候这个方法的真  // 正含义。</span><br><span class="line"></span><br><span class="line">// 看看beego 中获取行号和文件名的方法</span><br><span class="line"></span><br><span class="line">func FILE() string &#123;</span><br><span class="line"></span><br><span class="line">    _, file, _, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return file</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// __LINE__ returns the line number at which the function was invoked</span><br><span class="line"></span><br><span class="line">func LINE() int &#123;</span><br><span class="line"></span><br><span class="line">    _, _, line, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return line</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skip 1 ,仅仅跳出当前方法所在的文件，因为他仅仅封装了一层</span><br></pre></td></tr></table></figure>
<p><a href="https://studygolang.com/articles/3116" target="_blank" rel="noopener">https://studygolang.com/articles/3116</a>, 这篇文章对 call 和 calls 方法讲解的比较细致</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pc := make([]uintptr, 1024)</span><br><span class="line">for skip := 0; ; skip++ &#123;</span><br><span class="line">    n := runtime.Callers(skip, pc)</span><br><span class="line">    if n &lt;= 0 &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc[:n])</span><br><span class="line">&#125;</span><br><span class="line">// 当我们调用 callers 方法的时候，pc 这个array 的容量一定要足够大，否则 n 一直不会渠道数据</span><br><span class="line">// runtime.FuncForPC(pc[skip]).FileLine(pc[skip]) , 这个方法比较好玩，从上面calles 获取   //到的指针连获取对应方法的方法名和 函数</span><br></pre></td></tr></table></figure>
<p><a href="https://colobu.com/2018/11/03/get-function-name-in-go/" target="_blank" rel="noopener">https://colobu.com/2018/11/03/get-function-name-in-go/</a>, 这篇文章也对上面两个方法做了详细的解释</p>
<h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>429  ，限流了</p>
<p>499 ， 服务端返回的时间超出客户端设置的超时时间，到这客户端提前关闭</p>
<h2 id="fmt问题"><a href="#fmt问题" class="headerlink" title="fmt问题"></a>fmt问题</h2><p>平时为了打印结构体我们就用 fmt.printf(“%+v”), 但当我们用[]<em>struct 的时候，这个打印就不好使了，会直接打印内存地址（我们为啥要用</em>struct， 因为遍历的时候 struct 不能修改值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type Stu struct &#123;</span><br><span class="line">	Name string `json:&quot;name&quot;`</span><br><span class="line">	Age string `json:&quot;age&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*func (t *Stu)String()  string&#123;</span><br><span class="line">	return &quot;11&quot;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">	str := `</span><br><span class="line">[&#123;&quot;name&quot;:&quot;12&quot;&#125;]</span><br><span class="line">`</span><br><span class="line">	var students []Stu</span><br><span class="line"></span><br><span class="line">	err := json.Unmarshal([]byte(str), &amp;students)</span><br><span class="line"></span><br><span class="line">	for _, v := range students &#123;</span><br><span class="line">		v.Name = &quot;xiugia111&quot;</span><br><span class="line">		v.Age = &quot;1111&quot;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(&quot;%+v &quot;, students[0], err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为了让修改生效，我们必须让 students []*Stu</span><br><span class="line">// 但这样之后我们打印 []*Stud 就是内存地址，我们需要哥 *Stu 定义 string() 方法，这样就能 fmt // 直接打印了</span><br></pre></td></tr></table></figure>
<h1 id="Kafka使用"><a href="#Kafka使用" class="headerlink" title="Kafka使用"></a>Kafka使用</h1><h1 id="Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）"><a href="#Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）" class="headerlink" title="Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）"></a>Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）</h1><p>今天在使用es 的时候，想起了之前使用redis 的时候有not found 的判定，找了下 果然这个es 包中也有。只是这个es 包判定not found 用的是方法，原理是 http 请求的code，相比较redis， 感觉这个更靠谱些。</p>
<h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><p>time 很实用的一个方法， time.Since 可以获取时间差</p>
<p><a href="https://www.jianshu.com/p/f809b06144f7" target="_blank" rel="noopener">https://www.jianshu.com/p/f809b06144f7</a>, 时间的很好的一个文章</p>
<p>timer :  延迟触发，只触发一次。 可以重置</p>
<p>ticker : 多次执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// timer</span><br><span class="line">        d := time.Duration(time.Second*2)</span><br><span class="line"></span><br><span class="line">        t := time.NewTimer(d)</span><br><span class="line">        defer t.Stop()</span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line">                &lt;- t.C</span><br><span class="line"></span><br><span class="line">                fmt.Println(&quot;timeout...&quot;)</span><br><span class="line">		// need reset</span><br><span class="line">		t.Reset(time.Second*2), // 如果没有这个reset 就deadlock了</span><br><span class="line">        &#125;</span><br><span class="line"> // ticker , 这个随便获取</span><br><span class="line">  t := time.NewTicker(3*time.Second)</span><br><span class="line">        defer t.Stop()</span><br><span class="line"></span><br><span class="line">        fmt.Println(time.Now())</span><br><span class="line">        time.Sleep(4*time.Second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line"></span><br><span class="line">                select &#123;</span><br><span class="line"></span><br><span class="line">                case &lt;-t.C:</span><br><span class="line"></span><br><span class="line">                        fmt.Println(time.Now())</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>go 中 error 的处理还是没有总结出什么好的办法，目前想到的就是公用的方法，统一内部自己处理异常，当然也会抛出去，外层就可以不用处理了。</p>
<p>几种error 可以不处理的场景:</p>
<p>1.断言失败，有默认值的</p>
<p>2.调用方法，失败了error有返回，对于int float 这些都有默认的返回值。但对于一些结构体，还是要给默认值的，否则可能会是nil</p>
<p>3.思考一下我在项目中error 的处理方式。一般有问题，都在最底层的服务统一处理，因为一层层的往上抛，感觉日志记录可能重复，详见我的third 包调用 第三方的处理方式。但是我的service中， error 一般都没处理，一般是抛给了 controller 处理，因为我的service 虽然按道理也是公共的，但是调用方其实很少，当时考虑的也不太周到，所以都是交给controller 处理。</p>
<p>error 几种常见需要解决的问题</p>
<p>1.wrap ，我经常要 对错误信息添加，比如对发生错误时候的参数进行记录。</p>
<p>2.判断两个error 是否相等。我们需要注意的是 error 是地址类型 （可以通过 reflect 获取 ），所以两个error 完全相等必须是同一个变量，而不只是 new 里面的内容相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var UserSexNil = errors.New(&quot;未查到该用户信息！&quot;)</span><br><span class="line"></span><br><span class="line">// 然后我们通过 err == UserSexNil 判断</span><br></pre></td></tr></table></figure>
<p>go 1.13 之后又很完美的方式解决我上面的蛋疼问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Error(&quot;%w xxx&quot;, errors.New(&quot;old error&quot;)) // 这个新生成的error 就是old error + 自定义的xx信息， 但此时我们要判断是否是old error 生成，需要调用特殊的方法</span><br><span class="line"></span><br><span class="line">errors.Is(newError, oldError)</span><br><span class="line"></span><br><span class="line">当我们要断言某种错误的时候， 这个我其实用的很少，可以通过 errors.As() 来断言获取到对应的内容，因为要赋值</span><br></pre></td></tr></table></figure>
<p><a href="https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html" target="_blank" rel="noopener">这篇文章讲的很好</a></p>
<p>引申: 看了这个想到了怎么对interface 类型执行，可以</p>
<h1 id="静态文件引入"><a href="#静态文件引入" class="headerlink" title="静态文件引入"></a>静态文件引入</h1><p>php 中对于静态文件引入很容易，定义个相对路径就好了，但是我们go 微服务不可以（不是所有的都不可以）， 我们go 的执行方式是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec /app/&quot;$@&quot; -conf /app/config.yaml</span><br><span class="line"></span><br><span class="line">// 这个 @是个二进制文件（也就是build之后生成的文件），我们在go 中获取到的执行路径就是 当前路径，所以一旦修改了这个二进制文件地址，这个相对路径就不生效了， 所以这块有两种方式</span><br><span class="line">1. 相对路径改成绝对路径，我们把我们的文件也copy到文件中某个位置，然后用绝对路径</span><br><span class="line">2. go build 只会对go 结尾文件生效，我们利用第三方包把我们的静态文件也打包成go 文件，这样我们就能取到这个文件了</span><br><span class="line"></span><br><span class="line">// 对于静态文件打包成go 文件可以试一下这个包</span><br><span class="line">go-bindata， 我其实就用到他的压缩，然后获取内容用的 Asset方法， 可以看一下生成的</span><br></pre></td></tr></table></figure>
<h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><p>1.一些公共变量在框架init 的时候初始化，但这个变量应该放在哪？我开始是放在main 文件中，但有个很坑爹的时候，service 对于main 中变量引入不了，一来是因为循环依赖（比如 a 依赖b， b反过来也引入a），我们可以开一个单独的包，定义这个公共变量，并且 包含 自身init 函数</p>
<p>2.今天听大佬分享 公共pool 中对象被耗尽的问题，如何解决？ （最近接的案例就是我们的redis pool 被耗尽了）。1.池子里面对象尽可能给多，2.池子里面对象取出来尽快还回去。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wp.png" alt="chenye2017 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/zp1.png" alt="chenye2017 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

  <div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
  </div>

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/go/" rel="tag"><i class="fa fa-tag"></i> go</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/03/go-包的学习/" rel="next" title="go 包的学习">
                <i class="fa fa-chevron-left"></i> go 包的学习
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/07/17/gin-的那点事/" rel="prev" title="gin 的那点事">
                gin 的那点事 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/my.png"
                alt="chenye2017" />
            
              <p class="site-author-name" itemprop="name">chenye2017</p>
              <p class="site-description motion-element" itemprop="description">想用善良改变世界</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">107</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">99</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/chenye2017" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:1967196626@qq.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/3215254425" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-globe"></i>Weibo</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-crosshairs"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/" title="百度" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.google.com/" title="谷歌" target="_blank">谷歌</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#断言"><span class="nav-number">1.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Slice"><span class="nav-number">2.</span> <span class="nav-text">Slice</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#channel定义"><span class="nav-number">3.</span> <span class="nav-text">channel定义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#goroutine的意义"><span class="nav-number">4.</span> <span class="nav-text">goroutine的意义</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#json-序列化的小问题"><span class="nav-number">5.</span> <span class="nav-text">json 序列化的小问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#url处理"><span class="nav-number">6.</span> <span class="nav-text">url处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http-请求"><span class="nav-number">7.</span> <span class="nav-text">http 请求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#get"><span class="nav-number">7.1.</span> <span class="nav-text">get</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#post"><span class="nav-number">7.2.</span> <span class="nav-text">post</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Response"><span class="nav-number">7.3.</span> <span class="nav-text">Response</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sort"><span class="nav-number">7.4.</span> <span class="nav-text">Sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime-Caller"><span class="nav-number">7.5.</span> <span class="nav-text">runtime.Caller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http状态码"><span class="nav-number">7.6.</span> <span class="nav-text">http状态码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fmt问题"><span class="nav-number">7.7.</span> <span class="nav-text">fmt问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kafka使用"><span class="nav-number">8.</span> <span class="nav-text">Kafka使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）"><span class="nav-number">9.</span> <span class="nav-text">Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Time"><span class="nav-number">10.</span> <span class="nav-text">Time</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Error"><span class="nav-number">11.</span> <span class="nav-text">Error</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#静态文件引入"><span class="nav-number">12.</span> <span class="nav-text">静态文件引入</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些思考"><span class="nav-number">13.</span> <span class="nav-text">一些思考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">chenye2017</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span> |
</span>
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>





  <span class="post-meta-divider">|</span>





  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count"> | 博客全站共176.2k字</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  


  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.2.0/anime.min.js"></script>
   <script type="text/javascript" src="/js/src/fireworks.js"></script>



</body>
</html>
