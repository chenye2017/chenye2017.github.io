<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Laravel 关于blade]]></title>
    <url>%2F2018%2F10%2F10%2FLaravel-%E5%85%B3%E4%BA%8Eblade(%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E)%2F</url>
    <content type="text"><![CDATA[其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。 itbasic 用的也是模板引擎，名twig，其实和blade没有多少不同的地方，只是自己发现的twig新功能还比较少，只是一直在原先的基础上堆代码，感觉上在模板引擎里面还是不要做过多的逻辑判断，否则后面会越写越复杂，而且难于维护。 对于web网站，我们有很多页面，但这些页面大部分都是相同的？因为我们的布局需要相同，这个其实在写itbasic的时候应该能感觉到，我们似乎只需要填充中间的content部分就好了 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;@yield(&apos;title&apos;,&apos;测试&apos;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @yield(&apos;content&apos;) &lt;/body&gt;&lt;/html&gt; 什么是yield ,就是让继承者可以填充的东西，继承者通过 123456@extends(&apos;layout.blade&apos;) //继承上一个模板@section(&apos;title&apos;, &apos;cy&apos;) //填充数据@section(&apos;content&apos;) //这种方式填充数据要有结束符号 &lt;h1&gt;222&lt;/h1&gt;@stop 12@include(&apos;default.ce&apos;) // 包含额外的页面//传递变量，include(&apos;default.ce&apos;, [&apos;user&apos;=&gt;$user]) 123456789//判断@if ($a &gt; 0) &lt;h1&gt;cc&lt;/h1&gt;@endif//循环@foreach($counts as $count) &lt;li&gt;&lt;/li&gt;@endforeach]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站升级https]]></title>
    <url>%2F2018%2F09%2F11%2F%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7https%2F</url>
    <content type="text"><![CDATA[升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。 https原理HTTPS采用共享密钥加密(对称加密)和公开密钥加密(非对称加密，比较出名的有RSA)两者并用的混合加密机制。在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式之所以传输过程中用对称加密，是因为非对称很浪费资源 (hash加密是单向的，例如md5,不能解密)和对称加密还有非对称加密都是不一样的，不管是对称加密还是非对称加密，通过秘钥都是能解密的，但是hash，只能维持 hash(内容)之后的值保持一致，这也是我们数据库中只保存用户密码加密后的值就可以验证用户的密码是否正确了，因为我们可以每次获取到用户信息之后只要hash一下，然后和数据库中做下对比就可以了。 https ,首先让服务器和ca交互，获取服务器的公钥，这个过程是非对称加密，获取到公钥 https升级过程中遇到的问题: 不允许脚本调用http，可以先把接口转发到我们本地的服务起的https上，然后通过nginx转发到别人网站上的接口，因为本身调用外来接口接口比较少，这样能符合我们的需求 https证书申请无效（每个域名都需要申请单独的证书，之前以为只要申请一个www.chenye2017.cn证书就可以了，chrome直接显示https不安全，其实通过微软的edage浏览器访问，能清楚的看到证书不匹配的原因） （证书申请是通过腾讯云，腾讯云上有详细的教程，唯一不足的是没有给文件夹权限，导致第一次访问403） （https配置虚拟主机应该就和我们在vhost文件里面配置虚拟主机一样，现在是在ssl配置文件里面写）（话说我现在的服务器，域名用的是阿里的，服务器用的是京东的，https证书用的是腾讯的，zz）（还有不知道是hexo的原因还是github page 的原因，我的网站上有http的资源竟然不会显示https错误，不知道他是怎么解决这种http资源不出错的，有空可以了解下） https和http的区别 简单看就是 https = http + SSL SSL的运行机制，可以参考阮一峰老师的文章，我对上面的一些内容做了些自己理解的笔记 其中加密传播是因为我们的传播内容都是通过生成一个第三方不知道的公钥，这个公钥是怎么来的呢，首先通过ca证书，因为系统内容ca的公钥，ca用私钥加密文件内容（私钥加密，公钥解密，不被篡改），我们获取服务器的公钥，这个公钥是干什么的呢，并不是用来进行数据的加密的，而是用来加密传递的数据给服务器（公钥加密，私钥解密，不被获取），服务器接收到客户端的数据进行生成公共密钥，这个密钥是我们以后加密数据用来传递的(感觉只要记住证书里面的内容都是能保证绝对正确就好了) 具有校验机制，是因为我们的证书具有这个作用，比如我上次把我从www.chenye2017.cn 上获取的证书放到虚拟站点blog.chenye2017.cn就直接报错 配备身份证书，估计也是这个意思 所以ssl 和 tsl 是一样的意思嘛 感觉这个握手不是tcp的那个三次握手，这个开始的时候tcp那个三次握手应该都搭建好了，而且这个也是4次握手 剩下的内容就是4次握手的详细内容了，为什么要4次握手，写的都很详细，就不再补充了，总之这个生成传输加密内容的秘钥也是通过非对称加密，再后面就是http了。 总结一下： 通过CA 证书，发送服务器公钥，利用的是非对称加密算法，用的公钥和私钥来自CA（证书的作用是为了保证服务器公钥的正确性，不被篡改） 通过CA得到的服务器公钥，大家都可能有，但是我们通过公钥加密，私钥才能解密，和服务器交互，让两端都能生成一致的对称加密算法钥匙（随机因素可以通过客户端利用服务器公钥加密传给服务器） 利用生成的公共密钥进行对称加密，传输数据（这个公共密钥在每次连接的时候生成，别人不知道）]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于git]]></title>
    <url>%2F2018%2F09%2F07%2F%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%9C%E5%8D%8A%E7%90%83%E6%9C%80%E5%A5%BD%E7%9A%84git%E5%85%A5%E9%97%A8%E4%BA%86%2F</url>
    <content type="text"><![CDATA[公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨 关于分支. git branch -a ，可以查看项目的本地分支和远程分支（分支有本地分支和远程分支这两种，本地分支推送到远程就变成了远程分支，以后别人clone的时候就会包含这个分支）。当我们git clone 远程项目的时候，会把这个项目的远程分支都拉下来，我们可以在本地切换各个分支。各个分支的作用？可以作为开发的时间节点来用，比如慕课网上各个讲课阶段，每次代码开发前，先开个本地分支，开发完了推送到远程，然后和并到主分支上。我们通过切换到各个分支，就知道老师讲到哪了，还能对比代码有哪些变化，以后查看的时候还可以通过编辑器 来进行切换，注意切换的时候会在本地自动新建一个分支，不用担心，你想啊，本地要是不新建，你直接改动的内容算哪的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于单点登陆的那些事]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.单点登录：简单理解成一处登陆，到处登陆，一处登出，各处登出。其实在生活中的应用还是满广泛的。比如你登录淘宝的网站，可能当你跳转到天猫上，也不需要登陆，光从界面上看，也能分辨这是两个网站，这两个网站肯定有各自的登陆机制，其实内部就是用了单点登录的原理，让用户无感知的情况下实现一个账户在各个网站下的登陆登出。后来在写的过程中，发现这个单点登录也有点第三方登陆的意思，这个第三方就是sso登陆中心。很多人广从字面意义上看，可能会觉的单点登录应该是这样：一个用户在这个地方登陆了，比如手机上或者上海登陆了，当在电脑上登陆或者安徽登陆了，之前登陆过的账号会下线，但这并不是单点登录哦，想了下，上述功能实现起来也挺简单，比如我们经常存取 token =》 用户信息这样的登陆凭证，又或者是session_id =&gt; session 信息（用户信息）这样的登陆凭证，不妨我们在用户登陆的时候，再存储一封 用户id =&gt; 用户信息，这样我们可以很方便的统计有哪些在线用户，哪个用户是否在线（前面第一种的话需要遍历所有的session文件取出用户id）。当我们登陆接口产生了一个新的token =》 用户信息的时候，我们检测下这个用户是否在已登录列表，如果有，我们服务端直接让之前的token失效就可以了，就能实现前面账号的下线。回归正题，关于单点登录单点登录的原理大致就是上面了：1.先登录普通web1，web1后台检测是否登陆了，如果登陆过，直接跳转到web1,如果没有登陆，跳转到sso登陆中心。sso中心检测这个用户是否登陆过，如果没有登陆，跳转到sso登陆界面，输入用户名和密码（之前为什么说单点登录很像第三方登陆呢，因为接入单点登录的web1也不知道即使能登陆到他这个平台上的用户的用户名和密码，用户登陆的操作逻辑都是sso 这个第三方维护的，web1只是在登陆sso成功之后维护一个用户和web1的登陆态，比如web1派发给用户一把钥匙，以后拿着这把钥匙就代表你是web用户了），用户成功登陆sso这个中央站点后（用户和sso之间的登陆成功搭建成，之前我是通过jwt的方式维护用户和sso之间的，jwt相比较传统的cookie和session就是通过签名的方式能防止用户篡改已登录人的信息），sso会回调web1站点上提前设置好的接口（这个我当时是在跳转到登陆中心的时候附带在url后面参数，其实这个可以提前设定好，然后通过传入一个参数web1，sso去后台查找需要的会掉地址），传给他一个参数，可以理解成一个ticket，web1拿着这个ticket可以换取正在登陆的用户的用户信息，拿到之后web1就能实现自己的业务逻辑了，比如检测这个用户是不是第一次登陆，如果是第一次登陆的话需要绑定用户信息之类的，然后维护用户和web1之间的登陆状态建成。上面需要注意的点就是客户端如何接受服务端生成的登陆凭证.首先是用户和sso中心，这个好解决，因为我们的登陆页面可以可以当做一个静态页面，我们可以在上面写js，这就方便了，我们发送一个ajax请求给sso，成功后把返回的登陆凭证放在cookie中，每次调用sso接口比如验证用户是否登陆的时候都会携带着这个cookie，！！！千万要注意，携带这个中在客户端浏览器的cookie的前提是通过ajax之类的访问，你别通过curl之类的访问，curl需要自己手动设置cookie，并不会像浏览器一样自动添加上，所以我们在后台一般要用header location之类的跳转，而不是curl.web1和用户之间登陆态的维护：这块我没有使用header location跳转，用的是ajax返回给前端页面，前端页面去跳转，之所以这么做，好像是用第一种好像有点问题，没有去研究了，因为时间赶啊！！！前端拿着这个ticket，哈哈哈，你是不是担心不安全，我也担心呢！！而且我这块直接用的url跳转，为什么呢，因为我的后台是获取用户信息之后直接跳转，并不需要ajax那种返回了，如果这里用返回，首先是前台页面并不知道维护好登陆信息之后需要挑战的地址（这个静态页面是sso的），然后呢，如果通过ajax，后台跳转可能有些错误，之前那个sso登陆成功后台跳转不到web1，可能就是这个问题。web1的回调地址里面通过ticket拿到用户信息之后可以做很多自己事情了，比如绑定用户，比如验证用户是否合法等等 2.单点退出一处退出，处处退出。我是这样做的，当登陆成功后，会在数据库中写入，这个用户的登出地址，当我们登出的时候，查询数据库，所有用户的登出地址，循环调用，需要注意的是我们传给用户的是只能是user_id之类的公有信息，各个子网站接收到之后，需要拿这个信息获取用户的登陆凭证，然后让其失效。我是这样做的：redis中存储着phpsessid（我们用的传统的cookie session）,然后curl 模拟请求的时候cookie带上这个，··然后就实现啦 思考：如果我们模拟请求的时候带上完全一样的头信息，是不是就能达到和浏览器一样的效果了，··有些能，比如上面的登出，但是设置cookie不可以，明明就是header加上点信息嘛，为什么不可以呢，因为cookie只能在浏览器上使用？还有很多优化的空间，比如回调多个登出接口，用的消息队列，如果一个出错，是记日志吗，还是什么zzz每个网站需要自己的登陆界面嘛，这样每次未登录定位到登陆界面之后就只有个登陆按钮，点击之后才能进入sso输入用户名和密码，相比较之前略麻烦，但是如果sso登陆之后，我们点击就能直接跳转到我们的网站，感觉这样更符合单点登录。而且住校之后我们可以定位到普通网站的登陆界面，而且点击因为可以加回调地址，我觉得还是不能省略的。代码就不放了，放些接口的函数吧sso :login :检测是直接跳转到登陆页面还是检测cookie是否有效，有效回调web1站点地址，无效跳转到登陆界面（看了下仿佛ajax中header location 就是有点问题）logout web1:login: 判断是去sso还是直接登陆logout:退出，需要回调 sso 的logout, 注销sso还有各个子网站ssologin:回调登陆地址ssologout：回调登出地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于nginx的那些事]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%85%B3%E4%BA%8Enginx%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F08%2F17%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel 数据库相关操作]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel seeder 数据填充]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-seeder-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel migrate 数据迁移]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-migrate-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[虽然表哥说他们都不用这种方式，但这种方式确实很方便的解决了团队合作的时候数据库表的同步问题，像我们itbasic 就每次上线或者给队友同步数据库的时候都得自己手动去处理，而且这种方式更多的把sql语句转换成php语言处理，不知道建索引那些会不会很方便. 文件位置和命名： database/migrations/2014_10_12_000000_create_users_table.php 通过artisan 命令能直接生成对应目录下的文件 注意up 和 down 方法，分别是的执行的时候，还有回滚的时候的执行 注意create 和 update 表结构的时候的区别 自增：increment 字符串： string ， 方法的第二个参数限制最大长度 唯一： unique，感觉就像数据库的唯一索引 创建时间和修改时间，通过 timestamps 就能生成 记住我： rememberToken, 虽然一直不太清楚这个干啥的 create =&gt; dropIfExists() , 创建 回滚的时候对应 删除]]></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel router]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-router%2F</url>
    <content type="text"><![CDATA[关于路由的一些总结 1234&lt;?phpRoute::get(&apos;/&apos;, &apos;StaticPagesController@home&apos;)-&gt;name(&apos;home&apos;);Route::get(&apos;/help&apos;, &apos;StaticPagesController@help&apos;)-&gt;name(&apos;help&apos;);Route::get(&apos;/about&apos;, &apos;StaticPagesController@about&apos;)-&gt;name(&apos;about&apos;); 这个name是用来命名的，命名有什么用，看下面 route(‘help’) =&gt; 这个help 是路由命名，user.help 更为准确 route(‘help’,[1,2]) =&gt; 多个参数传递数组 这个函数的参数，通过下面这个函数，配合配置得环境变量，可以生成前端可以访问路径的，如果很直白的写url，以后url改动的时候但凡用到的地方，都需要改动]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于composer]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%85%B3%E4%BA%8Ecomposer%2F</url>
    <content type="text"><![CDATA[composer,php的包管理工具，类似nodejs的npm，类似python的pip，因为很多时候我们需要接入外来的服务，可能自己的能力不足，又或者是别人有更好的解决办法，不是有说过站在巨人的肩膀上能看的更远么。 composer require ```当我们需要安装一个外来服务的时候，注意这个不是安装php的扩展模块，两者有本质上的区别，php的扩展模块是c写的，需要我们源码编译到php中, 而通过composer接入的是php封装的内容。 之前我经常把需要的模块通过手动写入composer.json文件中，然后通过composer install 或者 composer update 这种方式更新，这都是不对的 composer install 会依据composer.lock 文件进行安装，如果没有这个lock文件按照composer.json进行安装 composer update 会依据composer.json 进行安装（composer.lock 和 composer.json 的区别lock文件中会严格规定版本号） composer init 初始化一个项目被composer 管理（很少用, 一般是手动编写一个composer.json文件，然后install） composer 还有文件夹管理的功能，现在一般用的是psr-4,原先项目组织有psr-0,现在废弃了，二者区别就是psr-4通过命名空间更能代表文件位置composer的自动加载有psr-4,我们那个api服务中有使用，注意定义了一个顶级之后，下面的子命名空间可以自动寻找，而不需要你的人为干预files 可以加载配置文件之类的，不用一直includeclassmap可以不遵循psr-4规范，会扫描指定文件夹，加载里面的类（一般的类名首字母大写，然后类名和文件名一样）当我们修改了composer的自动加载，通过composer dump-autoload来更新 我们php的框架和python 这种框架有挺大的区别，写了点python，还有问了写python的同事，得到的就是他们写python的时候还用的是面向过程的方式，他们的框架flask感觉更像是php中的包的概念，通过import方式导入，没有各个文件夹的内容规定，给了很大的自由给用户，我们通过composer 安装的文件一般在这个项目文件的vendor目录下，但是我们python 通过pip安装的一般是全局安装，就算是用了pipenv 或者vrtualenv 也是在全局下面然后分成各个子文件夹（仿佛是虚拟站点让php变得这么方便？） composer需要注意的东西： 修改源，下载东西更快 linux 下安装（composer.phar 就是 php composer, 只是单独使用的话需要composer.phar 需要执行权限 chmod a+x composer.phar）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于框架操作数据库的几种方式]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%85%B3%E4%BA%8E%E6%A1%86%E6%9E%B6%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[其实第一次有这方面的思考是来自七月老师的tp教程，他起了个头，他那个课程的核心就是为了提倡大家使用orm，后来在工作中开始留意这方面的知识.(如果没有那个引子，估计我会把builder query和orm弄混淆吧，因为真的挺相似，调用方法都是链式，orm对于bq方法的使用，又因为区别在于orm的面向对象这个特性上，而且现在基本都不用bq了，就算使用也是可以DB直接调用,而不用像orm那样需要定义一个model类，很难找出bq相对于orm的差别，换句话说因为本身orm就是基于bq的，所以我们需要发现的orm相对于bq的改变，但这个改变刚好是面向对象这种思想上，加上bq的少使用，这个改变很难发现) 看了下php关于linux方面的知识，pdo， builder query ，orm，我这种基础不好接触面不广的人经常混淆。在pdo之前应该是直接利用mysql 和 mysqli进行数据库连接操作，这种的只需要php开启对应的mysql或者mysqli扩展就好了（mysql已经废弃了），这还是我刚学习php的时候书上经常写的，后来在工作中这种的用的就比较少了，主要用的就是pdo了，个人感觉pdo和mysqli用起来查询那些操作还是差不多的，不管是函数还是查询到的结果集，感觉差别最大的还是 一个是new pdo一个是 mysqli_connect吧，:smile:。（pdo使用的时候除了安装pdo扩展，还要开启对应的驱动哦，比如 mysql_pdo）。 还记的我在学习慕课那个高性能api接口时候接触到的dao层吗，其实dao后来理解起来感觉是不是只有在那种处理比较麻烦和严谨的时候使用 &lt;?php class DB_user extends DB_base { public function find($username) { $query = self::$db-&gt;prepare(&quot;select count(*) as c from yaf_user where username = ?&quot;); $query-&gt;execute([$username]); $count = $query-&gt;fetchAll(); if ($count[0][&apos;c&apos;] != 0) { list(self::$errno, self::$errmsg) = Err_map::getCodeMessage(1004); return false; } return true; } 看这种，查询一个结果要写这么多，肯定需要独立出来呢。 后来是builder query，其实和orm是很像的，毕竟orm是基于builder query的，但二者不同之处在于orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例(虽然我们在使用bq的时候可能也是这样想的，但orm不止是想这么简单，他是具体的实现了，比如下面同样调用all方法，虽然查出来的数据类型可能都是collection，但是展开看下，一个下面是关联数组，一个是对象，有具体的public 和private属性)。因为orm基于bq嘛，所以bq的那些方法orm都可以使用，所以我感觉方法的混用也是容易把orm和bq混淆的原因。但你是否还记得bq使用的时候调用的类是 DB,以laravel举例，DB是库facade下面的，但是orm使用的时候我们调用的类是继承model的那个类名字 DB::table(&apos;student&apos;)-&gt;all() Student::all() 当我在学习yii的时候还接触到一个概念AR，其实AR只是实现orm的一种方式，比较常用的有AR和··mapper，laravel（Eloquent）和yii现在orm实现方式都是AR，所以不要把这个当做yii和laravel的区别啦。 AR和mapper的区别在于，mapper把数据对象和数据持久化分开了（啥叫持久化，就是数据存储啊笨蛋···zz，心痛的感觉），mapper中对于数据的保存需要用类似bq中一个统一的类去实现，比如 //伪代码,方法名纯属虚构，因为懒得去查了 $student = new Student(); $student-&gt;name = &apos;cy&apos;; $student-&gt;age = 19; DBMAPPER-&gt;config($student); DBMAPPER-&gt;refresh($student); 现在水平太低，也不知道这样的好处是啥：说是为了把数据对象独立出来，让他的作用就是在各个层中传递. 大致就这些了吧，最后来一个laravel中最基础的model定义，让我们来更能理解orm的那几个定义 //orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class Test extends Model { //定义表名 protected $table = &apos;test&apos;; //禁止更新时间戳，默认会更新created_at和updated_at public $timestamps = false; //可以批量赋值的属性，什么叫做批量赋值，就是我们可以通过create方法插入的，不是save那种，create是直接传入一个索引数组， //save 是通过给实例的属性一个个赋值，就这点看来，确实有批量赋值的意思 protected $fillable = [&apos;name&apos;]; } ​ laravel 中orm的实现用了很多PHP的特性（魔术方法等），比如属性，写的挺好的，在laravel核心框架技术解析中有写到。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux搭建git仓库]]></title>
    <url>%2F2018%2F07%2F24%2FLinux%E6%90%AD%E5%BB%BAgit%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。后来老大希望测试下我写的代码，看看需要哪些参数，给了另一台服务器。刚开始想到直接把修改好的代码打个包放上去，后来想了下不是长久之计，因为我的水平肯定要经常修改代码，不能每次修改下就打包一下，太麻烦了。又想到可以通过配置itbasic服务器上的svn，当svn up 的时候忽略掉特定文件夹的更新，百度了下集中方法，大部分是一下集中情况：windows下忽略文件夹，提交代码的时候忽略掉文件夹，很少有更新代码的时候忽略掉文件夹的解决办法。（有，但自己试验失败）。后来想到不如利用git吧，首先大部分都是我一个人操作，我经常向github提交代码，操作已经很熟悉了，再者毕竟用git也能跟上时代的潮流嘛。 先来介绍一点基础知识：当我们想下载github上的代码（或者说远程仓库的代码），我们可以通过123456git clone git@ip地址：git远程仓库的地址//例如git clone git@github.com:chenye2017/zerg.git//当需要下载github上的仓库的时候，直接去这个项目首页，会有个clone or download的选项，注意不要选择use https，因为选了那个每次提交代码额时候都要输入密码//winodows用户可以直接下载zipgit clone git@192.168.56.10:/home/resposity/bbs.git 新建一个目录，自定义名称进入到这个目录内，执行上述操作，就能把项目目录中的代码下载下来。 但上面仅仅只是下载项目，我们为了和远程仓库进行联动，我们需要在本地的这个文件夹建造一个git仓库，然后和远程仓库的某个分支比如master进行绑定，当我们修改完成的时候进行代码推送到远程的时候，别人下次再次clone或者pull就能收到我们提交的修改。下面就是创建本地仓库的实例代码 1234567891011cd dir//进入上面执行git clone的文件夹git initgit add. //把修改的文件夹都添加进来git commit -m &apos;init&apos; //提交到本地代码库git remote -v //查看远端仓库//如果有远程仓库，可以进行删除git remote rm origingit remote add origin git@192.168.50.16:/home/resposity/bbs.git //添加远程仓库git push origin master //和远程仓库的master分支绑定，以后提交只需要git pushgit pull origin master //同上，以后使用也只要git push 就好了 当我们提交代码的时候肯定是不成功的，提示我们需要输入密码，···而且每次都会提示，怎么办呢，可以通过一个命令1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 在windows中，生成密钥位置会在C:\Users\admin 下面，这个下面有.ssh文件夹，进去复制末尾是.pua 也就是公钥的文件，粘贴到你的git仓库所在的服务器的git 主目录下，比如我的是 /home/git/.ssh/authorized_keys,粘贴到文件末尾即可，如果还不能提交代码，重启下sshd服务，netstat -antp|grep sshd, kill, /usr/bin/sshd 启动如果还不行，可以查看这篇文章修改下配置 https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873 一直提交需要填写密码其实是个很常见的问题，收集了几篇文章，因为之前一直不成功，但后来成功了，但其实不是下面这几个问题，是我对git远程仓库理解出现了问题，所以操作不对.https://www.jianshu.com/p/9dbb1dea5929， （文件夹权限），https://ruby-china.org/topics/14182 （ssh真的出问题了，需要查看日志） 最后也是最终的要一步，按理说这应该是第一步的，就是linux上远程创建git仓库。本身应该 1. 创建远程仓库 2 git clone 3. git push这也是我们平时使用github 的主要步骤，但因为这一步最重要所以我放在了最后。 git创建远程仓库 http://www.runoob.com/git/git-server.html 菜鸟教程上已经说得很清楚了，只是我们需要区别一下两行代码12git initgit init --bare 第一个我们经常用到是实例化本地仓库，第二个是创建一个裸库，什么意思呢，就是这个裸库就是我们平时那个 git clone ip地址后的路径，这个仓库装的都是我们的提交记录，本身是并没有代码的，但我们通过git clone能生成最新的代码，以我的服务器为例123/home/resposity //专门用来放远程仓库的文件夹/home/resposity/bbs.git //我的bbs远程代码库/home/code/bbs 这是我的服务器上实际项目代码，也是被人访问我的项目的路径 当我本地修改好了代码（windows下），提交到远程仓库中，然后在服务器的/home/code/bbs (线上项目文件夹)下进行更新git pull最新的代码,别人就能访问到我本机的最新代码了。 对了，还记的我们当初svn代码更新提交失败，提示svn clean也不行的时候怎么处理的吗，就是清除.svn 下面两张表里面的数据 (通过Navicat建立连接).当时刚开始是不会这种方法的，同事告诉我直接删除.svn这个文件夹，说svn管理这个文件夹都是通过他，现在想起来挺有道理的，但没有试过（以前直接是删除了svn这个软件，然后肯定不成功啦，现在想想这和svn半毛钱的关系都没有撒，但感觉不能删除.svn,因为删除了，那些diff都找不到了）git应该也是通过.git这个文件管理的。 对了，关于免密码登录，当我们通过命令生成的ssh密钥linux下，一般在这个用户目录下面，比如root用户，在/root/.ssh 下面，我们需要把这个公钥粘贴到需要进行提交的git远程仓库的服务器中git的安装目录下面的ssh的auth···——key，里面，追加在文件末尾，注意着这两个地方文件名虽然类似，但一定要分清把那个粘贴到哪个上面，分清主从关系。 关于忽略文件夹，编辑.gitignore 文件，在项目根目录下面，因为windows下面不能这样命名文件，可以在linux下面编辑保存，编辑之后这个文件就是untracked形式,以后的提交就不会把这个文件保存在内，即使用了git add. 但是之前把.idea这个文件夹包含进去了，怎么办呢，git remove -n -r –cached –cached 只是git仓库删除了，本地不会删除，-r 类似删除文件夹的时候递归删除， -n 先列出来要删除的文件，真正想删除的时候不要加这个参数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网站部署随笔]]></title>
    <url>%2F2018%2F06%2F20%2F%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。 好久之前在阿里云上买过一个域名，29一年，chenye2017.cn,主要这个名字和我的github账号也是一致的，比较好记。当我想绑定域名到服务器上的时候，其实有点担心，我在阿里云上买的域名能绑定到服务器上吗？ 试试吧。首先需要对域名进行实名认证，域名的实名认证其实挺简单的，填下身份证号和联系电话就好了，后面需要备案，这点需要注意的是，我绑定的是京东云，所以需要在京东云上备案。之前对于域名的购买，我的理解是购买一款厂商的产品，但其实不是这样的，试想一下我们购买域名的时候是不是只要先构思一个自己想要的域名，然后查询域名是否在使用，如果没有使用就可以进行购买，这个凭空想象出来的域名厂商不可能提前为我们准备好，他能做的就是通过域名解析器dns把我们的域名注册进世界的万维网当中，当世界中的某个人通过浏览器进行访问的时候，dns能把域名解析成ip地址找到我们的服务器，既然这样，那我们是不是只需要在我们的服务器上搭建一个域名服务，就能不通过购买他的域名，直接使用自己注册的域名就可以了呢？理论上是可以的，但我没有去实践过。 备案未完成… 之前帮前端同事部署过一个vue项目，其实和部署一个php项目 极为相似，甚至更简单，都是通过找寻唯一入口文件，因为前端项目都是静态文件，而且apache默认找的文件夹下面的第一个文件就是index.html,所以都不需要进行特殊的设置（php的话因为要找index.php,所以要做更多的设置），唯一需要注意的就是前段项目的很多路径都是绝对路径，他本质上是相对网站的根目录来的，也就是默认项目部署在网站的根目录下，如果网站没有部署在根目录下，比如itbasic bbs，需要我对引入的静态资源路径进行适当的修改。比如给需要找的静态资源建立个软链接ln -s ,到新的静态资源目录下。 因为之前是根据网上教程搭建的hexo，其实不懂他的实现原理。 而且在教程的开始，就说了要使用node，对于我这种js都不好的人，看到node，首先就觉的完了。其实很多前端项目用到node，并不是用到nodejs的语法，而是用nodejs搭建了一个web服务，承载前端项目，然自己置身于一个联网的状态中，就能发出类似ajax这样的联网请求，因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。 我看了下上传到github上的文件夹，和我本地的项目代码结构还是有挺大区别的，我的理解就是把本地代码进行了打包，打包好的文件上传到github上了（类似vue代码的发布），上传到github上的文件夹全是静态目录结构，我惊喜的发现了index.html,于是大胆的假设了下如果把那个目录放在我的站点根目录下，是否也能进行访问了呢，我就不用通过chenye2017.github.io去访问，而是通过我自己的站点去访问呢，毕竟服务器在国内，访问速度也比较快。 结果是成功的，印证了我的假设。 在网站部署的时候还遇到了几个问题，比如源码编译apache2.4,在之前还需要安装apr,apr-util,之类的文件，apache2.4的改文件访问权限和之前的apache还不一样，还有文件夹名字结尾不能有空格，否则识别不出来，加载vhost.conf,启动apache失败，修改server localhost之类的apache配置文件，还有apachectl restart开始不管用，需要自己手动配置脚本····]]></content>
  </entry>
  <entry>
    <title><![CDATA[无限递归]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。 以部门举例，我们在使用的过程中，需要找到这个部门的相关父级部门（子孙树），或者我们需要知道某个部门是否属于某个部门，我们既可以用家谱树去实现，也可以用子孙树去实现，用子孙树去实现的一个好处就是，当我们知道父级节点，一次性求出这个父级节点的所有子孙，通过判断子节点是否在这个父级节点的子孙中，就能知道是否满足条件。但如果我们通过家谱树，我们需要每次根据子节点，去求一次家谱，然后来判断家谱树中是否有这个父级节点存在，来判断是否符合条件。 123456789101112131415161718192021222324252627282930&lt;?php$address = array( array(&apos;id&apos;=&gt;1 , &apos;address&apos;=&gt;&apos;安徽&apos; , &apos;parent_id&apos; =&gt; 0), array(&apos;id&apos;=&gt;2 , &apos;address&apos;=&gt;&apos;江苏&apos; , &apos;parent_id&apos; =&gt; 0), array(&apos;id&apos;=&gt;3 , &apos;address&apos;=&gt;&apos;合肥&apos; , &apos;parent_id&apos; =&gt; 1), array(&apos;id&apos;=&gt;4 , &apos;address&apos;=&gt;&apos;庐阳区&apos; , &apos;parent_id&apos; =&gt; 3), array(&apos;id&apos;=&gt;5 , &apos;address&apos;=&gt;&apos;大杨镇&apos; , &apos;parent_id&apos; =&gt; 4), array(&apos;id&apos;=&gt;6 , &apos;address&apos;=&gt;&apos;南京&apos; , &apos;parent_id&apos; =&gt; 2), array(&apos;id&apos;=&gt;7 , &apos;address&apos;=&gt;&apos;玄武区&apos; , &apos;parent_id&apos; =&gt; 6), array(&apos;id&apos;=&gt;8 , &apos;address&apos;=&gt;&apos;梅园新村街道&apos;, &apos;parent_id&apos; =&gt; 7), array(&apos;id&apos;=&gt;9 , &apos;address&apos;=&gt;&apos;上海&apos; , &apos;parent_id&apos; =&gt; 0), array(&apos;id&apos;=&gt;10 , &apos;address&apos;=&gt;&apos;黄浦区&apos; , &apos;parent_id&apos; =&gt; 9), array(&apos;id&apos;=&gt;11 , &apos;address&apos;=&gt;&apos;外滩&apos; , &apos;parent_id&apos; =&gt; 10), array(&apos;id&apos;=&gt;12 , &apos;address&apos;=&gt;&apos;安庆&apos; , &apos;parent_id&apos; =&gt; 1) );function test($data, $pid)&#123; static $arr = []; foreach ($data as $key=&gt;$value) &#123; if ($value[&apos;id&apos;] == $pid) &#123; $arr[] = $value; test($data, $value[&apos;parent_id&apos;]); &#125; &#125; return $arr;&#125;var_dump(test($address, 4)); 1庐阳区，合肥，安徽 子孙树的实现 12345678910111213function test1($data, $id, $level = 1)&#123; static $arr = []; foreach ($data as $key=&gt;$value) &#123; if ($value[&apos;parent_id&apos;] == $id) &#123; $value[&apos;level&apos;] = $level; $arr[] = $value; test1($data, $value[&apos;id&apos;], $level + 1); &#125; &#125; return $arr;&#125;//level主要用来显示是几级的儿子 还记得我们在大学学习数据结构的时候，因为递归对于效率有影响，所以经常需要把递归改成迭代，上述家谱树容易修改，子孙树需要用到栈，自己不是很理解 12345678910111213141516function test2($data, $pid)&#123; static $arr = []; while ($pid != 0) &#123; foreach($data as $key=&gt;$value) &#123; if ($value[&apos;id&apos;] == $pid) &#123; $arr[] = $value; $pid = $value[&apos;parent_id&apos;]; break; &#125; &#125; &#125; return $arr;&#125;var_dump(test2($address, 4));//迭代和递归的转换主要就是靠迭代找到那个停止往上找的条件 大致就是上面这些，像面包屑导航，不要看着从左到右，其实他也是一棵家谱树，因为他从始至终就只有一棵树。 还有就是移动各个部门位置问题： 想象一下，一棵树，我把某个分支截取下来放到另一个分支上是很正常的事情，但问题是有时候，我会出现把父亲节点的父亲设置成自己的子节点，这样树枝就断了，这样是不可取的，除此之外，任意移动都是可以的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域 cookie]]></title>
    <url>%2F2018%2F06%2F06%2F%E8%B7%A8%E5%9F%9F-cookie%2F</url>
    <content type="text"><![CDATA[cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。 cookie,对于传统的lamp架构，在服务器端想获取可以通过$_COOKIE[]数组获取到，但是对于swoole这种自己搭建web服务的东西，只能通过request请求获取，其实lamp里面本质也是这样，也是把apache或者nginx获取到的请求内容放到了php的\$_COOKIE里面，类似的\$_SERVER, \$_GET,这些在swoole里面都是永不了得，你可以把http-&gt;request-&gt;get 的值在请求到来的时候给与\$_GET数组，这样就能在swoole搭建的web服务里面和普通的lamp架构一样使用\$__GET数组了。正因为swoole的这些特性，像如果在swoole里面使用session登录机制需要自己去实现，还有对于一些框架的集成，因为外部传入的参数不在那些数组中了，所以需要对框架进行修改，让框架能获取到对应的参数，保证框架的运行，比如：swoole集成slime框架(swoole在客户端设置cookie也得用它自带的方法而不是setcookie)。 回归正题，通过上述，我们也只cookie是一个数组，那其中哪把钥匙是用来打开session的呢，答案是PHPSESSID,这个值是可以设定的，在php.ini,或者通过php的session函数来获取到。 对于session，我觉得他更像是一个模块的扩展，他不仅仅是提供一系列的简单的函数，这些函数其实还有具体的活动的封装。比如开启session的时候，session_start(),他做的东西有很多，首先检测客户端是否有 phpsessid，如果没有，通过函数setcookie，在客户端种植，其实底层就是通过在返回的header头信息中加入set-cookie，如果已经有phpsessid，会通过寻找客户端对应的session，获取里面的信息。那问题又来了，这个phpsessid的cookie是怎么传送给服务端的呢，我不记得我有加入这个cookie啊，一般情况下，在发送http请求的时候，默认都会带上浏览器的cookie。如果禁用了还可以通过url传递哦，话说从url中获取phpsessid也是在session_start()函数中实现的，可见这个函数的复杂性，和普通的函数还是不一样的，里面有具体的逻辑。 对于cookie的设置，也是有跨域问题的，a.test.com下的cookie,在b.test.com下面不能获取到，但是如果在test.com下面就能获取到了，为什么呢？看看跨域吧。不信？你可以设置下，在/path页面下设置另一个path的cookie，然后去对应的path下刷新，看是否有，答案是肯定有的啦。所以cookie的设定。path是不影响的。 既然能设定，自然就能删除，设定和删除可以归为一类操作（直接把过期时间设定成当前时间-100就可以删除了，注意cookie有max-age存在的时间和expire过期时间之分，php的setcookie设定的时间是expire时间，所以需要在过期时间+time()!!之前就犯了这个错误） 其实php的setcookie也能验证这点。在控制器中调用setcookie，如果不传path，默认是当前path，但也可以加path,比如/。 但需要注意的是不同path下面不能相互读取!!!怎么试验呢，可以在chrom的application下面写,然后在当前path写同一个域名下的另一个path，刷新cookie，发现另一个页面下面的有这个设置的cookie，请求的时候也能带上，但是自己这个设定页面没有，所以有时候如果setcookie没错误，但也没出现cookie，可以考虑下是不是设置路径错误了，虽然设置上了，但是看不见。这种情况特别容易出现在前后端分离的情况下，前端在80端口下，后端在8080端口下，后端api设定cookie是装在了8080那个域名下面，所以你无论怎么刷新前端页面都不会有这个cookie，但是没关系，当你请求后端接口的时候，请求会自动加上！！但要注意，请求的时候，http请求只能把他当前能看到的cookie带上，对于他看不见的肯定不会带上。]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F06%2F06%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。 关于浏览器同源策略的原因，可以网上查看各种资料，阮一峰的博客是个很好的选择。 什么时候会出现跨域 12345http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同）组成一个域名（协议号：//ip地址：端口号）三者任意一个不同就会出现跨域 如果解决跨域呢，自己主要了解的有两种，分别是cors和jsonp,自己平时用的主要是cors。 cors可以让后端代码不用做过多的变动，只需要对返回的内容多添加些头部信息即可。 jsonp主要是通过script，img标签这类不存在跨域，回忆一下，是不是通过img加载过百度的图片，通过script的src加载过cdn上的jquery。 通过script返回的内容因为在script标签内部，所以可以执行script代码，所以当我们传给后端我们定义好的方法名，然后让他们把我们需要的数据放进去，再返回来，类似 1showData(&#123;&quot;1&quot;:&quot;boy&quot;&#125;); 上面的返回结果在script代码中自动执行，就能得到我们想要的结果（需要注意的是传入的数据必须是json类型哦，毕竟后端和js是不同的语言类型，然后我们只需要在showData里面对json数据进行转换成js能识别的数据即可）。 对于jsonp，我用的比较少，因为很多时候不想特别写专门用来跨域的api接口，所以如果要用jsonp，后端逻辑代码需要更改（百度php如何配合jsnop完成数据传输）。 对于前端，像jquery有对jsonp的封装，可以自定义函数，然后传入，返回的数据会先走定义的函数，然后来到success函数里面，注意success传入的参数data是不包括后端返回的内容中的函数，而是函数的参数们。 juqery默认传的自定义函数名称是jquery带一长串数字，具体的用法可以百度查看，我没咋用过。 还有哦，jsonp只能支持get请求。 鉴于上面诸多的麻烦，我用的主要是cors。 首先我们需要知道浏览器将跨域请求分成了简单请求和非简单请求，什么是非简单请求，就是那些不是get post（请求方式）,返回头信息中加入token这类自定义的东西，就是非简单请求，一般情况下，我们的请求都是非简单请求，毕竟简单请求content-type 好像都不能是json类型。 对于非简单请求，会先在正式请求之前发送一个options请求，当有跨域请求的时候，我们可以看下Chrome的控制面板，很清楚的能看到。对于返回信息，我们需要加以下头信息 1234$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); //允许的ip$response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;); //允许的方法$response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, token&apos;);//自定义的头部信息 大致只需要做这些处理，一般像php，只需要在router的 end（返回具体信息）之前加上上面的信息就可以了。 像node，或者swoole都在启动web服务的文件处加上即可。 ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP opcache]]></title>
    <url>%2F2018%2F05%2F25%2FPHP-opcache%2F</url>
    <content type="text"><![CDATA[opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。 原理：大概的意思就是把php的脚本一次性全存入内存中，然后每次读取脚本直接从这里面取，而不用每个连接都读取一份脚本。 但这样就存在修改数据后服务器识别不到，可以配置参数，多少秒服务器检查一次，但一般生产环境直接把配置成0，就是间隔时间是0，单位是s，然后停止检查，而开发环境参数配置成1，一直检查，这样就不会存在修改文件，没有效果了。 还可以手动清除，必须脚本中写入 1opcache_reset() 但需要注意的就是不同模式下储存脚本是在不同的内存空间中，比如cli下执行脚本文件，和通过浏览器这种mod_php清除是不一样的，所以浏览器访问的话就通过浏览器的方式去执行脚本吧。 当然，如果和我们swoole那样，每次修改代码后重启web服务器，那是根本不存在这种情况的。 话说偶然间发现代码的不同方式发布 121.类似前端代码那种，每次新代码的发布都会重新打个包，然后把站点目录通过软连接指向这个新包2.我们现在用的，通过在服务器上更新svn上的代码，来发布新的代码 首先运行环境是php7.014,线上环境是php5.6,效果不是十分明显，还有opcache_reset() byte-code不是十分好用。 首先得开启这个扩展，在phpinfo中查找opcache或者 php -m 中查找opcache，其实直接php -m就好了，会有个很显眼的ZendOpcache, 安装方法就是因为默认编译的时候大部分都有–enable-opcache,或者phpinfo页面上可以看见编译的参数，直接在php.ini 里面开启zend_extension=opcahce.so就好了，或者下载文件源码编译。 或者重新编译一下php（这个忘记了） 或者可以像pgsql那样去php源码包里面找源文件进行编译？这样可行吗，没有试过。 参数 12345opcache.validate_timestamps=1 //是否检测修改opcache.revalidate_freq=0//单位时间opcache.memory_consumption=64 //memory_consumption 这个参数很好理解，代表这块内存区开辟的大小，另外需要注意不同 PHP SAPI 内存区不是共享的，就是说同一个 PHP 文件，运行在命令行模式或者 PHP-FPM 模式下，对应的 byte-code 会存储在不同的内存区中。opcache.max_accelerated_files=4000 //如果命中率不搞，可以适当提升这个值，直到1。opcache.opcache.fast_shutdown=1 //modern php上面说这个写1就可以了 （opcache_get_configuration()和 and opcache_get_status()）获取配置信息和运行信息，比如了解那些文件被缓存了、使用了多少内存、内存命中率等等。 感觉就是基于这两个函数出了两个opcache的项目，一个是单页面，一个比较复杂 1.PeeHaa / OpCacheGUI 2.rlerdorf / opcache-status 单页面的部署直接放在网站根目录下就好了，就理解成phpadmin那种网点就好了，利用的就是php的函数获取php的运行环境，然后可视化展示出来 opcache_invalidate()，这个函数就是更新特定的文件缓存，没去试验过，因为项目小啦，直接重启web server。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP yield]]></title>
    <url>%2F2018%2F05%2F25%2FPHP-yield%2F</url>
    <content type="text"><![CDATA[yield，生成器，自己感觉还是挺重要的，因为php在读取大文件的时候经常会有内存溢出的错误，其实yield还会涉及spl，这部分内容自己目前了解的还不是十分清楚，所以，暂时就把yield的作用归类于放置变量过大在内存中占用本大空间，导致内存溢出吧。 关于yield这种数据类型，还有迭代器，还有collection，都是能用foreach进行循环遍历的。 1234567891011121314function productNum($length)&#123; $data = []; for ($i=0; $i&lt; $length; $i++)&#123; $data[] = $i; &#125; return $data; &#125;$data = productNum($100000000);foreach ($data as $key=&gt;$value) &#123; var_dump($value); &#125; 用php执行上端代码会报出超出分配给php的内存错误 123456789101112131415function productNum($length)&#123; //$data = []; for ($i=0; $i&lt; $length; $i++)&#123; //$data[] = $i; yield $i; &#125; //return $data; &#125;$data = productNum($100000000);foreach ($data as $key=&gt;$value) &#123; var_dump($value); &#125; 能执行成功，其实这个时候打印$data变量，可以看出来他是一个类。 每次foreach 去$data中取数据，上面的那个for循环就会执行一次，再次输出一个变量\$i。 so，如果使用yield的内容，每次也得循环使用吗？ yield定义的内容不能有返回。 下面写一个读取文件，再往另一个文件中写入内容的例子，其实这个例子不具有实际价值，其实就是一个copy文件，用shell_exec执行linux命令就可以，或者file_get_contents,file_put_contents这样就好了，使用yield分多次，唯一可以想到的好处就是控制对内存占用的大小。 1234567891011121314function getContent($file)&#123; $res = fopen($file); while (feof($resource) === false ) &#123; yield fgets($resource); &#125;&#125;$res = fopen(&apos;/home/itbasic/3.pdf&apos;, &apos;a&apos;);foreach ($content as $c_key=&gt;$c_value) &#123; fwrite($res, $c_value);&#125;fclose($res);echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;; //使用: 362640B 用传统方式 123$res = file_get_contents($file);file_put_contents(&apos;/home/itbasic/1.pdf&apos;, $res);echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;; //使用: 39875608B 显然超过一个数量级，yield就是把一个结果集分批的给你，你什么时候问他要下一个结果集，他什么时候给你。]]></content>
  </entry>
  <entry>
    <title><![CDATA[框架学习0]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A00%2F</url>
    <content type="text"><![CDATA[想了下，还是把框架的基础知识也记录下来。 首先我们需要认识到框架也是一个脚本，不要因为现代的框架都是oop而忽略了面向过程。框架的入口文件其实可以看做框架的处理文件，就是一个php文件，只是因为框架把对于问题的处理发送到内部的面向对象库中去了，所以我们才会忽略框架本身的面向过程，这就经常会让小伙伴不知道比如记录用户的访问信息，如果不写在登录接口中应该写在哪呢。 框架中对于常量的定义，对于辅助函数的定义（没有用命名空间，类似原生php函数的使用）我们经常只是在框架定义好的文件中添加，但忽略了为什么在这个地方写就能这样使用，其实本质上都是因为在入口文件出有include 这个文件才会这样。 一般入口文件只写一些文件加载，像返回数据的处理之类的一般写在route之中，我们那个bbs写在了入口文件中，添加返回头信息啊之类的，感觉也还行。对于异常的捕获处理一般也写在最外层的入口文件处，这样很暴力，这样每当我们有错误的时候想立刻终止可以通过马上抛出异常，而不用执行到脚本的末尾。]]></content>
  </entry>
  <entry>
    <title><![CDATA[框架学习1]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[对于框架源码的学习，可以帮助我们以后快速学习一个框架的使用，虽然同样的效果同样可以使用多学习几个框架，比如你把tp学完你学习laravel和yii发现很多时候都是一样的，但这仅限于你对框架的使用，增删改查的使用，当你想去修改一个框架的时候（不包括把框架中常量提取出来放在一个文件中，给框架增加一个validate等等这种情况）而是类似于把框架原来的隐式路由改成显式路由这种情况，如果你没有动手搭建过框架，你会不知所措。 我们这里对于框架的搭建还不是从头到尾写一个框架这种情况，composer（php的包管理工具，类似前端的npm），我们可以像拼接乐高积木那样搭建一个框架，那用什么来充当积木间的凹槽呢，我觉得命名空间可以充当凹槽之一。 命名空间在我的理解中就是把项目代码看做一个文件夹，然后名称是/,然后下面的各个文件夹名称就是命名空间，为了区分不同文件夹下的相同文件夹名称，我们需要把文件夹名称的路径记录下来。如果我的文件放在文件夹中的目录结构比较深，那么外层的文件夹名称是否可以不要呢，答案是肯定的，我觉得这也是文件夹相对于使用路径的好处之一。 上文说到了composer，我们要怎么使用这个工具呢。在项目的根目录下（注意不是网站的根目录下，网站的根目录往往是入口文件的根目录）执行composer install，linux下需要时php composer.phar install,他会找composer.json文件，第一次可能没有，我们可以通过composer require xxx/xxxx 来安装一个依赖，这时候会多出composer.json , composer.lock, vendor 目录，我们在入口文件出只需要include vendor/autoload.php, 就能使用vendor中的依赖了。我们项目中自定义的文件夹也可以通过composer 的autoload来实现自动加载。php的psr-4和psr-0都有对命名空间的规定，但是0废弃了，现在大家都是用4，比较下0和4，比如 \controller\test.php, 12&lt;?phpnamespace controller; 123456789101112131415//psr-0&#123; &apos;autoload&apos; : &#123; &apos;controller//&apos; : &apos;&apos; &#125; &#125;//psr-4&#123; &apos;autoload&apos; : &#123; &apos;controller//&apos; : &apos;controller&apos; &#125; &#125; psr-0会把规定的路径再拼上命名空间当做相对路径去文件夹下找，而psr-4会直接把规定的路径当做命名空间去寻找，上面的例子只是针对简单的一层命名空间，还是看不出什么效果，多层的更容易看出0是多么的脑残。 还有当注册了controller文件夹，controller的子文件夹的命名空间默认注册。 我们在修改命名空间的时候只需要修改composer.json文件就可以了，对于composer的具体怎么加载的其实不用管的，他应用这么广泛，一般不会出现什么问题。 todo: use 的时候命名空间顶层不用加\,但是new的时候如果顶层写要加\，不是十分理解。 来自modern php 首先use 的时候默认的是来自绝对，默认会在前面加上\ 同一个命名空间下的类相互引用，不用引入命名空间，比如我同一个controller下面代码的相互使用 xxx/xxxx,这种的一般第一个 xxx是厂商的命名空间，顶层命名空间，比较重要，第二个xxxx是子命名空间。 仅仅use 其实默认用了as取别名，只是类名和别名一样 Exception默认是php自带的，应该在顶层命名空间下，用\，如果使用的时候不加，他会默认在当前命名空间下寻找，会出现错误]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookie和session的思考]]></title>
    <url>%2F2018%2F05%2F18%2Fcookie%E5%92%8Csession%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近新开了一个bbs的项目，因为也有登录和退出，但问题来了，和大多数的公司内部项目一样，如果每个项目都有自己的登录名和密码，都得注册，每次去不同的项目用户都需要进行登录，估计用户会疯吧。其实这个问题很久之前就遇到过，当时是别的部门的项目希望通过我们这边保存的用户信息进行登录，老大的想法是写一个接口给他们使用，但是如果项目越来越多，每次写接口肯定不太合适，那位同事和我说过单点登录，趁着这次机会，自己也了解了下。 首先是 /的理解。 关于相对路径和绝对路径，一般的解释是以/开头的就是绝对路径，以./开头的就是相对路径，没有这个开头的其实也是相对路径。 这个在linux中是绝对正确的, /这个在服务器中指代的就是/目录。 但这个理论也用在前端代码中，难道我们src = ‘/assets/xxx’,是去服务器根目录下assets目录下查找文件吗，显然这个理论是不正确的，所以这个/在前端代码中的意思是网站的根目录，对！！比如这个前端网站是itbasic.datatom.com,那么这个/指代的就是apache里面配置的root文件夹，所以前端代码中的这个/是由apache或者nginx等之类的web server 部署的时候决定的。 todo: itbasic中view文件夹不在/目录下，但是里面引用的文件相对路径却是相对/路径的，这是个很奇怪的问题。 php中有个函数setcookie,这是个在客户端种植cookie的函数，比如我们为了维持http的有状态，所以使用了session机制，通过在客户端的记录phpsessid ，然后服务器端（我用的是apache 的模块加载，默认是放在/tmp目录下）sess_(phpsessid)这个文件，这个文件中会保存你想让这个连接保存的相关信息。 那什么时候服务器端会在客户端记录phpsessid呢，是在start_session() ，这个函数调用的时候，php已经为我们封装好了对应的方法，注意setcookie，本质上是通过给浏览器头部发送消息，可以看下你调用setcookie这个方法的response，他的返回头中会有set-cookie，我的理解是如果想要返回头信息，在这之前不能有任何的输出，所以才会在start_session()之前不能有任何的输出。 setcookie函数可以看下，默认是在 当前文件所在路径下种植cookie，可以改成/,就可以在根域名下种植了，根域名下种植的好处就是下面的所有文件都能访问和删除这个cookie，如果你是在某个文件下种植的，只有当前文件才能放访问到，比如/bbs/dist,只有这个路径下的文件才能访问到。 还有放在/下的好处就是，/就在发送请求的时候他会自动的放在请求头部信息中，但是 如果你是放在/bbs/dist下面，他只会在请求/bbs/dist下的时候会携带，当访问/home之类的时候就不会携带。 还有个问题是关于重定向的，之前遇到的重定向就是爬取页面的时候会返回304，其实还有别的作用，比如cookie的种植。当今时代，api盛行，感觉这就是我忽略重定向的原因，我曾想着通过请求接口的方式进行setcookie，但好像是失败的，只能通过header（）这种方式。 关于单点登录： 使用场景：其实是一个很常见的情况，公司有很多系统，但用户基本信息只用一个就好了，虽然可以通过在各个系统中通过读取同一个数据库中的同一个表来实现登录，但如果每次用户使用公司的各个系统都得登录，这种体验真是太差了，最简单的方法，如果是在相同的域名下，可以通过在根域名下种植一个cookie信息，然后每次登录检测这个信息，这样其他域名也能检测到，这样就实现了统一登录和注销。 其实itbasic就是用的这个原理，所有的同一个域名下都可以使用这个原理，itbasic稍有不同就是登录原理的不同，一个是用cookie，一个用的是token。 其实最方便扩展的还是单点登录，对于单点登录就是独立出一个登录系统，虽然各个界面都有自己的登录，但每次登录之后都会在中间系统注册一下，然后每次登录都会去中间系统检测下是否登录，如果登录了，就不用再登录了，如果没有登录，首先在自己的系统中实现登录，再去中间系统中保存已登录状态。注销的时候也是，首先在中间系统中实现注销，然后遍历删除各个子系统中的登录状态。 单点登录因为没有去实现，所以理解还不是很深刻，只知道中间的登录系统最好用https。 还有对于session，传统的是以文件的形式保存，遇到的一个bug就是itbasic服务器内容满了，导致session写入一直失败，而bbs中token的作用类似session，但是他是放在redis中存储的，就不会有这个问题，感觉这也是session用redis和memcahe实现的好处之一，而不用file实现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[验证器]]></title>
    <url>%2F2018%2F04%2F25%2F%E9%AA%8C%E8%AF%81%E5%99%A8%2F</url>
    <content type="text"><![CDATA[验证器应该是我们在使用TP,Laravel这些框架的时候经常遇到的,英文名Validate,为什么要验证器呢？数据验证应该是所有web api的第一步，通过校验前端数据的是否合法，来进行数据的接下来的操作，如果数据不合法，直接退回给前端，而不用执行。 Laravel 123456//验证数据的正确性 $this-&gt;validate($request, [ &apos;name&apos;=&gt;&apos;required|max:50&apos;, &apos;email&apos;=&gt;&apos;required|email|unique:users|max:255&apos;, &apos;password&apos;=&gt;&apos;required|confirmed|min:6&apos; ]); TP 12345678910protected $rule = [ &apos;name&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;mobile&apos; =&gt; &apos;require|isMobile&apos;, &apos;province&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;city&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;country&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;detail&apos; =&gt; &apos;require|isNotEmpty&apos; ];$result = $this-&gt;batch()-&gt;check($param); 其实两个很类似，就是通过传入验证条件和接受到的参数，来进行对应规则的验证. 自己 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Libs;use Framework\Exception\ClientException;use Framework\Exception\ServerException;class Validate&#123; static $res = true; static $errMsg = &apos;&apos;; /** * @param $arr, 传入的验证规则 * @param $params, 请求的数据 * @throws ClientException */ public static function validate($arr, $params) &#123; foreach ($arr as $a_key=&gt;$a_value) &#123; $funcArr = explode(&apos;|&apos;, $a_value); foreach ($funcArr as $f_key=&gt;$f_value) &#123; if(is_callable([__CLASS__, $f_value])) &#123; call_user_func_array([__CLASS__, $f_value], [$a_key, $params]); &#125; else &#123; throw new ServerException(&apos;&apos;, &apos;你的验证函数名不存在啦&apos;); &#125; &#125; &#125; if(self::$res == false) &#123; throw new ClientException(&apos;&apos;, self::$errMsg); &#125; &#125; public static function required($key, $arr) &#123; if (!key_exists($key, $arr)) &#123; self::$res = false; self::$errMsg .= $key.&apos;不存在 | &apos;; &#125; &#125; public function __call($name, $arguments) &#123; throw new ServerException(&apos;&apos;, &apos;你的验证函数名不存在啦&apos;); &#125;&#125; controller调用 12$validate = [&apos;comment_id&apos;=&gt;&apos;required|test&apos; ,&apos;sex&apos;=&gt;&apos;required&apos;];Validate::validate($validate, static::params()); 需要注意的点是： 上面验证器的使用过程中并不是检测到错误就立刻返回，而是检测出所有的错误再返回，所以我定义了两个static用来存储数据，当标志位是false的时候再把存储的错误信息一起返回。 is_callable函数的使用，验证函数是否能执行，如果是类中，[‘类名’， ‘方法名’]， 都是字符串，注意这个类名用__CLASS__,之前我直接写的Validate，这样肯定是不行的，同理call_user_func_array这个也是，相比较于call_user_func,这个是后面传入函数中的参数要以array的形式，如果是非静态函数，就传入类名，静态的话要传入对象哦，$this,或者new一个对象吧。call_user_func_array is_callable 需要注意static的使用，用的self哦，一般的使用用的this(都是在类中)，在类的外面的话，static 是 类名::,非static用的是 object-&gt;func. __call 是类中不存在这个方法的时候调用会自动执行，传入的两个参数第一个是调用的方法名，第二个参数是参数.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME TYPE的作用]]></title>
    <url>%2F2018%2F04%2F23%2FMIME-TYPE%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[其实本来不用单独写这篇文章的，可以放在http协议中，因为他本来就是关联这个http请求和返回信息中的content type，但其实用的还挺多，主要就是上传文件这块和php不借助插件而是通过输出html表格元素让页面按照excel来解析的方式生成excel。 一、 首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的，例如:Content-Type: text/HTML表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。(现在不用xml，而是用json，一般在返回头中都有) 12&gt;$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;);&gt; &gt; 注意这个content type，不仅在response中有，在request中也有， 123&gt;application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）&gt;multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）&gt; &gt; 上面的两种应该是我们平时最常见到的，一种是普通的表单提交，一种是当表单中有上传文件的时候进行的提交方式中content type的设置(好像默认的表单提交就是第一种，不用设置，只有上传的时候需要特殊设置，像我们itbasic上面，大部分时候用的是ajax进行提交，而不是表单，content type在ajax中应该封装成了text/json) 1234567&gt;&lt;form action=&quot;http://192.168.33.10:56732/bbs/login/test&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&gt;&lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt;&lt;br&gt;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&gt;&lt;/form&gt;&gt; &gt; 当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。 更详细的介绍https://www.cnblogs.com/jsean/articles/1610265.html 因为这篇文章复制有很多重复的部分（▄█▀█●），复制下来改很麻烦。 认识的几点就是：服务器端要存储文件后缀名和mime type的对应关系，我是这样理解的，虽然在linux下文件后缀名并没有什么卵用，感觉这都是content type的作用，但在windows下起了很大的作用啊，在服务器端保存文件的使用，需要通过content type对应的mime type 转换成文件后缀名，然后保存（虽然感觉直接读上传的文件名就可以了，感觉也许是兼容那些没有文件后缀名的情况吧，linux？） response 里面content type的作用很明显是通知客户端怎么解析这个文件。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2018%2F04%2F23%2FRedis%2F</url>
    <content type="text"><![CDATA[缓存，对于现代web很重要，首先他比较快嘛，因为是在内存中的，像很多功能也是通过缓存来实现的，比如点赞功能之类的，记录下常用的redis命令。因为是写php的，所以举得例子大部分还是以php的redis扩展为参照，其实大部分都一样。（没有系统的学习，大致浏览了下菜鸟教程上的redis教程） 安装 常见知识点： 端口号：6379 密码：可以设置，也可以不设置。itbasic上没有设置，但只允许本机才能连接服务器上的redis。 启动：安装目录下的redis-server,最好后台挂起，要不然这个cmd就没法用了 连接： 安装目录下的redis-cli 常见数据类型：1.string 2.hash 3. 4. 5 通用命令： keys * : 获取所有的key string：get(),根据key值获取 12345678910class \Lib\Redis extends \Redis //因为这个继承于php自带的扩展，所以命名空间在\下&#123; public function __construct() &#123; 建立连接 &#125;&#125;$redis = new \Lib\Redis();$redis-&gt;get($key); set,设置值 1$redis-&gt;set($key, $value,) hash: hash类型不能像string的set方法中设置系统key的过期时间，可以通过调用expire来设置时间。 1$redis-&gt;expire($key, 7*24*60*60); hset: 设置hash的filed的值,这个key意思就是这个hash对象的唯一标识 1$redis-&gt;hset($key, $filed, $value) hmset: 给这个对象进行赋值, $arr是关联数组 1$redis-&gt;hmset($key, $arr) hgetall: 获取这个hash对象所有的内容 1$redis-&gt;hgetall($key) 坑： 之前很傻，因为接触到redis的时候，听到的好处就是相比较于mecache这种，多了很多的数据类型，memcache这种只有string，然后redis又在原先5中数据类型的基础上增加了表示地理坐标的新的数据类型。当时遇到一个问题就是想一个键值既能对应string，也能对应hash，想有没有这种数据类型。其实当时的思路是完全跑偏的，完全可以通过先构造一个比如token=&gt;string,string=&gt;hash两个类型，第一个是string，第二个是hash，通过token既能得到简单的string，也能得到hash。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理其实是我一直很少接触的，之前是因为异常处理相比较于php的基础知识更高一层，大学时就有个习惯，越到后面的内容看的越少，比如c语言的指针，每学期的专业课，都是只能讲完前面的语法部分，运算符？if？else？for循环？后面就没了。 但当我学习tp5的时候，发现tp5的所有错误都会以异常的形式抛出，然后在7月老师的指导下，认识到了AOP思想，了解了统一异常处理类的时候，我才逐渐重视了这个东西。 新项目中：因为我希望把每个函数写的尽量短些，虽然以后追踪问题的时候可能会跳来跳去，但如果单单只靠函数的名称就能了解到函数的作用，这将是多么美好的一件事，于是产生了一个问题：一般只有最外层的函数才能决定最终抛给客户端的内容，但如果我们在内部自己调用的函数中也这么写，比如 12345678910111213141516public function father()&#123; $res = $this-&gt;children(); return [ &apos;code&apos; =&gt; 200, &apos;msg&apos; =&gt; $res ]&#125;public function children()&#123; return [ &apos;code&apos; =&gt; 500, &apos;msg&apos; =&gt; &apos;你有毒&apos; ]&#125; 这个样子返回的结果肯定不是我们希望的，你可以说我可以处理啊，但其实如果层次深了之类的，处理是很麻烦的，如果我能立刻把结果给到前端，那该多棒啊，这时候就可以通过抛出异常，最外层统一对异常进行处理，比如抛出异常的时候 1throw new ControllerException(404, &apos;controller not exist.&apos;); 这个ControllerException 是继承于基本的\Exception，php自带的。然后我们在最外层进行捕获 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?phpdate_default_timezone_set(&apos;Asia/Shanghai&apos;);include_once(&apos;vendor/autoload.php&apos;);include_once &apos;./Libs/Eagles/Document.php&apos;;define(&apos;SWOOLE_PORT&apos;, 56732);define(&apos;SWOOLE_ERROR_LOG&apos;, &apos;/var/log/swoole_error.log&apos;);define(&apos;EAGLES_SERVER&apos;, &apos;211.144.114.26&apos;);define(&apos;EAGLES_PORT&apos;, &apos;17200&apos;);// error_reporting(0);// http服务的配置$http = new swoole_http_server(&quot;0.0.0.0&quot;, SWOOLE_PORT);$http-&gt;set([ &apos;worker_num&apos; =&gt; 20, // cpu 6核 默认启动6个, 1-4 倍合适 占用：40M内存*20 // &apos;task_worker_num&apos; =&gt; 6, //开启task功能 // &apos;daemonize&apos; =&gt; true, // 守护进程 &apos;log_file&apos; =&gt; SWOOLE_ERROR_LOG, &apos;buffer_output_size&apos; =&gt; 8 * 1024 *1024, // 8M 缓冲区。占用 8*12M,api接口可最大返回8M的数据内容 &apos;package_max_length&apos;=&gt; 5 * 1024 * 1024, // 最大数据块是5M。上传可上传4M大小文件 // 配置静态文件根目录 // &apos;enable_static_handler&apos; =&gt; true, // &apos;document_root&apos; =&gt; &apos;/home/projectx/server/upload&apos; // &apos;daemonize&apos; =&gt; true, // &apos;pid_file&apos; =&gt; __DIR__.&apos;/server.pid&apos;]);use Framework\Base\Route as Router;use Framework\DB\ConnectionManager as ConnectionManager;use Framework\Log\Logger as Logger;$config = include_once(&apos;config/config.php&apos;);Logger::logfile($config[&apos;logfile&apos;]);ConnectionManager::db_config($config[&apos;db&apos;]);$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123; try&#123; if ($request-&gt;server[&apos;path_info&apos;] == &apos;/favicon.ico&apos; || $request-&gt;server[&apos;request_uri&apos;] == &apos;/favicon.ico&apos;) &#123; return $response-&gt;end(); &#125; $param = $request-&gt;server[&apos;request_method&apos;] == &apos;POST&apos; ? @$request-&gt;post : @$request-&gt;get; $data = \Libs\Common::getCallData(@$request-&gt;header[&apos;www-authorization&apos;], $request-&gt;header[&apos;host&apos;], $request-&gt;server[&apos;request_uri&apos;], $param, $request-&gt;server[&apos;remote_addr&apos;], $request-&gt;server[&apos;request_method&apos;]); //\Libs\ElasticSearch::setIndexTableDoc(&apos;projectx_log&apos;, &apos;call_log&apos;, $data[&apos;doc_id&apos;], $data[&apos;data&apos;]); $allow_method = [&apos;POST&apos;, &apos;GET&apos;, &apos;OPTIONS&apos;]; if(!in_array($request-&gt;server[&apos;request_method&apos;], $allow_method))&#123; $response-&gt;status(405); return $response-&gt;end(); &#125; //如果需要设置允许所有域名发起的跨域请求，可以使用通配符 * $response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); $response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;); $response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Origin, X-Requested-With, Content-Type, Accept, www-authorization&apos;); $uri = $request-&gt;server[&apos;request_uri&apos;]; $uri = $uri; $res = Router::dispatch($uri, $request, $response); @$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;); @$response-&gt;end(json_encode($res)); &#125;catch(\Framework\Exception\ControllerException $ce)&#123; $status = $ce-&gt;getStatusCode(); $response-&gt;status($status); $errorcode = $ce-&gt;getErrorCode(); $msg = $ce-&gt;getMsg(); $response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); $response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;); $response-&gt;end(json_encode([&apos;code&apos;=&gt;$errorcode, &apos;msg&apos;=&gt;$msg])); &#125;catch(\Framework\Exception\RouteException $re)&#123; $status = $re-&gt;getStatusCode(); @$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); @$response-&gt;status($status); @$response-&gt;end(); &#125;catch(Exception $e)&#123; @$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); @$response-&gt;status(500); @$response-&gt;end(&apos;exceptions:&apos; . $e-&gt;getMessage()); &#125;&#125;);echo &quot;server start listening port:&quot; . SWOOLE_PORT . PHP_EOL;$http-&gt;start(); 看见了嘛，最外层的几个catch就是对他的捕获，注意最大的要写在外面哦，因为前面的如果捕获了，后面的就不会处理了呢。 其实通过上面的例子我们还能了解到其实一个php项目说到底还是一个脚本，上面代码是我用swoole搭建的webserver时候的启动脚本，其实用swoole能更好的帮助phper理解web是怎么样运行的，当服务器监听到request过来的时候，我们通过这个 1Router::dispatch($uri, $request, $response); 去执行对应的项目里面的代码，这就是我们平时经常写的工程，大部分用的是面向对象的思想，定义一个类啊，方法啊，因为这里面就像一个仓库，是我们用来取东西的，所以没有那种流程的概念，唯一的流程概念应该在我们这个启动脚本里，这也是我们把try catch 写在这里面的一个原因（这也是我找php统一异常处理的方法应该定义在哪的时候发现的），后来继续思考了下，感觉不管是我之前做的那个itbasic，还是现在这个bbs，其实都是脚本+类库合在一起的，因为很多时候我们往往都是在写类库，而忽略了脚本的存在（一般都是写好的，很少需要改），甚至把一个项目就当做一个面向对象，而忘记了面向过程的存在，之前群里面有个朋友不知道在哪定义通过哪个搜素引擎查找到自己网站的网上百度的方法，根源也是因为不理解一个项目的脚本到底存在于什么地方。 其实类比自己接触的两个框架，tp和laravel,为嘛他的入口文件index.php和路由文件分开了呢，:sweat: 其实本该分开，路由是个类库，入口文件是个脚本呢，之所以产生这种坑爹的想法是itbasic的route.php即是入口文件，也是路由类定义的地方。 观察server.php, 观察config目录，发现set.php 是定义的常量，这样在使用的时候可以直接使用，但是config.php 是返回的数组，项目里面想用这里面的值是不可以直接使用的，那数据库是怎么连接的呢，发现 1ConnectionManager::db_config($config[&apos;db&apos;]); 这个类和普通的类不一样，这个直接在入口文件中就有加载，这个是把config里面的值保存到他的类变量中了，所以在项目里面可以直接使用。 还有上次那个exception，其实子类继承了父类，父类中变量和子类中变量重名，但他们是各自的，子类继承了父类，用了父类获取自己errorcode的方法，那个其实是获取父类的，而并非是获取子类的，这点要注意。 子类继承父类的初始化函数的时候不要忘记传参数了哦。 wait: 1.异常处理的细节]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信开发]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgresql常见问题总结]]></title>
    <url>%2F2018%2F04%2F17%2Fpostgresql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本来是不想写这篇文章的，因为感觉自己对于postgresql理解不够深入，但因为生活中对于postgresql有些问题总是遇到，所以记录下来，方便以后查找。 1.navicate连接postgresql 第一次建立连接肯定会报错啦 上面初始数据库的意思并不是数据库的名称。毕竟这次连接成功后，里面有一堆的数据库 The server doesn’t grant access to the database: the server reportsFATAL: no pg_hba.conf entry for host “192.168.0.123”, user “postgres”, database “postgres” FATAL: no pg_hba.conf entry for host “192.168.0.123”, user “postgres”, database “postgres” 谷歌翻译 服务器不授予对数据库的访问权限：服务器报告FATAL：主机“192.168.0.123”，用户“postgres”，数据库“postgres”没有pg_hba.conf条目FATAL：主机“192.168.0.123”没有pg_hba.conf条目，用户“postgres”，数据库“postgres” 其实字面意思就很容易理解，虽然我还是百度的错误答案。我自己理解就是入口不被允许,就觉办法如下 PostgreSQL数据库为了安全，它不会监听除本地以外的所有连接请求，当用户通过JDBC访问是，会报一些如下的异常： org.postgresql.util.PSQLException: FATAL: no pg_hba.conf entry for host 要解决这个问题，只需要在PostgreSQL数据库的安装目录下找到/data/pg_hba.conf,找到“# IPv4 local connections:” 在其下加上请求连接的机器IP host all all 127.0.0.1/32 md5 //坑爹，那里面对于192.168.23.10当做192.168.23.1 32是子网掩码的网段；md5是密码验证方法，可以改为trust 一个服务器，有内网ip（类似192.168这些，有外网ip 211.这种，有127.0.0.1 这种，如果要包括所有的，就得用0.0.0.0，感觉如果你访问一个服务器用的是内网ip，应该意思就是你们在同一个局域网中吧。很奇怪的一点是，之前说vagrant会把ssh的22端口映射到host的2222端口，导致了127.0.0.1:2222或者192.168.23.10:22都能访问，其实不太懂这个原理，但好像这是由两个不同的网卡决定的，我好像把itbasic那上面一个网卡禁止了，导致127那种ssh访问不了，感觉就是虽然内网ip和外网ip可以对应同一个端口，但也可以对应不同的端口） 2.导入导出数据库 导出：/opt/pgsql/bin/pg_dump -U postgres itbasic &gt; /home/itbasic/itbasic.sql pg_dump 是postgresql安装之后的一个命令，-U 指定用户 postgres, itbasic,是数据库名，postgresql好像只能用postgres这个用户执行操作，itbasic这个数据库名一定要指定，还有pg_dump 这个命令所在目录没有加入系统变量的话，一定要加上路径，后面 &gt;/home/itbasic/itbasic.sql,代表数据导出到具体的文件中。 导出 数据库的导入必须要先创建这个数据库 postgresql安装之后的命令会有createdb，但用这个创建数据库感觉挺麻烦，直接 12341. /opt/pgsql/bin/pgsql -U postgres itbasic //进入pgsql 客户端2. create database project x //创建数据库3. \q //退出pgsql客户端4. /opt/pgsql/bin/pgsql -U postgres projectx -f /home/itbasic/projectx.sql //导入数据库 3.导入导出表 导入导出表和导入导出数据库的最大区别是导入导出数据库需要先建立一个数据库，而表则不用，最好还先把这张表删除了 导出 /opt/pgsql/bin/pg_dump -U postgres itbasic -t dt_admin &gt; /home/itbasic/admin.sql 导入 /opt/pgsql/bin/psql -U postgres itbasic -f /home/itbasic/admin.sql 4.数组类型 array_remove 会把出现的元素全都移除掉，而不是只移除一个 love=array_remove(love, chen.ye) array_append love= array_append(love, chen.ye) 如果元素不存在，也不会报错，只会接着往下执行 any() chenye = any(love) love这个字段中是否有陈野 5.今天在到处数据的时候发现了一个不得了的问题，就是通过命令导出的数据的时候当文件一定大的时候，会自动停止，但是导出语句不会报错，这就坑爹了，也就是说我每天备份的那些文件都没有任何的意义 可以通过 1/opt/pgsql/bin/pg_dump -U postgres itbasic -t &apos;(dt_user|dt_user_login|dt_userinfo)&apos; &gt; /home/itbasic/t4.sql 分表导出 表名的话可以通过 1select tablename from pg_tables where tablename like &apos;dt_%&apos; 筛选出来再连接，果然定义成有前缀好处颇多，要不然筛选出好多自带的无用的表 6.感觉要多看看别的项目是怎么进行数据备份的，之前的那种一次性导出的方式不行，当数据量大的时候，单表备份可能都不行。]]></content>
      <categories>
        <category>postgresql</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache简单配置]]></title>
    <url>%2F2018%2F04%2F16%2Fapache%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于apache的配置文件。不管是xampp安装的lamp环境，还是自己在linux下面搭建的lamp环境，之前关于apache的配置都是直接copy网上的，用的虚拟域名，本质是还是不够理解的，关于.htaccess 也只是刚开始学习tp的时候看到过，后来因为配置虚拟域名能解决问题，就没有过多的了解这个.htaccess了。 首先说一下之前遇到的问题。某次，帮助交付的一个同事配置xampp环境，他当时对多站点的配置文件都写在了apache的主配置文件中，httpd.conf,当时因为已经了解了虚拟域名，所以我在同级目录extra下面的httpd-vhost.conf中帮他写了新的配置，当时用的是不同域名分发到不同文件夹下的方式，其实这在实际生活中也是这样的，因为如果靠的是端口号的话，因为web服务默认是80端口，如果用了别的端口号，比如http:\\www.baidu.com:800, 这样访问百度的web服务，这对广大用户是不友好的，因为对于非程序员来说，根本不知道:800是什么。如果不想用域名开进行分发，端口号也是可以的，但为了不让用户去记忆端口号，可以通过nginx来帮忙。比如itbasic.datatom.com和bbs.datatom.com虽然绑定的是同一个服务器，但是通过nginx的转发，到了不同的端口，一个因为是从itbasic.datatom.com+ 80端口来的，所以转发到本服务器的8080端口，一个是从bbs.datatom.com+80端口来的，所以到了8081端口。我就是通过上述两种方式之一的域名不同来帮那个同事写的vhost配置的，可是呢，当我输入域名的时候，他虽然能访问，但是访问的还是之前他的一个网站，fuck！！！算了，配置文件写的这么乱，我就没找原因了，直接帮他copy了以前主配置文件里面写的一个站点配置。 其实后来我差不多知道原因了，大概是直接在主配置文件里面写了 1234567891011121314151617181920212223242526272829ServerName localhost:80DocumentRoot &quot;F:/www&quot;&lt;Directory &quot;F:/www&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&apos;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks Includes ExecCGI # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # AllowOverride FileInfo AuthConfig Limit # AllowOverride All # # Controls who can get stuff from this server. # Require all granted&lt;/Directory&gt; 问题的关键就是那个server name，因为是localhost：80，但凡是host（windows下）里面127.0.0.1 用的80端口，统一转发到这个目录下，造成了上述结果。其实itbasic的服务器配置上也是这么写的，但之外的那些bbs，51dana用的却是虚拟域名，为啥那个能正常访问呢，在于配置文件上面定义了server name itbasic.datatom.com。其实itbasic那个也是可以通过域名来进行分发的，主要在每个vhost里面加个server name 就可以了。itbasic那个完全也可以不用端口进行转发，完全可以通过域名，在每个vhost里面加上server name就可以了 先说一下关于vhost的配置方法吧 打开apache的配置文件 htppd.cnf。分别打开重写扩展和虚拟主机扩展： LoadModule rewrite_module modules/mod_rewrite.so 这句前面的 注释 # 去掉 Include conf/extra/httpd-vhosts.conf 这句前面的 注释 # 去掉 但现在一般apache都是默认开启的 12345678910111213141516171819&lt;VirtualHost *:80&gt; //包裹的内容代表虚拟主机，端口号80 DocumentRoot &quot;D:/wamp/www/testphp/&quot; //项目的根目录 ServerName php.iyangyi.com //域名 ServerAlias www.pptv.cn #可省略 //这个是我们的虚拟域名的别名，可以不要，他的出现场景就是我们希望另外一个域名也往这个目录下调整。比如 www.pptv.cn 我们也希望跳到这里来，就可以这样做，但是前提是 www.pptv.cn 也要绑定host 127.0.0.1 ServerAdmin stefan321@qq.com #可省略 //这里填 服务器管理员的邮箱，也可以不要，当服务器出现故障后，如果提前有配置邮箱的话，会往这个邮箱发邮件，或者是显示在网页的错误信息当中。一般我们可以不填。 ErrorLog logs/dev-error.log #可省略 //当访问出现错误的时候，就会记录到这里，注意：logs/dev-error.log 这个文件路径是apache的安装目录下的logs 目录 。可以不要。 CustomLog logs/dev-access.log common #可省略 //这里填 访问日志，用来记录每一次的请求访问，可以不要。注意：logs/dev-access.log 这个文件路径是apache的安装目录下的logs 目录 。记住：路径后面加common。 ErrorDocument 404 logs/404.html #可省略 //这里填 403,404等错误信息调整页面，用来访问出现404页面等情况时的错误页面展示，比较有用，也可以不要。注意：/404.html 这个文件路径是项目的根目录，不是apache的目录。 &lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Order Allow,Deny Allow from all RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] &lt;/Directory&gt;&lt;/VirtualHost&gt; 一般配置的时候，上面写了可省略的都不会配置。 1&lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt; 是最重要的一步了，这里也是填本项目的路径，然后所有的rewrite规则都是在里面完成。所以这个是很重要的。 1Options Indexes FollowSymLinks 作用我访问php.iyangyi.com，如果文件根目录里有 index.html(index.php)，浏览器就会显示 index.html的内容，如果没有 index.html，浏览器就会显示这文件根目录的目录列表，目录列表包括文件根目录下的文件和子目录。 到底是优先显示index.php还是index.html 有apache的配置决定的： 123&lt;IfModule dir_module&gt; DirectoryIndex index.html index.htm index.php index.php3 &lt;/IfModule&gt; 这个是单独写出来的，而不是写在上述标签之内。这个感觉应该是统一定义一个就行了，或者是在vhost里面直接写directoryindx 这个标签，如果没写默认是index.html或者是index.php 之前遇到一个问题就是public文件夹因为是统一对外开放的嘛，不做处理的话，比如itbasic.datatom.com/userpic,可以访问服务器上public下面这个userpic文件夹，为了不让用户访问，我们可以去掉 1Options Indexes FollowSymLinks 的indexes,用户就不能访问了。 Order Deny,Allow Allow from all这2个一般是组合在一起用。用来设置访问权限 ，设置哪些ip可以访问这个域名, 哪些ip禁止访问。 所以order是设置这2个的组合排序, 不区分大小写，中间用,分开，中间不能有空格。 所以order是设置这2个的组合排序, 不区分大小写，中间用,分开，中间不能有空格。Order Deny,Allow ：表示设定“先检查禁止设定，没有设定禁止的全部允许” Order Allow,Deny : 表示设定“先检查允许设定，没有设定允许的全部禁止” 而且最后的访问结果有第二参数决定！ Deny from All Deny from 127.0.0.1 禁止访问的ip， all 表示全部 Deny from All Deny from 127.0.0.1 禁止访问的ip， all 表示全部Allow from All Allow from 127.0.0.1 允许访问的ip， all 表示全部 我们看几个他们2个组合的例子。 这个例子： 12Order Deny,AllowDeny from All 表示先检查允许的, 没有允许的全部禁止。但是下却没有Allow，那么就表示是无条件禁止了所有的访问了。 123Order Deny,AllowDeny from allAllow from 127.0.0.1 上面表示 只允许127.0.0.1访问 123Order Allow,DenyAllow from allDeny from 127.0.0.1 192.168.1.51 上面表示禁止127.0.0.1和192.168.1.51访问，其他都可以！ 所以这个的组合就可以达到很多的过滤访问效果。 但现在一般不用那个了 1Require all granted 才能解决，要么一直都是403。 RewriteCond 与 RewriteRule 指令格式配置详解上面花了大量的时间讲述VirtualHost 里面的一些配置参数的写法和作用，接下来就是rewrite的重点了，3个核心的东西：RewriteEngine，RewriteCond，RewriteRule RewriteEngine RewriteEngine这个是rewrite的总开关，用来开启是否启动url rewrite，要想打开，像这样就可以了： RewriteEngine on RewriteCond 和 RewriteRule RewriteCond 和 RewriteRule表示指令定义和匹配一个规则条件，让RewriteRule来重写。说的简单点，RewriteCond就像我们程序中的if语句一样，表示如果符合某个或某几个条件则执行RewriteCond下面紧邻的RewriteRule语句，这就是RewriteCond最原始、基础的功能。 先看个例子： 123RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; ^Mozilla//5/.0.*RewriteRule index.php index.m.php 上面的匹配规则就是：如果匹配到http请求中HTTP_USER_AGENT 是 Mozilla//5/.0.* 开头的，也就是用FireFox浏览器访问index.php这个文件的时候，会自动让你访问到index.m.php这个文件。 RewriteCond 和 RewriteRule 是上下对应的关系。可以有1个或者好几个RewriteCond来匹配一个RewriteRule RewriteCond一般是这样使用的 1RewriteCond %&#123;XXXXXXX&#125; + 正则匹配条件 那么RewriteCond可以匹配什么样的数据请求呢？ 那么RewriteCond可以匹配什么样的数据请求呢？它的使用方式是：RewriteCond %{NAME_OF_VARIABLE} REGX FLAG 123RewriteCond %&#123;HTTP_REFERER&#125; (www.test.cn)RewriteCond %&#123;HTTP_USER_AGENT&#125; ^Mozilla//5/.0.*RewriteCond %&#123;REQUEST_FILENAME&#125; !-f 上面是常见的3种最常见使用最多的HTTP头连接与请求匹配。 HTTP_REFERER HTTP_REFERER这个匹配访问者的地址，php中$_REQUREST中也有这个，当我们需要判断或者限制访问的来源的时候，就可以用它。 比如： 12RewriteCond %&#123;HTTP_REFERER&#125; (www.test.cn)RewriteRule (.*)$ test.php 上面语句的作用是如果你访问的上一个页面的主机地址是www.test.cn，则无论你当前访问的是哪个页面，都会跳转到对test.php的访问。 再比如，也可以利用 HTTP_REFERER 防倒链，就是限制别人网站使用我网站的图片。 123RewriteCond %&#123;HTTP_REFERER&#125; !^$ [NC]RewriteCond %&#123;HTTP_REFERER&#125; !ww.iyangyi.com [NC]RewriteRule \.(jpg|gif) http://image.baidu.com/ [R,NC,L] NC nocase的意思，忽略大小写。第一句呢，是必须要有域名，第一句就是看域名如果不是 www.iyangyi.com 的，当访问.jpg或者.gif文件时候，就都会自动跳转到 http://image.baidu.com/ 上，很好的达到了防盗链的要求。 REQUEST_FILENAME REQUEST_FILENAME这个基本是用的最多的，以为url重写是用的最多的，它是匹配当前访问的域名文件，那哪一块属于REQUEST_FILENAME 呢？是url 除了host域名外的。 1http://www.rainleaves.com/html/1569.html?replytocom=265 这个url，那么 REQUEST_FILENAME 就是 html/1569.html?replytocom=265 看个例子： 123RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^room/video/(\d+)\.html web/index\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L] -d 是否是一个目录. 判断TestString是否不是一个目录可以这样: !-d -d 是否是一个目录. 判断TestString是否不是一个目录可以这样: !-d-f 是否是一个文件. 判断TestString是否不是一个文件可以这样: !-f 这两句语句RewriteCond的意思是请求的文件或路径是不存在的，如果文件或路径存在将返回已经存在的文件或路径。一般是这样结合在一起用的。 上面RewriteRule正则的意思是以 room开头的 room/video/123.html 这样子，变成 web/index.php?c=room&amp;a=video&amp;r=123 $1 表示匹配到的第一个参数。 RewriteRule 写法和规则RewriteRule是配合RewriteCond一起使用，可以说，RewriteRule是RewriteCond成功匹配后的执行结果，所以，它是很重要的。 来看一下 RewriteRule的写法： 1RewriteRule Pattern Substitution [flags] Pattern是一个正则匹配。Substitution是匹配的替换 [flags]是一些参数限制； 我们看几个例子： 1RewriteRule ^room/video/(\d+)\.html web/index\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L] 意思是 以 room开头的 room/video/123.html 这样子，变成 web/index.php?c=room&amp;a=video&amp;r=123 1RewriteRule \.(jpg|gif) http://image.baidu.com/ [R,NC,L] 意思是以为是访问.jpg或者gif的文件，都会调整到 http://image.baidu.com 所以，掌握正则级是关键所在了。以后，我会专门搞一个正则的篇章来学习下。 我们再看看[flags]是什么意思？ 因为它太多了。我就挑几个最常用的来说说吧。 [QSA] qsappend(追加查询字符串)的意思，次标记强制重写引擎在已有的替换字符串中追加一个查询字符串，而不是简单的替换。如果需要通过重写规则在请求串中增加信息，就可以使用这个标记。上面那个room的例子，就必须用它。 NC nocase(忽略大小写)的意思，它使Pattern忽略大小写，也就是在Pattern与当前URL匹配时，”A-Z”和”a-z”没有区别。这个一般也会加上，因为我们的url本身就不区分大小写的。 R redirect(强制重定向)的意思，适合匹配Patter后，Substitution是一个http地址url的情况，就调整出去了。上面那个调整到image.baidu.com的例子，就必须也用它。 L last(结尾规则)的意思，就是已经匹配到了，就立即停止，不再匹配下面的Rule了，类似于编程语言中的break语法，跳出去了。 其他的一些具体的语法，可以参考以下资料： http://www.skygq.com/2011/02/21/apache%E4%B8%ADrewritecond%E8%A7%84%E5%88%99%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D%E8%BD%AC/ http://www.2cto.com/os/201201/116040.html http://www.cnblogs.com/adforce/archive/2012/11/23/2784664.html .htaccess文件的使用.htaccess文件是啥呢？我们前面说了这么多的配置和修改，都是针对于apache的配置文件来修改的。.htaccess文件就是它的一个替代品。为啥呢？因为你每次修改apache的配置文件，都必须重启apache服务器，很麻烦不说，有些共享apache的服务器，你还没权限修改和重启apache。所以，.htaccess文件就应运而生了。（不用重启apache,是真的挺方便的） .htaccess分布式配置文件。它文件名字比较奇怪，没有文件名，只有一个文件后缀就是.htaccess。所以一般在windows下还没法新建这个文件，因为windows不允许文件名是空的，比较蛋疼。但是我相信你总归会有办法新建这个文件的。（在linux下新建一个，下载到windows中呗） .htaccess同时是一个针对目录的配置，你可以把它放到项目的根目录下，那么它就多整个项目其效果，如果你把它放到一个单独的子目录下，那么它就对这个子目录其效果了。 .htaccess文件如何生效呢。上面讲配置的时候，我讲过了AllowOverride All这个配置，它就是启动.htaccess文件是否可以使用的。AllowOverrideAll表示可以。AllowOverride None表示禁止使用。还是蛮简单的。 那.htaccess文件里的语法是怎么写额呢？ 其实和上面说的一模一样的写法。可以完全的搬过来用。没问题。 12345678910 &lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Order Allow,Deny Allow from all RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/Directory&gt; 上面的apache的`里的这一块就可以完全的搬到.htaccess`文件中来，且效果一模一样。 上面就是vhost文件里面的配置的大致写法，其实httpd.conf里面也是这么写的，毕竟vhost最后还是包含到主配置文件里面。 documentroot 其实自己一直好奇为啥和directory参数一样其实本质上该项目文件夹下只有这个document root能访问，所以重写规则也好，针对的都是这个document root，导致了二者之间的相同。 有一点要注意的就是，如果通过开不同的端口号转发到不同的文件夹，需要早配置文件的开头写上Listen 127.0.0.1：8080 这样，开启端口号。]]></content>
      <categories>
        <category>apache</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>linux</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel ORM]]></title>
    <url>%2F2018%2F03%2F30%2FLaravel-ORM%2F</url>
    <content type="text"><![CDATA[orm并不是一个新兴的概念，他出现很久了，只是刚开始学习的自己并没有接触到，他能帮我们少写很多代码，让我们能以更面向对象的方式来处理关于数据库的操作。 Eloquent 是laravel的orm，我们通过 123php artisan make:model Userphp artisan make:model Models/User //放在文件夹models里面php artisan make:model Models/User -m //顺便把迁移文件也创建了 生成的类虽然是继承Model，但本质上都是继承这个Eloquent，他把我们每张表看做一个类，表里面的数据看做一个实例，我们对其进行操作的时候，更类似于面向对象的操作 1234$user = User::find(1);$user-&gt;name = &apos;cy&apos;;$user-&gt;city = &apos;shanghai&apos;;$user-&gt;save(); 更便于理解。 生成的model很简单，大致 1234567891011&lt;?phpclass Article extends \Eloquent &#123;protected $table = &apos;my_article&apos;; //自定义表名protected $fillable = [];protected $hidden = [];&#125; 关于表名：基本都是小写，然后多个单词用_连接（php的类是首字母大写的驼峰命名法） 这个fillable里面就是可以批量操作的字段，批量操作在我之前的文章里面有提到过，我觉得更通俗的理解是可更新的字段。主要是create方法时的那种批量更新，会用到。 hidden 就是对一些用户数据的隐藏，还记得我们经常取数据时候的select * 吗，容易把用户的身份证号，密码都取出来，这样不太好 只需要继承一下 Eloquent 类，就可以干 ‘first() find() where() orderBy()’ 等非常非常多的事情，这就是面向对象的强大威力。 通过 1php artisan tinker 可以开启一个交互环境进行orm的调试，其实我感觉不止是orm，别的代码也都是可以执行的，只是方便了orm的打印操作，能很方便的看到执行结果。有一点需要注意的就是tinker是基于当前代码的，如果代码重新修改来了，我们需要重启tinker来加载新的代码。 还有我们会利用composer安装laravel-debugbar，来进行orm的调试，当我发现在别的项目中使用不了这个插件的时候，我改变了对composer的看法，他安装的东西更类似于代码，而不是软件，我们如果要在不同的项目中也使用这个插件，我们同样需要在另一个项目目录线面进行composer安装 介绍几个常用的函数 find() 12345678User::find(1)App\User &#123;#764 id: 1, name: &quot;cy&quot;, email: &quot;1967196626@qq.com&quot;, created_at: &quot;2018-03-30 01:42:40&quot;, updated_at: &quot;2018-03-30 01:59:51&quot;, &#125; 这个1是主键 first() 12345678User::where(&apos;id&apos;, &apos;&gt;&apos;, 1)-&gt;first()App\User &#123;#771 id: 2, name: &quot;Bella Lebsack&quot;, email: &quot;cristobal58@example.net&quot;, created_at: &quot;2018-03-30 01:59:51&quot;, updated_at: &quot;2018-03-30 01:59:51&quot;, &#125; save() save 能新增用户，通过构建一个new 的User 对象(不需要设置model里面的fileable，create需要设置)，或者更新一个对象 12345678910$user = new User();$user-&gt;name=&apos;cyc&apos;;$user-&gt;email = &apos;199@qq.com&apos;;$user-&gt;notification_count = 0;$user-&gt;password = bcrypt(&apos;12345&apos;);$user-&gt;save();exit;$user = User::find(10);$user-&gt;name=&apos;cy&apos;;$user-&gt;save(); update()更新 12$user = User::find(10);$user-&gt;update([&apos;name&apos;=&gt;&apos;Aufree&apos;]) ​ ​ 上面两个获取的内容都是对象，可以直接使用 get() 获取的是一个collection 123456789101112 User::where(&apos;id&apos;, &apos;&gt;&apos;, 1)-&gt;where(&apos;id&apos;, &apos;&lt;&apos;, 3)-&gt;get()=&gt; Illuminate\Database\Eloquent\Collection &#123;#773 all: [ App\User &#123;#778 id: 2, name: &quot;Bella Lebsack&quot;, email: &quot;cristobal58@example.net&quot;, created_at: &quot;2018-03-30 01:59:51&quot;, updated_at: &quot;2018-03-30 01:59:51&quot;, &#125;, ], &#125; all() 获取的是一个collection ​all的使用好像不能加条件 ​上面的collection可以通过toArray() 方法转换成数组，但其实我们平时用的时候没用toArray也是可以的 上面需要注意的点就是： 所有的中间方法如 ‘where()’ ‘orderBy()’ 等都能够同时支持 ‘静态’ 和 ‘非静态链式’ 两种方式调用，即 ‘Article::where()…’ 和 ‘Article::….-&gt;where()’。 所有的 ‘非固定用法’ 的调用最后都需要一个操作来 ‘收尾’，本片教程中有两个 ‘收尾操作’：’-&gt;get()’ 和 ‘-&gt;first()’。 每一个继承了 Eloquent 的类都有两个 ‘固定用法’ ‘Article::find($number)’ ‘Article::all()’，前者会得到一个带有数据库中取出来值的对象，后者会得到一个包含整个数据库的对象合集。 Builder 1Article::where(&apos;id&apos;, &apos;&gt;&apos;, 10)-&gt;where(&apos;id&apos;, &apos;&lt;&apos;, 20)-&gt;orderBy(&apos;updated_at&apos;, &apos;desc&apos;)-&gt;get(); 这段代码的 ::where()-&gt;where()-&gt;orderBy() 就是Builder。用面向对象的方法来理解，可以总结成一句话：创建一个对象，并不断修改它的属性，最后用一个操作来触发数据库操作。 12User::orderBy(&apos;id&apos;, &apos;desc&apos;);=&gt; Illuminate\Database\Eloquent\Builder &#123;#817&#125; 这个get() 就是那个最后的方法。 值的思考的一个问题 如果直接用 :: 来访问某个 function，无论这个 function 是否为 static，构造函数 __construct() 都不会被调用，那么创建对象是如何实现的呢？请看：https://github.com/illuminate/database/blob/master/Eloquent/Model.php#L3354 所谓 “终结者” 方法，指的是在 N 个中间操作流方法对某个 Eloquent 对象进行加工以后，触发最终的数据库查询操作，得到返回值。 first() get() paginate() count() delete() 是用的比较多的一些 “终结者” 方法，他们会在中间操作流的最后出现，把 SQL 打给数据库，得到返回数据，经过加工返回一个 Article 对象或者一群 Article 对象的集合。 all() 方法好像不是，因为all() 好像不能跟着条件 12 User::orderBy(&apos;id&apos;, &apos;desc&apos;)-&gt;all();BadMethodCallException with message &apos;Call to undefined method Illuminate\Database\Query\Builder::all() 关系 1 对 1 关系 做了个试验，发现如果通过传统的生成迁移文件，生成model，进行数据填充真的挺麻烦的，不如在数据库中快速建表来的容易 123456789public function hasOne1() &#123; return $this-&gt;hasOne(TestOneToOne::class, &apos;user_id&apos;, &apos;id&apos;); &#125; public function belongsTo1() &#123; return $this-&gt;belongsTo(TestOneToOne::class, &apos;id&apos;, &apos;user_id&apos;); &#125; 这是User 中的两个方法 User::with(‘hasOne1’)-&gt;find(1) User::with(‘belongsTo1’)-&gt;find(1) 获取的数据是一样的，说一下我的记忆方法。hasOne 的时候，对方表中的字段在前面，belongsTo的时候自己表中的数据在前面。（我一般喜欢用with表示模型的结合） 还有第一个参数注意一下，话说这个::class出现好久了，而我却很少用，真的很方便哦。 还有默认的orm模型名称都是表名的单数，这个是一定要注意的哦。除非自己重新定义。（many 都能识别成功manies,牛逼） 1对多 这个时候的belongsTo 只有一种了，和上面的一样，hasMany() 和上面也类似。值的注意的一点就是那个表::with就成主体了，还有一点的就是使用with的时候并不是和我们传统的那种使用left join，而是先计算出主表，再根据主表中的数据，就算从表中对应数据in() 这个集合中，我不能理解的一点就是这样通过in，怎么完成了数据的连接。 多对多 这个时候经常需要第三张表来存储数据，值的注意的一点就是第三张表往往不需要生成model。 第三张表值记录对应关系，感觉默认的就是主键id 1234public function belongsToMany1() &#123; return $this-&gt;belongsToMany(\App\User::class, &apos;test_many_to_many&apos;, &apos;user_id&apos;, &apos;test_id&apos;); &#125; 上面是一种我的粉丝，比如我是users 表中的一员，我的粉丝也是这张表中的数据，注意存储数据关系的表不要用::class，因为不存在这个class，还有如果要加where条件，里面的条件用调用主题的字段，比如users中的字段id。]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 数据填充]]></title>
    <url>%2F2018%2F03%2F30%2FLaravel-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%2F</url>
    <content type="text"><![CDATA[作为一个phper，Laravel的学习是必不可少的，可是这个框架的学习成本还是挺大的，有些东西现在可能不明白，但至少记录下来，慢慢的成长。 在laravel的学习中，感觉挺好用的相比较于我们现在，数据填充是一个很不错的功能，能生成一大堆假的数据把页面填充起来，让他更有实际的样子。 数据填充，和数据库相关，自然去database下面。seeds目录，databaseseeder,这个文件主要是让我们在运行 1php artisan db:seed 的时候，执行哪些数据填充的文件，其参数可以让我们执行哪些填充文件 1234567public function run() &#123; // $this-&gt;call(UsersTableSeeder::class); Model::unguard(); $this-&gt;call(UsersTableSeeder::class); Model::reguard(); &#125; 上面就是基础的database seeder 里面的内容，前面两个主要是接触限制（官方叫批量赋值，就是默认model里面只有fileable的字段可以填充，为什么要规定这个呢 1234567891011public function create(Request $req)&#123; $this-validate($req, [ &apos;name&apos; =&gt; &apos;required|min:5&apos;, &apos;password&apos; =&gt; &apos;required|confirmed&apos; ··· ]) $name = $req-&gt;name; $password = $req-&gt;password; User::create(compact(&apos;name&apos;, &apos;password&apos;));&#125; 这样填充数据太麻烦了，比如我之前在itbasic上面填充数据，一个合同二十多个字段，这样往方法里面插入，一般这样 public function create(Request $req) { $this-validate($req, [ &apos;name&apos; =&gt; &apos;required|min:5&apos;, &apos;password&apos; =&gt; &apos;required|confirmed&apos; ··· ]) User::create($req-&gt;all()); } req的all方法获取的是一个关联数组，可是这样插入会导致一个问题，比如现在的表的字段的越来越规范了，比如admin字段 is_admin,这样当用户传入is_admin 1， 就完了，所以设置批量赋值，用来规定哪些字段可以传入，哪些字段不可以传入，filable 代表可以传入的，guard 代表这些不能传入。 当我们进行数据填充的时候，可能不需要字段限制，所以才会有了开始的解除限制和后面的开启限制。 接下来就是种子文件。 1php artisan make:seeder UsersTableSeeder 也是只有一个run方法，这个UsersTableSeeder,只是命名规范，其实并不用，因为我们在写run方法的时候，就是在写普通的插入语句 public function run() { DB::table(&apos;articles&apos;)-&gt;delete(); for ($i=0; $i &lt; 10; $i++) { \App\Article::create([ &apos;title&apos; =&gt; &apos;Title &apos;.$i, &apos;body&apos; =&gt; &apos;Body &apos;.$i, &apos;user_id&apos; =&gt; 1, ]); } } 这种方法就太没有意义了，因为我们可以通过写一个接口，来进行插入，我们希望的是更真实的数据，laravel中一般使用的用工厂模式生成批量化的对象，然后进行数据填充。 查看database 下面的factory文件夹， factory-&gt;define(App\User::class, function(Faker faker) { static $password; return [ &apos;name&apos; =&gt; $faker-&gt;name, &apos;email&apos; =&gt; $faker-&gt;unique()-&gt;safeEmail, &apos;password&apos; =&gt; $password ?: $password = bcrypt(&apos;secret&apos;), &apos;remember_token&apos; =&gt; str_random(10), ]; }); 这里面只是定一个一个model对象，然后在seeder里面批量化的生成这个对象 public function run() { // factory(App\User::class)-&gt;times(50)-&gt;create(); $user = App\User::find(1); $user-&gt;name = ‘cy’; $user-&gt;email = ‘1967196626@qq.com’; $user-&gt;password = bcrypt(‘123456’); $user-&gt;save(); }综上： 通过factory ，定义批量化的实例对象。 通过seeder 去实例化生成对象，然后插入数据库中。]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP闭包]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[咱是写PHP的，可是PHP的很多特性咱都不是很熟，比如trait，闭包，咱不能只局限于表单的操作，不能只局限于面向过程的写法，记录下来那些年很少接触的特性。就从PHP的 闭包 开始咯 第一次接触闭包还是在js中，后来是在python中，最后才是php中！！!深刻的怀疑我是不是做php的。php中闭包和js中还是不一样的，php中把匿名函数和闭包混为一谈，这让开始只知道js闭包的我好蛋疼，因为比如array_map 中经常写的回调（注意回调只是一种动作，匿名函数闭包或者是自定义函数只是实现回调的不同方法），还有最近很火的swoole，因为是异步的嘛，所以写了大量的回调函数，所以也属于闭包 ，虽然js和php的闭包有些不同但本质上还是封装函数的运行环境。js:12345678910111213function out() &#123; var a = 1; var b = function(name) &#123; console.log(a); console.log(name) &#125; return b; &#125; var a = 2; var name = &apos;cy&apos;; var c= out(); c(name); 上面这段代码虽然简单，但是包含了几个重要的知识点： js的闭包主要是靠两层函数的嵌套，然后通过调用外层的函数返回内层的函数，内层的函数可以调用外层函数中的变量，内层函数的执行可以通过后来调用的时候传入参数。 php1234567891011121314151617class Foo&#123; public function __call($method, $args) &#123; if(is_callable([$this, $method])) &#123; return call_user_func_array($this-&gt;$method, $args); &#125; // else throw exception &#125;&#125;$obj = new Foo(&apos;Sam&apos;);$obj-&gt;say = function () &#123; return &apos;Hello World&apos;;&#125;;echo($obj-&gt;say()); 当执行的say() 方法不存在的时候会自动执行call方法，然后method 传入是say方法，这里面args 因为是空，所以自动传入为空。is_callable 方法判断这个$obj 实例中是否有这个方法，因为后面有定义$obj-&gt;say ,所以会自动调用。call_user_func_array 会把前面这个$this-&gt;method 执行，后面args是传入的参数，相比较js就多了call() 部分。上面还有一点没体现出来就是，闭包可以引用的变量是自己定义时候的父亲变量，js中可以直接在函数中使用，但是php中要用use关键字引入。 后来的php12345678910class Foo&#123; &#125;$obj = new Foo(&apos;Sam&apos;);$obj-&gt;say = function () &#123; return &apos;Hello World&apos;;&#125;;echo($obj-&gt;say-&gt;__invoke()); 因为php的闭包都是一个closure类，而invoke 是这个类除了（construct 不能实例化，bind bindto 绑定方法之外的一个方法）。但是这个类中不能使用this关键字，主要是这个this指代的是closure自身，因为js中this关键字老变，虽然这都被别人诟病，但相比较于php，他还需要手动绑定呢。12345678910111213141516171819class Foo&#123; private $name; function __construct($name) &#123; $this-&gt;name = $name; &#125;&#125;$obj = new Foo(&apos;Sam&apos;);$cl = function() &#123; return &quot;Hello &quot; . $this-&gt;name;&#125;;$cl = $cl-&gt;bindTo($obj, $obj);echo($cl()); 我們不再執著該closure一定要動態成為 $obj的method，但要存取$obj property的目標不變，程式也不變，一樣使用$this。假如我們能將$obj以手動注入的方式，讓closure內部的$this改指向$obj，我們就能達到如JavaScript的效果了。$cl = $cl-&gt;bindTo($obj, $obj);bindTo()如同__invoke()一樣，是closure物件內建的method，它的目的就是讓我們能手動注入一個物件，讓closure物件的$this指向手動注入的物件$obj。因為在closure中我們有$this-&gt;name，經過bindTo()去手動注入 $obj後，$this已經改指向$obj，所以$this-&gt;name就相當於$obj-&gt;name。根據bindTo()文件 :若要讓closure物件只能存取其他物件的public變數，只傳第1個參數即可。若要讓closure物件存取其他物件的private或protected變數，就要傳第2個參數。bindTo()對於第2個參數的要求不嚴，有幾種傳法 :傳進欲存取物件的class名稱，是字串。傳進欲存取的物件也可以，bindTo()會自動得知該物件的class名稱。在此就一併傳進與第一個參數相同的$obj。echo($cl());因為$obj已經透過bindTo() 手動注入進$cl()，此時$this已經指向$obj，所以執行$cl()就可順利存$obj的property Modern PHP中对php闭包的重要方法bindTo的解释(注意闭包closure的bindTo方法本身是三个参数的，但因为第一个参数是闭包自身，所以经常$this-&gt;bindTo(arg1,arg2)这样去掉用）。 接下来我们来看看bindTo方法，通过该方法，我们可以把闭包的内部状态绑定到其他对象上。这里bindTo方法的第二个参数显得尤为重要，其作用是指定绑定闭包的那个对象所属的PHP类，这样，闭包就可以在其他地方访问绑定闭包的对象中受保护和私有的成员变量。你会发现，PHP框架经常使用bindTo方法把路由URL映射到匿名回调函数上，框架会把匿名回调函数绑定到应用对象上，这样在匿名函数中就可以使用$this关键字引用重要的应用对象：class App { protected $routes = []; protected $responseStatus = ‘200 OK’; protected $responseContentType = ‘text/html’; protected $responseBody = ‘Hello World’; public function addRoute($path, $callback) { $this-&gt;routes[$path] = $callback-&gt;bindTo($this, __CLASS__); } public function dispatch($path) { foreach ($this-&gt;routes as $routePath =&gt; $callback) { if( $routePath === $path) { $callback(); } } header(&apos;HTTP/1.1 &apos; . $this-&gt;responseStatus); header(&apos;Content-Type: &apos; . $this-&gt;responseContentType); header(&apos;Content-Length: &apos; . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; } }这里我们需要重点关注addRoute方法，这个方法的参数分别是一个路由路径和一个路由回调，dispatch方法的参数是当前HTTP请求的路径，它会调用匹配的路由回调。第9行是重点所在，我们将路由回调绑定到了当前的App实例上。这么做能够在回调函数中处理App实例的状态：$app = new App();$app-&gt;addRoute(‘/user’, function(){ $this-&gt;responseContentType = ‘application/json;charset=utf8’; $this-&gt;responseBody = ‘世界你好’;});$app-&gt;dispatch(‘/user’) 总结一下，闭包的bindTo方法的根本原因是闭包中$this关键字指向了自己，而不是指向某一个对象。 Laravel中对闭包的使用IoC 容器匿名函数可以从父作用域继承变量，而这个父作用域是定义该闭包的函数（不一定是调用它的函数）。利用这个特性，我们可以实现一个简单的控制反转IoC容器：12345678910111213141516171819202122232425262728293031323334353637383940414243class Container&#123; protected static $bindings; public static function bind($abstract, Closure $concrete) &#123; static::$bindings[$abstract] = $concrete; //如果还需要container自身的一些方法的话 //可以这么写： static::$bindings[$abstract] = $concrete-&gt;bindto($this, $this); &#125; public static function make($abstract) &#123; return call_user_func(static::$bindings[$abstract]); &#125;&#125; class talk&#123; public function greet($target) &#123; echo &apos;Hello &apos; . $target-&gt;getName(); &#125;&#125;class A&#123; public function getName() &#123; return &apos;World&apos;; &#125;&#125; // 创建一个talk类的实例$talk = new talk(); // 将A类绑定至容器，命名为fooContainer::bind(&apos;foo&apos;, function() &#123; return new A;&#125;); // 通过容器取出实例$talk-&gt;greet(Container::make(&apos;foo&apos;)); // Hello World 上述例子中，只有在通过make方法获取实例的时候，实例才被创建，这样使得我们可以实现容器。在Laravel框架底层也大量使用了闭包以及bindTo方法，利用好闭包可以实现更多的高级特性如事件触发等。 laravel中的控制反转还不是很熟，以后多了解下 今天说一下对于闭包的重新认识： 首先是array_map里面的内容。array_map 用到了闭包的知识，函数作用：通过对传入的数组进行自定义的函数处理，传入的数组多少个，自定义的函数接受的参数就要多少个 1234&lt;?phparray_map(function($i, $z) &#123; var_dump($i+$z);&#125;, [1,2,3], [2,3,4]); 但如果我们想传入额外的参数呢 12345&lt;?php$z = 100;array_map(function($i, $z) use ($z) &#123; var_dump($i+$z);&#125;, [1,2,3], [2,3,4]); 通过use 这和我之前看到的内容都是一致的，只是这次我希望不要把这个use和bindto绑定的参数作用弄混淆了，bindto的目的是修改closure类里面this对象. 对了php的闭包很类似于js的万物皆是对象的概念，function也是对象 对的php中的匿名函数，也就是闭包，他也是对象，他是closure类的实例 但和js不同之处，php的对象不能改变，所以匿名函数中的this指向的是closure这个实例，这个实例除了——invoke和 bind（静态方法）bindto() 一无所有 但是我们可以通过bind，我的理解是让两个实例互相拥有对方的属性，其实不是 12345678910111213141516171819202122class Foo&#123; private $name; function __construct($name) &#123; $this-&gt;name = $name; &#125;&#125;$obj = new Foo(&apos;Sam&apos;);$cl = function() &#123; var_dump($this instanceof Closure); //false var_dump($this instanceof Foo); //true return &quot;Hello &quot; . $this-&gt;name;&#125;;$cl = $cl-&gt;bindTo($obj, $obj);echo($cl()); zzz,感觉绑定之后这个closure的实例就有了家的感觉，就变成了那个被绑定的类了。 很多时候我们会纠结bindto和bind的区别···其实很简单，一个是静态类，需要::去调用，一个是类的方法，需要自身去调用 $c = function() { }; $c-&gt;bindto(); or Closure::bind($c, , ,); so就是多了个参数而已。 还有bindto的两个参数，主要还是第一个参数是具体的实例，第二个参数就是扩大第一个参数的类的使用权限问题。但仅仅在于扩大原始的不能访问的protected和private，并不扩大注入对象没有关系的或者说注入对象所在类不能访问到的变量。 还有很重要的一点，我们在使用闭包的时候，function（）{}，这种只是定义了一个变量，并没有使用，我们想使用的换，比逊function() {} (),这样，或者是 function（）{} -&gt;invoke();这个可以理解成 function（）{} 是一个对象，当我们调用他的时候就自动触发了Closure类里面的\invoke方法，所以上述是等价的结果。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP魔术方法和魔术变量]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%92%8C%E9%AD%94%E6%9C%AF%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[有些东西如果不是经常使用，很容易忘记，比如魔术方法和魔术常量。最主要是当看一些基本原理的代码的时候经常用到，比如闭包的时候，希望自己在学习过程中能对文章中的内容进行补充，改造，而不是单纯的靠这些简单例子来记忆&gt; 魔术方法(Magic methods)PHP中把以两个下划线__开头的方法称为魔术方法，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __construct()和__destruct()构造函数和析构函数应该不陌生，他们在对象创建和消亡时被调用。例如我们需要打开一个文件，在对象创建时打开，对象消亡时关闭 1234567891011121314&lt;?php class FileRead&#123; protected $handle = NULL; function __construct()&#123; $this-&gt;handle = fopen(...); &#125; function __destruct()&#123; fclose($this-&gt;handle); &#125;&#125;?&gt; 这两个方法在继承时可以扩展，例如： 123456789101112&lt;?php class TmpFileRead extends FileRead&#123; function __construct()&#123; parent::__construct(); &#125; function __destruct()&#123; parent::__destruct(); &#125;&#125;?&gt; __call()和__callStatic()在对象中调用一个不可访问方法时会调用这两个方法，后者为静态方法。这两个方法我们在可变方法（Variable functions）调用中可能会用到。这个方法和is_callable经常配合调用，注意是callable，不是callback， 不是回调。callback 回调更多的可以理解成一种使用方式，而匿名函数则是用来满足这种使用方式的一种途径，还有别的方式能满足callback,比如直接定义一个函数，传入函数的名称（字符串，如果是匿名函数的话，要把这个匿名函数对应的变量传进去，二者还是有些不同的），只是这种方式使用起来比较麻烦，比较少而已 12345678910111213141516&lt;?phpclass MethodTest &#123; public function __call ($name, $arguments) &#123; echo &quot;Calling object method &apos;$name&apos; &quot;. implode(&apos;, &apos;, $arguments). &quot;\n&quot;; &#125; public static function __callStatic ($name, $arguments) &#123; echo &quot;Calling static method &apos;$name&apos; &quot;. implode(&apos;, &apos;, $arguments). &quot;\n&quot;; &#125;&#125;$obj = new MethodTest;$obj-&gt;runTest(&apos;in object context&apos;);MethodTest::runTest(&apos;in static context&apos;);?&gt; __get()，__set()，__isset()和__unset()当get/set一个类的成员变量时调用这两个函数。例如我们将对象变量保存在另外一个数组中，而不是对象本身的成员变量var_dump($this-&gt;aa)$this-&gt;aa = ‘pp’isset($this-&gt;aa)empty($this-&gt;aa)值的注意的是 isset 和 empty 触发的魔术方法好像只能返回true和false123456789101112131415161718192021222324&lt;?php class MethodTest&#123; private $data = array(); public function __set($name, $value)&#123; $this-&gt;data[$name] = $value; &#125; public function __get($name)&#123; if(array_key_exists($name, $this-&gt;data)) return $this-&gt;data[$name]; return NULL; &#125; public function __isset($name)&#123; return isset($this-&gt;data[$name]) &#125; public function unset($name)&#123; unset($this-&gt;data[$name]); &#125;&#125;?&gt; __sleep()和__wakeup()当我们在执行serialize()和unserialize()时，会先调用这两个函数。例如我们在序列化一个对象时，这个对象有一个数据库链接，想要在反序列化中恢复链接状态，则可以通过重构这两个函数来实现链接的恢复。（还没有用到过）例子如下： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Connection &#123; protected $link; private $server, $username, $password, $db; public function __construct($server, $username, $password, $db) &#123; $this-&gt;server = $server; $this-&gt;username = $username; $this-&gt;password = $password; $this-&gt;db = $db; $this-&gt;connect(); &#125; private function connect() &#123; $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password); mysql_select_db($this-&gt;db, $this-&gt;link); &#125; public function __sleep() &#123; return array(&apos;server&apos;, &apos;username&apos;, &apos;password&apos;, &apos;db&apos;); &#125; public function __wakeup() &#123; $this-&gt;connect(); &#125;&#125;?&gt; __toString()对象当成字符串时的回应方法。例如使用echo $obj;来输出一个对象 123456789101112&lt;?php// Declare a simple classclass TestClass&#123; public function __toString() &#123; return &apos;this is a object&apos;; &#125;&#125;$class = new TestClass();echo $class;?&gt; 这个方法只能返回字符串，而且不可以在这个方法中抛出异常，否则会出现致命错误。 __invoke()调用函数的方式调用一个对象时的回应方法。如下 12345678910&lt;?phpclass CallableClass &#123; function __invoke() &#123; echo &apos;this is a object&apos;; &#125;&#125;$obj = new CallableClass;var_dump(is_callable($obj));?&gt; __set_state()调用var_export()导出类时，此静态方法会被调用。注意var_dump很强大，直接输出了，并不会触发。 12345678910111213141516171819&lt;?phpclass A&#123; public $var1; public $var2; public static function __set_state ($an_array) &#123; $obj = new A; $obj-&gt;var1 = $an_array[&apos;var1&apos;]; $obj-&gt;var2 = $an_array[&apos;var2&apos;]; return $obj; &#125;&#125;$a = new A;$a-&gt;var1 = 5;$a-&gt;var2 = &apos;foo&apos;;var_dump(var_export($a));?&gt; __clone()当对象复制完成时调用。例如在设计模式详解及PHP实现：单例模式一文中提到的单例模式实现方式，利用这个函数来防止对象被克隆。 1234567891011121314151617181920&lt;?php public class Singleton &#123; private static $_instance = NULL; // 私有构造方法 private function __construct() &#123;&#125; public static function getInstance() &#123; if (is_null(self::$_instance)) &#123; self::$_instance = new Singleton(); &#125; return self::$_instance; &#125; // 防止克隆实例 public function __clone()&#123; die(&apos;Clone is not allowed.&apos; . E_USER_ERROR); &#125;&#125;?&gt; 魔术常量(Magic constants)PHP中的常量大部分都是不变的，但是有8个常量会随着他们所在代码位置的变化而变化，这8个常量被称为魔术常量。 __LINE__，文件中的当前行号 __FILE__，文件的完整路径和文件名 __DIR__，文件所在的目录 __FUNCTION__，函数名称 __CLASS__，类的名称 __TRAIT__，Trait的名字 __METHOD__，类的方法名 __NAMESPACE__，当前命名空间的名称 这些魔术常量常常被用于获得当前环境信息或者记录日志。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP函数]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[工作的久了，反而基本功没有原先好了，也许要记得东西很多，内存中不够放置那些无规律的参数位置，但至少不要混淆哪些是框架自带的，哪些是PHP原生的。 一年多了，重复相同的工作可能让之前很多学会的但没用到的PHP函数忘记了，但这些在modern PHP 中，在新的环境中可能都是很重要的，记录下来。 string str_repeat（’cy’, 10） //把cy这个字符串重复10次 1var_dump(str_repeat（&apos;cy&apos;, 10）) //注意一定要打印，这个函数的作用只是构成一个字符串 var_dump 和 var_export先来说下以后的使用都是使用var_dump,而不要使用var_export,因为第一个已经很强大了。var_dump 可以输出数据类型，但是var_export不可以。var_export 第二个参数给true, 他会把这个变量的值存储起来，可以用于赋值，但是当变量是resource的时候，返回的总是null,但是此时var_dump 虽然也不能打印出来，但是能123resource(2) of type (stream) NULL$a = var_export([2,3], true); 综上，用var_dump 面向对象 is_callable()与method_exists() //method_exists 只能判断方法是否存在，但如果比如父类的方法是protected这种，没权利执行也会返回true，这种情况就得callable了，他会返回false12345678910111213141516171819202122232425&lt;?phpclass Foo &#123; public function PublicMethod()&#123;&#125; private function PrivateMethod()&#123;&#125; public static function PublicStaticMethod()&#123;&#125; private static function PrivateStaticMethod()&#123;&#125;&#125;$foo = new Foo();$callbacks = array( array($foo, &apos;PublicMethod&apos;), array($foo, &apos;PrivateMethod&apos;), array($foo, &apos;PublicStaticMethod&apos;), array($foo, &apos;PrivateStaticMethod&apos;), array(&apos;Foo&apos;, &apos;PublicMethod&apos;), array(&apos;Foo&apos;, &apos;PrivateMethod&apos;), array(&apos;Foo&apos;, &apos;PublicStaticMethod&apos;), array(&apos;Foo&apos;, &apos;PrivateStaticMethod&apos;), );foreach ($callbacks as $callback)&#123; var_dump($callback); var_dump(method_exists($callback[0], $callback[1])); var_dump(is_callable($callback)); echo str_repeat(&apos;-&apos;, 10); echo &apos;&lt;br /&gt;&apos;;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP知识点]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[PHP中很多稍微高级的知识点自己都不是很熟悉，trait, 闭包，又或者composer等， 记录下来，成为现代phper。 PHP中闭包]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hi , swoole]]></title>
    <url>%2F2018%2F03%2F23%2Fhi-swoole%2F</url>
    <content type="text"><![CDATA[学习目的：想让自己从增删改查，做web，表单的生活中调出来。 swoole的安装 swoole作为PHP的一个扩展，用c语言开发，在使用他之前我们当然需要有php的基础环境。这里我们并不需要传统的lamp或者lnmp的架构，仅仅只要安装好php就行了。网上都说php最好编译安装，虽然我倒现在还不知道编译安装的好处，我看慕课上的那个教程也仅仅只是指定了php的安装文件夹。首先要搭建我们的虚拟环境，强烈推荐vagrant，真的很方便，虽然他把镜像都放在了c盘，我也懒得改了，但其实自己平时练习的话一个镜像就够了，剩下的只要操作这个镜像就好了，我用的centos7。安装好vagrant和vitrual box后去网上找镜像吧，http://www.vagrantbox.es/,挺快的，详细说明也有，我是先用迅雷下载到本地，然后再添加的。123vagrant box add centos7 d:/centos7.box //把这个box文件装到系统中，之后这个box文件可以直接删除vagrant box list //查看系统中是否有这个box文件的镜像vagrant box remove centos7 //如果这个镜像没用了，可以直接移除，节约c盘空间 加入镜像后，就是去一个文件夹装载你的虚拟环境，他的底层是操作virtual box嘛，我的感觉就是和vitrual box那样找个文件夹存储这个虚拟环境。1234567d:cd virtual //这是我平时虚拟环境统一放置的目录mkdir centos7 //为了区别开，这是我这次试验放置的目录，centos7代表镜像的名称cd centos7vagrant init centos7 //初始化虚拟环境，后面这个是上面添加进系统的镜像名称（这时候文件夹会生成vagrant的虚拟环境）修改vagrant file //配置共享文件夹，开启ip地址vagrant up //启动虚拟机（会重启加载上面配置文件的内容） 几个命令很长时间使用哦12345vagrant halt //关闭虚拟机vagrant suspend //挂起虚拟机vagrant resume //唤醒虚拟机，对应上面的挂起，这样就不用每次启动了，就和linux永不关机都可以一样vagrant destroy //摧毁虚拟机，没用的即使删除，虽然感觉也不占多大地方vagrant reload //这个我用的不多，主要是不记得他是否会重新加载配置文件了 上面的一些坑就是： 把镜像纳入系统的时候，默认会放在c盘，virtual box 也有些文件放在c盘，导致c盘越来越小。 加入镜像的时候，镜像的名称最好取得有点意义，比如ubuntu1604 这种，以后用起来的时候方便，时间长了，自己都忘记了。 不要用ubuntu16.04这种，之前用过这种，虽然添加镜像的时候没有啥问题，但是后面启动虚拟机的时候会报错。 挂载文件夹的问题。之前下载了ubuntu的box文件和centos56 的box文件，ubuntu能挂载上，centos挂载不上，网上说是vitrualbox的原因，可我都升级到2.0了都没法解决，仔细看了报错信息，说可能是这个box文件的问题。后来新下载了centos7的box文件，reslove。 1vagrant ssh //进入虚拟机，注意要在上面建立的装载虚拟环境的文件夹下使用 上面就是基础环境的搭建，可以理解成系统的搭建，剩下的就要我们去虚拟机中进行处理了。 首先是php的编译安装这篇文章里面写的很清楚，源码是我去php.net上面下载的。然后去swoole.php上面下载swoole的源码。phpize,这是php源码编译后的一个命令，按照上面那篇博客应该是在/usr/loca/php7/bin 下面，这是因为swoole的源码包下面没有configure文件，产生后./configure,可能会报找不到php-configure,注意这里面不是php 的配置文件，而是php7那个文件夹bin命令下面有个php-configure，直接写这个地址就可以了。 遇到的坑。编译出错，直接执行make，显示找不到configure文件，··其实./configure那时候就报错了，我不知道，直接执行make，然后显示找不到目标，注意一下报错信息，其实这些编译的时候都没什么错误，或者把错误信息粘贴去百度google，很容出来。注意要在php.ini 里面开启扩展 extension=swoole因为我们这没有lamp环境嘛，不要想着在页面访问phpinfo,直接php -m,查看加载的扩展。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己的http记录]]></title>
    <url>%2F2018%2F03%2F07%2F%E8%87%AA%E5%B7%B1%E7%9A%84http%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[上周老师让我们写一个关于http的总结，记录下这些天来的自己关于http的认识。 1.http请求动作 移动互联网时代，不像之前web时代，实现了前后端的分离，前端请求后端接口从之前基于soap变成调用基于rest的restul api接口，restful api是基于资源，他对于不同的http请求方式有不同的含义，最常见的get，post，put，delete, option,。传统的get和post区别主要是一个是url明文传递，另一个是加密后传递更安全。但是restful api中常见的4中请求动作分别代表一下含义get ： 对于资源的请求post ： 对于资源的创建put ： 对于资源的更新delete ： 对于资源的删除例如 : get /users/1 代表获取用户1的信息post /users/1 创建put /users/1 更新delete /users/1 删除这样的好处之一就是更有利于语义化，而且更能指定统一的标准, 比如laravel里面Route的resource方法就能根据资源users统一生成一堆的url，而不是通过不同的方法名来区分。但比如传统表单提交只能实现get 和 post方式，如果我们直接修改提交方式会报错 1&lt;form action=&quot;/posts/62&quot; method=&quot;POST&quot;&gt; 我们只需要在里面增加一个隐藏的input1&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; 就可以改变原先的form表单提交方式了 2.content-type的作用 对于接口返回数据的处理 以python flask为例 12345678910from flask import Flask, make_responseapp = Flask(__name__)@app.route(&apos;/hello&apos;)def hello(): response = make_response(&apos;&lt;html&gt;&lt;/html&gt;&apos;) return responseapp.run(host=&apos;0.0.0.0&apos;, debug=True) 默认浏览器是按照html的格式解析的，上面当我们访问/hello的时候输出是空，因为html标签里面什么也没有 1234567891011app = Flask(__name__)@app.route(&apos;/hello&apos;)def hello(): headers = &#123; &apos;content-type&apos;:&apos;text/plain&apos;, &#125; response = make_response(&apos;&lt;html&gt;&lt;/html&gt;&apos;) return responseapp.run(host=&apos;0.0.0.0&apos;, debug=True) 但这样就能输出 1&lt;html&gt;&lt;/html&gt; 因为我们让浏览器按照字符串的形式来解析 itbasic中也对header信息做了设置 123$response-&gt;header(&apos;Content-Type&apos;, &apos;text/json&apos;); $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); return json_encode($res); 这就是为什么我们每次调用接口的时候返回的都是json数据的原因 但是当我们输出模板的时候，观察控制台返回的 1Content-Type: text/html; charset=UTF-8 应该是模板在哪里进行了处理 常见的输出图片 content-type 属于返回内容的一部分，主要是用来告诉浏览器返回的数据应该怎么解析，比如你访问 homestead.app/1.jpg,并不是根据文件的后缀名解析的成相应的文件，而是根据resresponse headers里面的内容，常见的mini type。例如php输出一张图片 1234&lt;?php$fileres = file_get_contents(&apos;./1.jpg&apos;);header(&apos;Content-type: image/jpeg&apos;);echo $fileres; 不使用插件导出excel文件 其实这个作用还是挺大的，比如我们经常输出的excel，虽然php有个很强大的插件phpexcel，但是那种东西经常就内存溢出了，我们可以通过修改header，直接输出csv文件，而不用使用任何插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 导出excel(csv) * @data 导出数据 * @headlist 第一行,列名 * @fileName 输出Excel文件名 */function csv_export($data = array(), $headlist = array(), $fileName) &#123; header(&apos;Content-Type: application/vnd.ms-excel&apos;); header(&apos;Content-Disposition: attachment;filename=&quot;&apos;.$fileName.&apos;.csv&quot;&apos;); header(&apos;Cache-Control: max-age=0&apos;); //打开PHP文件句柄,php://output 表示直接输出到浏览器 $fp = fopen(&apos;php://output&apos;, &apos;a&apos;); //输出Excel列名信息 foreach ($headlist as $key =&gt; $value) &#123; //CSV的Excel支持GBK编码，一定要转换，否则乱码 $headlist[$key] = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $value); &#125; //将数据通过fputcsv写到文件句柄 fputcsv($fp, $headlist); //计数器 $num = 0; //每隔$limit行，刷新一下输出buffer，不要太大，也不要太小 $limit = 100000; //逐行取出数据，不浪费内存 $count = count($data); for ($i = 0; $i &lt; $count; $i++) &#123; $num++; //刷新一下输出buffer，防止由于数据过多造成问题 if ($limit == $num) &#123; ob_flush(); flush(); $num = 0; &#125; $row = $data[$i]; foreach ($row as $key =&gt; $value) &#123; $row[$key] = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $value); &#125; fputcsv($fp, $row); &#125; &#125; 文件的上传 之前在调用datrix的上传接口的时候，他要求传过来的数据文件得是form表单的g格式，可以通过 1var writeData = new FormData(); 3.http是无状态的协议（cookie 和 session）无状态的协议代表我们在登录网站后，浏览器不知道我们在不同的网页间是同一个个体，这就得靠session和cookie了。session和cookie都能保存用户信息，只是一个存储在客户端，另一个存储在服务器端。存储在客户端就说明用户可以进行修改，不安全，所以一般开启session后，服务器返回给用户一个session id,下次用户登录的时候，拿着这个session id 去服务器端获取session文件。php里面默认的cookie 名字是PHPSESSID 里面装的是sessionid的内容(这个名字是可以改的，比如laravel框架里面默认的是laravalsession,这个也是可以通过配置文件改的)，只要拿着这个去服务器端sess + sessionid的内容（这个存储地址在php.ini里面有配置），就能找到对应的session，session里面的内容是序列化后的（如果客户端禁止了cookie，也可以把session id 放在url里面带过来）。默认这个session id的cookie是种在 域名下。比如 itbasic.datatom.com,这个域名下的所有网页都可以访问（只有同一个浏览器，如果是不同的浏览器，就获取不到这个cookie了··） 文件1 ：12345&lt;?phpsession_start();$_SESSION[&apos;username&apos;] = &apos;cy&apos;; 文件2123&lt;?phpsession_start();var_dump($_SESSION); notice: 这个获取session的时候也要调用session_start（）函数，有时候因为框架的或者函数的封装，很容易忽略 4.http 状态码http状态码表示这个请求的状态，常用的有200成功 ，3xx 资源的重定向，4xx客户端的错误（404 请求的文件找不到 403 没有权限 401 没有登录）， 5xx服务器端错误（500 经常代码的错误 502 网关，经常nginx出错）。然后现在的restful api在我们返回客户端的请求内容的时候经常也会携带着一个状态码，比如 12345return json_encode([ &apos;errorCode&apos;=&gt;10001, &apos;errorMsg&apos;=&gt; &apos;xxx&apos;, &apos;result&apos;=&gt;[]]) errorCode一般是我们内部定义的错误状态码，可以展示给用户看，让用户更能清楚的了解问题的所在，举个例子就是文章的创建，可能title不合法，过长了，文章删除的时候没有传递id，都可以以一个具体位数开头的错误码，归于一类。不管是http状态码，还是我们传递给用户的状态码，都是可以改变的，比如tp里面的json方法，第一个参数就是http状态码的参数，第二个参数才是要返回的具体的内容。 location也是返回信息中的一个字段，虽然状态码和我们的返回信息没有关系，即使正常调用接口我们返回一个404也是可以的，但是location必须得配合30x才能实现页面的跳转。 5.无连接无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。记得之前好像看过一篇文章说现在的http协议支持长连接了 1Connection:keep-alive 在请求头里面包括这个东西，虽然自己平时好像从来也没感受到，但还是记录下 6.url url组成 统一资源定位符。比如http://itbasic.datatom.com:80。http 是网络协议，默认端口80，如果不是80，需手动添加，比如我本地的xampp修改了http默认端口8080，访问的时候itbasic.app:8080才能访问，除了http，还有https 443， ssh默认端口22，访问这些服务的时候都要加上端口号，除了域名之外。其实域名只是为了让人们更好的记住，其实它本质上是翻译成ip的，打开cmd，ping itbasic.datatom.com 就能看到ip地址。ip地址代表服务器，一个服务器上可能提供多种服务，比如web服务，为了识别出不同的服务，我们用端口号进行标识，这和之前说的刚好吻合。 域名解析 其实当我们在浏览器中输入itbasic.datatom.com 的时候，浏览器会先去找比如windows host文件（经常我们本地测试的时候，瞎写的域名能访问就是这个道理，他不会去网络上进行解析，而是根据hosts文件中的配置进行ip地址转换，可以测试一下把www.baidu.com ip地址换成itbasic的，当然只有自己这台电脑访问百度会显示的是itbasic的主页），如果找不到，寻找浏览器缓存，再找不到会进行DNS域名解析，最终找到服务器，给他发送http请求，如果是传统的lamp架构，apache接受到请求会把通过模块加载的形式把关于php的内容传递给php进行解析，php会把其中关于数据库的内容，交给数据库处理，返回来的数据处理后统一返回给apache，再返回到浏览器进行渲染。现在lnmp，利用nginx，fpm对php请求进行统一处理，自己关于这方面内容现在还不足，了解还不是很深。 跨域 itbasic.datatom.com中 com是一级域名，datatom是二级域名，itbasic是三级域名，同属于datatom,这个二级域名下还会有很多，比如blog.datatom.com,51dan.datatom.com,域名的不同会导致出现跨域的问题，之前看网上处理方式主要分为两大类，一种是jsonp,另一种是返回的请求头中添加 1&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos; 7.请求头1234567GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 第一行get代表请求方式， 后面那个是请求的资源，最后是http的版本号，话说http 1.0 和 http1.1 使用时间好长第二行host 代表主机名第三行 表示 访问的主机的系统，还有浏览器，经常通过这个来判断是手机还是电脑登录。其实这个在服务器端也是可以获取的，通过打印 $_SERVER 数组。第四行第五行 上一个链接地址，经常用来进行回退。这个请求头和后面传递的数据需要空一行。这个请求头里面还可以放置很多别的数据，比如laravel里面表单为了放置csrf攻击，在里面放置了额外的参数1&lt;meta name=&quot;csrf-token&quot; content=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt; 请求的时候建立连接还会有4次握手 你在吗 我在 那我给你发数据了 好的，你发吧虽然到今天还没用上过 8.返回信息12345678910HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt; 这个和上面的请求消息差不多，断开链接需要3次握手 我要断开链接了 好的 （我不发送数据） 我也要断开连接了（这下两条都断开了） 9.https https 默认端口443，其实他不是一种新的协议，他还是http协议，只是在外层包裹了ssl。 https传输数据比http安全大家都知道，但原因呢，是由于数据进行了加密。很早之前有种协议talent，他也是通信协议，默认端口23，但现在这个端口默认都被禁止掉了，原因就是他传输数据的过程是明文传输，导致别人用抓包工具抓到了请求，或者监听这个端口，直接就能获取客户端传递过来的数据。想象一下，钓鱼网站如果用这个，很容易就能获取到用户的密码，太不安全了，于是ssh诞生了（我猜的）。ssh用的地方很多，比如我们用xshell时候建立的连接，还记得我们第一次连接新的服务器的时候的弹窗吗 一次性接受密钥 这是什么东西？这其实就是服务器的公钥。你发给服务器的内容，用服务器的公钥进行加密，服务器接收到你的内容用私钥进行解密，保证了数据传输的安全性（你发送的数据只有服务器能查看到，别人永远不能查看，因为你加密的媒介是计算机的公钥，能解密的只用服务器的私钥，而服务器的私钥只有你自己有，so，数据绝对安全。但有一点，数据的不可变性，就是数据的被篡改性不能得到保证）。或者你是否记得第一次对github进行提交的时候，或者换新的机器对github进行提交的时候，需要在github上贴你的公钥，为什么呢？因为我们git clone代码的时候，需要让github用我们的公钥加密，然后我们用自己的私钥进行解密（git clone 的时候的地址有ssh和https之分） 上面说的公钥加密，私钥解密舒服非对称加密，记得有RSA算法之类的。但是我们在数据通信的过程中如果一直用非对称方式进行数据传输，消耗会很大。于是我们用了另一种对称加密。对称加密顾名思义就是：同一种密钥进行加密解密，简单。可问题来了，这个密钥如果被获取到，加密就毫无意义了，我们该如何传递这个密钥给客户端。我们不能预先在所有的客户端都放置所有的密钥吧，这样不现实，也不能变动。 上面说的第一种非对称加密是公钥加密，私钥解密，保证数据的安全性。其实我们还可以通过私钥加密，公钥解密的方式，这样虽然不能保证数据的安全性（指的是被别人获取，因为公钥的公开性），但可以保证数据的不被篡改，因为私钥的私密性，一旦篡改内容，我们没法复原到私钥加密前的状态，我们只需要在私钥加密的内容中添加一些公共的东西，比如一个值，一个算法，这个值经过算法加密后的值，当我们通过公钥解密后这这个值加密后不等于这个算法加密后的值，那我们就能发现文件内容被篡改。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F02%2F27%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>工具</tag>
        <tag>Python</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python学习笔记]]></title>
    <url>%2F2018%2F02%2F22%2Fpython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[虽然自己是写php的，但现在python这么热门，而且想挑战一下自己，多学点东西，感觉python的用途非常广泛，反正就是能给自己加分的选项。 运行环境python和php一样，也是脚本语言，解释型语言， 翻译一行，执行一行。python运行环境的安装很简单，直接去官网上下载，我是windows，所以下载了合适的exe文件，双击运行就可以了。勾选下面的添加到环境变量，直接在cmd中敲击python，就能进入交互界面，这个customize其实就是选择python的安装位置，放在c盘还是哪，别的没有多少变化。想了一下关于php的，其实当时对php的安装理解错了，不管是xampp，还是lamp的编译安装，都是对整个架构lamp的安装，并不单单是php，所以相对而言复杂些。lamp整个架构安装的成功，可以通过浏览器去请求，php进行处理，从数据库中获取数据这些一系列的功能。如果我们单单只是想编译php代码（因为php大部分用来web，所以这种情况比较少，这也是我们一直用集成环境的原因），单单安装php就可以，同样也是去php的官网上下载exe文件。python代码的执行python xx.py,php其实也是类似的，php -c 指定配置文件xx.php,lamp的本质执行php文件就是这样。python，php，bash这些脚本文件还可以直接执行，并不用在前面加上解释器的名字，在文件的开头加上这些注释：#!/usr/bin/env python3，php，bash都可以，加上注释的好处是为了执行的时候的兼容性。别用word和记事本写代码！！！ 字符编码廖雪峰的教程中提及的字符编码，ascii，utf-8,unicode,这三种，其实理解的并不是很深。后面的bytes类型，并不是很懂。首先是ascii，早些时候，为了表示大小写字母，一些特殊符号，用8位二进制字符表示的东西，其实只有7位在用，最高的一位代表着正负号。后来，为了表示中文，中文这么多汉字，ascii那点数量已经不够用了，出现了GB2312，可是日本韩国那些也出了对应自己文字的标准，为了实现兼容出现了Unicode，可是unicode中每个字符长度一致，导致很浪费，比如A你用一个很长的字符进行编码，后来就出现了针对节约空间的utf-8，字符变长。其实Unicode还有utf-8都是兼容ascii的，对于ascii中已经存在的字符要么是没有变化，要么仅仅就是在前面补位0就可以了。 重要的数据类型首先是list，这个我得理解就是类似队列一样的东西，在php中可以看做索引数组。初始化 a = [1,2,3,]取元素 a[0]末尾加元素 a.append(6)删除元素 末尾直接删除 a.pop() 返回的是要删除的元素删除特定的元素a.pop（0） 删除第一位元素添加到特定位置元素a.insert(0,88) 在首位添加元素88 tuple 不可变的链表，初始化 a=(0,)注意只有一个元素的时候一定要在末尾加上逗号tuple虽然不可以变化，但是这种（9，[1,2]）=&gt;(9, [2,3]) 还是可以的但这个赋值还不能 a[1] = [2,3] 这种只能a[1][0] = 2这种单独改变只是针对第一层结构的不可变 dict 字典，类似php的关联数组，无序，类似数据结构的链表，查找添加速度元素块，类似字典中查找字的方法。初始化 a = {2:’222’}获取元素和之前的还是一样 a[2]因为是无序的，所以不能用数字啦添加元素很简单，直接a[‘ll’] = ‘pp’ 这种方式删除元素 a.pop(‘ll’) set 集合，就是dict的key部分，so也是无序的初始化 a = set([9,9,9]) 感觉是强制转换因为dict的key不能重复，所以上面的初始化后还是 9添加元素 a.add(10)删除元素 a.remove(10)集合··差，并，交 不可变对象str不可变，tuple不可变 可变list可变，dict可变 str的不可变，其实在别的语言中也是，只是廖雪峰的教程中有强调，比如在js教程中，其实php中也是如此，对str本身的改变并不影响str本身，只是返回了一个新的str。还有就是dict的key，必须是不可变对象，否则key的实际值总变换，查询到的value总在变化，那就乱了套了。 常见的结构if elif else12345678mod = 3if mod == 1: print(&apos;cy is good&apos;)elif mod == 2: print(&apos;cy is bad&apos;)else: print(&apos;ccc&apos;) 感觉写python就不要在末尾加 ;判断条件可以是表达式，不要加括号注意条件语句末尾加：用缩进代替 {} for in 进行循环遍历123a = &#123;&apos;pp&apos;: &apos;oo&apos;, &apos;rr&apos;: &apos;pppp&apos;&#125;for x in a: print(x) 函数的定义def print_function(a): for key,value in a.items(): print(a+’–’+value) 类的定义class ClassName(object): 零碎的知识点 python中的注释，单行是 #，多行是 ``` ``` python的代码不能压缩，因为if 后面的空格是必须的，压缩之后就没有当初的意义了 python里面的if 表达式好像不用用括号包围起来，然后表达式不能用赋值语句，感觉这些虽然在别的语言里面可以用，但是本质上用这个不规范，感觉还是不用比较好 python里面变量的命名用驼峰法，然后如果变量位于模块里面而不是类下面，会被直接认为是常量 python的代码规范是pylint，要求python代码结尾需要一个空行 除了：，剩下的运算符两边好像都需要空格，python文件的开头（模块的开头），一般都有个doc文档描述 python的缩进是4个空格 感觉逻辑运算符应该就是 and or这种， 但是 &amp;和|挺方便所以用的比较多，所以以后感觉python中还是多使用 and 和 or比较好 python中没有我们那种for（） 循环，只有一种循环就是for in，如果想用数字那种控制循环条件，可以通过range构造一个类似list的东西，rang（start, end, step）,包括开始，不包括结束，最后一个参数代表每步的大小，python中还有个切片，功能一致。a = [0:len(b):2],只是这个输出的直接是一个list python中的组织结构：包（文件夹）模块（文件）类，虽然python中一个模块可以包括多个类，但是最好还是只包括一个，这样更符合规范 python中除了类名，首字母大写，后面用驼峰法，好像剩下的所有的都用_ 进行分割 包在外表物理形式上是类似于文件夹的，但是文件夹并不一定是包，要想成为包，必须的有个init.py 这个文件夹（里面的内容是空的，可以随便写，现在我还不知道他有什么用） 导入包邮两种形式 import a , from a import hello，hello2, hello3,第一种在使用变量的时候需要加上包的名称，第二种在使用的时候直接使用hello就可以了(连着导入了三个变量) __pycache__ 二进制文件夹，感觉应该是缓存文件，可以 加速python的编译执行,这个文件夹里面的内容是没有用的 import 包名的时候也可以用 as，用来简化包名 不管是导入包，还是导入包下面的文件 init.py 都会被自动的执行 几个比较常见的内置变量doc: 文件的注释file : 文件的物理位置package: 代表文件的包名，文件外层文件夹的名称name:代表文件的名称，没有后缀 python可以同时返回多个值，return a,b ，其实这是返回一个tuple，感觉是不是tuple可以不用（）包裹起来 a,b,c = (1,23,3) 这样赋值了，php也有类似的功能。list(a,b) = [0,1],只能用于索引数组 python 中字符串的连接用的是 +， python中函数的调用参数可以不按照顺序返回，只需指定变量名就可以了 python中的可变参数，比如print可以接受任意多个参数。def print_function(param),这样打印出来的param是一个tuple，如果print_function((1,2,3)), 这样打印出来的依旧是tuple，但是如果直接print_function((1,2,3)),这样打印出来的就是二维数组了(不止是tuple，list这些也是可以的) 作用域：python中for和php，js都一样，构成不了作用域，es6里面用的let。import代码的时候其实是把不同的代码拼装在了一起，import的文件里面如果有可执行的内容，都是会被执行的 函数内部的变量本来是不能被执行的，但是如果在函数内部定义了global c.单独起一行，这样就能在函数外面也可以使用 php类里面的定义没有参数（），python里面类的定义有（） 类中方法的定义一定要传入参数，self init 是类的构造方法，也要传入参数self感觉self在python类中属于实例。self.name 代表这个类的实例属性，即使这个类没有类变量name也没有关系（注意这个self只是一个变量的名称，是可以改变的，不属于关键字范畴） python中类Test().name 可以直接调用类属性 上面这种直接使用类变量一般用在类的外部，如果在类的内部使用，一般是不可以的，如果实在想使用，用self.class.name 这样使用]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于token]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%85%B3%E4%BA%8Etoken%2F</url>
    <content type="text"><![CDATA[关于token。故事背景：itbasic用vue做了个手机版，之前是用jquery识别是手机还是web实现页面上元素的尺寸变化，实现兼容，但是页面其实还是同一个。所以通过dom元素绑定的后台请求ajax，api接口可以通用。现在用了vue，这种mvvm模式的框架，需要后台返回纯json格式的数据，并不需要之前接口中可能返回的html，实现页面元素的变化，这样一来，很多接口得重写。之前的itbasic更像是远古时代的web，调用接口的基本权限控制用的是session里面存储的登录用户信息，而itbasic的web端更像是现代的web网站，调用接口不需要用户登录，而是通过令牌，也就是token进行身份认证。 token肯定要保存的啦,保存的内容有哪些？从上面可以看出token的作用就和之前的session作用是一样的，因为session中存储了用户的基本信息，我们可以通过解析session数组，从中获取自己有用的东西，但我们的token一般只是一串无意义不重复的数字，所以光靠token是实现不了用户的区分的，所以我们一般在缓存中保存（为什么是缓存呢，我觉得首先返回给客户端的token信息不重要，并不用都保留下来，还有就是频繁的调用api接口，如果我们每次都去数据库中取缓存，太多的与数据库的交流并不好）。那我们需要保存的内容有哪些呢？最基本的用户的uid，因为我们一个token需要区分一个用户，我们得通过token知道这个用户是谁，当然你可以保存的不单单是uid，你可以理解成token是session数组的session_id,session数组就是我们token可以对应的内容，你可以在里面存放用户权限，登录时间，等一些常用的信息，这样就不需要为了取一些常用的信息的时候，先通过token找到用户id，再通过数据库查找这个用户的相关信息，再返回。token对应的内容只要你乐意，随便存储什么，但最基本的应该有个uid哦。 ​总结：token保存在缓存中，并不用记录在数据库中，保存的内容是和uid 的对应关系。 token的产生其实之前我一直纠结怎么生成一个token，网上有很多算法，后来呢，感觉如果安全性不用太高的话。取一堆字符串，从中随机取个，通过mt_rand()，然后拼接下，你也可以再拼接个你自己的盐，再加上时间戳这种的东西，再md5（）加密下。(js,php这些都有md5加密的，同样的内容，不管通过什么语言md5加密应该是一样的）。总结：方法很多，自己想吧，别太纠结了 token有过期时间和session一样啦，不能请求一次就一直可以使用啦。 token一般放在cookie里面，这样请求接口的时候就不用一直带上这个参数了。 token的申请。token需要和用户相对应，这种对应关系怎么知道呢。在之前做的微信小程序登录接口中是这样做的。 首先用户通过登录小程序获得一个code码（还记得我们每次进入小程序的时候都有个允许授权吗），这个码可以换取对应这个用户在这个小程序里面的一个独一无二的openid，可以理解成类似uid的东西，我们一旦获取到这个openid，意味着就相当于我们多了个用户uid，我们在自己的用户表中存储这个openid。（为什么要用code换区openid呢，可以理解成openid比较重要，包含用户的重要信息，而且类似uid，永远不会变，一旦获取，就代表永远知道了，这个不能用来表示身份，或者说通过openid不能换取表示身份的token，所以还是放在服务器端吧。古代的用户密码登录因为有只有自己知道的密码，所以可以通过固定不变的大家可能都知道的用户名换区session_id,现在通过变化的code同样的道理，code理解成密码，服务器端给这个密码给微信，微信通过自身维护的code和openid的对应关系，把用户openid返回给你，注意这个code只能用一次哦） 服务器收到这个openid， 生成和这个用户相匹配的token，存储对应关系在缓存中，再返回给客户端token。客户端拿着这个token再来服务器端请求数据，服务器端看token是否存在和token是否失效，如果没有，可以访问。如果过期了，需要重新走上面的流程生成新的token。可这个时候就不用在用户表里面添加新的用户了，因为用户已经存在了，可以生成新的key=》value对应关系，key=》代表新生成的token。 大致就这些了吧··· 关于app接口设计的token，有signature签名的作用：主要是为了放置提交数据的安全性，token：1.第三方access_token,调用第三方接口的凭证。2.自己用的token，作用就相当于用户登录的密码，参见链接:https://blog.csdn.net/qq_26291823/article/details/53337518]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>token</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件操作]]></title>
    <url>%2F2018%2F01%2F29%2FPHP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[上篇文章里面写了关于文件上传。其实在做文件上传的功能的时候遇到很多php关于文件的处理，记录下来。其实文件处理在我们刚开始学习php的时候肯定学习过，可后来因为项目当中，做网站的时候关于文件的操作很少，所以很容易忘记这部分的内容，毕竟其实也挺枯燥的。1.遍历文件夹下的所有文件。在做大文件切割的时候，本来想用php做，可是php的fopen好像最多只能接受8000多个字节，就是8000B，而我们上传文件大小一般能达到4m,如果按照8000B的切割也就太多小文件了，于是用linux新建个文件夹，在文件夹中split -b 4m 文件名 （还有个参数代表切割文件的名称，我没有仔细看，使用的默认的，就会产生xaa,xab···这种的文件），然后删除原始文件，遍历文件夹下的所有文件，每次上传一个，像服务器上刚开始创建好的文件持续写入，这样就能实现php的大文件上传php:1234567891011&lt;?php$dir = &apos;/root/test&apos;;$handle = opendir($dir);$fileArr = [];while($filename = readdir($handle)) &#123; if ($filename != &apos;.&apos; &amp;&amp; $filename != &apos;..&apos; &amp;&amp; !is_dir($filename)) &#123; array_push($fileArr, $filename); &#125;&#125;//var_dump($fileArr);exit; 2.遍历文件夹下所有文件这个是面试题中经常考得一道题 php123456789101112131415161718192021222324252627function listDir($dir)&#123; if(is_dir($dir)) &#123; if ($dh = opendir($dir)) &#123; while (($file = readdir($dh)) !== false) &#123; if((is_dir($dir.&quot;/&quot;.$file)) &amp;&amp; $file!=&quot;.&quot; &amp;&amp; $file!=&quot;..&quot;) &#123; echo &quot;&lt;b&gt;&lt;font color=&apos;red&apos;&gt;文件名：&lt;/font&gt;&lt;/b&gt;&quot;,$file,&quot;&lt;br&gt;&lt;hr&gt;&quot;; listDir($dir.&quot;/&quot;.$file.&quot;/&quot;); &#125; else &#123; if($file!=&quot;.&quot; &amp;&amp; $file!=&quot;..&quot;) &#123; echo $file.&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; closedir($dh); &#125; &#125;&#125;//开始运行listDir(&quot;./nowamagic&quot;); 上面两个场景大致差不多，主要就是几个函数的使用。首先要明确读取文件夹的内容和读取文件的内容是不一样的。 is_dir 判断该文件是否是文件夹，注意的一点事一定要跟上文件名的前缀··，否则不能找到指定文件，会有奇怪的错误发生。 is_file 判断是否是文件 读取文件夹的内容，首先要打开文件夹,opendir() ,会产生一个资源型的数据类型，句柄，readdir() 会循环遍历文件夹的内容。closedir()读完文件之后关闭。 注意每个文件夹下的两个特殊文件’.’ 和 ‘..’ fopen打开一个文件，返回一个句柄，其实和上面打开一个文件夹是一样的，只是这里面多了几种模式。这个句柄可以理解成连接数据库时候的资源文件，每次关于数据库的操作都得用到这个文件 12345678&quot;r&quot; （只读方式打开，将文件指针指向文件头）&quot;r+&quot; （读写方式打开，将文件指针指向文件头）&quot;w&quot; （写入方式打开，清除文件内容，如果文件不存在则尝试创建之）&quot;w+&quot; （读写方式打开，清除文件内容，如果文件不存在则尝试创建之）&quot;a&quot; （写入方式打开，将文件指针指向文件末尾进行写入，如果文件不存在则尝试创建之）&quot;a+&quot; （读写方式打开，通过将文件指针指向文件末尾进行写入来保存文件内容）&quot;x&quot; （创建一个新的文件并以写入方式打开，如果文件已存在则返回 FALSE 和一个错误）&quot;x+&quot; （创建一个新的文件并以读写方式打开，如果文件已存在则返回 FALSE 和一个错误） 这个模式也可以分成指针指在文件头部还是尾部来记忆。 feof 判断指针是否到了文件尾部 fgets读取一行文件 fclose关闭文件 fgetcsv 与 fgets() 类似，不同的是 fgetcsv() 解析读入的行并找出 CSV 格式的字段，然后返回一个包含这些字段的数组。 fread(), 读取指定大小的文件，但有大小限制，然后还有二进制文件的限制（没有仔细了解过二进制文件和文本文件的区别） 3.php合并文件思路：其实就是打开一个文件，不断往里面写入。关于打开fopen() 参数很多，感觉很多都是遇到的时候再看吧，二进制文件记得加b。php12345$fb = fopen(&apos;/root/1.css&apos;, &apos;wb&apos;);foreach ($fileArr as $key=&gt;$value) &#123; fwrite($fb, file_get_contents(&apos;/root/test/&apos;.$value));&#125;fclose($fopen); 每次的写入都是从尾部开始写入的。（相比较打开文件夹，他少了个readdir这种循环遍历文件夹的函数，好像fgets也有这种功能，但是用的不多，就没细看了）。 4.还有一些关于文件的函数，比如获取文件内容file_get_contents,写入file_put_contents,获取fgets这种的好像是按照行获取的，一般读操作用file_get_contents,能读取全部的内容。 文件读写是经常进行的一个动作，读取文件的函数真是千千万万个，复杂的有，简单的也有。最常用方便的有file_get_contents(),file_put_conents()，不需要进行打开文件，关闭文件的操作。但是对超大文件进行读取时，file_get_contents()会把内容都读取进内存，造成内存溢出，最好是循环按行读取。fgetcsv()用来读取一行csv文件，fgets()用来读取一样普通文件。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2F2018%2F01%2F26%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[今天遇到一个问题，关于大文件的上传。其实不管是大文件的上传，还是普通的文件上传，一直都是迷迷糊糊的，今天对其进行整理下。首先，最基本的，文件大小单位 1KB等于1024B，B是英文Byte(比特，字节)的缩写,KB即kilobyte,字面意思就是千比特。byte是文件大小的一个计量单位，大家都知道在计算机里面，文件都是以二进制方式存储的，这样一个最小的存储单元（譬如10、11、01、00）叫做一个bit(位，位元)，八个位元等于一个比特。转换关系：8bit=1b1024byte=1kb1024kb=1mb1024mb=1gb1024gb=1tb以上单位k指千、m指百万、g指10亿，t指万亿，大小写均可。因为1024≈1000，所以1024b,也称为1k，以下类似。 简单点说就是 1G =1024M 1M = 1024K 1K=1024B B之后就是位了，8位是1B，一般都是B为计量单位。 菜鸟教程这里面有对最基本的php文件上传的demo html :123456789101112131415&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这个是以最基本的表单提交方式，当点击提交的时候文件就直接飞到upload_file.php那边了，注意接受的变量以表单控件的name字段的内容为变量名（$_POST[]）数组里面（想了下，其实框架的路由都是从这些大数组里面获取变量的信息）。这个 enctype 很重要 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。 标签的 type=”file” 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。 不仅是这块，当用curl模拟文件上传的时候，也有相关的参数设置1curl_setopt($ch, CURLOPT_POSTFIELDS, $params); 这个param如果是普通的post数据提交，要拼接成&amp;这种string方式，如果是文件上传，直接是传输组参数就可以了。 php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php// 允许上传的图片后缀$allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;);$temp = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]);echo $_FILES[&quot;file&quot;][&quot;size&quot;];$extension = end($temp); // 获取文件后缀名if ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;))&amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 204800) // 小于 200 kb&amp;&amp; in_array($extension, $allowedExts))&#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123; echo &quot;错误：: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;; &#125; else &#123; echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br&gt;&quot;; // 判断当期目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在。 &quot;; &#125; else &#123; // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;文件存储在: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; &#125;&#125;else&#123; echo &quot;非法的文件格式&quot;;&#125;?&gt; 之前一直以为这是框架的内容，其实这是php自带的，框架可能只是对他的封装和安全性的校验。如果有时候实在上传出错，试试这个数组。 几个要注意的点： 临时上传文件的地址可以通过phpinfo() 查看，但如果你真到那个文件夹下是找不到的，通过move_uploaded_file 函数移动到你需要的位置。因为我们itbasic之前的上传都写好了，导致我以为上传直接上传到指定的文件夹。 几个函数 is_dir 判断文件夹是否存在，file_exists,判断文件是否存在，move_uploaded_file 移动文件。注意创建文件夹的时候给权限755. 移动到新的地址直接返回新的地址给前端就可以了。 注意一下我们平时比如itbasic上表单的提交都不是以form这种格式，都是直接通过按钮触发click事件，然后获取页面内容进行提交，这种方式是上传不了文件的，我们可以利用jq，12var writeData = new FormData();writeData.append(&apos;object&apos;, objid); 然后往里面添加属性，通过append 之前还上传过base64格式的image图片，其实这个要比前面的文件上传简单很多，这个与其说是上传文件，不如说是保存数据内容。 一个image的base64格式码：1data:image/png;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCABPAFgDASIAAhEBAxEB/8QAGwAAAQUBAQAAAAAAAAAAAAAAAAECAwQGBQf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbvbIA1B7alwUwuyLDRxUFCaSOQRHRmJ6VXHHe9DyusEUCqASyMeJRs8Y5uTu9cbqMohvlyGwKgoTRySGL6Wg55i2dBh3+15fuzpTNcVQCZ0MRaoTBbSqhJw+yFxtVB5EH/8QAKBAAAAYABQMFAQEAAAAAAAAAAAECAwQFEBEUMzQGFTESEyFBRCBC/9oACAEBAAEFAj3fH8fePkfpPd84LWTaGJceSP8AT96uPPZdJ9keAfJPdHnDtS4trY2KEtwH6yO6PGB8k93BaUrQ7W1iTr3o7L0O0hOPYnyT3c/nP5elRUBXY0nXSo8V3vyUCFNTNZzGfz+k90zIiN5pIk9rfVarhJBWrDUBjqLJtfUihAvCkvg+Se6+y3IaLpxn1opYSAiM5XSbGyjvxauDo4eWYJpslA+Se7g9OixidtZM0N9P5s+7YU7sCc3YM4HyT3QpJLSivhtgiyL7fYbktV1WqBIwPkuK9CikIIalA1KBqUDUpGpSNSgalA1CDCFe4/8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAwEBPwF3/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAgEBPwF3/8QAMBAAAQMCBAQFAQkAAAAAAAAAAQACAxEhEBIxcQQTUXIiIzJBYYEFIDAzQ1JigpH/2gAIAQEABj8CGxV/wLIdqGxxc91mtFSvJla7498JI8jHxNNLapsoDgHDRwviO1DY40KjmicBBmqammX4XLg4mIF2r61y/wCJoDZJZT+o5ipiO1DY4lrtCjzJsu8qJ4qMPZTpW6EMMJiLtPAPuDtQ2xMU0sY6tcVfl/SpUjp4s4Itaq8ngrb0WcMcw1oQcRshsVcq8jB/ZVnfAXD+d1E3ggyouXNWRsodxGT1NjpdUnizO6t914OGA3chDNHkc7QjAbIbFGKVtWlXnfl6UQ8rN8ucpJZ+CE0R0Lbhv0Qi4WOmb1eGlFR35j7uVwFmEbQetMB2obHCi8yZoPStSuV9nwvp+9HnSnnG9RoFkcas9gbtKJAo4epvRUwHahsVZFrhY6rw8NH9RVUCojHK2rSpXczMxwoOuF0O1B3tRaFaOWjlo5aFaOWjlo5aFZh0X//EACcQAQACAAQFBAMBAAAAAAAAAAEAESFBUfAQMWFxkYGh0fEgweGx/9oACAEBAAE/Id21IZFjl+C4TUfweYWOccNrnNm1IgKYLaPmJTYJV0E5qvOj/jnLwHRmFOxydWPeXG0FARWwPMAFE23WbNqcEpTMNa9c5XJ7QoZ9UA2OCuHQtjGixVBL6F2S7sOOsClHDbdZs2pxNeypxqIIrL+mM5HlzG7IitqVF+Pw23WOu7/0lcGPiVwY+I03JQXJ1JfNvpvaYcaCGj6wFS72RKBZQs+8rdY+JXBj4ju9Zs2pLEAas90wErs/lT2MKvKi+Mc5ThUWBp5ka9jyejuuJ8hf+oChFPsXThtes2bUma45LBTfAAfP8lWG9Q+3KWdQogL5/wBS05eQgZYQgMU7eh6fMpYcSnC5DfDbdZs2pwu1HnSLAZl9gRhCWCzH0yINBX8wn7lUzok9NIqbDs+XaXSLzrw23WbNqRtwXd0l9w6GsUuzr+1AIADIJeHoYdz2nUlDdY1qz4FmC7Os23WXMLYNekAo8Z8z6A+Z9AfM+gPmYmX2J9MT6A+Z9AfMQU+MlICBTGf/2gAMAwEAAgADAAAAEMOMPOMFLGOPAJPGEJMFGDBNAELPBODP/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAwEBPxB3/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAgEBPxB3/8QAJhABAAEDAwMEAwEAAAAAAAAAAREAITFBUWFxgaEQkbHwINHhwf/aAAgBAQABPxASF94zS7DKmURIb812q21dqUKEKnWyfutXWrV2pWMCJRMDtzRhS4Z1u9NLgJJmos2Lg1/tN9k3QErBdsaUcxclABvOIdqWWcKPZP3RED2SaBkUYlppmj1GYExc7dyGoM2bq0/v3rGCCZrwHy9dJpgawLcRZbh7Ubx4KgBZCSETZvu6Wx2KwEqWNtyi5XAAnTXUheaS1gEIMf2jDAUV4D5fhplJMMrOpc6lR5ihK3ZMjrUlzpSgSMg3za1R/KYNmL2G2pFAGI7evgPlQSxZEgX2aRlJzGce8RSEpPGce8RUDB7UhqaI6lX/ANwB0JHtUAjlvNMkwKNE7oJOi/NXyMTQytCEvm3IUhbn1x7xFQCM1DOPeIpyd7HJy9FKAzykBRUj/YloGVIvo2U170QmDpjAHLU3nzRKRKp6B0WCUmL0sOQAE4YPSZ4i6CXrLn2B81JAwpTCG5w37Vonivv8vTSPg0KwiNkTCN5oLAWJTm8aXIdfxonhWu+0wUEMWgwjfc9x17AEGCrtoc0CuDF5RZdQeWk7OAYITpvQnBowdwmivAfL0070z8yFxSxllujmZO5Vq+JwbynurO0NEgmFkkszec3ZLlt2dwLKec57EdzdbzkgUzAdVDDbDQWDKWVCvAfL0UsUQzH0ZqVhLJsSHFRAMgKO4XzQQ2ggAUsMQKe0fuhzvccrRNHmjGJypZKdEmJMy2KSf8p2Wsx9Ga+xyqHmS0klWrxUNM9z8BAgQYcWTOSbRr1rL9Dv6kCD1MfpmgES45yu/Nf/2Q== 图片在使用的时候只用image src=”” 等于上面这串内容就可以了。像wangeditor里面，写的内容，两种保存图片的方式：1.base64， 直接把这个image src = base64格式保存在html中 2.把文件上传到服务器上，然后获取链接地址。 base64 php处理代码：12345678910if (preg_match(&apos;/^(data:\s*image\/(\w+);base64,)/&apos;, $src, $result))&#123; $type = $result[2]; $body = str_replace($result[1], &apos;&apos;, $src); $filename = $path.date(&apos;YmdHis&apos;, time()).&apos;.&apos;.$type; if (file_put_contents($filename, base64_decode($body)))&#123; &#125;else&#123; return [&apos;code&apos;=&gt;CODE_ERROR, &apos;msg&apos;=&gt;&apos;文件保存失败&apos;]; &#125; &#125; 大致说下一下，type 获取的是正则 （\w+）里面内容，代表图片的格式，body 获取的正则的内容，注意看表达式最外面的（）括号，result[0]代表的是完全匹配内容。 php获取到图片base64加密后的内容，通过解密，file_put_contents 写入文件，返回文件地址。 上面是通过前端 js + 后端php，实现的文件上传，其实完全可以通过 php + php 实现，下面分别介绍通过这两种方式实现的大文件上传。 客户端php代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#!/usr/bin/env php&lt;?phpconst DATRIX_URL = &quot;http://211.144.114.26:19980&quot;;//const DATRIX_URL = &quot;http://192.168.50.229&quot;;const DATRIX_UID = &quot;itbasic&quot;;const DATRIX_PUID = &quot;itbasic&quot;;//const DATRIX_DATA_DIR = &quot;9bbd816d16ff589aee0ffe0ce68323ba&quot;;//const DATRIX_DATA_OBJ = &quot;20180126/09/9bbd816d16ff589aee0ffe0ce68323ba&quot;;const DATRIX_DATA_DIR = &quot;4bb4db1235077fb2ba6ea2b9a0220693&quot;;const DATRIX_DATA_OBJ = &quot;20180125/16/4bb4db1235077fb2ba6ea2b9a0220693&quot;;const DATRIX_EXECUTE_ID = &quot;itbasic&quot;;const DATRIX_CREATE_URI = &quot;/api/sw/file/create&quot;;const DATRIX_WRITE_URI = &quot;/api/sw/file/write&quot;;const DATRIX_FINISH_URI = &quot;/api/sw/file/finish&quot;;$filename = substr(date(&apos;Ymd&apos;), 2).&apos;.sql.tar&apos;;$trueFileName = &apos;/var/dataitbasic/&apos;.$filename;function http_post_data($url, $params = array(), $string = 1)&#123; if (is_array($params) &amp;&amp; $string) &#123; $params = http_build_query($params, null, &apos;&amp;&apos;); &#125; $ch = curl_init(); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_ENCODING, &quot;&quot;); curl_setopt($ch, CURLOPT_POSTFIELDS, $params); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $response = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); curl_close($ch); return [$httpCode, json_decode($response,true)];&#125;$param = [ &apos;filename&apos;=&gt;$filename, &apos;filesize&apos;=&gt;filesize($trueFileName), &apos;createuid&apos;=&gt;DATRIX_UID, &apos;parentuid&apos;=&gt;DATRIX_PUID, &apos;dirid&apos;=&gt;DATRIX_DATA_DIR, &apos;parentobj&apos;=&gt;DATRIX_DATA_OBJ, &apos;city&apos;=&gt;&apos;上海&apos;, &apos;district&apos;=&gt;&apos;&apos;, &apos;gps&apos;=&gt;&apos;121.48789949,31.24916171&apos;, &apos;isperdir&apos;=&gt;&apos;true&apos;, &apos;userid&apos;=&gt;DATRIX_EXECUTE_ID, &apos;debug&apos;=&gt;true];function uploadToDatrix($createParam, $trueFileName)&#123; $block = 4*1024*1024; $create = http_post_data(DATRIX_URL.DATRIX_CREATE_URI, $createParam, 1); $objid = $create[1][&apos;result&apos;][&apos;objid&apos;]; if ($create[1][&apos;code&apos;] == 200) &#123; if (filesize($trueFileName) &gt; $block) &#123; $dir = DIR.substr(date(&apos;Ymd&apos;), 2); $handle = opendir($dir); $fileArr = []; while(($filename = readdir($handle)) !== false) &#123; if (!is_dir($filename) &amp;&amp; $filename != &apos;.&apos; &amp;&amp; $filename != &apos;..&apos;) &#123; array_push($fileArr, $filename); &#125; &#125; closedir($handle); $offset = 0; foreach ($fileArr as $key=&gt;$value) &#123; $writeParam = [ &apos;object&apos;=&gt;$objid, &apos;bucket&apos;=&gt;DATRIX_EXECUTE_ID, &apos;length&apos;=&gt;filesize($dir.&apos;/&apos;.$value), &apos;debug&apos;=&gt;true, &apos;filedata&apos;=&gt;file_get_contents($dir.&apos;/&apos;.$value), &apos;offset&apos;=&gt;$offset ]; $writeResult = http_post_data(DATRIX_URL.DATRIX_WRITE_URI, $writeParam, 0); $offset += filesize($dir.&apos;/&apos;.$value); &#125; $finshData = [ &apos;objectid&apos;=&gt;$objid, &apos;createuid&apos;=&gt;DATRIX_UID, &apos;userid&apos;=&gt;DATRIX_EXECUTE_ID, &apos;fileid&apos;=&gt;$create[1][&apos;result&apos;][&apos;fileid&apos;], &apos;debug&apos;=&gt;true ]; if ($writeResult[1][&apos;code&apos;] == 200) &#123; $finish = http_post_data(DATRIX_URL.DATRIX_FINISH_URI, $finshData,1); &#125; if ($finish[1][&apos;code&apos;] != 200) &#123; echo date(&apos;Ymd&apos;); &#125; &#125; else &#123; //$file = fopen($trueFileName, &apos;rb&apos;); //$content = fread($file, filesize($trueFileName)); //$content = fgets($file); $content = file_get_contents($trueFileName); //echo &quot;filesize:&quot;.filesize($trueFileName); $writeParam = [ &apos;object&apos;=&gt;$objid, &apos;bucket&apos;=&gt;DATRIX_EXECUTE_ID, &apos;length&apos;=&gt;filesize($trueFileName), &apos;debug&apos;=&gt;true, &apos;filedata&apos;=&gt;$content, &apos;offset&apos;=&gt;0 ]; $writeResult = http_post_data(DATRIX_URL.DATRIX_WRITE_URI, $writeParam, 0); $finshData = [ &apos;objectid&apos;=&gt;$objid, &apos;createuid&apos;=&gt;DATRIX_UID, &apos;userid&apos;=&gt;DATRIX_EXECUTE_ID, &apos;fileid&apos;=&gt;$create[1][&apos;result&apos;][&apos;fileid&apos;], &apos;debug&apos;=&gt;true ]; if ($writeResult[1][&apos;code&apos;] == 200) &#123; $finish = http_post_data(DATRIX_URL.DATRIX_FINISH_URI, $finshData,1); &#125; if ($finish[1][&apos;code&apos;] != 200) &#123; echo date(&apos;Ymd&apos;); &#125; &#125; &#125;&#125;uploadToDatrix($param, $trueFileName); http_post_data 是通过curl封装的post方法，需要注意的点是，传的post参数不要组装成string（post三种传递数据方式，string， 表单还有一种），其实我们平时可以通过观察控制台，发现我们itbasic的每次提交都是post方式，但是数据组装方式，有string，表单两种类型。还有注意我之前一直file以为传文件名就可以了，··坑爹啊··这样传服务端怎么获取内容，用file_get_contents()获取文件内容。（今天偶然碰见，file_get_contents()不能获取itbasic.app这种本地定义的域名哦）。 php读取指定文件大小 完整的php接受大文件上传 上传大文件 js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167var uploadToDatrix = function(fileObject, fileId, fileText, type, dirid, dirobj, pro, button) &#123; //参数是上传文件对象 if (button) &#123; $(&apos;#&apos; + button).attr(&apos;disabled&apos;, &apos;disabled&apos;); &#125; for (var i = 0; i&lt;fileObject.files.length; i++) &#123; var file = fileObject.files[i]; //具体的文件 var filename = file.name; var fileSize = file.size; console.log(file); var data = &#123; filename: filename, filesize: fileSize, createuid: DATRIX_UID, parentuid: DATRIX_PUID, dirid: dirid, parentobj: dirobj, city: &apos;上海市&apos;, gps: &apos;121.48789949,31.24916171&apos;, isperdir: true, userid: DATRIX_EXECUTE_ID, debug: &apos;true&apos; &#125;; $.ajax(&#123; url: DATRIX_URL+DATRIX_CREATE_URI, type: &quot;POST&quot;, dataType: &quot;json&quot;, data: data, success: function (data) &#123; var back = data.result; console.log(back); /* var writeData = &#123; object: back.objid, bucket: &quot;itbasic&quot;, length: fileSize, offset: 0, debug: true &#125;*/ fileWrite (fileSize, back.objid, fileSize, file, 0, back, fileId, fileText, type, button); &#125;, error : function(error) &#123; showAlert(&apos;上传失败&apos;, &apos;danger&apos;); &#125; &#125;); &#125;&#125;;var fileWrite = function(uploadSize, objid, trueSize, file, start, back, fileId, fileText, type, button) &#123; var writeData = new FormData(); if(uploadSize &lt;= 2 * 1024 * 1024) &#123; var fileSize = uploadSize; &#125; else &#123; var fileSize = 2 * 1024 * 1024; &#125; var end = start * 1 + fileSize * 1; var func = (file.mozSlice ? &apos;mozSlice&apos; : (file.webkitSlice ? &apos;webkitSlice&apos; : &apos;slice&apos;)); var uploadFile = file[func](start, end); writeData.append(&apos;object&apos;, objid); //var writeData = new FormData(); writeData.append(&apos;bucket&apos;, &apos;itbasic&apos;); //上传文件用户id writeData.append(&apos;length&apos;, fileSize); //filesize,上传文件内容 writeData.append(&apos;offset&apos;,start); //文件开始点 writeData.append(&apos;debug&apos;, true); writeData.append(&apos;file&apos;, uploadFile); //文件内容 console.log(start, fileSize, uploadSize); $.ajax(&#123; url: DATRIX_URL+DATRIX_WRITE_URI, type: &quot;POST&quot;, dataType: &quot;json&quot;, data: writeData, processData: false, contentType: false, async : false, success : function(data) &#123; //console.log(data); uploadSize = uploadSize - fileSize; console.log(uploadSize); if (uploadSize*1 &gt; 0) &#123; fileWrite(uploadSize, objid, trueSize, file, end, back, fileId, fileText, type, button); return ; &#125; var finishData = &#123; objectid:back.objid, createuid:DATRIX_UID, userid:DATRIX_EXECUTE_ID, fileid:back.fileid, debug:true &#125; $.ajax(&#123; url: DATRIX_URL+DATRIX_FINISH_URI, type: &quot;POST&quot;, dataType: &quot;json&quot;, data: finishData, async : false, success : function() &#123; $(&apos;#&apos;+button).removeAttr(&apos;disabled&apos;); if (pro == 1) &#123; var f = &#123;&apos;fname&apos;:back.filename,&apos;fid&apos;:back.fileid, &apos;objectid&apos;:back.objid&#125;; uploadContractFile.push(f); console.log(uploadContractFile); &#125; else &#123; if (fileId) &#123; var file_id = $(&apos;#&apos; + fileId).val(); var upload_text = $(&apos;#&apos; + fileText).val() || &apos;&apos;; if (!file_id) &#123; file_id = back.fileid + &apos;,&apos; + back.filename; $(&apos;#&apos; + fileId).val(file_id); &#125; else &#123; file_id = file_id + &apos;,&apos; + back.fileid + &apos;,&apos; + back.filename; $(&apos;#&apos; + fileId).val(file_id); &#125; if (!upload_text) &#123; upload_text = back.filename; $(&apos;#&apos; + fileText).val(upload_text); &#125; else &#123; upload_text = upload_text + &apos; , &apos; + back.filename; $(&apos;#&apos; + fileText).val(upload_text); &#125; &#125; else &#123; var upload_text = $(fileText).find(&apos;.upload_text&apos;).val() || &apos;&apos;; var html = &apos;&lt;a href=&quot;javascript:;&quot; class=&quot;primary-link preview&quot; data-filename=&quot;&apos;+back.filename+&apos;&quot; data-fileid=&quot;&apos;+back.fileid+&apos;&quot; data-objid=&quot;&apos;+back.objid+&apos;&quot;&gt; &apos;+ back.filename +&apos; &lt;/a&gt;&apos;; $(fileText).find(&apos;.file_preview&apos;).append(html); if (!upload_text) &#123; upload_text = back.filename; $(fileText).find(&apos;.upload_text&apos;).val(upload_text); &#125; else &#123; upload_text = upload_text + &apos; , &apos; + back.filename; $(fileText).find(&apos;.upload_text&apos;).val(upload_text); &#125; &#125; Model.addupload(&#123; fileid: back.fileid, filename: back.filename, type: type, objectid: back.objid &#125;, function (res) &#123; if (res.code === CODE_SUCCESS) &#123; &#125; else if (res.code === CODE_ERROR) &#123; showAlert(res.msg, &apos;danger&apos;); &#125; &#125;) &#125; &#125;, error: function() &#123; showAlert(&apos;上传失败&apos;, &apos;danger&apos;); &#125; &#125;) &#125;, error : function() &#123; showAlert(&apos;上传失败&apos;, &apos;danger&apos;); &#125; &#125;)&#125; 没维护了，以后接着看吧。 php 文件处理，主要包括文件的分割和合并 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function file_split($file,$block_size= 2 * 1024 * 1024)&#123; $block_info=[]; $size=filesize($file); $i=0; while($size&gt;0)&#123; $block_info[]= [ &apos;size&apos;=&gt;($size&gt;=$block_size?$block_size:$size), &apos;file&apos;=&gt;$file.&apos;.&apos;.$i++ ]; $size-=$block_size; &#125; $fp = fopen($file,&quot;rb&quot;); foreach ($block_info as $bi) &#123; $handle = fopen($bi[&apos;file&apos;],&quot;wb&quot;); fwrite($handle,fread($fp,$bi[&apos;size&apos;])); fclose($handle); unset($handle); &#125; fclose ($fp); unset($fp); &#125; function file_combine($file,$save_file=&apos;&apos;)&#123; $filename=basename($file); $filepath=dirname($file).&apos;/&apos;; $block_info=array(); for($i=0;;$i++)&#123; if(file_exists($file.&apos;.&apos;.$i) &amp;&amp; filesize($file.&apos;.&apos;.$i)&gt;0)&#123; $block_info[]=$file.&apos;.&apos;.$i; &#125;else&#123; break; &#125; &#125; if($save_file)&#123; $fp = fopen($save_file,&quot;wb&quot;); &#125;else&#123; $fp = fopen($file,&quot;wb&quot;); &#125; foreach ($block_info as $block_file) &#123; $handle = fopen($block_file,&quot;rb&quot;); fwrite($fp,fread($handle,filesize($block_file))); fclose($handle); unset($handle); &#125; fclose ($fp); unset($fp); &#125; php上传大文件有种就是先用php进行文件分割成小文件，然后小文件上传，然后上传到服务器上进行大文件合并。但有个问题就是php读取文件的fopen就8192字节，也就是8192B，一般上传文件都是4mb的上传，所以用的linux split分割文件后，放入文件夹里面，然后遍历文件夹，读取内容，写入操作的时候传入同一个objectid，往同一个文件里面写入]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP5 学习笔记]]></title>
    <url>%2F2018%2F01%2F24%2FThinkPHP5-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于TP5框架的学习。之所以写这个，是因为平时公司里面不用tp，工作快一年了，最深的印象就是不用的东西忘记很快，即使是你以前很熟练的东西，更别说以前就没有太懂的东西了，仿佛从来没了解过一样。自己对于一个框架的学习体验： 关于面向对象。 学习tp和我们公司的框架最大的比较就是，面向对象。在tp中使用别的类，不管是new class,还是class::function这种静态方法的调用，都得引入命名空间， use app\controller 这种，app对应tp的application目录。 think对应 think\下面内容，注意使用的时候要用到把类的名字也加上use xx,但是定义的时候 namespace 只是到文件夹，这个虽然很常识，但对于面向对象的新手来说还是很容易忽视的。 还有如果不引入命名空间的话，直接使用的话还需要在，use 后面的那个命名空间前面加 \。 tp有个Exception , php自身也有个Exception，在使用tp的exception的时候，注意一定要引入think 的exception 类，如果想要使用自身的exception，注意，\Exception, 否则会出错的。 老师的教程中，controller里面的banner类，名字是banner,model里面的banner类也是banner,，这样在引入banner的时候虽然好区分，但是使用的时候比如实例化的时候都是 new Banner,这样去分不开来，可以在引入的时候 使用 as进行重命名。 关于属性访问权限还记得当初学java面向对象的时候最开始部分吗，所哟的属性都定义成protected，不能被外部访问，但有个统一的方法能调用，获取属性值，这个在tp中也遇到好几次，属性不能访问，但有方法可以调用，获取这个属性值。 入口文件。像我们itbasic的host里面的router文件，tp public里面的index文件，只是tp里面把路由单独分离出去了，在应用application下面的router.php。这个文件是web server的访问入口文件。一般像apache里面的虚拟域名的配置（像router.php这种不是index开头的，还要作更多的rewrite规则的配置），nginx因为用fpm进行管理，所以还会location ~.php 之类的做更多的配置。 router路由文件。作为一个初学者，现在还不用知道router里面是怎么写的，怎么具体工作的，我们要学会的是怎么使用它，怎么让他根据url请求路径找到特定的控制器。比如我们itbasic的klein ,1$response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); 对返回的信息头部进行配置，可以跨域访问。这个$response变量是什么东西呢，是klein对于请求的接口的回调函数里面传入的参数，有request和response，属于依赖注入的内容。tp里面关于route:默认是pathinfo模式域名=&gt;根目录 入口文件=&gt;index.php 模块 index 控制器 index 方法 index 这种，很多时候这种pathinfo模式是不被nginx是别的，可以使用兼容模式，但现在兼容模式使用的也很少了，在这个restful api 的时代，所以大部分时候都是我们自己定义。需要注意的点：1.默认url是大小写不区分的，所以方法名里面的驼峰法，第二个大写字母和前一个单词之间应该用_连接。（这个修改url的大小写可以在conf.php里面修改）。2.conf.php里面有两个参数url_route_on url_route_must 两个参数和route的开启有关，用默认的就可以了，在router.php进行配置就能通过这种方式访问控制器了：12Route::rule(&apos;hello&apos;， &apos;index/index/hello&apos;, &apos;post|get&apos;, [&apos;https&apos;=&gt;true])Route::get(&apos;banner/[:id]&apos;, &apos;index/v1.index/banner) 其实重写route还有别的方式，只是这种方式比较简单。引入think 的route 类，静态方法get是rule，访问类型是get方式的简写，[:id], 代表id可以有也可以没有， id是后面可以访问到的变量的名称，这个里面还可以对访问url进行更多的限制，比如http请求，具体的可以参考手册。3.获取变量1.最简单的获取变量的方式就是在函数的参数（）里面写上参数名称，比如$id,$name,函数会根据参数名称获取传过来的参数，注意这块是参数名称，并不是参数的顺序，像我们平时调用函数的时候，定义的函数，参数只是语义化，根据顺序来确定传入的参数是哪个对应哪个，我们要区分开。2.通过think的request类，实例化，调用静态方法::instance,-&gt;get()···获取对应的参数，注意这块get不能获取到[:id] 这个id参数的值，这个id需要rule() 这个方法，还有如果[:id], 后面 ？id = 也定义了id，这样的话，前面的id不会被后面覆盖。3.依赖注入123public function get(Request $req) &#123; $req-&gt;param&#125; 这个param方法上面那个也可以使用。param获取任意方式传递过来的变量，params获取所有传入变量，放到一个数组里面4.助手函数，input(‘get.’) 获取get方式传过来的所有变量，点号后面跟着参数名，可以获取对应的参数 推荐依赖注入吧。 参数验证tp有个validate类，是专门用来验证参数的，老师的课程里面专门把拿出来，作为和c m 同一级别的验证层，我感觉没有太大必要，其实tp自带的验证已经够用了，他只是在原有的基础上把check验证方法整合进去了，然后定义了更多自己的校验方法。如果按照他的关联，同一个验证器类的名字只是体现了一种变量的验证规则，但是rule里面却是传入了多个变量，感觉也不合理。1234567891011121314151617181920212223242526class baseValidate extends validate &#123; protected $rule = [ &apos;id&apos;=&gt;&apos;must | max 1&apos;, &apos;num&apos;=&gt;&apos;in: 1,2,3 | idMustInt&apos; ]; //这里面可以定义传入的参数 //自定义验证规则 public function idMustInt($id)&#123; if (is_int($id) &amp;&amp; ($id*1+0)&gt;0) &#123; return true; &#125; else &#123; return &apos;id 必须是整数&apos;; &#125; &#125; //自定义验证方法public function goCheck(Request $req)&#123; //接收参数 $params = $req-&gt;params(); if ($this-&gt;batch()-&gt;check($prams)) &#123; &#125; else &#123; throw new paramsErrorException( [&apos;errorMsg&apos;=&gt;$this-&gt;error]); &#125;&#125;&#125; 因为这种参数验证错误，都应该归到http 400 errorCode 也是统一的，唯一不同的errorMsg, 验证错误的返回信息可以通过validate的error属性来获取。 Exception半吊子入门的编程人员，这一年的工作其实代码也不规范，刚开始看的别人的代码也不规范，加上天生不聪明，后天不努力，导致现在的代码也不规范。很少用到Exception。异常处理，是php中原生就有，一般在连接数据库的时候使用。 12345try &#123; 可能出现异常的代码&#125; catch （Exception $e）&#123; 处理方法&#125; 其中$e 也会有一些可以使用的方法，比如errorMsg,不太记得了，不同的扩展里面可能有不同，比如pdo里面有PDOException, phpmailer里面有他自己定义的mailer Exception。（这个exception是类名称哦，所以首字母要大写）tp5的exception很强大，可以捕获所有程序中运行的错误，并抛出异常。如果是我们平时，我们必须要在try {} 代码块中出现错误，才会抛出异常，然后捕获处理。tp5中如果我们出现了错误，会直接在错误页面出现什么Exception之类的，之前还是很好奇为啥每次出错之后和我们项目中不一样，这其实是tp5的异常机制产生的。对于try catch 捕获的异常，我们可以在catch（） 参数里面定义异常类型，或者是在catch 代码块里面重新再抛出异常或者直接写上异常的处理方法。和前面的验证一样，我们面向切面编程，把validate 异常处理这种可以统一进行处理的方法封装起来。这样就不用再每个接口中写参数验证和异常处理，这样就能让接口显得很简单。比如验证123456$validate = new BaseValidate(&apos; [ &apos;id&apos;=&gt;&apos;require|idMustInt&apos; ]&apos;)$validate-&gt;goCheck(); 所有的细节都封装到了验证层的内部； 相比较于验证，不同的验证返回的参数应该不一样，so，我们得定义不同的exception12345678910111213141516171819public ParamErrorException extends Exception($param)&#123; public $http = 400; public $errorCode = 100000; public $errMsg = &apos;参数错误&apos;; public function __construct($param)&#123; if (!is_array($data)) &#123; return ; &#125; if (array_key_exists(&apos;httpCode&apos;, $data)) &#123; $this-&gt;httpCode = $data[&apos;httpCode&apos;]; &#125; if (array_key_exists(&apos;errCode&apos;, $data)) &#123; $this-&gt;httpCode = $data[&apos;errCode&apos;]; &#125; if (array_key_exists(&apos;errMsg&apos;, $data))&#123; $this-&gt;errMsg = $data[&apos;errMsg&apos;]; &#125; &#125;&#125; 这个初始化方法是为了某些不像传入很多参数的时候使用的。 话说之前总想着函数时候能以数组作为参数···有时候还加双引号，真的笨。 接下来是统一的处理方法。首先在conf.php里面要配置exception_handle 里面写上异常处理类的位置123456789101112131415161718192021222324252627282930313233class ExampleHandle extends Handle&#123; private $httpCode; private $errCode; private $errMsg; public function render(Exception $e) &#123; if ($e instanceof BasicEception) &#123; $this-&gt;httpCode = $e-&gt;httpCode; $this-&gt;errCode = $e-&gt;errCode; $this-&gt;errMsg = $e-&gt;errMsg; &#125; else &#123; if (config(&apos;app_debug&apos;) == &apos;false&apos;) &#123; return parent::render($e); &#125; else &#123; $this-&gt;httpCode = 500; $this-&gt;errCode = 999; $this-&gt;errMsg = &apos;服务器内部错误不想告诉你&apos;; $this-&gt;recordLog($e-&gt;getMessage()); //服务器错误信息记录了日志 &#125; &#125; return json([&apos;errCode&apos; =&gt; $this-&gt;errCode, &apos;errMsg&apos; =&gt; $this-&gt;errMsg, &apos;request_url&apos; =&gt; Request::instance()-&gt;url()], $this-&gt;httpCode); &#125; public function recordLog($content) &#123; Log::init([ &apos;type&apos; =&gt; &apos;file&apos;, // 日志保存目录 &apos;path&apos; =&gt; LOG_PATH, // 日志记录级别 &apos;level&apos; =&gt; [&apos;error&apos;],]); Log::record($content, &apos;error&apos;); &#125;&#125; 首先是自定义的异常，不用记录日志 服务器抛出的异常，线下环境，直接调用parent::render($e), render方法是异常处理类对类的处理3.线上环境，返回json数据，记录日志。 conf.php 开启了自动记录日志，把日志那块的type 从file改成test，···就能不记录日志。log_path 重新再入口文件出定义就能使用自己的了，level代表日志级别。记得之前的日志记录功能因为关闭了，所以新的日志记录使用的时候要开始初始化。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>ThinkPHP5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStorm开启断点调试]]></title>
    <url>%2F2018%2F01%2F22%2FPHPStorm%E5%BC%80%E5%90%AF%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[关于xdebug。作为一个phper，相信大家平时的调试用的都是var_dump,echo之类的，像我之前不知道var_dump可以打印出多个变量，在写代码的时候，经常为了打印多个变量，要写很多var_dump,后来无意间解除了xdebug，虽然现在还是经常用var_dump,但我感觉这类的辅助工具都是为了更好的，更高效率的完成工作，得变通，什么方便，什么自己用的舒服就用什么。平时的我感觉xdebug对于框架的学习，和自己平时不熟悉的代码的时候用的方便，var_dump,我一般用来进行简单的调试。1.原理没去看了 2.安装首先得安装xdebug的php扩展。这个xdebug的安装真的方便，他的网站上对xdbug的安装简直是傻瓜式，百度他的网站，http://xdebug.org/wizard.php，把你的pathinfo() 的内容粘贴过去，她能自动帮你选择扩展版本，其实window下要的就是之前文章里面提的四个版本，以及php的扩展存放路径，已经php.ini, linux下好文件，同之前的文章一下。安装完成之后pathinfo，查找xdebug。这里注意下我们通过xampp这类软件安装的lamp其实不是lamp，这个l linux根本不存在，我们用的是w，windows。 具体的版本选择可以看这篇文章 帮xdebug选择合适的安装版本 3.phpstorm的配置之前的配置在网上找吧，因为懒得截图了简书上的这篇文章对安装方法写的很详细 4.注意事项 首先是关于断点的位置。代码会在断点之前结束，所以如果想要获取断点处的内容，务必在该内容之后打上断点。记得老师在将课程的时候甚至在这个方法结束处的 } 打了断点。 之前遇到的一个问题就是多个断点，只是执行了其中的几个断点，并没有执行完所有的断点，以为是使用的方法不对。后来发现其实是两个断点之间的代码又bug，导致后面的端点没有执行，··所以其实还是自身的问题。 断点调试的时候，所以的端点前面会有 √ 的标志，断点执行的那行代码会有颜色加深的标志。断点执行完，所有的 √ 的标志会没有。只要断点执行完了，接口才会有输出，并不是执行到哪个断点，哪个端点前面会有 √的标志。 代码可以一行一行的执行，也可以从这个断点直接跳转到下个断点，这样的好处是，对于复杂的框架可以知道代码是怎么执行的，然后断点间的跳转也可以迅速定位解决问题。但好像不同php文件断点间跳转，只有一个页面那个地方会对变量有输出。 变量的输出在下面那个debug tab标签处，开启断点调试，会在页面的url路径后面有xdebug_session 标志，把这个标志粘贴到不同的url，就能对不同的api进行测试，其实感觉这个就像一个接口一样，只要传递这个参数，就能执行这个debug接口的服务功能。 断点调试的关闭，··关闭那个phpstrom上方的类似电话的监听按钮肯定能关闭的，现在想了下，关闭下方tab肯定也是可以的，记得我每次close tab 他都会提醒是否close connect，断点调试的开始按钮是phpstorm的那个小瓢虫的标志。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
        <tag>工具</tag>
        <tag>调试</tag>
        <tag>Xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lamp 源码编译]]></title>
    <url>%2F2018%2F01%2F19%2Flamp-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[lamp的源码编译安装。！！！注意哦，这里面是lamp，不是lnmp。之前的lamp中，apache和php的交流主要是apache把php作为自身的一个模块，而ngixn是通过cgi，php-fpm进行管理进程（这段话有待考证，因为apache也能使用php-fpm进行管理，并不是php-fpm和apache绑定的。我们那个lamp环境搭建的时候安装好apache,编译php 的时候要指定apxs的位置，–with-apxs2=/app/httpd24/bin/apxs ,这之间的交互过程还不是特别清楚）。 所以lamp的编译安装是有顺序的，因为php在编译的过程中需要指定apache的apxs模块位置。 apahce 的编译安装apache2.4之后编译安装之前需要apr和apr-util的支持（这两个文件下载位置，百度，好像在apr.apache.org下面，首页上面只是展示最新的，注意有个archive.download.sit,点击他，你会发现新世界的大门）apache在httpd.apache.org下面下载（讲道理我不知道他们之间的搭配有没有版本限制，so 下载的时候都下载最新的？比较靠谱的办法就是网上再找一份教程上面有apr apr-util apache的版本，对照着做就好啦··我的文章只是自己的思路呢）。 12345[root@localhost src]#pwd/usr/local/src[root@localhost src]#tar zxvf apr-1.6.2.tar.gz [root@localhost src]#tar zxvf apr-util-1.6.0.tar.gz [root@localhost src]#tar zxvf httpd-2.4.27.tar.bz2 安装apr-util之前得先安装apr，因为需要配置 （–prefix==/usr/local/apr），上面的三个编译安装或者 说所有linux的软件编译安装都是一个套路 : 1.进入解压目录，./configure 配置参数，百度吧 2.make 3.make install 4.查看 需要注意的就是可能安装的时候要安装额外的包，其实刚开始没安装也没什么大事情，后面编译肯定通过不了，所以就百度，一下子就能出来答案。 还有就是 configure 文件不存在，怎么办？一般目前我遇到这种情况主要是在编译安装php扩展的时候，可以通过 phpize(这个命令在php安装生成的bin目录下的一个指令),运行后会生成configure脚本，然后再像上面一样执行 参考文章：centos7 源码编译httpd7其实这一块都不用lamp中安装apache和单独安转apache没啥区别。 notice : （而且后来发现一个问题 apachectl start 这些用不了，应该是按照上篇博客中安装出现的问题，其实还是要解决下，因为在lamp中，刚开始修改php.ini 是很常见的，每次修改都需要apachectl restart 一下还是很方便的) ​httpd -k start 这戏好用 ​其实ps -ef|grep httpd ,也能看到这个httpd 的命令 把apachectl 添加到环境变量中，我一般通过的方法是 1234567vim /etc/profile HTTP=/usr/local/apache/bin$PATH=$HTTP:$PATHexport $PATH需要注意的是我们在使用变量的时候会从前往后找的，比如http 和 path 中都有 apachectl,但是http 在最前面，会使用前面的http中的apachectl, 通过 which apachectl可以查看这条命令来自哪里（yum安装的软件可能把命令自动加到/usr/bin 里面去，卸载的时候也删除不掉，这个很坑爹，需要注意下，经常用的时候不是你想用那条命令，所以一直加在前面可能会避免一些这样的事情发生）source /etc/profile 让他生效echo $PATH 看是否包含了你需要的路径 我在正常启动apache 之后，外网总是访问不了，通过查看配置文件的日志 access_log 是空的，error_log中有内容，但其实是notice 级别的错误，一直以为是这个原因导致外网不能访问，百度了好久这个错误信息，都没有找到解决办法，问同事，演变成apache正常启动，外网访问不了的问题，先通过curl 127.0.0.1:80 来尝试访问，得到内容， it works 说明服务器没有问题，想到防火墙，看了下服务没有开启，想了下selinux 也没有开启，最后是阿里云的锅，zzz,其实问题很简单，解决过程也很简单，只是自己很笨，不知道怎么去排查问题 虚拟主机的配置，测试外网是否能访问，需要修改配置文件，需要注意的点 开启httpd-vhost,需要包含，然后再那个配置文件中写入 开启apache rewrite模块 开启端口监听，Listen 0.0.0.0:8080，注意0.0.0.0 默认查找Index.php，除了在虚拟主机的virtual host 中配置，在外层的配置文件中也要配置 开启php文件处理，主配置文件中修改， 这时候在apache的根目录下访问phpinfo这种文件还是不幸的，需要支持对php的mime类型解析，（想了下框架不能处理json输入是因为框架原因，还是web server原因）1AddType application/x-httpd-php .php ​ mysql 编译安装失败，用的yum安装（直接下载编译好的二进制码比较好，比如subline下载之后直接就能使用，不用安装，这些java写的东西啊，好用，但是mysql不行，即使是编译过的二进制码，还要执行一些脚本） postgresql 的编译安装（网上的教程很详细）这个下载速度很快，可以考虑源码安装 有两个配置文件，一个用来进行用户权限的限制，一个好像是具体的配置 有两个目录，一个专门装数据，一个装软件，比如命令这些 默认root 访问不了，创建postgres用户和组（源码编译，yum的话自动创建），修改配置文件trust pg_config 这个命令很重要，安装中文搜索引擎，先安装scw库文件，再去安装zhaper这个分词，多个pgsql 一定要指定pg_config（好像指定不起作用,一定要把pg_config 直接运行的这个命令对应的pgsql 对上你想要装扩展的pgsql,要不然在数据库里面创建扩展会不成功 create extension ） 可以通过sql语句查询配置文件的位置（locate 不知道为啥找不到/mnt 下的文件，坑死我了） php编译安装 php.net 上下载源文件 安装额外的包1yum install libxml2-devel bzip2-devel libmcrypt-devel 3.编译安装php7123456789101112131415161718192021222324[root@localhost php-7.1.10]#./configure \&gt; --prefix=/app/php \&gt; --enable-mysqlnd \&gt; --with-mysqli=mysqlnd \&gt; --with-openssl \&gt; --with-pdo-mysql=mysqlnd \&gt; --enable-mbstring \&gt; --with-freetype-dir \&gt; --with-jpeg-dir \&gt; --with-png-dir \&gt; --with-zlib \&gt; --with-libxml-dir=/usr \&gt; --enable-xml \&gt; --enable-sockets \&gt; --with-apxs2=/app/httpd24/bin/apxs \&gt; --with-mcrypt \&gt; --with-config-file-path=/etc \&gt; --with-config-file-scan-dir=/etc/php.d \&gt; --enable-maintainer-zts \&gt; --disable-fileinfo# 进行编译安装[root@localhost php-7.1.10]#make -j 2 &amp;&amp; make install 注意那个with-apxs2 的选项下面那个 make -j 2 指的是用两个cpu进行编译 注意这时候时没有配置文件的，到解压的php文件夹下1[root@localhost php-7.1.10]#cp php.ini-production /etc/php.ini notice 编译php7的时候with-config-file-path 指定了配置文件的位置,这个是很重要的，因为要不然我们没有指定也没有放在默认的php文件存放位置，以后每次运行php 的时候都要指定 配置配置文件的位置很麻烦 测试phpinfo， 看到了local value 还有另一行没，之前看过好像一个是apache 中指定的位置，但是本地可以通过脚本修改，所以local value 是实际的位置 讲道理，上面的编译参数运行不了， –with-config-file-scan-dir=/etc/php.d \，感觉是这个参数在作怪，不太明白这个文件夹中装的啥，反正是开启了一些curl 等的扩展，但实际上好像没有开启，所以需要把屏蔽掉（上面的php 编译参数不太好用，像curl 都没有开启，在项目中用会出错） php 源码包的作用。像pgsql 这些扩展，源码包中都是有的，如果想开启，不用再网上下载，直接去源码包的ext 下面找就好了，然后phpize ```编译，修改php.ini, php -m 查看是否成功。需要注意的是，一个包编译失败之后，再次编译，最好make clean一下。（pgsql 和 pdo_pgsql 是两个扩展···） 关于错误信息的输出。php.ini 有不同的两个版本，development, product， 虽然我没有研究过他们的不同，但目前发现最基本的就是，开发版本会把错误信息输出在页面上，但是生产版本不会，是php.ini 中一个选项的原因，生产版本可以把错误信息输出到日志中保存，好像nginx fpm 那种比较复杂，lamp这种直接在apache 的错误日志中就可以找到。（多熟悉lnmp,最好完全切过来，熟悉swoole） redis 的安装需要注意的就是 redis 启动服务要手动指定配置文件， 遇到的问题就是估计之前别人在路径中加入过redis-server 这个命令，导致我用 redis-server /opt/redis/conf/redis.conf 不匹配，出错， 还有有个配置选项是是否展示cli 下 那个命令行redis图像，果断关闭，虽然不知道他为啥报错 改成守护进程模式 之前测试测试数据库总的出错···总结了下原因 不能清楚的认识到mysql怎么连接数据库的。其实换一种思路，php是怎么连接redis的，我们安装好redis服务，然后安装php的redis扩展，就可以了。什么连接函数啊和连接mysql是一样的。关于php连接mysql，现在主推两种方式，mysqli和pdo，分别对应两种扩展，具体的可以参考菜鸟教程里面的这个php连接mysql。 mysqli() 第一个参数’localhost’ 和’127.0.0.1’ 的区别，localhost 连接基于socket，这个文件的位置在php.ini有指定，如果换了位置，则找不到。127.0.0.1基于tcp，就可以啦，不用那个文件，参考链接segmentfaultmysql 这个status挺好用的哈哈]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>lamp</tag>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lnmp yum安装]]></title>
    <url>%2F2018%2F01%2F19%2Flnmp-yum%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[关于lnmp环境的yum安装。作为一个phper，肯定得熟悉。之前写过关于在windows下php环境的搭建··咳咳咳，其实那根本算是搭建，像xampp都是把环境搭配好了，自己只是做了配置虚拟主机，然后运行框架。框架在我的理解中本身除了yaf之类的安装，主流的框架tp，yii，laravel更像是一个文件夹，代码的集合体，这个文件夹中各个子文件夹联系紧密，成为一个整体。当外来请求通过lamp进入到入口文件，路由进入到控制器，模型层，数据库，变成一个有用的数据返回出来，再通过lamp返回给浏览器，上面的流程就很容易发现，简单的像apache,nginx里面的配置文件定义，只是让外来请求找到这个入口文件，进入到入口文件里面之后就靠框架的路由寻找具体的控制器了。lamp环境方便的让外来请求比如对于index.php的请求，如果是直接在linux中，我么需要php (编译器) 可能还需要 -c指定配置文件的位置 文件.php,这样。但是如果是lamp，我们可以通过浏览器直接访问这个php文件。 首先是yum源的安装，更新。 123[root@localhost ~]# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm[root@localhost ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm[root@localhost ~]# rpm -Uvh http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 先说这个mysql yum安装，现在要通过这个社区版。 然后剩下两个是为了安装第三方软件用的。这个epel以后可能经常用到，虽然没lamp好像只要这个webtatic就可以了。之前添加源的时候看过一篇文章，好像是说最好不要和官方源里面有内容冲突。这个epel很合适，大家都在用，当然自己也就用咯。 yum安装nginx，mysql，php123[root@localhost ~]# yum -y install nginx[root@localhost ~]# yum -y install mysql-community-server[root@localhost ~]# yum -y install php70w-devel php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-pdo.x86_64 php70w-mysqlnd php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo 其实这里面比如php7安装的那几个我也不懂，据说把70w改成71w就能装7.1版本了。 3.yum安装的一个好处是通过systemctl enable 能控制软件的开机启动 关闭，通过systemctl status 能看软件的状态，启动，关闭。默认安装的mysql没有密码，可以直接登录进去。据说要配置默认编码，utf8，但我好像没有配置，它自动就是utf8。12345[root@localhost ~]# vim /etc/my.cnf[mysqld]character_set_server=utf8init_connect=&apos;SET NAMES utf8&apos;[root@localhost ~]# systemctl restart mysqld # 重启 MySQL nginx的配置1234567891011121314location / &#123; #定义首页索引文件的名称 index index.php index.html index.htm; &#125;# PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.location ~ .php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 注意这块document root的位置，要卸载location外面，我之前写在上面那个location里面，下面那个location获取不到。 重启nginx，重启php-fpm. 测试是否成功。在nginx根目录下 &lt;?php echo phpinfo();die; 看能不能输出php信息咯。其实还可以检测下和mysql的连接。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>环境</tag>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php安装扩展]]></title>
    <url>%2F2018%2F01%2F18%2Fphp%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[好久没有写文章了，今天来说一下关于php的扩展，虽然自己理解的不是很深，也没有仔细去研究，只是把平时工作中遇到的情况，解决途径写下来，还有很多不足的地方，以后去补充 php的扩展大部分都是c编写的，php -m 可以列出我们php中安装的扩展 其中swoole就是现在很火的php扩展。以这个为例子Linux下安装 获取tar.gz压缩包（可以去github上直接下载，或者去pecl（php 扩展库里面搜索））。 解压缩 tar xvf 进入解压缩目录（如果进入解压缩目录内部文件是so结尾的，不是.c 之类的结尾的，不用进行后面的操作） phpize (这个命令在php的安装目录下，bin目录下，和php命令在一个目录下) ./configure 生成配置文件，之前安装swoole的时候需要指定php-config,这可不是php的配置文件，也是一个命令，和上面的php，phpize在同一个bin目录下，如果想看更多参数可以 –help, make make install (安装失败make clean，重新再来呗)8.生成的so文件自动放到了/usr/local/php/lib/php/extensions/no-debug-zts-20160303，然后在php.ini 文件里面加上一句extension = swoole.so就可以了 可能需要ldconfig下，http://man.linuxde.net/ldconfig windows下安装 大部分都是xampp的这种集成环境，首先去pecl上下载dll文件，··像swoole我是没找到windows下的扩展文件，需要根据php版本 vc版本 TS Windows版本（windows一般是x86 和64，操作系统位数） 来选择 扩展文件的版本 解压后，把dll文件放到php的扩展目录下ext下面，然后在php.ini里面加上zend_exten```= 这个扩展文件名。就可以了 之前安装redis扩展的时候，···当时用的是xampp，··然后安装好了redis扩展，可是使用不了。坑爹啊，window下我都没安装redis，光安装redis扩展有什么用，····其实这个扩展知识为了让php能操作redis，像apache，在编译安装php7的时候，也要指定apache的apxs之类的位置。 坑： 机器上安装了挺多php的，有5.6，有7，因为7编译安装的时候没有填写配置文件的位置，默认应该是放在/usr/local/lib目录下（php -r “phpinfo();”|grep configure, 注意一定要在phpinfo();后面加引号，查看编译安装参数，像apache，直接去安装目录下的build文件夹里面，查看就可以了），而我的机器上一直还有/etc/php/php.ini 这个配置文件，因为php安装的时候是不存在配置文件，讲道理编译的时候没有写配置文件的位置，应该放在/usr/local/lib目录下，但他还是放在了/etc/php/php.ini,聪明的apache自动去找到了这个配置文件，但当我在默认/usr/local/lib目录下放置了php.ini的时候，他是去这下面寻找的，以前的那个就废弃了。apache可以指定php配置文件，只需要在apache的配置文件里面指定下，地址：[http://www.jb51.net/article/106111.htm] php -m 的好处就在于不用重启服务器，就能看到已经加载的php模块，php -r “phpinfo();” 执行后面的函数返回结果。 php -c 指定配置文件的位置，注意 php -m -c 加载扩展的时候默认使用的是默认配置文件的位置，php -c 文件位置 -m 这里才是新的配置文件位置方式加载扩展。 遗留的问题： php -m显示出扩展swoole ， phpinfo 页面没有这个扩展]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见问题]]></title>
    <url>%2F2018%2F01%2F09%2FLinux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[因为linux平时用的不是很频繁，所以经常会遇见一些问题，然后很容易忘记，然后还经常遇到，所以记录下来。 目录： yum源替换 修改密码 locate 查找文件 添加环境变量 ~ 普通用户和root用户 1.yum源的替换我们每次安装centos的时候，如果不是打包安装，是从新安装的话，为了安装软件速度快点，我们通常会替换yum源，把国外的镜像替换成国内的yum源镜像。常用的有163，阿里云啊。首先我们进入 /etc/yum.repos.d 文件夹下面，查看repo文件，把centos-base 这个yum源文件改名，作为备份文件（mv,剪贴，又能当做重命名来用，注意不是复制哦）。然后wget，国内的yum源地址，yum clean all 清除缓存，yum makecache 在本地生成源的软件信息，方便软件的查找。总结： cd /etc/yum.repos.d 进入目录 mv centos-base.repo centos-base.repo.bak 备份文件 wget -nc http://mirrors.aliyun.com/repo/Centos-7.repo 下载原文 yum clean all 清除缓存 yum makecache 生成缓存 12345* 阿里yum源:[http://mirrors.aliyun.com/repo/](http://mirrors.aliyun.com/repo/)* 163(网易)yum源: [http://mirrors.163.com/.help/](http://mirrors.163.com/.help/)* 中科大的Linux安装镜像源：[http://centos.ustc.edu.cn/](http://centos.ustc.edu.cn/)* 搜狐的Linux安装镜像源：[http://mirrors.sohu.com/](http://mirrors.sohu.com/)* 北京首都在线科技：[http://mirrors.yun-idc.com/](http://mirrors.yun-idc.com/) 2.修改密码passwd 用户名 root用户，非root用户只能修改自己的密码哦，所以passwd后面不能加参数 3.locate查找文件 locate 命令的使用之前一直使用find / -name 文件名，太慢了，使用locate吧。首先yum install mlocate,然后updatedb ,就可以使用locate 文件名称。每次使用前locate 文件名称。（如果是安转好了，每次使用前只用updatedb,然后再locate 寻找就好了） 4.添加环境变量 lamp环境如果通过源码编译安装，安装的位置一般是/usr/local,命令一般在/usr/local/软件/bin/命令，每次使用起来这么一大串，是在麻烦，加入环境变量效果棒棒的 echo $PAHT 查看环境变量 编辑/etc/environment文件，在里面更改PATH环境变量。 例如：向环境变量中添加 /home/YRS/Nim/bin /usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/YRS/Nim/bin，保存后记得source /etc/environment 。重新启动后就不用source 。 ​ 5.普通用户的 ~代表家目录，比如/home/vagrant,但是root用户的这个~代表根目录 /home ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn Git 思考]]></title>
    <url>%2F2017%2F12%2F20%2Fsvn-Git-%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[···今天碰到一个问题，其实这个问题好久之前就没碰到了，只是之前可以通过别的方式化解，然后今天没法通过别的方式解决了，只能通过正确的方式解决。 问题描述：在线上修改了代码，怎么更新到本地。 直接通过小乌龟update，肯定不行。因为小乌龟是直接从svn服务器上更新内容，然而我是线上的代码修改了，而不是svn服务器上的文件修改了。 之前我们这个小项目提交代码到线上是这样的，本地修改后，用小乌龟提交，然后连接到服务器上，切换到网站根目录下，svn up，这样线上就能正常访问了。正是这个过程导致了我一个误区，我以为svn的工作流程是这样。 但其实他应该是这样 其实线上网站根目录下文件夹也是svn客户端服务的内容，他只是svn服务器大脑下的一个分支 之前的错误概念还有就是把线上服务器的内容等同于svn大脑的内容。举个例子，在实际的大项目中，代码整理后，要经过测试环境等等多重步骤才能发布，放到正常的生产环境中，如果我们直接把大脑合并的内容放到生产环境中，这样是太不合理了，这样感觉会导致线上的代码太不稳定了。 所以，正如第二个图中看到的一样，网站根目录也是从线上代码往下拉的，所以我们对线上代码的提交，就应该和我们平时提交代码一样，只是我们平时用小乌龟习惯了，可能已经忘记命令了，还有svn up是svn update的缩写，这个up并不是提交的意思哦（···误导我一年了）。 所以，我们在线上svn commit（svn ci）缩写，必备参数 -m(我原先以为svn不需要，肯定是小乌龟做了处理)。这样就能把代码更新到svn服务器上，然后别的同事svn up就可以了。 svn提交失败，经常需要clean up，可是呢，点击clean up的时候又会显示clean up失败，请clean up，无限死循环。可以进入当前目录的.svn目录下，用Navicat 打开那个wc.db文件（用Navicat打开，如何打开请百度 ），然后清空 work_queue和wc_lock就好了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>svn</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用教程]]></title>
    <url>%2F2017%2F12%2F15%2FGit%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[感觉有必要写一篇关于git的使用教程，其实像我现在根本用不到git，平时公司用的是svn，然后还是一个人做项目，对于版本控制工具那些处理冲突，回退基本用不到，对于修bug开新的分支，也是没有那个需求，因为一般的bug都比较简单，而且也没那么急。 之所以用git，主要还是因为github吧，上面优秀的代码太多了，（其实是不会写，主要用来下插件）关于git的教程有很多，本身基本的用法也不是很难，写这个文章主要是为了记录我平常的一些基本操作，因为有些东西不用了，就忘记了，然后重新查找，坑爹的Google，每次查找相同的东西总出来不同的结果，坑爹啊，又得重新看一遍，不如自己总结下。 因为自己平时不用git，所以对git很多用法理解的不是很深，只是为了基本的日常写下了这篇文章。 主要参考来源：廖雪峰的git教程 : https://www.liaoxuefeng.com 先来介绍一下市面上主要的两款版本控制工具svn和git，两者有什么差别呢，svn学名叫集中式版本控制工具，git叫分布式版本控制工具，我对他们之间的区别看待就是：git的操作步骤比svn要长，git在svn后面还有一步操作。svn必须联网才能操作，git没有网也能进行操作，这是一个很重要的点，想象一下，如果你在没网的环境下开发（这个可能概率不大，但感觉作家写作有很大可能）不能用用于提交，当你有网的时候才可以提交的时候，也许你的文章已经写了很多了，这个时候再提交，不管是版本回退，还是这次的修改量都会很巨大，就相当于我们在编程的时候写了一个很大的主函数，以后维护起来会很困难。（刚刚有看到了一点，因为我们公司的服务器就在我旁边，我们在同一个局域网内，所以不管是更新还是下载都会很快，但要是贵阳，云南那些朋友，更新代码，怪不得经常嫌弃慢，有时候还外网访问出问题，这样就更新不了代码了，gg，心疼二帅大周末要来公司修复网络）但是git却可以，git可以让你在没网的情况下进行提交，只是没有提交到远程服务器上，当你有网的时候再推送到服务器上，这很方便，感觉就是没有网的svn，git的冲突处理是出现在把代码远程push到代码仓库的这个联网阶段。为什么会出现这种情况呢，为什么svn叫集中式，而git叫分布式呢，我的理解就是svn的版本库在远程服务器上，其实git也在远程服务器上，只是他在本机也copy了一个版本库，所以可以理解成每个电脑都是一个版本库，所以有很多的版本库，所以git叫分布式版本控制系统。所以对于集中式版本控制系统，中央大脑坏了，版本控制工具就不能用，但是分布式中央大脑其实只是用来进行差异化的合并，他坏了，版本控制的功能还是能使用的。这其实是和断网是同一个场景，网断了，不能连接主大脑，svn不能使用，git还是能使用的。在说git之前推荐款git的可视化工具，小乌龟，不只是git，svn也有，很简单的配置加上点点点，就可以了（以前的我一直把小乌龟当做git和svn··坑爹啊，因为平时一直用小乌龟提交代码嘛，所以就把这个当做版本控制工具了，其实他是版本控制工具之上的可视化管理工具，有svn版，也有git版）算了，还是先介绍我平时用的比较多的东西吧1.首先呢，我是因为github才开始使用git的，git的安装直接百度就可以了，下载好git软件（感觉这是git客户端）2.下载好，然后和所有的windows软件一样，安装好后会生成一个git文件夹，里面有gitbash，这是个很方便的cmd工具哦，相比较window的dos，他支持很多linux的命令，cd啊，ll啊，特别是ssh，window是不支持的，（好像是git是基于ssh的，所以也支持ssh远程连接的啦）3.然后呢，在github上点击创建个项目，之后下面会出现这个项目地址啊，等等，我一般只是旺这个项目里面塞代码嘛，这个的传输的过程需要ssh的配合，通过命令生成ssh秘钥，把公钥贴在github上，这样就可以支持传输喽（生成的ssh秘钥在该用户.ssh文件下面）4.执行命令把远程仓库和本地的关联起来，分支什么的，在github上创建好仓库下面会有提示。5.去到本地项目下面，git init 初始化一个git仓库，然后git add 把该项目下面所有文件添加进去，然后git commit -m “” git的提交好像必须得附加信息，最后push（如果用小乌龟，点点点就可以了，其实也是这个三步，只是小乌龟的add好像得单个文件一一添加，反正第一次添加用git add ,后面再添加多个文件的数量的时候数量也不会很多，没什么关系） 我大致用的东西大概就这么多，其实在工作的过程中（针对我的svn使用经历，其实开个分支修bug，版本回退还是很重要的，只是因为我平时git用的比较少，所以很容易忘记现在） 下面的内容是看书得来的：git的好处（或者说是版本控制工具的好处）：感觉两点最能体验：1.协同合作同一个文件的时候，对同一个文件的修改，如何合并多个人员的异同。2.对于文件修改的历史，特别是基于同一个文件不同的差异较大的修改方向的时候，后来以什么文件为标准，怎么回退到以前的版本，怎么标识每次修改内容。 上述如果通过手动，那将是多么痛苦的过程。 番外：这两天安装composer啊，git都会提到brew，其实这是mac的一个包管理工具，感觉就像yam一样（安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/） 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 这个好像没有什么实际的作用，–global 代表所有的仓库都用这个，还可以给不同的仓库指定不同的name和邮箱。 git init 把一个文件夹变成git仓库，会发现该目录下多了一个.git 文件。 git只能记录纯文本文件的修改（因为文本是有编码格式的，还是用utf-8吧，通用啊）对于word，图片这种二进制文件，只能记录大小的变化，并不能知道文件哪块修改了，还有不要用记事本（window自带的那个东西写，会出现很多奇怪的东西，我现在系统好像默认的编辑器是subline） 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 小结 现在总结一下今天学的两点内容：初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步：第一步，使用命令git add ，注意，可反复多次使用，添加多个文件；第二步，使用命令git commit，完成。 git status 查看仓库当前状态，不管是没有add的，还是add之后没有commit的（相比较于小乌龟这种，修改之后如果之前add过，后面就不用再add了，但是命令行却还要，廖雪峰说因为add可以一次性加很多文件内容，commit只能一次····，所以才会分成两步） 都能通过git status看见，git diff 发现文章的不同（+代表新加的内容， - 代表减少的内容，一条语句的修改可以看做是先删除这个语句，再加上这个语句） 当工作目录是干净的时候，就代表没有东西被修改了。 git log 查看git 提交的历史 123456789101112131415161718$ git logcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 15:11:49 2013 +0800 append GPLcommit ea34578d5496d7dd233c827ed32a8cd576c5ee85Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Tue Aug 20 14:53:12 2013 +0800 add distributedcommit cb926e7ea50ad11b8f9e909c05226233bf755030Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Mon Aug 19 17:51:55 2013 +0800 wrote a readme file 最近一次提交是 信息是 append GPLcommit后面的id代表的是对这次提交的标记，记得以前用docker的时候对容器的标识也是用这样一大串很长的数字。 git reset –hard HEAD^ 回退一个版本 git reset –hard 3628164 会退到版本号是3628164···这个版本 版本回退很快，是因为git的版本控制通过的是指针指向的不同。 git reflog 记录每次操作，比如你回退了某个版本，现在后悔了，cmd也关闭了，可以通过git reflog找到版本号，这里面记录了你的每次操作。 123456789101112$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt## Untracked files:# (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)## LICENSE 没有加入仓库的文件是untracked,修改了未添加是not stage，都得git add 工作区：我们的工作目录。暂存区： add文件进来分支：git init的时候自动创建的，commit的内容都是天价到这个分支上来。 git的每次修改，如果不add到暂存区，commit的时候就不会提交。可以做一个实验：先修改一个文件-&gt;git add-&gt;再修改-&gt;git commit 查看会发现第二次修改没有提交。 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时（git add），想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时(git commit)，想要撤销本次提交，不过前提是没有推送到远程库,git reset –hard HEAD^。 感觉现在学习git，不想想着远程仓库推送的那个环节，那个环节其实就是合并冲突用的，和版本控制无关，git commit之后就会产生版本号。 删除版本库里面的软件：一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit。（和给版本库添加文件类似）。 在github上创建一个远程仓库，然后本地关联，这个教程太多太多，百度知道上都有，就不写了。 关联远程仓库：git remote add origin git@github.com:michaelliao/learngit.git （orgin是远程仓库的名称） git push -u origin master 关联本地master分支和远程master分支（之后的推送就只要git push origin master） 我平时都是使用git的流程都是现在本地剑豪文件夹，然后推送到远程。 还有种是在从远程clone文件，创建仓库的时候勾选初始化，会新建一个md文件，然后git clone git支持多种协议，除了ssh，还有https，但ssh更快，除非一些公司不开放ssh端口，那只有用ssh了（注意前面名称还是git）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>版本控制工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant使用]]></title>
    <url>%2F2017%2F12%2F13%2Fvagrant%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用vagrant的原因？ 其实主要是因为来公司的时候用的这个东西，相比于传统的xampp这种window下的一体化工具，vagrant其实是在vitrual box 之上的一种管理工具，他是基于虚拟机的，所以你可以在虚拟机上干的事他都能干。 首先xampp是window平台下的，他的lamp这个l不具备，所以，你xampp永远都接触不到linux，但是vagrant不同，他是基于虚拟机的，虚拟机可以装linux，所以使用vagrant，你可以使用linux。 使用vagrant首先得加载镜像，这个镜像就相当于最原始的环境，他是个box文件，想象一下，如果这个镜像是你们生产环境的打包，那你是不是就不用做别的处理就可以直接使用了，节省了新人安装环境的成本。 其实vagrant 构建开发环境分为两大部分，第一部分是加载镜像，这主要和box有关， so,先来介绍几个关于vagrant box 的相关命令 vagrant box add (镜像名自定义) 文件路径 （建议下载到本地，vagrant cloud 上面的文件下载很慢） vagrant box add（命名空间/文件名） 其实这样也是可以的，只是很慢 这样下载的文件放在了windows 用户 目录下面的 .vagrant 下面的box文件里面 这个可以修改的 setx VAGRANT_HOME = “” 路径名 /M 就可以了,/M代表整个系统都修改了 set 环境变量名 这样得到环境变量的值 set 环境变量= 这样是删除环境变量 vagrant box remove （box名称） 这样是删除box文件 vagrant box list 展示有哪些box文件 这样把远端或者是本地的box文件加载到系统中，如果是下载的.box文件就可以删除啦 镜像加载完成啦，接下来干嘛呢，就是在这个镜像的基础上构建虚拟环境，我们得用到vagrant的相关命令。 然后呢，新建个文件夹，建议vitrual，代表虚拟环境，再在下面新建单个项目的文件夹，这样的好处是vagrant虚拟环境不容易到处都有 进入对应文件夹（后面的这些vagrant操作命令都是在这个文件夹中进行的） vagrant init （add的box文件名） 初始化，会生成vagrant file 文件，修改其中的 config.vm.box = “new_itbasic” 这个代表box的名称 config.vm.network “private_network”, ip: “192.168.33.10” 私有网络只能自己通讯，相当于虚拟机里面的桥接，不能和局域网中的别的电脑通信（这个ip地址有要求吗） public 相当于net，可以和局域网中其他通信，记得得是局域网中同一个网段哦 config.vm.synced_folder “D:\code\yaf_api”, “/home/itbasic” 设置共享文件夹，配置文件中这上面是两个\\应该是为了转义 config.vm.boot_timeout = 100 config.ssh.username = “root” config.ssh.password = “root” 这个是为了直接可以远程连接虚拟机 配置好后，vagrant up 第一次好像都是用这个，重新加载配置文件了，其实点开vitrual box，会发现自动创建个虚拟机，然后 不用的时候挂起 vagrant suspend，再启动 vagrant resume vagrant halt 是关闭，vagrant reload 重新加载配置文件 vagrant status 查看虚拟机状态 vagrant package - -output itbasic.box 去自己的vitrual环境下，打包自己的环境成box文件，方便以后使用（好像vagrant 打包环境最好把虚拟机关掉，省略后面 - - output itbasic.box 默认生成package.box） vagrant destroy 摧毁虚拟机镜像，这个是保存位置是第三个位置了，这个是由vitrual box决定的，在vitrual box的全局设定里面。 几个坑 vagrant box 可能就2.5g，可是新建的虚拟机可能要10g，这就是我之前环境一直错误，以为是虚拟机的错误之类的，其实报错信息很明显，是我的磁盘空间不足，这里不是指虚拟环境vagrant up的那个文件夹，而是c盘装的virtual box 装的虚拟环境的文件夹。 新导入的虚拟机，可能没有mac地址，需要在网卡配置里面加入对应的mac地址，通过tail -f /var/logs/message 查看启动错误日志，看启动了哪些网卡，把不用的网卡onboot = no就好了，然后再systemctl start network,还可以systemctl stop networkmanger, systemctl disabled networkmanger, 这些不用的东西。 关掉网卡之后可能ssh有问题。config.ssh.host=”192.168.33.10” config.ssh.port=”22” config.ssh.username=”root” config.ssh.password=”root” 把ssh先配置好，要不然改了网卡之后可能连接不上。config.vm.boot_timeout=100 配置好超时时间，这样就不用一直等了。 总结一下：vagrant构建环境其实一共有4个文件夹的位置 vagrant box的文件位置，box add镜像之后，.box文件就可以不要了（如果以后要用，可以直接打包生成） vagrant 的虚拟环境，生成vagrant file 配置文件的目录 基于box生成的供vitrual box 使用的镜像存储目录 共享文件夹目录（用于写代码的目录） 上面的1，3两个大文件默认都是在c盘，坑爹啊，结果我的c盘越来越小 最近遇到的问题： 1.Homestead 需要的vagrant是2.1版本，我那个是1.9，为了升级，我直接卸载了vagrant，然后装了新的vagrant，奇迹就是 vagrant box list 的时候之前的数据还在，zz，看了下文档，vagrant分为程序部分卸载和数据部分卸载，我们单单通过windows卸载的是程序部分， 如果我们删除了用户下.vagrant，那之前的数据才会丢失 2.关于vagrant init 只是通过一个镜像文件生成一个vagrant file 文件，我们在使用homestead的时候，没有使用vagrant init ,直接是vagrant up，这样也是可以的，因为针对这个box的配置文件之前就已经存在了，homestead 中配置文件的名称是homestead.yaml 3.vagrant的那些镜像应该都有个默认用户 vagrant vagrant，虽然这个用户的权利也不是很大，但是我们能通过sudo 完成我们的绝大多数操作 4.之前那些suspend 的项目需要halt，然后up，如果直接resume 会有奇怪的问题]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vagrant</tag>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https通信原理]]></title>
    <url>%2F2017%2F12%2F02%2Fhttps%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考：https://segmentfault.com/a/1190000012196642作为一个web开发者，对于https和http肯定要有所了解，现在的我对于深层次的https通信看着还不是太懂，但是对于https和http的差别，记得有一次去中科招商的时候面试有问到过。写这篇文章的时候，主要是方便自己看的时候理解。 首先呢 https默认端口号是443，http是80，都知道http相比于http更加安全。但是安全主要在什么方面呢，http通过明文传输，post方式好像看不见，但是get方式可以通过在服务器上监听这个端口，就能看见甚至都不要解密传进来的数据。像之前的talent，远程连接（默认端口23），因为传输过程明文，而且远程连接主要就是用来远程登录，肯定要输入用户名和密码，so，通过对这个端口的监听，就能知道用户通过talent服务的这个端口传进来的用户名和密码，这个安全性的要求不言而喻，所以现在都不用了，现在用ssh。还记得每次连接服务器的时候，让你接受公钥的弹窗嘛，这是为了在传输过程中用服务器的公钥进行加密，然后数据到达服务器端，服务器可以通过私钥进行解密。之前看过一个很形象的比喻。公钥就相当于锁，私钥就相当于钥匙，我这个东西用锁锁起来了，当然就可以用钥匙打开了（这是公钥加密，私钥解密的比喻） https和http都是基于tcp/ip 协议，属于应用层，他们其实是一样的，只是https外层有个ssl包裹起来 其实本质上还是属于http协议。 https在传输过程中使用了加密，有对称加密和非对称加密。 对称加密就是在加密和加密过程中使用同一个密钥，但是这样有个不安全点就是，密钥需要进行传递，传递过程中，如果密钥被捕获了，那加密如同虚设，so，就产生了我们的非对称加密 我所接触的非对称加密有ssh加密，这个因为不管是github上开始代码的提交，还是我们开始远程建立数据库的连接，都要用到。记得我第一次给github提交代码的时候，因为window默认不支持ssh，所以下载了git客户端，在gitbash上进行操作，生成了ssh密钥，把公钥贴在了github的setting里面。（非对称加密算法好像有个叫RSA）。 因为非对称加密有些复杂，https通信过程中,注意是通信过程中，不用非对称加密，用的还是对称加密，因为我们只要保证通信过程中对称加密的密钥不被窃取捕获篡改，就可以了。所以我们在传输密钥的过程用的是非对称加密，这样就得需要服务器的公钥，我们用服务器的公钥加密我们传输数据石宏对称加密的密钥，然后传输到服务器端，服务器用他的私钥进行解密，这样密钥传输成功，我们进行通行的过程中就可以用对称加密了。 那问题来了，服务器怎么传输过来他的公钥呢，怎么保证他传输过来的公钥的安全性呢，用对称加密？不行，无法保证密钥的准确，用非对称加密，也不行，这就陷入无限的死循环中了。 其实非对称加密不仅可以用公钥加密，私钥解密，保证传输数据的数据不被获取（需要私钥解密，可是私钥是私密的东西哦，别人都不知道）到，但不能保证数据不被劫持篡改（但无法保证别人对你这个文件进行修改），还可以使用私钥加密，公钥解密，这样不能保证数据不被获取到，但是可以保证数据不被篡改（因为每个人都可能获取到公钥，然后用公钥解密你这个私钥解密的文件，但无法修改，因为一旦修改了，文件的内容和私钥加密的内容就不一样了，等到客户端接收到服务器端传过来的内容，用公钥解密后，发现内容不一样，就很容易判断到文件被修改，如果一样，则能保证传输过来文件的准确性（我对不能同时修改文件和私钥加密文件的看法是私钥是服务器所特有的，所以不能还原修改文件被私钥加密后的样子）） 首先，CA会向申请者颁发一个证书，这个证书里面的内容有：签发者、证书用途、服务器申请的时候附带的公钥、服务器的加密算法、使用的HASH算法、证书到期的时间等等。 紧接着，把上面所提到的内容，做一次HASH求值，得到一个HASH值。 再接着，用CA的私钥进行加密，这样就完成了数字签名。而用CA的私钥加密后，就生成了类似人体指纹的签名，任何篡改证书的尝试，都会被数字签名发现。 最后，把数字签名，附在数字证书的末尾，传输给服务器 因为这个传输服务器公钥的过程就是为了保证数据的不被篡改，不用管数据是否被窃取到，因为传输的是服务器的公钥，本身就是公开的，所以我们用私钥进行加密，公钥进行解密。 客户端拿到这个数字证书以后，用CA私钥对应的公钥，可以解密数字证书末尾的数字签名，得到证书的内容以及原始的HASH值。 紧接着，客户端按照证书中的HASH算法，对证书的内容求HASH值。如果通过CA公钥解密的HASH和通过计算求得的HASH值相同，那么认证通过，否则失败。 如果认证通过，就可以取得服务器的公开密钥。 所以对服务器公钥的传递本质上还是通过费对称加密算法，只是找了个中间机构ca，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。这样，就方便客户端对于数字证书真实性的验证。 客户端证书HTTPS中不仅可以使用服务器证书，还可以使用客户端证书。以客户端证书进行客户端认证，它的作用与服务器证书是相同的。由于客户端获取证书需要用户自行安装客户端证书，同时也面临着费用的问题。因此，现状是，安全性极高的认证机构可办法客户端证书但是仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入ID和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。 总结一下： 首先服务器端让ca用他的私钥对自己的公钥进行加密，然后传给客户端，客户端用ca的公钥进行解密，保证接收到服务器端公钥的准确性。 然后客户端用服务器端公钥对自己传输过程中数据进行对称加密的密钥进行加密，传输给服务器端，因为只有服务器端有私钥，所以只能服务器能解密，保证数据传输过程中密钥的安全性。 最后客户端通过对称加密的密钥给自己传输的数据进行加密，传输给服务器端，服务端用之前客户端传输过来的密钥进行对称结密，完成通信。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具分享]]></title>
    <url>%2F2017%2F11%2F29%2F%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[这篇博客的目的就是把自己平时用的比较顺手，方便能提升效率的工具分享给大家，互相交流，提升工作效率 Evernote 一款记笔记的工具，之所以用这个，是因为刚开始编程的时候，有一次记笔记，当时用的还是word，然后没保存，然后····大家都懂得，记得那时写了挺久的关于php的笔记，不知道你们有没有相同的感觉，即使再看一遍书，很容易把笔记都能写回来，但是心里还是很难受，于是就开始用这款印象笔记了，不知道没网能不能用，···因为我一直在有网的情况下使用，然后他可以最多三个终端上使用（免费版），还有就是会有冲突的，记得冲突的时候及时查看，然后修改就好了，不要像我一样攒着很多（听说有道云也挺不错，但是没有用过） 简书 我用他主要是因为他上面写文章（编辑器可以调整成md）可以一边写，一遍预览 七牛云 主要用来做图床（写md的时候用的啦） phpstorm 真的好好用（下面的terminal，还有新建文件能自动git添加等等） 可以快速打开文件，不用在项目中找（ctrl+alt+n） 本文搜索 ctrl + f 全局搜索 ctrl + shift +f 回退 ctrl + alt + 左方向键 大段注释 ctrl +shift + / alt + 上下键 上下方法切换 alt + 左右键 左右tab页切换 本行注释 不太记得了 应该还有很多，但不太记得了（创建文件自动添加命名空间） 面板上的类的结构 百度云，现在的百度云下载速度受限制了，只有开通会员才会下载速度贼猛，百度干净云帮你解决疑难杂症， 链接: https://pan.baidu.com/s/1dFzqZK1 密码: cjrr，直接下载是个安装好的文件包，点击baiduyunguanjia.exe,，然后就当做普通的百度云用就好了，速度能到4 5m，··当然这和你本身的网速也有关（记得点击召唤大神提速） git bash 命令行，有很多linux命令都可以使用，比如ll这种（直接在git官网下载git.exe,然后安装后就直接会撞上这个）windows有个很有用的命令,explorer .,这是打开当前文件夹，图形化界面的形式（记得xampp也有这个按钮）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结]]></title>
    <url>%2F2017%2F11%2F28%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[netstat -an 展示所有的端口号，-a 表示包括tcp和utp，-n表示不用域名代替ip地址 ll -a ls-la 展示该目录下所有文件包括隐藏文件 cd 进入目录，~ 普通用户的家目录 /home/vagrant, root用户 /home pwd 展示路径 mkdir 创建目录 chmod -R (文件夹) 755 修改权限 chown root:root 文件名 修改文件所有者和组 chgrp 修改组 useradd 添加用户 passwd 修改密码 （切换到当前用户下就可以修改了哦，不知道怎么修改别的用户的） groupadd 添加组 touch 新建文件 echo 11 &gt;&gt; 文件名 把这个内容输出到文件中 vim i 修改模式 ：wq 保存 ：q 退出不保存 ：q！强制退出 / 查找 ：num 多少行 ：$末尾 cat 查看 echo 输出，比如输出当前进程号 echo $$ (PID的值代表的就是进程号) export 设置环境变量 export FOO = foo ,让当前环境变量立即生效，source ~/.bash_profile 执行这个脚本文件（source在当前进程中直接执行而不是复制子进程执行）感觉直接在命令行这样export FOO = foo 好像就直接生效了，但是如果修改bash_profile 文件的话，要执行source才能生效 env 查看环境变量，比如查看刚刚的环境变量是否生效 env | grep FOO cp 复制文件 cp 源文件 目标文件 ，如果是文件夹 记得带上 -r 参数 lsof -i|grep 3306 查看端口号 ps -ef | grep httpd 查看httpd进程是否在 tar -xjvf 解压 常用端口号 ： http 80 https 443 mysql 3306 redis 6379 ssh 22 ~代表家目录，root用户 /root,普通用户/home/用户名]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux网络管理]]></title>
    <url>%2F2017%2F11%2F28%2FLinux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[首先来介绍下有关网络的相关知识吧，iso，国际标准化组织 制定了 osi七层模型，但这个模型在现实生活中并没有使用，使用的是基于7层模型之上的tcp/ip 4层模型 二者区别 上三层是给用户提供服务的，下四层是数据传输用的（数据不传输的下4层不用了，但上3层还是要用的） 既然是数据传输，那必然就有单位，每一层传输的单位是不一样的，osi7层模型上都有标识，最底层的物理层单位比特，代表的就是0或者1这个单位这些层在水平上的传输，然我们以为他们就是直接想通的，其实他们是从高到低，再从低到高这样传输的。 各个层的作用，感觉了解一些就可以了1.物理层：底层传输2.数据链路层：通过不同的mac地址，通过交换机进行传输，此时还没有ip地址，so交换机肯定是不认识ip地址的啦3.网络层：ip地址，路由器，通过对不同路由器的选择，去寻找不同的主机服务器4.传输层：tcp udp的定义，tcp安全可靠没有udp快，但udp不可靠，还有来确定端口号（端口号的理解，这封信送给你家，只有署名了，才知道给你家的某个人，外来的请求，只有确定了端口号，你才知道这个请求是给哪个服务的）5.会话层：这个文件是直接存储呢，还是要进行网络传输呢6.表示层：数据的表现形式，加密啊，我们window上文件的高级属性也能加密，但是秘钥保存在本机应该是c盘，一旦重装系统，秘钥丢失，那这个文件也可能就打不开了7.应用层：用户接口 线面这张图能表名上面的作用 a: 你在吗？b:我在，你还在吗？a：我还在，我穿输了 其实这个应答应该是没完没了的，但3次之后准确率就比较高了 下面介绍一下ip有关内容ipv4结构如上所示，图中可以看出选项有的有，有的没有，所以结构不唯一，需要检测，没有ipv6固定，速度快 可以看出32次方，一共2的32次方个默认 0.0.0.0 到255.255.255.255其实如下，很多不给用的，就a b c类能用，其中还包括一些私有的，只有局域网内网才能用127这个网段只有一个也就是自己127.0.0.1 上面的ip地址第一个字段代表不同的网段，不同的网段需要通信，要用路由器 a类网段，拥有的主机数是 2的24次方b类：前两个数代表不同网段，后面两个数代表不同的主机c类：前三个数代表不同网段，后面1个数代表不同的主机同一个网段交换只要交换机就可以了这个网段是怎么决定的呢，是有子网掩码决定的，子网掩码的255代表网段，0代表主机，ip地址都是配合子网掩码使用的，没写是因为有默认 最大的主机数（-2 一个是网络地址，一个是广播地址） 私有ip不要钱，有效的保护公网ip不够用 缺点：不能访问公网ip，公网ip也不能访问私网ip（公网ip是互联网上唯一的门牌号） 网络的计算：ip地址和子网掩码和，因为子网掩码前面全是1，所以网络地址网段和ip地址一样，后面子网掩码全是0，所以网络地址主机是0 广播地址怎么算呢，子网掩码有多少位是0，就换算多少位1，前面网段不变，这样就是广播地址 udp 比tcp简单，所以udp比tcp块 常见端口号http 80 https 443mysql 3306ssh 2222redis 忘记了smtp 25(简单邮件传输协议) 不管是window还是linux都禁止了23端口，因为telnet是明文传输，截获了都不用破解 DNS 进行域名解析 虽然我们的端口分tcp和udp，但是系统怕我们弄混淆了，不管tcp的20 21还是udp的20 21都是分配给ftp使用的 DNS（尽然既可以接受tcp协议也可以接受udp协议） listening 表示本机正在监听 establish 表示建立连接 udp的状态为空，因为udp不管你在不在，都会给你发送数据 （我想攻击一个游戏服务器，我把我所有的外部连接都关掉，然后登陆游戏，然后netstat 查看外部连接，就能知道对方的ip地址了） 关于DNS的知识 ip地址太难记，没有域名形象，so 产生了DNS window的host文件是做静态ip和域名对应，优先于DNS匹配，so我们经常本地测试绑定虚拟域名的时候都是这么干的 早期就是通过host文件这么解析的，坏处 dns原理 域名解析原来是从后往前的，··顶级域名在后面 原先有个.me 的国家域名可以申请 这个是全球唯一的（比如www.sina.com 和www.sina.cn就是两个域名，为了防止别人误入错误的地址，大公司会把那些顶级域名都注册了，以免坏人的误导） 三级+二级+顶级+组成完整的域名 根域名管理一级域名，一级域名管理二级域名，二级域名管理三级域名，这种层层管理 dns一般劫持被误导非常难，你只要确保imooc.com 这个二级域名是否是这个网站的，就能确保是否是钓鱼网站（确保二级域和顶级域一致） 域名解析过程主要分为开始的递归查询和后面的迭代查询默认本地域名服务器解析的域名保留3天 （这种分级的更有利管理） 迭代查询允许返回一个最优的值，比如顶级域名不知道，让本地域名服务器去找cn解析 全球所有的域名服务器都知道13台根域名服务器 但是递归查询不可以，递归要么返回一个准确值，要么返回错误 所以，递归查询一般用作客户机和本地域名服务器之间进行查找（注意这个查找虽然图中只是一台，其实会有很多台）而迭代查询一般用在根dns和cn，com这些之间进行查找]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window下运行各种框架总结]]></title>
    <url>%2F2017%2F11%2F25%2Fwindow%E4%B8%8B%E8%BF%90%E8%A1%8C%E5%90%84%E7%A7%8D%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这篇文章主要是对于php运行环境的搭建中运行起来框架的总结，其实运行框架，不管是yii，还是tp，还是laravel，还是我们那个项目框架，与其说是运行起来，不如说是找到框架的入口文件，然后剩下的就直接交给了框架进行处理（route.php的处理，restful api等等，通过解析模块，控制器，方法），绝大部分时候就这这么简单，至少上面三个都不用对apache进行特殊的配置（目前的这篇文章只是单纯的针对Apache）。 so，简化的思考了一下，就是找public下面的index.php 文件（tp laravel都是这个文件 yii是在web目录下，其实找一下就行了，大部分都是reqire项目的核心库这种东西。例如yii 123456789101112&lt;?php// comment out the following two lines when deployed to productiondefined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;, true);defined(&apos;YII_ENV&apos;) or define(&apos;YII_ENV&apos;, &apos;dev&apos;);require(__DIR__ . &apos;/../vendor/autoload.php&apos;);require(__DIR__ . &apos;/../vendor/yiisoft/yii2/Yii.php&apos;);$config = require(__DIR__ . &apos;/../config/web.php&apos;);(new yii\web\Application($config))-&gt;run(); ），所以只要配置好了一个环境，剩下的框架的运行基本就一样了。上面已经说了我们这片文章的目的了，运行起来框架，通过的是直接下载代码的这种方式（现在绝大部分框架都是支持composer来安装）。我们先安装好xampp，xampp会帮我们集成安装好apache和mysql，他们和在linux下是一样的，至少我到现在还没有发现什么不同，so，因为太过相似了，导致我从前以为xampp是在window环境下集成安装了lamp这种，其实这个l（linux是没有的），他的环境准确说是wamp（我代表 window这种架构）。他把php，mysql还有apache都放在了他自己也就是xampp的安装目录下，我们找到apache的安装目录，在conf文件夹里面找到（httpd-vhosts.conf）这个配置虚拟域名的文件，我记得以前apache配置虚拟域名是在一块的，都是写在httpd.conf文件里面，现在分开了，其实是包含了conf文件下的所有文件，但这样更清楚。接下来我们就开始配置虚拟主机了（配置虚拟主机的意思就是在一个服务器上配置多域名访问的站点，其实不通过域名通过端口号啊什么的都可以，本质上就是把不同的请求分发到不同的目录下。我们的itbasic就是通过Nginx通过域名的不同把对80端口不同的域名请求分发到不同的端口下，然后通过apache虚拟主机的配置（通过的是端口的不同）来达到发送到不同目录下）。添加1234567891011121314&lt;VirtualHost *:800&gt; ##ServerAdmin webmaster@dummy-host2.example.com ##DocumentRoot &quot;D:/xampp/htdocs/dummy-host2.example.com&quot; ##ServerName dummy-host2.example.com ##ErrorLog &quot;logs/dummy-host2.example.com-error.log&quot; ##CustomLog &quot;logs/dummy-host2.example.com-access.log&quot; common DocumentRoot &quot;D:\code\laravel-v5.1.11\laravel-v5.1.11\public&quot; ServerName laravel.app &lt;Directory &quot;D:\code\laravel-v5.1.11\laravel-v5.1.11\public&quot;&gt; Options Indexes FollowSymLinks Includes ExecCGI AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 简单的记录下apache的语法 DocumentRoot 代表根目录配置虚拟域名要写在virtualHost标签之间，后面的代表端口号，servername代表域名，directory里面allow代表接受任何的请求，之前安装larave的时候代开index.php嫌弃我权限不够，其实是这个directory标签的内容写错了，注意这个如果说打开文件夹没有权限，在window下你改这个目录的什么所有者权限啊什么都是没用的，我的理解是web请求的时候打开这个文件夹的用户不是我们能预测的，应该是other什么的，因为加了这句话，所以我们在window下安装这些框架不用修改日志文件，要么在linux下安装yii，laravel都要修改log日志文件夹的权限（感觉是因为写日志的操作是来自http的请求，像我们之前安装seaslog第三方的日志的时候，也得修改那个文件夹的权限，道理是一样的）（yii框架的话conf文件夹下web.php cookiekey要随便填一个数，） 当然还要配置个虚拟域名，因为之前apache里面填写的域名如果是假的话，在本地host文件里面配置一下（因为浏览器解析是通过缓存（贼端）host文件，dns解析来找的，配置之后ping一下能不能同，就可以啦） 大功告成。 总结一下,本机运行起来一个框架。 1.安装集成环境（xampp）2.修改apache配置文件，配置虚拟主机3.修改host文件，修改域名到本机127.0.0.1 注意的点：1.配置虚拟主机之后，xampp原先那个localhost直接就访问不了了，所以把那个localhost也配置一个虚拟主机（localhost也属于一个域名）2.如果访问不了，先ping一下域名，看是否能ping通，然后查看apache的access日志和error日志，如果没有，确认http服务是否起起来了，如果有查看日志（linux下tail -f 动态看），window下在文件的最下面，像我现在这个window下环境，就是因为端口号被占了，改成800，所以每次访问域名后面都得加 ： 800，这个Apache的错误日志里面会记录的很清楚 附上三张框架图1.2. (其实在用外链的时候想到了树洞外链，GitHub上一个关于php的开源项目)对了突然想起来yaf框架，其实因为yaf框架是需要扩展模块支持，所以得先安装php扩展（php扩展大部分都是c开发的，），然后原理是一样的（只是yaf框架需要手动生成基本目录） 地址 简单记录下window下安装php扩展（phpinfo能输出php的详细信息，在框架的index.php目录下是唯一所有人都能访问的）然后去pecl下载php扩展，下载dll文件的时候要注意那个什么tc之类的，注意好，下载好放在php的扩展目录下ext，再在php.ini 里面模仿之前的php扩展，加上相应的话就好了，那个扩展还是可以配置一些属性的1zend_extension = D:\xampp\php\ext\php_xdebug-2.5.4-7.0-vc14.dll 像mysql这种，都是可以添加配置信息的12345678[MSSQL]mssql.allow_persistent=Onmssql.max_persistent=-1mssql.max_links=-1mssql.min_error_severity=10mssql.min_message_severity=10mssql.compatability_mode=Offmssql.secure_connection=Off yaf好像不配置，不能再生产环境下用，有个参数，其实安装seaslog的时候那些日志模板啊，日志格式啊都是在这里配置的，就是初始化的感觉。linux下的安装扩展要先下载文件，然后编译成so文件放在对应目录下，然后配置php.ini，有机会再说。window下只要注意好下载对应的dll文件就可以了]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>linux</tag>
        <tag>框架</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用]]></title>
    <url>%2F2017%2F11%2F25%2Fhexo%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[感觉七牛云和我们公司的产品datrix做的东西是一样的，都是用来做存储的，还有树洞外链（GitHub上一个php star很高的项目） hexo server -port 4000 启动服务器，因为我改了端口，导致得换端口 hexo new “文章名称”产生新的文章，注意这个地方一定要是双引号，单引号会出错 hexo g 产生静态文件 hexo c 清理缓存 hexo d 部署到github上 （这个其实就是代码提交，以前很傻比，每次提交代码都用git，其实这个就是把一些静态文件代码git到GitHub上，只是封装了一些操作而已） 注意经常写好了，命名没问题，但是本地测试显示不出来，其实有时候是type那个save快捷键的问题，手动点击保存 还有经常显示不出来都是语法啊什么问题（md语法），不要总怀疑缓存，服务器，注意下md语法和是否保存好了，刷新就可以了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>datrix</tag>
        <tag>七牛云</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法使用记录]]></title>
    <url>%2F2017%2F11%2F16%2Fmarkdown%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于段落，不用使用 &lt;p&gt; 直接使用换行 关于首行缩进中文两字符 &amp;emsp 后面加上 ; 代表缩进一个，因为这个; 如果直接写在&amp;emsp 后面会直接不显示，所以我分开来写 如果是英文字符，肯定就是 &amp;nbsp 啦 *** *** 两个星号之间的内容是加粗, ** ** 代表泄题 `` 两个点好之间代表标记，比如我这上面想显示的md标记都是放在标签里面显示出来 有序列表的话 1. 空格后会自动生成列表，以后想生成下一个列表，自动换行就可以了，不用一个个手敲（这个markdown语法都是空格后好像才能生效） ``` 代表下面的内容是代码块，结束也是 ``` []() 插入超链接，中括号里面是要显示的文本内容， ！[]()插入图片，[]也是文本内容 &lt;!--more--&gt;nexo 产生阅读全文的按钮 *代表无序列表，（小圆点图标）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>markdown</tag>
        <tag>语法</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写博客的原因]]></title>
    <url>%2F2017%2F11%2F15%2F%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[之前学习hexo建站的原因很简单，一个朋友弄过，当第一次见得时候很好奇，好像是被h5那个背景图所吸引，还有一点就是相比于wordpress他更大方，更感觉是现代化的产物。随着进一步的了解，相比于wordpress他不用主机，对于我这种穷人来说就更有好啦，哈哈哈，而且还能在GitHub上混commit。 但当我建出这个小站的时候，我却发现不知道写什么，难道纯粹是为了面试的时候简历上有个博客地址博取好感，感觉仅仅因为这个去经常写些文章花费太大，有些人说生活笔记，关于笔记我用的Evernote，这个随时随地都能同步，没有必要非得用这个。 但不久之后我发现在学习的过程中我虽然记了很多的笔记，但我从来没有去总结，我的总结都是通过第二次第三次第四次去再次碰到这个问题，再去解决，而学会的这个问题，所以我觉得我这种记笔记的方法从根本上说并不是记笔记，而是自我安慰，所以我想通过写博客总结我写过的笔记，进行进一步的加工，还有列出关键的点，这样还能方便平时自己对问题的快速查找，这是我写博客的初衷，当然分享也是其中一点，希望如果有朋友能看见，能指出我的不足，或者我写的东西很方便的帮你找到了答案，这也是我最希望看到的。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>职业</tag>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
