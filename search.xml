<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[外接广告]]></title>
    <url>%2F2020%2F04%2F21%2F%E5%A4%96%E6%8E%A5%E5%B9%BF%E5%91%8A%2F</url>
    <content type="text"><![CDATA[最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。 首先介绍一下前置知识吧，对于ios 和 android 手机的标识。ios手机现在一般用idfa， 但是用户可以关闭广告追踪，那我们获取到的就是一堆 0000-000··这样乱七八糟的东西，毫无价值，为了实验效果，我们一定要开启ios手机的广告追踪。（怎么快速获取当前手机的idfa，可以在appstore中下载一个myidfa,可以快速获取到，注意字母都是大写）。所以要是苹果手机用户关闭了广告跟踪，那么我们就完全追踪不到点击广告的用户信息了，广告的转化率我们必然 android 手机五花八门，之前一般都是用的imei ，然后有的手机可能还有多个，目前没有考虑很多的情况，都是取的默认的第一个。但现在imei好像逐渐开始也获取不到了，国内的手机一般用的都建议用oaid，据说覆盖量已经 80%以上（但是oaid是国内手机联盟定的东西，像海外的安卓机器是没有的，而且现在识货android客户端也是不支持回传oaid的） 主要流程：当我们app（识货）在头条（或者朋友圈）上面投放广告的时候，当用户点击我们投放的广告，会给我们的web server发送一条请求，这个请求包括用户的基本信息，比如ios 的idfa 或者android 的imei,还有个call_back,类似标识这个用户信息是头条回传给我们的，我们拿到这个信息存储下来，当用户启动我们app的时候，我们可以把这个用户的信息（imei 或者 idfa）和 头条回传给我们的信息作比对，如果对应上，然后时间间隔在我们希望之内（比如两天），就可以当做这个用户是头条带来的。 头条头条应该是接入的几个广告主中最简单的。头条是没有账号区分的（接口中让我们传入sign，但其实可以不用传），所以当我门投放部使用多账户进行广告投放，在我们代码中是没有影响的，我门只需要调用头条的上传用户行为的接口，传入设备信息和call_back 就好了。 坑点： 1.首先我们要区分开发者和广告主两个角色，开发者角色在这次广告对接中基本没啥用处，就是用来看开发者文档的。广告主角色很重要，因为我们配置好监控链接，联调上传行为的时候需要用广告主角色登陆后台管理界面，进行联调（填写头条用户id，然后刷新头条信息流，出现联调广告，点击，观察头条发起调用我们的url，我们可以直接拿这条url测试我们的监控接口是否正常，然后取出callback 和 idfa或者imei，作为参数调用头条的上传用户行为,这就是整个步骤啦，注意imei属于隐私数据，所以会用md5加密） 2.在我们联调的时候需要填写很多信息，比如下载链接，ios就是App Store我们应用的连接，android 需要我们上传apk到头条或者自己上传一个到七牛云，说白了，用户点击广告需要下载，我们给他们提供一个下载地址（好像不能用应用宝地址，因为腾讯？） 3.主要就是上面两个，剩下的就是代码设计方面，首先是对于表的设计，因为头条那边我们回传用户行为不需要去重，所以我们之前的代码中自己检测到属于头条带来的新用户直接就上报了，自己没做任何处理，比如记录日志，比如存表。这样带来一个坏处就是万一逻辑哪里出错了，不好排查，比如我们和bi那边做数据差异对比，完全拿不出证据证明这个用户在我们逻辑中属于新用户，为什么bi那边不算新用户，所以可以把用户的上报行为时间也存下来。 快手快手和头条内容基本一致，就是快手不支持去重，只能我们这边自己去重，所以我们终究要保存下我们上传的用户信息，再次触发上报条件的时候，需要检测之前是否上报过。 （为什么我们会触发多次激活的上报条件？按理说不正常，但历史原因是识货这边在获取用户启动信息的list里面可能第一次没有获取到imei 或者idfa，这样用户虽然激活了，但是没法匹配到头条那边的点击广告信息，只能在第二次用户启动app的时候去激活） 快手比价坑的就是他的callback往往很长，··长的你不能想象，所以我们要注意数据库是否会自动截断。 广点通广点通相比较上面二者更加复杂，首先就是多账户系统和开发者。 1.开发者需要把多账户（多个广告主）接通流程，首先开发者需要自己建立一个应用（这个应用不用区分ios 和 android ，目的就是获取一个appkey 和 appsecret, 这个信息在我们上传用户行为的时候需要，头条那边之前以为也需要，但是他那个sign 可以不传，所以这个应用可以不建立） 2.建立好应用之后就需要我们通过腾讯系老一套的oauth2.0 ，把广告主账户挂载在这个应用下面，因为应用需要获取我们的广告主信息，所以需要通过模拟第三方登陆，让我们应用获取到广告主的信息（比如accesstoken）,这个accesstoken 很重要，上传用户行为就靠他了。ps:这个accesstoken 有时间限制的，为了让他一直有效，我们需要通过refreshtoken 一直刷新accesstoken 的时间（感觉上就是类似redis 的set， 不断的刷新有效期，可以写个定时任务） 3.获取到accesstoken ，我们再建立用户行为，（但是激活和次留可以用一个行为id），然后把accesstoken ，行为id，事件回传就可以了 综上，其实各家广告厂商套路其实都差不多，我们提供给他们的广告连接都是可以加上我们自己的参数的，类似微信登陆我们在回调的时候对于scene字段传入我们自定义的值。我们可以利用这个值作为不同的投放计划名称，方便我们不同计划的统计，虽然头条他们本身也能传给我们计划名称。 各家公司对于ios 和 android 需要建立不同的计划，但是我们的检测链接可不需要，因为我们可以从他们回传的内容中获取到os,判断是android 还是 ios，而且毕竟是mysql，关系型数据库，我们只需要把它们返回的内容都保存就好了，有个例外就是快手不行，因为他们的回传内容中获取不到os，我们无法判断是android还是ios，（android 和 ios 匹配头条用户信息的逻辑不一样，所以要区分）难道通过idfa或者imei去判断，显然不保险，不如填写两条不同的检测链接，标识哪个是ios ，哪个是android。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>广告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-validate验证器]]></title>
    <url>%2F2019%2F12%2F16%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-validate%E9%AA%8C%E8%AF%81%E5%99%A8%2F</url>
    <content type="text"><![CDATA[我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。 曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。 首先说下php 的验证库可以做哪些事吧，还是蛮丰富的。 首先是验证器，在我看来验证器就是单独抽象了一个层出来，我们在controller里面只需要调用，让controller更加简洁，而且也能复用，验证器类都继承于think\validate。 其次controller 里面的validate 方法可以直接调用，本质上和前面一样都是调用tp的验证器库。 最后我们如果想单独使用验证器，就当做普通方法那样也是可以的，毕竟有时候我们除了对于传入参数的验证，业务代码中也有一些内容需要验证的。 Validate属性： static type : 这个主要是我们第三种方法独立验证器用到的。rule 规则都存在这里面，当我们使用独立验证器的时候，想扩展验证规则，extend 方法修改的就是这个属性，因为是static， 所以在本次请求的下次使用中，也能调用上次extend 的验证规则 alias： 就是我们rule 中可以用 &gt;: 5, 当做 gt: 5 来使用 rule: 验证规则，我们在写验证器的时候，重写的就是这个属性 message: 提示信息的重写。包含5个占位符，:attribute, :rule, :1, :2, :3 field: 字段的描述，主要作用用在message中message 中的占位符 :attribute 会被这个内容替代 typeMsg: 提示信息呗，这块是英文的，最终会通过 lang\zh-cn.php 转换成中文 currentScene: 当前验证的场景，这个感觉就是为了验证器准备的（场景），其实也蛮实用的，方便验证器中规则的自由组合。 filter: 主要是利用php filter_var函数的验证 regex: 主要是用到正则的验证, ctype 也是php 很好用的一个扩展，方便一些特殊字符的验证 scene: 场景 error: 错误信息，只有控制器中错误才能抛出异常 batch: 当前参数验证错误，还能轮到下一个参数 only: 场景中哪些参数被验证 remove: 场景中移除 append: 场景中添加 1234看源码写的一点总结// remove 不可能移除所有，除非append 中是空// remove 连续移除是通过 |// remove append 的最佳实践是二者不要存在顺序关系，因为程序不会鉴别 方法： __construct: rule 验证规则， message 提醒， field 字段描述 :attribute 占位符实际内容 make: new self 生成一个验证器 rule: 独立验证修改rule 和 field 属性，供后面check 使用。方便直接传入 rule 和 message extend: 独立验证器中的方法扩展 setTypeMsg: 独立验证器中使用 message: 提示信息 scene: 修改当前验证场景 hasScene: scene 优先考虑 sceneEdit 方法，再考虑 scene -&gt; [‘edit’ =&gt; []] 属性 batch: 批量验证 only: 场景的使用验证哪些字段 remove: 场景移除验证规则 append: 场景添加沿正规则: 上线 remove 和 append的调用的时候没有先后顺序 ！！！ check: 验证器核心，这时候传入的内容会覆盖掉初始化的内容。 getScene: 根据传入的scene 和 current scene 修改 only remove add 内容 getDataValue: 根据传入的data 数组和 可以， 获取对应的内容 checkItem: 实际的验证，通过 call_user_func 去调用对应的验证内容 checkRule: 官网上这么说， 感觉意义不大，毕竟静态方法make 创造的更好用点 getRuleMsg: 获取错误信息，可以好好看看，挺好的，调用了lang 类。因为自定义的closure ，如果 不是 === true， 就当做error， 结果就当做errorMsg，和调用类方法还是有点区别的。 getValidateType: 像一些 is，比如 isEmail, isIp 都走的is 方法 后面就是一些验证方法了，以后写代码都可以借鉴下 ValidateRule这个类的主要用途就是通过rule 类的形式去调用对应的验证规则 属性： title :attribute rule 规则 message 提示信息 方法： addItem ： 为 is 方法统一添加rule，message 属性 getRule getTile getMesage 获取对应属性 title 设定title ——call ——callStatic]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPhP</tag>
        <tag>validate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持久化]]></title>
    <url>%2F2019%2F12%2F03%2F%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true), 但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server 在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。 举个例子吧，之前接手的一个任务毒和nike关联出价，当前台下发撤单任务的时候，因为牵扯到很多curl 请求，不能同步实现，1.感觉可以通过把请求内容放到mq当中，然后利用daemon 化的task始终监听这个mq，如果有内容，则触发任务，往后执行，否则停歇1min 继续监听。2.那个前作者是通过把内容放到redis中，通过daemon化的task监听这个redis，如果检测到这个redis这个key，就执行相应任务。 总结一下吧，其实上面两个方式php的daemon话都是通过while true，那么supervisor 的作用是啥呢，当php的这个脚本挂掉了，supervisor可以重新拉起这个脚本。同理pm2也可以，而且不一定是脚本挂掉，脚本执行完了，也可以重新拉起，比如 1234&lt;?phpecho date(&apos;Y-m-d H:i:s&apos;)echo &apos;end&apos;;// 利用上面两个进程管理工具之后，可以一直输出 上面的例子还有个很重要的技术点就是定时触发。相比较crontab 的task，上面的task 触发任务时间不一致，触发时间靠前台控制，所以我们这时候就通过始终运行一个后台任务，然后靠前台触发一个开关，后端始终运行的task始终监测这个开关，如果是开就运行，虽然可能存在一定时间的误差，但大体上还是能完成任务的。 再比如之前接手的一个安卓灰度更新的任务，当某个渠道开启灰度之后，我们需要每隔30min发送一条钉钉消息，我们同样可以检测表中渠道是否有开启灰度的状态，如果有，则发一条消息，并记录通知时间，下次的循环任务检测是否灰度还在开启，如果还在开启，检测时间通知是否超过30min，如果超过了，再发送消息，并更新通知时间。 上面的任务看似已经解决，但还是会涉及一个多进程问题，再举个例子，比如erp系统，需要爬取商户的店铺信息，这个task 要一直执行，如果我们有100个商户，就得运行100个task，启动100个脚本。我们上面灰度通知的好解决，一种办法就是检测运行的渠道，循环运行的渠道列表，然后发送消息通知，另一种就是一次性检测，把渠道更新信息包含在一条短消息中发出去，之所以这么做是因为后续的任务（发送钉钉通知）可以在很短时间内完成，如果像erp的那种爬虫任务，只能通过启动多个脚本了。 关于php的多进程扩展pnctl 这里暂时不做讨论，说一下pm2 和 supervisor 的简单使用。 PM2这篇文章关于pm2讲解的很好 我比较常用的命令 123456pm2 listpm2 app.js --name wx_spider --watch // name 名称，方便理解， watch 文件变动，方便重启，类似nodemonpm2 delete allpm2 delete (:id)pm2 restart apppm2 logs (:name) pm2 配置简单，非常好用，echo 的内容之间在log中能看到，除了node， php也是能管理的 （PM2 的安装需要通过node 和 npm， node 的安装很简单，但我们一定要注意npm 安装的module 位置，如果是linux 下，一定要配置好node_path ,否则 npm -g 安装的内容可能不能使用， npm config get prefix 可以查看node -g 包安装的位置 。同理node的安装位置最好也是/usr/local/ 下面，方便直接访问） 今天在使用pm2 管理我的一个task的时候遇到一个问题，就是普通的脚本pm2 start app.js 或者 pm2 start test.php, 但是我现在的命令是这样的 1php symfony trade:UpdateCommentDgTags updateUserPublishment --split=4 之前的那个命令是肯定不可以的，需要使用配置文件 12345678910&#123; //统计报表更新 &quot;name&quot;: &quot;up4&quot;, // 随便取 &quot;args&quot;: &quot;trade:UpdateCommentDgTags updateUserPublishment --split=4&quot;, // 这些都属于参数 &quot;script&quot;: &quot;symfony&quot;, // 这个地方一定要注意，symfony 其实是脚本，只是没有 .php 的后缀 &quot;exec_interpreter&quot;: &quot;php&quot;, // &quot;exec_mode&quot;: &quot;Cluster&quot;, // &quot;exec_mode&quot;: &quot;fork&quot;, &quot;max_memory_restart&quot;: &quot;100M&quot;, &quot;cwd&quot;： &quot;../&quot; // 上一级目录&#125; 一定要注意，这个地方symonfy 是脚本，怪不得之前我在执行task 命令的时候忘记输入symfony ,他说找不到脚本。 后面的那一长串都会统一看成参数，只是参数解析的形式不一样，比如 trade:UpdateCommentDgTags, 解析成方法名称，–split = 4 解析成参数。 12345678910111213ps: php test.php --goods_id=12 uo22test.php&lt;?phpvar_dump($argv)输出内容：Array( [0] =&gt; test.php [1] =&gt; uo22 [2] =&gt; --goods_id=12) pm2 log日志的位置 12error log path │ /home/username/.pm2/logs/app-error-0.logout log path │ /home/username/.pm2/logs/app-out-0.log 需要注意的是这个error 应该是pm2 自身的error, 一般我们程序抛出的都是在out 日志里面 ！！~notice: pm2 虽然香，但也不能乱用，比如之前我在预发布机器上跑的一个task 脚本，因为跑完了，脚本 die， 不断的被pm2重启，导致cpu 很快被耗尽，所以很多脚本停止的时候 都会有个sleep 操作，过一段时间再重启。当然如果你是那种常驻内存，比如node 做的webserver 肯定不用，因为一般不会崩溃，唯一一种就是你的代码有问题，不断的报错，导致服务不断的被唤醒。 supervisor使用和安装可以大致看看这个文章，但这篇文章的配置文件有问题 配置文件里面一定要有[supervisord]和[supervisorctl] 部分，否则会报错。这篇文章应该还可以 需要注意的就是监听端口从 127.0.0.1:9001 改成 0.0.0.0:9001 ,方便外网访问，贴个图 基本就能用啦 （比如我那几百万的任务task就能通过这两个处理，不用我一直看着了，跑完了看看 log就好了）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>daemon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复盘一下代码的提交流程]]></title>
    <url>%2F2019%2F11%2F28%2F%E5%A4%8D%E7%9B%98%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。 首先我们开发一个功能需要从master上面下拉代码 注意是远程的master，本地的master没啥屌用，因为一般为了提交方便和方便记忆，本地分支和远程分支保持同名，如果你用master 的话，总不能推送到远程master上吧，似乎没人有这个权限。 提交代码前是否要合并master ？ 血的例子，别吧。如果你往master上面提交代码没冲突，那就别合并了，对吧，为啥要合并呢 ？只要你的代码正常上线，dont care anything ，因为要是你真的在这个时候合并了远程master，然后远程master 0.01%的可能是个脏master，这时候你的开发分支也就脏了，意味着你合并master 之后改的东西，在领导发现master 脏了之后，都是要被回滚的，回滚的终结点不一定，凭他们的感觉吧，其实感觉就是那个人把release 合并到master 上的点。那问题来了，如果，万一你真的合并了脏master，咋办，其实也好办，你git reset 到合并master之前的那个commit，重新提交给master，看是否能合并，不能合并，再去解决冲突（后面会介绍冲突解决办法），所以感觉在merge 别的分支的时候一定要做好commit message （最好不要改merge 的info，比如当时我修改改成conflict resolve 我都不知道我要回退到哪个版本，其实只要回退到merge 之前的版本就好了）， 有时候真的会帮大忙，方便你的开发分支剔除掉别的合并的内容 开发feature中是否要合并master ？ 还是血的例子，别吧。万一你开发分支合并了错误的master，万一你不知道，接着在错误分支上开发，当开发很多的时候，当master 需要回滚的时候会很艰难，毕竟开发了那么多。这时候只能继续相信master， 不断的合并master，其实没啥屌用，你的开发分支已经领先master了，如果你没回滚，你合并的时候只会在人家前面，你会多提交很多内容，这些内容在你给领导要求pr merge 的时候被看到肯定会打回来，~~~不知道咋解决 我的流程总结。开发的时候下拉master成为一个开发分支，比如chenye/feature/gray_test, 开发完了，提交dev。万一和dev冲突，下来dev到本地，merge gray_test,看冲突是啥，万一是自己的文件，直接解决。解决完了，推送到远程，给dev提交pr，合并之后，自己的gray_test 就能合并到dev了。注意，在解决冲突的时候一定不要修改自己的开发分支，也就是gray_test, 万一在release 或者 master合并的时候修改了自己的开发分支，一定要dev， release ，master 按顺序重新提交一遍！！！！！否则，别人拉代码的时候一定会冲突。 当发现别人的代码冲突的时候咋办，最好的办法就是告诉别人，因为你不知道以哪个为标准。 你觉得是以master为标准，毕竟线上跑着呢，万一人家当初并不想把代码提交到master上，被另一个同学误操作了，也就是你clone的master是错误代码，这时候以master会覆盖调用dev的正确代码。 你说以dev标准，毕竟dev是最新的代码 ？还是不对，可能别人着急，直接提交了master，也就是说master代码比dev新，这样dev就会覆盖掉master上的新代码。 所以遇到这种情况，直接告知吧，任何一种自己修改别人冲突的方法都是不负责任的行为。 顺带提一下最近遇到的win 和 linux 下空格遇到的问题，我们都知道代码是跑在linux下的，所以我们的换行一定要 用这个LF, win下是 我们既然改变不了win，可以通过phpstorm自带的功能，去编辑文件，模拟在linux下的编辑。 （ps:我是怎么发现这个问题的，在用php的heredoc 换行的时候就能发现）]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>虎扑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-数据库操作]]></title>
    <url>%2F2019%2F11%2F17%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo 的api 去操作数据就好了。 我们先来看看常用的pdo api 首先是关于pdo的安装部分，我们要安装统一的pdo扩展，然后在这个扩展的基础上安装 pdo mysql ,或者 pdo postgresql，类似针对不同的数据库的驱动的感觉。 预定义常量：]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 学习笔记]]></title>
    <url>%2F2019%2F11%2F17%2Fgo-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能 环境安装和php 的安装基本没啥区别，找篇文章就能解决。需要注意的是 go 1.13 以上加了 goproxy 的功能，我的理解就是类似composer 中国镜像， github 上有个goproxy-cn, 修改一下就好了。 然后go 运行脚本是 go run xxx.go, 需要这个脚本 package 是main, 执行的当前方法是 main (go build 那些以后用到再补充) gopath 那些概念在1.13以上好像都淡化了，以后用到再补充 语法变量变量申明多种方式 123456789101112131415161718192021222324252627282930313233var num int // 没给初始值，默认 0num := 1 // 这样更简洁更方便， 函数外不给使用int, float64, bool 这都是和别的语言一样的，array , slice, maparr1 := [...]int&#123;1,2&#125; // 因为不能扩展，用的比较少slice1 := []int&#123;1,2&#125; // 关联数组map1 := map1[string]string&#123;&#125; // 索引数组// 换一种看法看go， 下面两种都代表数组，只是填充的对象是byte 或者是rune[]byte&#123;&#125;[]rune&#123;&#125;(不管是byte 还是 rune，对应的字符序列都是 十进制，要想转换成 十六进制需要通过 hex.encodetostring ,或者 printf , 第一个只能对 slice 处理，第二个可以对数组)// 结构体，类似type cy struct &#123; name string `json:Name` // json 的时候生成key 的名称 &#125;cy1 := new(cy)cy1.name = &quot;haha&quot;fmt.Println(cy1.name)//cy 类似类名，所以我们还需要变量名// 别名type// map value 定义成某个字段太局限了，可以 map[string]interface&#123;&#125; 这样，更灵活// := map[string]interface&#123;&#125;&#123;&#125; ,一定要给初始值// go 中 printf %v struct 这种不够，因为 名称打印不出来，需要 %+v 打印 一次性给多个值 1arr1, arr2 := []int&#123;1,2&#125;, []int&#123;2,3&#125; 因为go 中的异常机制和php还是有点区别的，很多函数在使用之后会有error 的返回，我们根据 error != nil ,就能知道是否错误 123456789if _,error := test(x , y ); error != nil &#123; 错误处理&#125; := ,只有多个变量中有一个是新的，:= 不会报错真实因为go 的这种语言机制，导致 if 才能这样用，最多有两个表达式，第二个 值的内容是布尔 （上面 _ 属于匿名）还有go 中和 js let 一样，都有块状作用域，比如那个 if 里面赋值的变量，只能在 &#123;&#125; 中使用 var 和 const 一次性声明多个值 12345678910var ( test1 int test2 int)// 枚举，内部可以用iotaconst ( test2 iota test3) 循环go 中 if 和 for 都是不用括号包裹的]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 学习笔记]]></title>
    <url>%2F2019%2F11%2F17%2Fnode-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[虎扑这几天的git流程总结]]></title>
    <url>%2F2019%2F11%2F12%2F%E8%99%8E%E6%89%91%E8%BF%99%E5%87%A0%E5%A4%A9%E7%9A%84git%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[首先说一下虎扑的代码开发流程（包括提交，发布流程不太明白，对金啃死了解太少）。公司给每个人分了台虚拟机(类似云主机)， 我原先的想法是通过在虚拟机上clone 代码，然后通过phpstorm 的远程连接主机的功能，实现在本地开发，然后映射到虚拟机上代码改变。可是这样有一个问题就是虚拟机linux上clone的代码的换行和我本地win上的换行不一样，虽然开发的时候没有影响，但是要是在win上提交代码就会出现很多没有修改的代码也会有modifyed（其实git 本身做了兼容，在clone的时候，但主要是我现在把linux代码拉取到本地，所以才会这样）。而且我也不可能在linux上提交，毕竟提交的时候需要通过一些工具观察文件的改变，所以改成了第二种方式 通过在本地和远程都clone 代码，然后通过sftp实现两个文件夹的关联，本地代码的修改也能直接映射到虚拟机，而且可以在windows上提交代码，因为是在win上clone迁出远程仓库的代码，所以提交的时候不会出现换行(crlf)的问题。 首先是开发分支的命名。 姓名/feature(bugfix) 特征/ 自定义名称 （这样切割之后，在一些git 工具上可以发现是以文件夹方式显示的） 开发完了，推送到远程 git push origin chenye/feature/dgtag(本地分支):chenye/feature/dgtag(远程分支) 然后给develop 提交一个pr，再合并（最好不要直接给develop提交，就算提交也是通过git fetch origin develop(远程分支):deve1 去提交, 千万不要把自己的分支推到远程的develop分支上了，防止覆盖） 当我们提交的时候出现conflect 的时候，我们可以 git fetch origin develop:dev1, 然后在dev 上merge 我们的分支 chenye/feature/dgtag, 合并完了，再推送到远程新建分支，再把这个分支和dev分支合并。 当我们merge本地分支的时候肯定会出冲突，这个冲突的来源有两种可能，一种自己的，这个很好办，把head 到 ==== 中间删除，替换成自己最新的。 还有种可能是别人的，要是别人的呢，也好办，最暴力的方法就是用dev替换自己分支上最新的，这样自己的分支和dev合并就没有冲突了，但这个只适用于dev哈，如果是release 和 master ，一定要问一下出现conflect文件的那个人！！！ 远程仓库更新完了，我们需要更新服务器上的代码，这和itbasic 一样，直接去28机器上git clone 就好了 唯一有区别的就是release， 我们这边release 的发布类似以前，每次发布之后都会在服务器上产生一个新的文件夹，通过改变软链接指向的文件夹，保证每次发布成新的代码（而不是通过代码覆盖，感觉这样是不是发布更快速，如果是clone的话，有时候需要很久才能全部完成） 进入release 环境，我们第一个选2， 第二个选项是不同的php， 7.1 和 7.2，7.2的count() 真的很坑呀，要注意，其中3环境我们每次执行完脚本要及时删除 文件夹下的cache， 否则脚本执行不了 （很奇怪~~）。 有时候我们在release 环境修改文件会发现没生效，这可能是因为有人发布代码了，所以你后面再次进入修改的文件，可能对应的文件夹已经不是之前你修改的那个了。 这几天git常用的几个命令 git pull origin master:master1 注意这个和 git pull origin master 不一样，后者会下拉master 并和 当前分支合并，前者即使当前在master1 分支上，也是用master 强制覆盖master1 ，类似push 。 git fetch origin master:master1 下拉远程master 在本地新建master 1 git reset commitId 回退本地 commit 的内容到工作区（并不是删除） (如果没有 –hard， 内容会再次回到工作区，需要 git checkout . 抛弃， 默认是 git reset –soft) git checkout . 删除工作区的内容 git clean 删除添加的文件，或者直接 rm 删除文件 git branch –delete 分支名 删除本地分支 git push origin –delete 分支名 删除远程分支 git merge ing 的时候如果想放弃，也可以通过删除merge的文件，这样是不是能少记一个命令呢，哈哈哈 我们在解决冲突的时候，千万不要把develop，或者release 上面的代码合并到自己的开发分支上， 因为自己的开发分支最终是要合并到master上的，所以我们对这两个分支解决冲突只能通过新拉分支来解决，解决完也不要推送到自己的开发分支上，可以推送到远程的临时分支上，与dev和release合并 今天在给一个新项目做远程sftp配置的时候（本地clone，远程也是clone）,始终配置不上server， options 这块总是显示mapping 不对，打开 configuration 注意那个地方一定要有个 / !!!! 今天用sftp 发现，为了删除文件，只能在phpstorm上面删除，如果自己打开文件夹删除，是更新不到服务器上的 今天用git 的时候，想给部署多个仓库 小垃圾们看一下，~是不是对origin 有更深刻的理解了 ，地址https://segmentfault.com/q/1010000008366409 今天在推送本地分支到远程的时候推送错了，导致远程分支提前自己的开发分支，所以只能强推，当然只有自己的分支能这么坐哈，~公共分支千万别，因为感觉强推就是覆盖 git push origin dev -f 今天在提交代码的时候，发现想删除某个提交，其实这个情况蛮常见的，比如之前某个大佬把release合并到master上，我们只需要 git rebase -i 还是蛮重要的，目前我就用在删除当前分支的某次提交。变基的时候如果没有修改同一个文件的话，没有冲突的话，改起来话挺快的，可以快速删除某个不想要的提交，比如：https://www.36nu.com/post/275， 但是如果改了同一个文件的话，可能存在某种冲突，所以变基操作会每个commit 慢慢操作，只需要 git rebase –continue 这样就行了 git reset 的后遗症蛮严重的，特别是自己开发分支修复不当，所以我们每次提交一定要严格执行合并dev， release，master 流程，一旦开发分支修改过，都要重走一遍。今天有人合并分支出现冲突，强推了merge，导致我的代码被覆盖，但归根结底都是之前提交代码不规范，~一定要引以为戒]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-数据库和模型]]></title>
    <url>%2F2019%2F10%2F25%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-Cache]]></title>
    <url>%2F2019%2F10%2F22%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cache%2F</url>
    <content type="text"><![CDATA[需要改变的观点是 这个cache 并不能完全替代redis， 这个cache 只提供一些缓存比如redis,memcache，file 方法的聚合，比如set 设置缓存，如果配置的是redis， 走的是redis string的get 方法，如果配置的是file， 则对文件名进行hash， 然后存储在对应文件下面 （redis 键的过期不用我们代码中主动考虑，当我们使用redis 的set 命令的时候自动帮我们实现（redis有自己的键过期策略），但是file 没法设置过期时间，只有在get的时候拿着文件的mktime 加上 存储的expire time 和当前时间进行对比，如果超过了就返回null，并删除文件，当然我们在调用的时候不用考虑，单纯的通过 Cache::set() 就行了，上面的操作都是 cache的driver 之一 file 帮我们封装好了） 介绍一下 cache 库的基本结构 首先 \Cache -&gt; facade Cache -&gt; think Cache, 所以上述三个类都能调用cache，前面两个类等同，都只能通过 静态方式调用方法 ！！！，走的是我们的默认配置。think\Cache 属于实际类，他没有 _call_static 方法，所以我们不能用这个类静态的调用方法，需要先实例化，然后去调用。 这个库包含三个基本文件 cache.php ,这个类是入口，实例化的时候走的是他的_construct, 生成handel实际处理句柄，干啥的？ 对于set， get 操作，实际发起者就是他。然后就就是一些config 的配置，具体的操作并不涉及。 cache 文件夹下的 driver.php .是一个abstract class （abstract 相比较interface ，首先abstract 是类，类只能单继承，interface 是接口，可以多实现。再者abstract 中可以包含 方法实体，但是interface 中的方法都不能包含实体。这个driver.php 应该用abstract，因为他包含一些公共方法，比如 pull -&gt;取出缓存中的一个数据并删除，可以直接通过各个cache driver 的 get 和rm 方法的组合，并不需要每个 cache driver 各自定义，所以他的pull 方法可以直接包含方法体）。 首先来看一下 think\Config instance 容器类，装着一个个 options 的驱动类，这些驱动的名字默认是配置项（options）序列化，保证同样的配置不会生成多个实例 config 配置属性，用来选择使用哪个驱动，file ? redis or memcache handler 注意这个和driver 下面的驱动类的handle 区分开，那个handle 是实现具体操作的句柄，比如 驱动是 redis， 那个handle 是 new \Redis （c 实现的php扩展）， 而Cache 中的handle 是驱动类， think\cache\Redis __construct() 初始化方法，config 属性的赋值，然后调用init() 方法 connect() 根据配置生成实际的cache 文件夹的实体类，存储在instance 属性中 （可以有多个cache配置），名字用配置项的序列化生成的字符串。返回的内容是实体类 init() 返回内容也是实体类，但操作的是 handle，handle属于instance 中的一个，是当前调用Cache 时候某个config 生成的实体类，不多于一个。因为这个条件的限制，所以只有第二个参数force 在 true 的时候，或者当前handle 是null（比如file），才能实现 cache 加载类的切换。 getConfig() 获取options, 操作的属性名叫config （不叫options） setConfig() 设置options,操作的属性名叫config store() 上面也说了init 方法不太方便切换当前操作的cache， 这个store很方便，通过传入不同配置项的名称，实现cache 加载的config 的切换。 1234567891011121314151617181920212223242526return [ // 使用复合缓存类型 &apos;type&apos; =&gt; &apos;complex&apos;, // 默认使用的缓存 &apos;default&apos; =&gt; [ // 驱动方式 &apos;type&apos; =&gt; &apos;file&apos;, // 缓存保存目录 &apos;path&apos; =&gt; &apos;../runtime/default&apos;, ], // 文件缓存 &apos;file&apos; =&gt; [ // 驱动方式 &apos;type&apos; =&gt; &apos;file&apos;, // 设置不同的缓存保存目录 &apos;path&apos; =&gt; &apos;../runtime/file/&apos;, ], // redis缓存 &apos;redis&apos; =&gt; [ // 驱动方式 &apos;type&apos; =&gt; &apos;redis&apos;, // 服务器地址 &apos;host&apos; =&gt; &apos;127.0.0.1&apos;, ], ]复合cache， 通过传入redis， file ，还可以定义更多的 再看一下cache 文件夹下的Driver.php handle 实体类操作句柄，类似 redis 的 new Redis, pdo 的 new Pdo readTimes 读取次数，自身用的比较少 （每次读取都会增加） writeTimes 写入次数，用的比较少 （每次写入都会增加） options tag 给缓存加标签，比较方便的就是 clear 的时候会清除掉tag 绑定的缓存，而不是整个redis 库的flushDB serialize 一个数组，其中的四个参数分别代表，序列化方法，反序列化方法，缓存前缀，缓存前缀的字符数量 abstract has 是否有这个缓存 abstract get 读取这个缓存 abstract set 设置这个缓存 abstract inc 新增步长 abstract dec 减少步长 abstract rm 删除缓存 abstract clear 删除缓存 getExpireTime 这个方法太傻比了，不知道咋用，传入的参数是个时间，返回的还是时间，没啥用 getCacheKey 正如名字上写的，获取缓存的名字，比如redis 的key值，file 通过这个返回的内容加上自身逻辑，生成对应文件名（其实就是options 中的prefix 拼接上 key） pull get 和 rm 的组合 remember 不存在则写入，类似redis 的分布式锁，5s 中内每隔 0.2 s 执行一次 看是否能设置成功。 5s 中后直接操作，不管有没有锁 （按理说锁的存在时间不应该这么久，所以直接覆盖了之前的锁） tag 给当前类设置属性tag. 如果传入额外的key, 则把传入的key 存入该tag 名下，这个tag 和key的对应关系如下 ： tag 名根据定义关系生成key, 把对应的key 连接成字符串当做value， 做成 key -&gt; value 映射 （整个cache 库的映射关系都是 key value 形式，没有别的数据结构） setTagItem 给当前tag 加入新的 key getTagItem 获取当前tag 对应的key 123456789101112protected function getTagItem($tag) &#123; $key = &apos;tag_&apos; . md5($tag); $value = $this-&gt;get($key); if ($value) &#123; return array_filter(explode(&apos;,&apos;, $value)); &#125; else &#123; return []; &#125; &#125; 发现上面的array_filter 方法用的蛮多的，用来过滤 数组中的 false， 蛮好用的 serialize 获取的上面 serialize 属性参数1对应的序列化方法序列化 unserialize 获取的是上面serialize 属性参数2对应的序列化方法反学历恶化 registerSerialize 修改serialize 属性 handler() 获取句柄 getReadTimes 获取读取次数 getWriteTimes 获取写入次数 下面是cache 文件中的驱动，随便选一个，比如 redis.php 分析 (看了这个类很容易自己封装一个 redis 操作库) （为啥还需要自己封装redis 操作库，因为这个cache 类只是简单的使用redis 的string 类型，更多的操作类型并没有） （封装redis lib 其实蛮简单的，把这个redis 连接抄一下，然后加入一个_call 方法就好了，最简单的redis lib） (其他的lib 比如es lib 也可以这么考虑，重要的就是一个tcp 连接) options redis连接的参数 _construct 建立redis 连接 （支持 php 扩展 redis （phpredis） 和 predis (单纯用php 实现的redis 客户端)） has 调用redis 的 exists 方法 get 调用redis 的get 方法 set 调用redis 的set 方法，其实 setex 可以直接用set 实现 inc redis incrby 方法 dec redis decrby 方法 rm redis delete 方法 clear redis delete 或者 flushDB !!]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三个星期的PHP面试]]></title>
    <url>%2F2019%2F10%2F01%2F%E4%B8%89%E4%B8%AA%E6%98%9F%E6%9C%9F%E7%9A%84PHP%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[故事发生背景：男，94年，工作经验2.5年，普通一本，软件工程，裸辞，8月9日裸辞！！！然后在上海和家呆了一星期，去云南玩了一星期，后来回上海写简历，租临时住所一星期，9月1日正式开启我的找工作之旅。 简历简历真的很重要，因为很多hr真的会把你的简历筛掉 所以啦，不能怪他们，只能怪我们自己没有写的好，怎么写好PHP面试的建立？老李的文章写得很详细，这里我就大致说一下我自己的看法： 首先是对于基础的掌握程度，比如各种框架的生命周期，composer加载原理，facade，ioc，各种设计模式，比如单例，工厂，装饰器。又比如网络层面的基础，比如tcp三次握手4次挥手，https原理，tcp 编程，php-fpm fastcgi swoole。再者就是各种更深层次的原理，比如php7 的优化，redis 数据结构，索引b+ 树最左前缀。 写完基础，就要看项目经验了，是否有电商的项目经验，redis的应用场景，mysql 的分库分表，最高并发和最多数据量的表是多少，是否有服务拆分，微服务相关经验。是否有app 开发的相关经验，代码发布流程。 很大程度上面试官都会依据着你写的简历问你相关的问题，哪方面比较擅长就多写点呗，很多时候面试官都会给你机会让你在你擅长的领域上发挥，我们不用管我们擅长的是项目还是PHP本身，把你最好的表现出来就好了，一定不要因为你觉得更熟悉框架对请求的加载流程相较于有高并发经验比较低级，硬往上面靠，到头来不仅没有因为你擅长的东西得到面试官的青睐，还会因为表达不清楚或者说瞎编被抛弃（深有感触，在sty面试之后有感） 面试首先想说一下关于裸辞这件事。 本身我是很赞成裸辞的，毕竟觉得找工作单纯靠着上班时间请假很难完成，而且觉得自己有能力，辞职之后还可以专心准备找工作。但是经历了这三个星期之后，我的想法产生了极大的变化，可能以后我还会裸辞，但是我想告诉大家一些事情，当你裸辞之后你要做好长时间找不到工作，又或者是下家比上家还差的打算。下面是我大致的新路历程： 第一周因为2年多从来没面试过，很仿徨，觉得redis 数据结构不懂，php 源码不会，总感觉自己没准备好，而且为了练手，我在拉钩上只投了很小的几个企业，大致规模是 150人以下，收到了4个面试邀约（很少了，其实如果裸辞的话，一周感觉10个吧，然后筛选一下到7个，也不会很累）。 第一家是做线上培训的。公司很小(一层楼都没有)，大概类似传统行业的格子间 。首先是做面试题嘛，他家的面试题很杂，大概就是网上找的那些html+css+js+mysql+php, 其实这些都是web开发应该会的，但是他家的题很恶性，类似那种mysql 改密码一共有多少种方式，以下哪个js 语法有错误，mysql事务的4个特征属性是什么，唯一一道有参考价值的应该是末尾的用php写一个广度优先。后面就是面试官，balabal，问了一个场景，同时4w人考试的系统怎么设计(全国范围内)。在后面是 ceo 宣传了1个小时他家的产品，给的很低，而且试用期打折，pass。 第二家是做的一个类似实体店铺的导购，完全没有面试官，就是ceo 宣传（！真的敢这么招人，仿佛来了就要），没有学到一点面试经验，所以呢，以后小伙伴们投递的时候对于50 人左右的公司， 或者是ceo直接在拉钩上招人的公司，慎重投递，没啥意义。 第三家，sty (二面很惨)。 这应该是这一周唯一一次有价值的面试了，公司蛮大的，研发也挺多，环境高大上，hr 挺好看，就是有点冷漠 （不要水的话，他们不会给你倒的哦）。做题。一面，说一下地址栏输入地址之后的过程。这个我擅长呀，先hosts 文件，浏览器缓存，dns解析，域名转ip 地址，然后和服务器建立连接，nginx 传php-fpm , 给php ，我顺便补充了一下tp框架执行流程。 那你用过composer吗，用过，然后我直接给他说了composer 源码加载原理。用过redis吗， 说一下场景 （我这个级别，很多时候就考这个，redis 命令一定要记熟悉！！！比如怎么获取zsort 中元素数量），还问了redis 集群，raft算法 (不会啦，redis 真的很重要) ，git 怎么回退 （！！！啧啧啧，真的很少用 git reset），说一下array 经常用的方法。本来以为很简单的过了，和朋友都发了短信，二面面试官来了。真的很厉害，tcp 三次握手建立连接除了syn ack包还有那些 ？pdo 是长连接还是短连接 ？连接池有什么作用 ？到底用长连接还是短连接比较好 ？为什么主键需要连续 ？索引怎么查找的 ？事务没提交出现大量close_wait 错误是出在哪里，php 还是mysql ？ 第四家，rt 。第四家在soho 的地下室，其实面的感觉还不错，但是没要，不知道是不是像我朋友说的那样套路创意，因为之前他面的ios， 聊得很不错，后来就没消息了。面试题很不错，总共4道题，第一眼看上去可能一道都不会，第一道是对msyql 表的设计，给了一个场景。第二道是对laravel 的collection 一个方法的实现。第三道是写一个sql。第四道是关于mysql 可重复读时候修改数据阻塞的考察，问的内容大致就是一些简单项目，还有一点点es。 第二周因为第一周面试之后给我的阴影蛮大的(最主要sty的二面让我真的认识到自己的不足)，周六和周日投的基本是b轮以上的公司或者是150人以上的，可竟然周一一个面试机会都没有！！！ 我慌了！！！ 周一晚上疯狂的海投（但是类似lb，bd，tx，fl，hp，yw，bz 这些大厂还没有投，想留在第三周），终于约了4个面试。 第一家，yhxc。大概两个小时的车程，主要到了那边下地铁之后坐不到公交车，对的，你没有听错，在上海竟然等不到公交车（ps，可能之前都住在比较靠近市里的地方，公交车基本10分钟以内一班），打车去的软件园。公司挺大，一层楼，很高档，相比sty 的 ins风，这边更加温馨，但可以看得出来，不缺钱。笔试，拿走了手机。面试，面试官对着我两个for 写的冒泡看了半天，说不对，··我讲了半天我自己都怀疑了，然后他拿来的dell 笔记本，我写了一下，运行正确，他又看了5分钟····二面，一个不喜欢我用DateTime 去写时间的人，说实话，我挺反感的，主要是他直接定义我date 用的不熟，于是我直接用date 实现了一遍，他还是不服气，因为他的题是 2018-9-7，~~不同人的看法不一样，这tm 和 2018-09-07 的考察点的区别真的很大吗。后面就是hr面，背调了2个小时，真的！！！本来想着凑合着他过吧，出现了另一家拯救我的公司，yx。 第二家，yx的面试是下午5点钟，因为中午回去不了，我找了家星巴克（肉疼）。没有笔试题，一面面试官来自百姓网，穿个大裤衩，北方人，看上去就很放荡不羁，一直擦着鼻涕，但真的很厉害好嘛~~~我们之间的面试很短暂，可能是我了解的知识正好是他get的点，而且聊到情深处，他自问自答，当他对我说索引 b+树查找原理之后，我顺便拿着这个回答了二面面试官。真的蛮想去他那，可是呢，996，对不起了，如果以后有机会的话，真的想认识一下。二面面试官也很厉害，他更注重项目经验，眼光狠毒辣，仿佛我的两年半工作经历都被他看穿了，不管我怎么掩饰。tinyint 占用几个字节，能表示的数多大，你们代码发布流程？没有app的开发经验。然后是hr面 上面两家公司的offer 让我很是头疼，是去一个类似国企的公司还是去一个技术更占优势但是996的公司，我失眠了。 第三家，xyk。要是xyk 给的钱多的话，可能就没有后续了。笔试题， 8 % -2 多少？ 0！！！，他们那的一个对我影响蛮深的面试题就是 setcookie, var_dump($_COOKIE); 答案是 null。一面面试官就对着面试题询问，我们大概聊了1个小时，他和我工作经验差不多，然后人很好，很热情，对于面试题上出现的没达到他想要的内容都会耐心引导，一度让我以为他很闲（哈哈哈，真的，小哥人真的超级好）。二面面试官，首先不说他技术咋样，反正蛮反感的，就是类似比如觉得你restful 说的不全面，但自己也不说哪不对，滚混去查~~~。hr面，钱给的少，pass。技术还行，不加班，介于上面二者之间，氛围不错 第四家，ydkd。是一家在青浦的快递公司，真的PHP的兄弟们！！！不要去，真的。首先面试距离远不说，去了要做一份智力题，不过不给面试，那些题目真的恶心到家了。而且公司里面员工都穿着快递服装，进门就是一股浓浓的网吧味道（塑料胶门）。因为那边的环境，逻辑题8分钟糊弄完，没过，滚回家了。 第三周第一家，sm。┭┮﹏┭┮，sm真的不是司马的意思，但去知乎上面搜一下，这个公司的负面新闻真的蛮多的，这也是我面试以来第一次没通过一面的公司。比较难的点 php 源码，zend 引擎， docker 和 k8s。不管你答得好不好，他反正没有反馈，真的很sm 那。唯一一点好处就是，以前一直没关注abstract 和 interface 的区别，这次回来自己弄明白了。面完之后朋友说半小时内你可能会受到一个面试反馈，这家公司应该是hr在刷kpi，果真这也是我第一次收到面试反馈··· 第二家，lb。lb 那三道万年不变的面试题。但和面试官沟通之后，学会了几个技巧，比如有序数组，就要想到二分查找，原先的结果反转，就可能得到组合的效果。lb里面人的反馈蛮差的，本身觉得他和pdd有什么关系，但实际上好像并没有，面了两轮技术，一轮hr， 最后一轮hr没面到。 第三家，fl。笔试题好像很不错，好像错了一道，直接过了。然后是两轮技术。fl不是一个技术驱动的公司，他们那更多的在乎是业务。fl的前台真的巨好看，好想再去面一次。fl的面试中午提供午餐，真的很好吃。26号入职，fl也给你交社保。fl的hr 真的超级贴心。对不起，fl。 第四家hp。 面试官，我要给你奉献我的心脏。 第五家bd。真的sb bd， 周三约电话面试，我推掉了所有的事情，你tm值面了我10分钟，让周五去现场面试。周五我推掉了所有的面试，你tm周五早上对我说面试官有事情，只能下周一，我之前就清楚的说了我下周一就要入职了。你的股价跌也是有原因的。 第六家，lyg。lyg和hp的评价在看准网上都挺低的，我一度不想去lyg面试了，可真当我可lyg的面试官交流后，我发现他是面试以来最和蔼的人top3。二面，可能没get到他的点，他也没问我啥。（lyg在宜山路一栋楼，好像饮料也都是免费的，如果能进去应该不错，在做类似比心的陪玩)。二面面试官类似lb面试官跑去和hr商量了一下，回来说hr不在。 总结以上就是这次大致的面试经历，其中第三周还省略了好几家，比如一家上机面试（hr夸我厉害，说很少有人能做出来，后来给的很多，而且6险2金）,一家洗涤公司（希望我做过二次开发，为啥？因为这样读别人的烂代码就有经验了），收到了蛮多offer的，相比前两周的失意，第三周仿佛开了挂一般，虽然大公司不多。所以想告知小伙伴们，如果裸辞了，一定要做好打持久战的准备，而且可能这个城市没机会了，只能换一个城市，（中国也就上海 北京了吧，php的话），所以呢为了保险起见，还是不要裸辞了，安安心心做事，踏踏实实学本领，总会变得有钱的]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于ob函数]]></title>
    <url>%2F2019%2F09%2F30%2F%E5%85%B3%E4%BA%8Eob%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在看源代码的时候还有phpexcel 的时候经常都会看到ob 函数，ob函数主要是用于处理php 的缓存的，默认cli 下ob 是关闭的，需要我们手动打开 ob_flush和flush echo 加速echo (之前看到的fastcgi-finish-request 和上面的缓存也是有一点关系的哦), 每当php 返回数据的时候，我们可以这么看待传输过程，首先是php把数据给webserver， webserver 再把数据给cli ，webserver 在传输给cli 的过程中php的处理进程并没有结束，所以这之间的传输效率也会影响php进程的存活时间，当这之中传输过慢的时候，就会导致大量的php进程存在（php维护的的数据库单例连接也就存在），有时候我们想尽快的结束这个php进程，可以让php 传输给webserver 的时候开启一个缓冲池，当缓冲池满的时候一次性推给webserver，然后fastcgi_finish_request ,这之后就和php进程没关系了，php就可以接受下一个请求或者断开都可以]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-Response]]></title>
    <url>%2F2019%2F09%2F30%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Response%2F</url>
    <content type="text"><![CDATA[框架可能让你对PHP 怎么给webserver 返回内容产生了误解 ！！！ PHP 是怎么把数据返回给前端的？通过response 对象？因为我们一直在用框架，框架中对于这些返回都是包裹成了response 对象，然后我们想要改变返回的内容，直接修改这个response对象就好了，比如在itbasic上 123456789$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/[:controller]/[:func]&apos;, function ($request, $response) &#123; $res = $obj-&gt;$func($request, $response); //$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;); $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); $response-&gt;json($res); // return json_encode($res);&#125;); 上面就是一种很常见的route 组件的使用，很多时候我们可能以为代码就在这结束了，殊不知，这块只是我们定义个的一个callback， 框架代码在执行了这段之后只是完成了response 对象的封装，之后他们还会处理response 对象，比如调用php原生header 处理response的header 属性，echo response 对象的data 属性。 又或者下面这种 123$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/[:controller]&apos;, function ($request, $response, $service) &#123; return $obj-&gt;$func($request, $response);&#125;); 直接返回数据，并没有返回response 对象，那后面程序就可以根绝默认的配置比如content-type html, 然后echo 返回的string。 上面两种方式大概就是一般路由的使用方法，下面我们来看看tp 中到底是怎么处理的。我们查看一下入口文件index.php 123// 执行应用并响应Container::get(&apos;app&apos;)-&gt;run()-&gt;send();从容器中获取 App.php 的实例，执行run 方法 run 方法很长，我们筛选这次用的几个重要点123456789101112131415161718192021222324public function run() &#123; try &#123; // 初始化应用 $this-&gt;initialize(); // 这个里面会帮我们加载自定义的路由中间件到 middleware 的queue 属性中···· $this-&gt;middleware-&gt;add(function (Request $request, $next) use ($dispatch, $data) &#123; // var_dump(&apos;ppp&apos;); // var_dump($data); // 没错误，直接走的run 方法 // 这个地方因为 next 用不到了，所以 return is_null($data) ? $dispatch-&gt;run() : $data; &#125;); // 这个地方往middleware 的queue 属性中加入一个callback， 如果之前有路由中间件，这块就是前面需要需要的参数 $next $response = $this-&gt;middleware-&gt;dispatch($this-&gt;request); // 中间件的执行，包括控制器的执行都在这里面 // 监听app_end $this-&gt;hook-&gt;listen(&apos;app_end&apos;, $response); // 钩子 app end 执行 return $response; &#125; 所以呢，通过上面的代码可以看出来在tp 中路由中间件和控制器其实是同一个层面的，他们的核心就是返回一个response， 比如中间件过滤失败 ，我们也需要返回一个response，万万不可以在路由中间件里面返回false， 因为后面的send() 方法需要response 类来调用，控制器中之所以可以直接返回数据是上面那个回调函数写的好，\$dispatch-&gt;run() 中有对控制器返回内容的自适应，如果控制器返回的是一个response，那就直接让他调用send 方法，否则会根据配置文件包装一个response 方法返回。 但凡我们想停止路由中间件的执行，我们可以不执行 $next() 方法，直接返回response， 这就他就会直接调用 send 方法，而不去处理控制器中内容。tp这块的原理和 laravel 还是不同的，laravel 中是通过array_reduce 不断的去执行绑定匿名函数，tp 中是通过对middleware的queue属性数组中的匿名函数不断shift， 每一个匿名都依赖下一个匿名，但要是当前匿名不需要比如执行下一个匿名 \$next() 的执行，那只会传入一个function， 而没有实际执行。这在我思考为什么 控制器执行的时候 ，明明queue 数组中没有办法shift 匿名函数了，却没有报错时候产生了极大的困惑 12call_user_func(&apos;test&apos;, [$callback]) // 不执行，除非test方法中 $callback() 主动调用call_user_func($callback, [$parama]) // 执行 接下来我们分析一下 Response 类， 首先是最重要的方法， send hook 当中的listen_send ,属于常规操作，在我们response 解析之前 然后是 getContent 对于我们的控制器返回进行处理，生成最后要echo 的内容。其中的output方法就是我们response 文件夹下所有继承response 类要实现的方法，比如json 类，会json_encode, 要是普通的类， response的data 属性就直接赋值给content 属性了，默认content-type 是html. 思考一下为什么我们在控制器中返回arr 有时候会出错？因为我们最后的数据都要echo ,然后都必须要转换成string， 当我们使用默认的配置文件的时候，如果我们直接返回一个数组，默认生成的类是response 类，他的output 方法就是直接data 给content， 这样就导致我们echo 了一个arr ，能不出错嘛 后面一段是开启 trace 调式 trace 调试我感觉方便的一点就是能看到执行的sql 语句，这在开发中是很必要的。 再后面就是头信息的处理， 调用php 原生header 再后面就是 echo data 在后面就是 fastcgi_finish_request(); 执行这个方法，这个方法的好处就是在我们尽快把客户端要的内容返回后，php 脚本还能继续执行， 参考鸟哥这篇文章 再后面就是客户端输出完成后服务端自己的一些收尾工作 再来整体分析下response 这个类 __construct 初始化 其中content-type charset 拼接很重要，标准的就是拼在一起，有时候当你没有识别json的，想想客户端传过来的content-type 是否多了 charset utf8 信息 create 生成一个response 这个就相当于一个factory， 根据type的不同，生成不同的response， 注意我们控制器中返回的response 或者官方对于控制器中 string 这种的返回包装的response ，都是new 的，而不是从app 容器中取得 send 解析response对象，给webserver 返回数据 output 对于data 依据content-type 进行处理，转成对应的string, 比如 json 转string sendData 就是最后一步，echo 数据 options 一些额外的参数配置，比如tp 中，可以对于json_encode 添加参数 ，json_encode 之后汉字我们仍旧能识别 12345options([ &apos;var_jsonp_handler&apos; =&gt; &apos;callback&apos;, &apos;default_jsonp_handler&apos; =&gt; &apos;jsonpReturn&apos;, &apos;json_encode_param&apos; =&gt; JSON_PRETTY_PRINT, ]); data 设置data 属性 allowCache 设置是否允许缓存request 内容，如果允许的话，会配置header头信息 header 配置header 头信息 content 把content 的内容转换成 string code 设置http 状态码 lastModified 设置上次修改时间 expires 设置过期时间 etag 设置etag cacheControl 设置cacheControl nocache 设置不缓存 contentType 设置contentType getHeader 设置请求头 getData 获取 data属性 getContent 类似上面的content 方法 getCode 获取http 状态码 debugInfo 补充： 因为今天在看response类，他对很多header头部信息处理过，比如allowCache, 大致了解几个新的header 头 https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ cache-control 这个我们经常看到，no-cache,但这个其实并不是不缓存的意思（强制确认缓存的意思），no-store 才是不缓存的意思。其中还有max-age 属性，代表这个缓存最大活多久，must-revalidate, 代表使用之前要检验是否过期了。 expires 代表缓存过期的时间 今天在控制器中设置header 头发现不生效，原因有两个， php的header 蛮反人类的，这样用 header(“Content-Type:application/json”),竟然是字符串。 后面response send 中header 会覆盖掉控制器中的header 那为啥文件结尾header 没生效呢，因为response send 方法调用了 fastcgi_finish_request(), 结束了相应]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-异常处理]]></title>
    <url>%2F2019%2F08%2F30%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考文章 上面这篇文章写得很好，让我对异常处理除了 try catch 之外有了更深的认识，大致记录一下对php 异常处理的理解以及结合tp框架的源码分析 PHP 处理错误的两大类方式首先我们要明白php 的异常处理分成两个独立的大块，一个是php自身的标准处理，就是我们经常error_reporting ， display_error 的设置（呈现形式就是界面上的php warning 信息， php fatal error 这种）；另一个是我们通过try catch 捕获异常进行处理（我们可能在catch 中 记录 $e-&gt;getMessage()） . 我们要清楚的是这两块对错误的处理级别是相互独立的，互不影响。比如error_reporting(0), 不对任何异常进行处理（ps: -1 ,类似 E_ALL ）,try catch 还是能捕捉到我们的exception。 123456789&lt;?phperror_reporting(0); // 0 的时候没有任何错误信息， -1 的时候会打印出 //fatal_errortest();try &#123; throw new Exception()&#125; catch (Exception $e) &#123; var_dump($e-&gt;getMessage())&#125; PHP 标准错误处理 error_reporting() 参数的意义error_reporting(), 不带任何参数，返回的是错误处理级别，带参数意思是设置错误处理级别 error_reporting(E_ALL ^ E_NOTICE) , ^ 是异或，代表除了E_NOTICE 都进行处理， 或者 error_reporting(E_ALL &amp; ~E_NOTICE), &amp; 是同或， ~代表取反，和上面是同一个意思，E_ALL是一个常量，数值是 E_NOTICE 那些的结合体 error_reporting(E_NOTICE | E_WARNING), 包括notice 和 warning 错误 PHP的错误等级1234567891011121314151617181920212223242526# 系统级用户代码的一些错误类型 可由 try ... catch ... 捕获E_PARSE 解析时错误 语法解析错误 少个分号 多个逗号一类的 致命错误E_ERROR 运行时错误 比如调用了未定义的函数或方法 致命错误# 系统级用户代码的一些错误类型 可由 set_error_handler 捕获处理E_WARNING 运行时警告 调用了未定义的变量E_NOTICE 运行时提醒 E_DEPRECATED 运行时已废弃的函数或方法# 用户级自定义错误 可由 trigger_error 触发 可由 set_error_handler 捕获处理E_USER_ERROR 用户自定义错误 致命错误 未处理也会导致程序退出E_USER_WARNINGE_USER_NOTICEE_USER_DEPRECATED==========================开发中常遇到/不常遇到分割线=======================# Zend Engine 内部的一些错误 应该也能通过 try ... catch ... 捕获 略难测试E_CORE_ERRORE_CORE_WARNINGE_COMPILE_ERRORE_COMPILE_WARNING#编码标准化警告(建议如何修改以向前兼容)E_STRICT 部分 try ... catch ... 部分 set_error_handlerE_RECOVERABLE_ERROR 这个地方需要我们注意的是结合PHP7 的 error 和 exception 来看，php7 的error 和 exception 都来自throwable， 所以我们在 catch throwable都能捕获到，他和上述php 标准错误级别的关系如下 也就是说我们平时throw 的都是实际的error， 需要注意的是上面的 E_USER_NOTICE,并不指的是我们用户写的代码触发的notice， 或者throw 的 notice (用户throw的都是error)， 这个实际上我也没见过，但我们可以通过trigger_error 函数模拟出来 PHP 各种错误的触发123&lt;?phperror_repoting(0)aa 为什么上述代码还是会抛出parse error， 因为我们在当前脚本中存在着错误，还没有执行error_reporting 就会报错，但有个方法可以让上述代码不报错，就是把 aa 写在另一个文件中，然后require 这个文件 。我们php-fpm 模式的本质，其实就是 php index.php, 所以我们在 index.php 中可以写上很少的代码，至少保证这个index.php 的正确性。 （可能是因为php是解释性的代码，只会检测require 的文件是否存在，不会检查被包含的该文件正确性，但是会对require 的文件中 require 语句正确性检测，蛮奇怪的,而且require 的文件不存在会抛出两个错误，一个是warning ，一个是fatal error， 这个warning 会被set_error_handle 处理，这个fatal error 不能被捕获， 而且竟然能通过error_reporting 屏蔽，感觉就是严重性介于 文件本身 parse error 和 try catch 捕获的 error 之间） 关于PHP 异常处理的几个函数 try catch , 不用做过多的介绍了，老朋友，可以捕获 throw 的所有内容，相当于 php 标准错误的fatal_error, 但不是fatal_error 就等于他，比如 require 的文件错误不存在，就不能被捕获 set_error_handle, 和上面的try catch 互补，try catch 捕获的都是 E_ERROR 级别，对于那些warning ,notice 就靠这个东西来处理了，他有个返回值，当返回false 的时候，错误还是会提交个php 标准错误处理的 （也就是处理错误的流程是先php代码处理，然后php 自身处理， 我觉得php自身处理应该就是日志记录，还有display error 。 php 的错误日志一定要注意位置，很多时候不是php.ini 里面配置的位置，而是虚拟主机 apache 或者 nginx 里面配置的日志位置） set_error_handle要比想象中的强大多了，我们可以在这之中接受 erroNo, erroStr, 封装成 exception 抛出去，那么就会在当时被set_error_handle 捕获的地方抛出 （注意几个常用的 error的数字 ，比如 e_error 1, e_warning, e_notice. -1 代表 e_all, 0 代表关闭所有的错误报告）（adodb即使开启了错误处理，也只能触发 e_user 级别错误，所以只能被set_error_handle 处理，set_error_handle 再抛出异常，才能被捕获） set_exception_handle, 对于没有用try catch 捕获的错误（注意是没有用！！，而不是不能捕获的，捕获的内容等同于try catch）, 会走到这个里面进行处理，但是这个里面处理后程序就停止了，而try catch 处理之后程序还能接着往下走（ps:其实就我们平常而言，很多时候我们捕获了异常，除非在foreach 中，如果在平时逻辑中，也就直接return 给客户端，停止后面逻辑了） register_shutdown_function， 注册一个程序结束的时候执行的函数，就是无论是崩溃啊，还是正常结束，都在最末尾执行的方法 error_get_last, 如果一个错误走到了php标准处理那块，就能通过这个获取错误内容，如果一个错误提前被捕获处理了，那这块就是空的 throw new Exception , throw new Error, 通过throw 异常，测试try catch 和 set_exception_handle trigger_error, 对于 warning ，notice 那些错误的触发，测试set_error_handle(当然也可以通过 var_dump 一个不存在的变量来触发) ​ tp 所有的异常处理都会走到Error 的 appException 方法中,最后给到 getExceptionHandler方法 首先最基本的提点try catch 的，会被 set_exception_handle 捕获，包括 \Exception 和 \Throwable, 交给 appException warning 和user 级别，会被当做 errorException 抛出，转而到 appExcepiton 当中 register_shutdown_function , 那些没有被捕获到的错误，通过error_get_last 捕获，然后判断是否要塞入 appException 中 TP 框架中的异常处理我们对于异常的处理最好写在代码的最前面，否则error 触发之后，该错误之后的代码都不会生效。 tp 在base.php 中 Error::register(); ，注册了代码的错误处理。(核心文件 Error.php) 我们大致测试一下cli 模式下的异常处理 register 1234error_reporting(E_ALL); // php 标准错误处理级别 set_error_handler([__CLASS__, &apos;appError&apos;]); // 对于warning 级别的处理 set_exception_handler([__CLASS__, &apos;appException&apos;]); // 用户自定义的try catch , 会在执行完之后停止，但是不会交给php 标准错误处理 register_shutdown_function([__CLASS__, &apos;appShutdown&apos;]); // 感觉就是只要注册了，不管怎样都会执行 appError 接受php 传递过来的参数，生成ErrorException 交给 appException 处理 appException 首先判断捕获的异常是error 还是exception， 如果是error ，统一转换成 errorException 处理 然后获取异常处理类，官方是Handle.php, 因为tp 允许用户重写这个类，如果重写了，需要继承官方的Handle 类，重写的方法是render， 框架会自动调用（为什么要重写这个类呢，因为比如记日志这种统一的方法就不需要重写了，框架会自动调用原先自己的方法）。如果没有重写，单单的给了匿名函数，会把这个匿名函数保存到 handle 的render 属性中，后期执行。如果匿名函数都没有，那就执行官方自己的render 方法 appShutDown 如果这个错误没有被处理直接交给了php标准错误，会抛出一个ErrorException, 交给自定义的异常处理，否则就记录下日志就好了 isFatal 需要抛出的错误级别 setExceptionHandle 设置自定义异常处理级别]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云南]]></title>
    <url>%2F2019%2F08%2F26%2F%E4%BA%91%E5%8D%97%2F</url>
    <content type="text"><![CDATA[女朋友想让我陪她去洱海，因为上海直达大理的机票太贵啦┭┮﹏┭┮(后来算上住宿, 中间的火车,花的钱差不多)，我决定带着她从昆明，丽江再到大理，最后从大理再回昆明坐飞机回上海。 购买机票 我是买的早上7点45的飞机票，这个时间段和晚上9 10点的飞机都比较便宜，但不好的就是这么早很难赶到飞机场，再加上如果路途遥远，堵车等元素，很容易误车，然后我惊奇的发现美团上在机场旁边有那种精品酒店，其实就是机场周边的农村盖得房子，提供接送机！！！而且不贵，大概就100来块（当然也有贵的，O(∩_∩)O哈哈~），挺干净，噪音也不大，正常人完全能睡着，酒店阿姨会为你登记送机时间，提前半小时给你打电话，很暖心。 起飞前的那晚 这是破蛋25年来第一次带女生出去玩，再加上第一次住这种地方，还有见到女朋友的激动，最最重要的是我每次坐火车或者飞机起码检票前1个小时到目的地，那晚很紧张，没有睡着。后面因为从昆明到丽江，再从丽江到大理，从大理到昆明，这样来回折腾，其实都习惯，哪有那么多的特殊情况，安心睡吧，提前半小时到就好了。 下飞机 女票比我先到机场，然后因为天生自带shy属性，我在下飞机之后又在厕所呆了半小时，差点把她气疯了，还好她出门没化妆，在机场打发了一点时间。我们在美团上定的民宿在昆明的五华区，离翠湖公园还有南屏街，云南大学很近，因为担心媳妇嫌弃转车麻烦，我们直接打车过去，相比较重庆50元南山区和渝北区随便跑，80元的车票还是蛮贵的，司机师傅确认了2遍我们是否要开发票被我们说不用后，可能在想这两个瓜娃子是不是钱多了。 昆明初印象 昆明这座城市还是蛮破的，可能因为我们在市区的原因，还有时间是8月20日，没有书本中的花城的样子，周围都是破破的，相比较重庆没有那么繁华，现代化 玩在昆明 昆明的景点还是有挺多的，比如翠湖公园，云南大学，南屏街，滇池，海埂公园 （打算去的，可是女朋友嫌弃太晒了，所以我们最后只去了翠湖公园 + 看了场哪吒！！！，翠湖公园很一般，和普通公园差不多），如果时间充足，可以去看一些石林呀，云南名族村，或者11月份之后去，可以在海埂公园喂海鸥。 吃在昆明 我们选择了大众点评上的第一家云南菜，云海肴，相比较那么多的好评，其实菜的味道一般般，但价格还是蛮实惠的(民宿老板推荐茄子恰恰)。 我们点了纳西族烤鱼(纳西族是云南这边的主要名族)，鱼腥草(女朋友爱吃，我实在难以下咽), 白切鸡倒上辣椒油(上海的一个味道, 女票爱吃)，还有一个豆尖豆腐汤(豆尖吃不习惯，泥土的味道)，后来想想是因为可能是让女票点菜的原因，没有吃上特色菜，下次就跟着点评上的top走。我们只在昆明呆了1天，所以只吃了3顿饭，其余的两顿中一个是世界级连锁kfc的桶饭，真的难吃，媳妇只是喝了点汤，一个是早餐，昆明的早餐很难找到喝粥的地方，只有米线，我们点了个清汤的和一笼包子，不知道为啥，米线有股臭臭的味道，包子也是皮蛮厚的，华夏大地应该都能吃到。 昆明总结 感觉很一般，可能是因为我们去的地方比较少，不推荐住在五华区，也就是市区，这边的景点可能就是翠湖公园 丽江古城 从丽江站到丽江古城有公交车可以直达，蛮方便的。相比较之前知乎上写的丽江站有很多黑车拉你去拉市海不骑马不给回，好像是因为政府整治了，丽江站可能是我去过的最干净的一个站，没有任何一家黑车，公交站台比较少，每一站中间距离很大，所以一定不要坐过站，我们住在古城中，在古城停车场下车。古城中有很多客栈，大部分都是木质的房子，不隔音，晚上睡觉的时候时不时有路过宿醉的年轻男女，放声高歌，这都是女票告诉我的，因为男生一般都睡得比较死的哈哈，所以如果你喜欢安静，那就去新城住吧。（ps:不知道是不是女票叫的太大声，客栈老板给我取了个外号，睡哥~^_^。)老板很热心，虽然可能是因为紫外线比较强的原因，皮肤黝黑，但是给我们仔细介绍了古城有哪些景点，大水车，木府（商业化，都是卖茶叶的不推荐），五一街，四方街（酒吧街），狮子山（最高点，可以看到古城全景），忠义市场（水果比较便宜，我们买了，到底便宜不，无从考证，可是没有网上说的日照时间足，甜）。 古城总结 丽江古城可能是我去过的最好玩的一个古城，古城的地面都是转头，所以行李箱只能拎着！！古城的道路上还有很多狗屎，似乎踩狗屎是这边的一个风俗了，古城里面有个丽江之眼 的观景台，看到的风景和狮子山上差不多。四方街也就是酒吧街很适合拍照，古城中的嘉华鲜花饼是真的好香，袋装的大概32，盒装的56，晚上和女票闹矛盾，如果有时间的一定要去试吃一下。古城的晚上超级多的人，如果怕挤的话，那就白天逛逛，但是肯定没有晚上热闹了，女票买了一个鸡血藤55，原价150，后来在别的地方看到10元三个。陪着女票去了狮子山，她看到一个清吧就钻进去了，点了两杯喝的，一盒瓜子，一盒牦牛肉，175，客栈老板说蛮坑的，但是女票想看夜景呀，后来发现古城的夜景真的好垃圾哦，但也可能我们那个地方不够高，不推荐狮子山上的商业清吧。我们在丽江吃了一顿，滇厨餐厅，还可以，他家的水性杨花（一定要在云南吃水性杨花）很好吃，腊排骨分量太大，两个人吃不完，红豆酸奶味道和别的地方一样，铜锅饭两个人吃刚好，但味道一般，鸡豆凉粉一般，玫瑰糍粑有花的味道，对于我这种很少吃糍粑的人来说一定要点，土豆泥不好吃。 玉龙雪山 我们在美团上团了雪山的一日游，320一位，小索道 + 甘海子 + 蓝月谷 + 云杉坪，蛮推荐的，早上八点的时候有师傅来接我们，晚上5点能回到古城。索道一共分成3种，大索道（冰川公园），牦牛坪中索道，云杉坪小索道。当时我们一车8个人，只有我和女票是小索，剩下的都是挑战4680的玉龙雪山，当时害怕死了，以为女票要和我发火，可是后来呢师傅说我们这个季节小索道最好玩，11月到来年2月大索道才好玩，因为现在山顶都是雾，看不到东西，而且没有雪（媳妇夸我功课做得足，嘿嘿），而且大索道需要排队很久。上午的行程就是坐小索道去半山腰，然后徒步去云杉坪，路途很短，中间可能遇到马，可以喂食，所以带点面包或者买个玉米喽，路途的风景就是类似高海拔的林区。栈道的尽头就是云杉坪了，很大的一片草场，有一些牦牛在吃草，还有很多新人在拍照。这边的天气阴晴不定，要随身带着伞，或者纯玩团发的羽绒服，也是可以防雨的。 小索道的行程一点不紧张，中午有团餐，真的这是我来云南吃的最好吃的一顿（水月阁老山鸡火锅），第一次发现火锅中烫鸡肉能这么好吃，汤汁特别鲜美，泡上米饭，让人欲罢不能，而且可以随便加肉加菜，胃口大的小伙伴们有福了。 下午我们逛的是蓝月谷，蓝月谷的湖水真的像网上那般蓝绿，但小瀑布处的水又白的那么彻底，从下游走到上游，一路上很多拍婚纱的新人，希望他们的爱情也能永远和这湖水一样纯净，没有杂质，配着远处白云缭绕的玉龙雪山，真的美不胜收。 逛完蓝月谷之后我们的行程就基本结束了，坐大巴（免费的，都包含在门票中，所以看到大巴就可以随便上）来到入山口，等着纯玩团的小伙伴们集合，一起坐导游师傅的车回古城，沿途路过甘海子，司机会让拍拍照，^_^因为这也算一个景点啦（总共4个），因为太累了，男生们都没有下车，女生会出来走走，其实就是一个大片的小树林。 大理 在大理住宿的话，大概有两个主要地方，一个是古城，感觉住宿情况应该类似丽江，但肯定只会比丽江差，因为我们去古城玩的时候会看到很多民宿，真的就是那种农村自建的房屋，肯定看不到海，另一个就是双廊，双廊那边因为紧靠洱海，可以看到海，所以住宿比较贵。我们呢选的是滨海俊园，在大理白族自治州博物馆旁边，那家住宿真的除了甲醛味道，应该是我们这次旅行最满意的地方了，所有可能用到的物品（矿泉水，棉花棒，byt，熨斗，雨伞…）能想到的都有，而且很多小设计很贴心，比如浴室的感控灯，浴室的喷头是对着墙，所以刚开始放水的时候喷不到身上，方便我们调整水温，还有因为云南那边四季如春，loft的房屋基本都没有空调。 我们在大理一共吃了两顿，一家是遇见小仙女，点了豆腐，汽锅鸡，野生菌，因为媳妇不饿，所以我们店的不多。不太好吃，^_^，豆腐很油，汽锅鸡以为和昨天的老山鸡火锅一样才点的，其实他更像是炖鸡，媳妇比较爱吃。最坑的应该hi那个野山菌了，80元，但味道一般，也不下饭。还有一家是方胖子厨房，我们点的是野山菌火锅，点了三种菌加两个蔬菜，加一个鲜牛肉，锅底中有鸡肉，所以两个人能吃的很饱，同样没有很惊艳，汤汁肯定没有老山鸡鲜美啦（哈哈哈，水月阁老山鸡火锅是我的最爱） 大理景点 大理古城：一般，肯定比不上丽江古城，也没有什么景点 大理白族自治州博物馆：很安静，我对历史没有什么兴趣，但值得一去 花语牧场： 门票蛮贵的，两个人80，媳妇说就拍了几张照片，我感觉还好，要是有喜欢拍照的朋友，还是可以拍出很多漂亮的照片的 喜洲古镇：一般，没有逛，牛奶冰棒和喜洲粑粑，可能我们没迟到正宗的，一般 双廊古镇：一般，但是媳妇吃到她最喜欢的猪大肠，还给她妈买了个银镯子，8元一克，后来发现别的家只用6元 小普陀：停车费10元，然后就没有啥印象啦 洱海：如果想环洱海的话最好租车，电瓶车肯定不行，而且挺晒的， 价格大概是 80 vs 500, 小伙伴们自行斟酌 挖色镇，太阳宫都没怎么去，基本都差不多，我们租了车（媳妇说很难开，500一天，蛮贵的当时感觉，我当时想订的是350，但是看到她发朋友圈就感觉蛮值得，毕竟我想订的那个确实不太好看） 上面大概就是这次云南的五日游，总的来说，丽江最好玩，昆明和大理（农村）一般，但也算是圆了女票的一个梦，这就够了吧，拜拜~~]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>云南</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-middleware和hook]]></title>
    <url>%2F2019%2F08%2F09%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-middleware%E5%92%8Chook%2F</url>
    <content type="text"><![CDATA[这块的中间件主要值的是route 中间件，对于请求发送到controller之前进行一系列的判断，是否缺胳膊少腿不符合要求，如果不符合，返回false, 符合 next($response) 钩子就是流程执行到某个点，触发用户绑定的方法，之所以这么做是为了用户可以在框架的层面做某些修改，而不用修改框架源码。 Hook12345678910111213141516171819202122echo &apos;start&apos;.&quot;&lt;br&gt;&quot;; // 在触发钩子之前，绑定行为到指定钩子 Hook::add(&apos;test_1&apos;,&apos;app\\test\\behavior\\BehaviorTest&apos;); // 添加钩子处理 Hook::add(&apos;test_2&apos;,&apos;app\\test\\behavior\\BehaviorTest&apos;); // 调用设置了钩子的函数来触发钩子，进行测试 Hook::listen(&apos;test_1&apos;,[&apos;name&apos;=&gt;&apos;cy&apos;]); // 设置钩子，并执行钩子绑定的函数方法，第二个变量是数组方式传入钩子函数需要的变量 Hook::listen(&apos;test_2&apos;,[&apos;name&apos;=&gt;&apos;cy&apos;]); class BehaviorTest &#123; public function test_1($param) &#123; var_dump($param[&apos;name&apos;]) &#125; public function test_2($param) &#123; var_dump($param[&apos;name&apos;]) &#125; &#125; php 因为是同步的，所以他这个钩子函数和别的语言理解起来还不一样，比如这个listen， 在监听的同时并且执行了后面类中绑定的方法，而不像一些异步语言，listen之后等待着事件的触发。 还有就是我们绑定的是类，一个类中会有多个方法，默认的初始方法是run ,这个类中还可以有多个方法，多个方法对应多个钩子，方法名和钩子名一样 分析一下Hook tags 核心属性，不同的钩子对应不同的类（可以是多个类组成的数组） bind 别名，也是给类绑定别名 portal 入口方法名称，默认run app 应用对象，App的实例，也是单例模式 __construct 构造方法，注入App 实例 $app portal 设置入口函数名称 alias 修改bind 属性，给行为（对应某个类中特定方法，也是唯一一个方法，所以这个behavior 方法就是是class）绑定别名 add 添加点对应的行为，行为可以是关联数组，key _overlay 会让添加的value 覆盖之前的value, key first 会让添加的value 排在第一位 import 批量导入 点对应的行为，可以是让import 和之前的tags 标签合并，也可以是让之前的tags 覆盖import 导入的内容 get 获取tags 属性 listen 其实就是执行某个点中绑定的类中的方法 exec 执行某个类中方法（方法名确定，就是portal） execTag 执行绑定的类中的方法，先去执行listen 的点对应的method是否存在，如果能执行，执行默认方法 middleware中间件用的设计模式是装饰器模式，每个装饰器类中只有一个方法，handle，第一个参数是Request请求，第二个参数是匿名函数 next， 还可以接受额外的参数，他这块也用的是反射，所以你如果没有添加第三个参数，在方法内部用func_get_args() 是获取不到额外的参数的，即使你在路由上middleware 传入了这个参数。因为反射没有获取到第三个参数的存在，所以执行的时候就不会传入。 123456789101112131415&lt;?phpnamespace app\http\middleware;class Check&#123; public function handle($request, \Closure $next, $pa1 = 1, $pa2 = 2) // 难道只能装一个参数吗 &#123; var_dump($pa1,&apos;|&apos;, $pa2);exit; $request-&gt;name = &apos;cy&apos;; return $next($request); &#125;&#125;Route::get(&apos;/testhook&apos;, &apos;index/testhook&apos;)-&gt;middleware([&apos;Check:name&apos;]); 如果我们在application下面的middleware.php 中写入，那么全局所有的route都会经过这个中间件]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>TinkPHP</tag>
        <tag>中间件</tag>
        <tag>钩子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-facecde和ioc]]></title>
    <url>%2F2019%2F08%2F09%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-facecde%E5%92%8Cioc%2F</url>
    <content type="text"><![CDATA[首先我们梳理一下关系，ioc 作为一个容器，是个单例的存在，它存在于自身container的instance 属性中，他还有个instances 属性，作为一个关联数组，key的内容是类名，value 内容是某个类的实例(这个类并不一定要是单例)， 当我们下次再去容器中取这个类实例的时候，还是之前的实例 (!!!千万注意一定是容器中取，才能保证是上次的类实例), 我们从容器中获取类实例，并不一定要提前bindto, bind 本质只是绑定一个别名，通过别名最终还是找到实际的类名，所以没有绑定直接传类名也是可以的。 那什么是facade 呢， 通过返回容器中的类别名或者类实际的名称，去容器中找类实例，然后调用该实际类的方法 ContainerContainer 实现了arrayAccess (方便数组调用)， iteratorAggregate (方便foreach循环) , countable(方便 count()) 调用 instance container 的单例 instances [] 装的类的实例 bind 类标识，通过标识寻找实际类 name 别名，感觉和前面bind差不太多 getInstance 获取container 的单例 setInstance 设置container 的单例 get 从container 的单例instance 的属性 instances 中获取类的实例，对于container 的单例调用 make 方法 set container 实例 绑定一个类、闭包、实例、接口实现到容器，注意可能并没有生成类的实例，也就是instances属性中可能并没有 remove container 实例中instances 属性删除某个类实例 clear bindTo 修改bind属性，包括关联数组（merge）, 闭包直接赋值，string 修改bind, 对象，修改bind ,并把 instances中绑定这个实例 instance 绑定一个实例到容器中，感觉作用相当于bindTo的一部分 bound 判断容器中是否存在类标识或者实例 exists 判断容器中是否有该类实例 从这个方法很容易判断，instances 中key 是实际的类名 has 调用的上面bound 方法 make 创建类的实例， 第三个参数newInstance 类似我之前写的那个token 文件的第三个参数 force，强制刷新实例。 make 会先去查看是否有别名，然后换算成实际类的名称，去instances属性中查找。如果没有只能生成啦。如果是匿名函数，通过反射获取参数，然后绑定参数，如果有依赖注入，首先查看是否有传入这个实例，没有的话生成。如果是类的话，会先判断是否有__make 方法，没有的话调用constructor 构造函数，执行函数的过程类似上面执行匿名函数 delete 删除instances中的实例 all 输出instances内容，也就是生成的所有实例 flush 置空 instances ， bind， name 属性 invokeFunction 从一个方法中获取反射，然后执行这个方法 invokeMethod 从一个类的方法中获取反射，然后执行这个方法 invokeReflectMethod 这个方式要求传入实例还有反射，还有参数，（所有的参数都给备齐了）就相当于上面方法的子方法，上面方法也是调用这个方法去实际执行反射类中的方法 invoke 实现方法 invokeClass 实现类 bindParams 生成类或者方法需要的参数，支持依赖注入 getObjectParam bindParams 对于依赖注入的处理需要用到这个方法 后面的方法都是为了上面那几个接口中方法的实现，操作的都是instance 实例中的instances属性 Facadebind 别名，类似container 中的bind alwaysNewInstance ，因为facade 本质上也是从container 中取实例，所以也需要这个强制刷新属性 bind 绑定别名 createFacade 先根据继承了facade 的类中getFacadeClass 返回的内容中确定类，如果没有，去bind属性中查找（注意这里是self）,都没有的话就用传入的类名。确定了类名去container 中找实例，没有的话自动生成 getFacadeClass 返回容器中类的别名或者直接返回类的名称 instance make 和createFacade 差不多 __callStatic facade 的核心，通过createFacade 实例化实际类，然后用这个实例去调用method方法 （一定要注意我们在调用类中的方法的时候除了static都是在一个类实例上调用的方法，我们的方法中可能会用到\$this ,这个\$this就是对象） 总结以Config 举例，\Config 通过class_alias 实际找到的是 \think\facade\config,然后这个类中没有我们想要的方法，调用的是父类 facade中的__callStatic, 这个方法先通过createFacade 生成实例，实例是先从container 中查找别名换成真的类名，然后去instance中查找实例，有就返回，没有再生成。实例获取到后，再去执行方法]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
        <tag>设计模式</tag>
        <tag>facecde</tag>
        <tag>ioc</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-Config]]></title>
    <url>%2F2019%2F08%2F09%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Config%2F</url>
    <content type="text"><![CDATA[thinkphp config 源码阅读，为了更好的使用~ 首先 config implements ArrayAccess, 所以我们可以这样 12345678$z = new \think\Config();$z-&gt;load(__DIR__.&apos;test.ini&apos;,&apos;test&apos;); // test 作为前缀，用来分割不同文件的配置项，如果不加，会放在一级目录，不太合适// test 内容[boy]name=cysex=1var_dump($z[&apos;test&apos;][&apos;boy&apos;][name]); // cy 分析Config的几个属性 12345config . 核心，配置文件内容加载进来的存放prefix 默认前缀，set的时候，如果key 是个string , 默认前缀， 注意set 的内容如果是个数组，那就直接合并path 初始化构造函数，配置文件的位置ext 初始化构造函数，配置文件的类型yaconf 布尔值或者字符串，用来支持yaconf __construct 配置一些基本的参数，比如path 配置文件路径，ext 配置文件后缀，yaconf 判断是否安装了yaconf扩展 __make 获取注入类app 中config文件路径和ext 文件后缀，初始化一个config类 setYaconf 注意这个一定要在属性yaconf true 的时候才能设置 getYaconf 获取 setDeafultPrefix 设置前缀，比如app parse 把一个配置文件（config driver 下面支持的类型，默认ini, json, xml）加载到 \$this-&gt;config 属性中 load 加载文件(先判断该文件是否存在，不存在添加上文件夹前缀和文件后缀)解析放到config中，调用parse，并添加支持php,yaml. getYaconfName Yconf::get(key), 获取的就是这个key yaconf 获取yaconf 中内容，感觉比如直接调用yaconf 的get loadfile load = loadfile + yaconf has 判断是否有某个key , 如果没有添加前缀，会添加默认前缀. (默认所有的config 都得挂在某个 一级key 下面，比如app(默认)， 比如 log) pull 获取所有的config 中一级配置，或者yaconf 中的某个属性 + config 中的一级配置 get 获取配置，key 中没有 . ,默认添加app 前缀，支持获取多层嵌套 set 只能支持两级key ,不包括文件名，如果传入数组，合并原先 config属性（只有在key 是string 的时候才会添加默认prefix ） remove 移除key reset 重置某个key 剩下arrayAccess 需要实现的方法，方便数组方式调用 缺点config 文件中支持 yaconf 和 \$this-&gt;config, 可有的方法是从二者中某个取值(一般都是yaconf优先)， 有的是yaconf 和 config 合并。 yaconf 的key中，第一个肯定是文件名 config key 中，如果没有. 默认都会拼上prefix , 想获取一个文件中所有内容，key 可以这样 app. , 感觉没有yaconf 直观，规范 关于yaconf(具体可以参考鸟哥博客)yaconf 是鸟哥写的一个常驻内存的配置文件扩展，（windows下使用有些问题） 很简单，默认两个配置项，一个是dir (把该文件夹下的所有的ini文件都加载进内存，不支持文件夹是为了简单，不支持别的类型文件是为了简单),一个是check 更新时间(每隔比如2s检测一下文件是否改动, 只能用mv, 不能用cp, 可能是根据文件修改时间来进行判断是否改动) api 也只有两个， // test 是文件名，name是属性 get(‘test.name’) // 获取内容 has(‘test.name’) // 判断是否有内容 我们来想想yaconf 解决的问题：我们在开发itbasic 的时候经常被这样的问题困扰，对于配置项，线上环境和本地环境不一样，所以导致我们每次提交代码都很麻烦，但凡用到配置参数的文件都会和线上文件冲突。后来我们把配置项都写到一个文件中，通过config 去获取，并且不把config文件纳入版本库，其实yaconf的本质也是这样，只是他分的更彻底，把config 完全移除项目代码，和项目代码分离，放到一个单独的文件夹中，可以让运维人员或者任何人员去修改。 关于配置文件格式tp 中有ini, json, xml, yaml, php 文件 对于ini 文件（.env文件也是ini ）可以直接调用方法解析 json ,我们直接读取文件内容，然后json_decode xml ,我们直接调用方法解析 yaml ,我们需要安装yaml 扩展（centos7 中安装yaml 工具） php, 我们直接include , 文件中的return 内容会被include 返回]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
        <tag>Config</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp源码分析-composer加载]]></title>
    <url>%2F2019%2F08%2F03%2Ftp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-composer%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[之前写过一篇文章是关于composer 的基本用法，这篇文章是composer源码的简单阅读和thinkphp5.1的自动加载。 先来熟悉一个函数，get_declared_classes, 这个函数是干嘛的？是获取当前脚本中已经加载的类的，但凡这个返回结果中有的类，我们都可以直接生成，默认在一个空脚本中 12&lt;?phpvar_dump(get_declared_classes()); 是当前php中包含的所有扩展类，那如果没有包含在这其中的类我们应该怎么生成实例对象呢？远古时代是通过 require_once，想想添加每个新脚本的时候都要在上面写个require, 这样太不智能了，php给我们提供了一个函数spl_autoload_register, 通过不断的调用这个函数，可以绑定自定义的函数到一个队列中，如果我们生的对象的类在内存中找不到，他就会执行这个队列中的所有自定义方法，直到找到为止， composer 本质上也是基于这个函数。 123456来自composer ClassLoader.php&lt;?phppublic function register($prepend = false) &#123; spl_autoload_register(array($this, &apos;loadClass&apos;), true, $prepend); &#125; 当我们在github上安装一个包（或者叫库）， 我们先composer require, 安装完了之后再在我们的脚本中加上 vendor/autoload.php, 然后就能用了，注意一定要require_once vendor/autoload.php 这个文件，否则你只是下载了包，当生成对象的时候，内存中还是没有这个类的存在(以klein举例) 那我们开看一下这个autoload .php 1234567&lt;?php// autoload.php @generated by Composerrequire_once __DIR__ . &apos;/composer/autoload_real.php&apos;;return ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378::getLoader(); 调用的是composer 包中autoload_real 中的getLoader 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static function getLoader() &#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register(array(&apos;ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378&apos;, &apos;loadClassLoader&apos;), true, true); // 这个为了能让生成classLoader 的实例对象 self::$loader = $loader = new \Composer\Autoload\ClassLoader(); spl_autoload_unregister(array(&apos;ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378&apos;, &apos;loadClassLoader&apos;)); $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&apos;HHVM_VERSION&apos;) &amp;&amp; (!function_exists(&apos;zend_loader_file_encoded&apos;) || !zend_loader_file_encoded()); // true if ($useStaticLoader) &#123; // 走的这个逻辑 require_once __DIR__ . &apos;/autoload_static.php&apos;; // 包含这个文件是因为要调用他的getInitialize()方法，也就是这个方法 call_user_func(\Composer\Autoload\ComposerStaticInit23a88103aab8adc5d1263de38cceb378::getInitializer($loader)); // 这个方法的作用就是让一个闭包复制给ClassLoad类(核心类)上，让这个闭包可以访问classLoad 的私有变量 prefixLengthsPsr4， prefixDirsPsr4， classMap （psr0 过时了，不看）。classMap 文件就是composer.json 中classMap, 他会把一个文件夹中的文件中包含的类和文件名对应出来，自动加载的时候通过类名作为key, 去寻找这个文件的位置。想laravel thinkphp 生成类和文件的对应关系，也是基于这个原理 // 说说prefixlengthsPsr4 还有prefixDirsPsr4 吧，当我们在composer.json 中自定义composer autoload psr4 ,就是就是往这里面写对应关系，首先去类的第一个字母在prefixlengths 中寻找，找到之后再去prefixDirsPsr4中找具体的命名空间对应的文件夹，然后通过把命名空间依据psr4转换成文件名称，在之前找到的文件夹下面寻找这个文件，具体的验证方法可以看classLoad的 loadClass,也就是spl_autoload_register 中注册的 &#125; else &#123; $map = require __DIR__ . &apos;/autoload_namespaces.php&apos;; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . &apos;/autoload_psr4.php&apos;; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . &apos;/autoload_classmap.php&apos;; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; $loader-&gt;register(true); //注册ClassLoader 的 loadClass 方法作为最终的spl_autoload 方法 if ($useStaticLoader) &#123; // true ,走的这个逻辑 $includeFiles = Composer\Autoload\ComposerStaticInit23a88103aab8adc5d1263de38cceb378::$files; // autoload_static 中的文件，这个文件咋来的，composer.json 中的autload files 选项 &#125; else &#123; $includeFiles = require __DIR__ . &apos;/autoload_files.php&apos;; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire23a88103aab8adc5d1263de38cceb378($fileIdentifier, $file); //这个方法就是包含上面的文件，所以 composer.json 中的files 是我们包含了vendor 目录下的autload.php就直接包含进来了，不是后期通过spl_autoload_register 中的方法生成的。为了验证我们可以在这些files 中定义class, 然后不new生成对象，也就没有触发spl_autoload_register中方法，看内存中有没有这个类 &#125; return $loader; &#125; 好了，我们来总结一下composer 文件夹中的几个比较重要的文件，autoload_real.php 是注册Classload .php 成为spl_autoload_register中的方法，autoload_static.php类似一个配置文件，把他包含的类对应文件夹的属性都绑定到ClassLoad 上，ClassLoad 调用自己的loadClass 方法，根据类名，去自己的属性上找对应的类所在文件位置。 现在抛出问题，我们如何不通过composer require去安装一个库文件？ 其实很简单，composer require 做了两个工作，首先git clone 那个库到你本地vendor目录，再接着配置autoload_static.php 文件中的两个属性，prefixLengthsPsr4， prefixDirsPsr4，第一个属性是命名空间的首字母对应命名空间，第二个是命名空间对应类的文件位置，配置好了之后，我们就可以试着new class了，看会不会报错，一般情况下不会，除非这个类库中除了psr4 还有classMap 或者files 或者psr0,这样我们一点点的添加，就能完成。 接着我们看看thinkphp5.1 的自动加载机制，thinkphp的自动加载其实就是composer的翻版，他为了兼容composer, composer 中的文件没有动，只是他没有require vendor 下面的autoload.php， 转而是通过think 库 base.php -&gt;load.php,这个load.php 作用类似composer 的autoload_real 和 CLassLoader, load.php 中的register 方法通过获取composer 的autload_static 中的prefixLengthsPsr4’, ‘prefixDirsPsr4 属性，绑定到自身，获取了composer 中通过psr4 加载的类，顺便把自己的think 和 trait也加入其中. 对于classMap, 他获取的自己runtime 文件夹下的classMap.php 文件中的内容，该内容需要调用命令生成，就是thinkphp 自身的类和对应文件位置的集合。 最后是自动加载目录，他的功能类似psr4,就是把自动加载的目录当做根目录，类文件按照psr4，由这个相对根目录展开。 thinkphp 还有个classAlias 功能，classAlias 利用的是class_alias 这个方法，让两个类一模一样，除了类名，这样可以简写我们的类名长度，注意使用的时候一定要加上根命名空间\，否则可能会在当前命名空间下寻找改类，这个在laravel中用的也很多 12345678910111213141516171819202122// 注册类库别名Loader::addClassAlias([ &apos;App&apos; =&gt; facade\App::class, &apos;Build&apos; =&gt; facade\Build::class, &apos;Cache&apos; =&gt; facade\Cache::class, &apos;Config&apos; =&gt; facade\Config::class, &apos;Cookie&apos; =&gt; facade\Cookie::class, &apos;Db&apos; =&gt; Db::class, &apos;Debug&apos; =&gt; facade\Debug::class, &apos;Env&apos; =&gt; facade\Env::class, &apos;Facade&apos; =&gt; Facade::class, &apos;Hook&apos; =&gt; facade\Hook::class, &apos;Lang&apos; =&gt; facade\Lang::class, &apos;Log&apos; =&gt; facade\Log::class, &apos;Request&apos; =&gt; facade\Request::class, &apos;Response&apos; =&gt; facade\Response::class, &apos;Route&apos; =&gt; facade\Route::class, &apos;Session&apos; =&gt; facade\Session::class, &apos;Url&apos; =&gt; facade\Url::class, &apos;Validate&apos; =&gt; facade\Validate::class, &apos;View&apos; =&gt; facade\View::class,]); 好了，大致就这么多了，所以我们可以猜测一波（没有仔细看啦） composer dump-autoload,主要是因为我们修改了composer.json文件中的autoload.psr4选项，没有及时修改autload_static 文件， composer require 1. git clone 2.修改autoload_static 文件 实战：如何用命令行的方式运行tp，测试tp中的函数 首先因为tp重写了composer 的加载方式（但没有修改composer 的文件, 为了方便composer update, install )， 所以我们用不了vendor 中的_autoload.php, tp起到相同作用的是 Loader::register 方法，这个方法中 对app 文件夹，和 think\composer 进行了psr4 加载，同时把thinkphp 核心文件夹library 下的think 和traits 也进行psr4 进行加载，这样我们就能访问app , think\composer, thinkphp\libraray\think和thinkphp\libraray\traits 下的所有文件了。同时他还通过loader 的addAutoLoadDir 把extend 文件夹做成classmap 进行加载，所以为了测试我建立了cy文件夹，也需要Load::addAutoLoadDir(realpath(‘cy’))。 当然如果我们还可能为了方便使用系统的一些类，需要class_alias。 12345678910111213141516171819202122232425&lt;?php/** * Created by PhpStorm. * User: cy * Date: 2019/8/4 * Time: 13:08 *///require_once &apos;../vendor/autoload.php&apos;;require_once &apos;../thinkphp/library/think/Loader.php&apos;; // 为了使用Load中的方法require_once &apos;../thinkphp/helper.php&apos;; // 为了使用助手函数$nowDir = realpath(__DIR__); //获取当前文件夹的绝对位置，方便函数调用//var_dump($nowDir);\think\Loader::register(); // 把composer 的自动加载接管过来;\think\Loader::addAutoLoadDir(realpath(__DIR__)); // 加载当前脚本下的类进入psr4// 注册类库别名，方便直接调用，比如 \Config\think\Loader::addClassAlias([ &apos;Config&apos; =&gt; \think\facade\Config::class, &apos;Env&apos; =&gt; \think\facade\Env::class]); 其实为什么要遵循ps4规范，就是为了能够通过命名空间方便查找文件的具体位置，然后require， 当我们主动require 了文件（比如文件数量过少的情况），我们的命名空间可以随便定义的，并没有任何硬性规定一定要和文件夹名称相同，你甚至可以在一个根目录下定义一长串的命名空间前缀，没有任何语法错误的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步 异步 阻塞 非阻塞]]></title>
    <url>%2F2019%2F07%2F20%2F%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%2F</url>
    <content type="text"><![CDATA[灵感来源别人利用多进程写了个python 的下载器，于是想自己用php试一下 先说下多进程和单进程 lnmp请求过程 http请求到达nginx，nginx 转发给php-fpm(一个php进程管理器，~so，这个地方就是多进程啦)，每个进程中实现了fast-cgi 协议(请求完毕，并不重启进程，而是等待下一个请求的到来，除非到达该线程接受http请求最大数量，会自动重启，目的是为了防止一些代码不好，导致内存泄漏)，每个进程中其实就是 php index.php（请求处理完逐个往回返回）, 所以我们可以把lnmp 模型理解成多进程模型，同一时刻并发的数量就是php-fpm配置的进程数量，但为什么别人说php是单进程呢，因为我们平时在开发的过程中，所有的代码都是跑在一个请求中，也就是一个进程中，所以我们可以说php就是单进程的，但php真的只是单进程的吗，不是，php有个扩展叫pcntl ，这个扩展不建议在php-fpm模式下使用，但是在php-cli 下可以正常使用，也就是说我们不建议在php-fpm的工作进程中再fork新的子进程（同理swoole 中也不建议在worker进程中new process 新的进程），既然在工作进程中不涉及fork 子进程，而php也很少操作线程，那么php就和异步搭不上边了。 同步，异步区别： 12所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。 最常见的异步莫过于前端的ajax， ajax 允许浏览器在发出请求的时候浏览器（一个进程）还可以去做别的事情，而不用干等着（同步就不行了，同步阻塞显然不行，同步非阻塞呢？同步虽然进程还可以去做别的事情，但是进程但过一会还得再来询问一下，请求是否完成，所以哪怕是同步非阻塞，代码流程执行到这会，始终会停住，不会继续向下走，这和异步代码能继续往下跑是不一样的，所以同步更符合我们的日常习惯。 比如异步编程，我们不知道ajax执行的函数啥时候回给我们返回内容，所以我们无法用 $a = ajax(xxx), 去获取ajax 执行的内容，大部分情况下用的是回调函数，然而为什么php中也有回调函数呢，php中的回调更类似于js中的匿名函数，他只是代码同步执行到用户定义的函数中，调用了之前定义的一个匿名函数，和js的回调存在本质上的区别。js中的回调，更类似swoole的回调，发现了嘛，都是通过事件的触发机制（但是这个应该和事件io不一样，之前看的阻塞io 非阻塞io 事件io 信号io都属于同步，只有异步io属于异步方式） 所以我们平时在看php的代码中就不要考虑异步方式了，基本没有，因为都是同步的，又因为阻塞和非阻塞都会有返回值，所以我们平时的那些函数基本都有返回值，但是有些回调形式的函数返回值有没有用，那就另说，看定义这个函数的人怎么想了。（其实看同步和异步看函数的return 也能看出来，如果return外面能接收到，那就是同步,比如php-fpm,包了那么多header头信息，还是return就能返回，你看swoole中的return ，在事件回调中，他是通过 $response 返回给别的进程的，所以属于异步）。 (可能有小伙伴看klein 或者larave中的路由函数觉得可能是回调，因为callback 中的内容总在 callback 外面先输出，首先，你在 123456$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/test/test/[test|cry:test]/[i:id]&apos;, function ($request, $response) &#123; $obj = Box::getObject(&apos;out&apos;, &apos;controller&apos;); return $obj-&gt;oop($request);&#125;);的 respond 方法中返回 值，看外面能不能接收到，能接收到就是同步 再者，他这个地方绑定了callback，并没有执行callback呀，所以这个地方并没有执行是很正常的，但是php这种没有触发机制，必须得执行呀，看后面 1$router-&gt;dispath() // 其实是在这里面执行了 ) 为什么说swoole 的task任务是异步任务，因为我们在worker进程中调用task添加异步任务的时候，当异步任务执行完的时候，我们能在之前的worker进程 中收到task返回的消息（onFinishi事件中）。(在没有swoole 之前，php中对于异步的实现都是通过第三方软件，比如把耗时任务放到消息队列中，由消费者自己去消费，消费者可以通过crontab 这种去轮训消息队列，虽然不太环保，但还是能完成任务) swoole进程模型 master 整除ractor 线程和manager 进程， manager 进程 生出 worker进程（异步非阻塞）和特殊worker进程（task进程，同步阻塞），负责进程重启和 回收 ractor 线程检查连接，还有可写的socket 发送给worker进程处理 swoole4之前请求过程 单个请求被单个worker处理，处理完再处理下一个 swoole4 之后 woker可以同时接受多个，遇到io，协程切换，处理下一个请求，当上一个请求io完毕，再切回来（感觉通过fd -&gt; 运行环境），继续往下执行（注意就是这儿，虽然说协程本质上还是异步，但是他的运行方式类似同步，更好理解） 相较于异步的不容易理解，比如回调地狱，swoole 希望我们仍旧用同步的方式编写代码，但是对于一些io操作同步返回太慢了，所以就出现了异步io，redis, mysql，没有用过~~，swoole4中为了把这个异步摒弃，又引入了上述的协程，协程是比进程线程粒度更小的资源管理。 关于阻塞和非阻塞： 123 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。 php中虽然sleep， file_get_contents 中有同步阻塞io，但是string， arr这些函数还是同步非阻塞函数 当我们在项目在swoole的http server中，没有用上面的同步阻塞io的时候，我们整个项目代码就是异步的，但凡用了，那我们的项目代码就是同步的，所以这个同步和异步由两部分决定，一个是swoole server， 一个是我们的项目代码。 swoole 本质上是为了对标php-fpm,和php本身没有什么关系，他对项目的性能提升类似php7对项目代码的提升，我们不用修改源代码，就能提升并发量，只是php7是对php中函数的改造，而swoole 是对php-fpm的改造或者说php的运行环境的改造，他吧php-fpm 的功能也纳入到我们项目代码中。 所以总结一下： php多进程 ： 针对php-fpm， 或者php-cli 模式下的php进程而言 php单进程：针对php-fpm模式下php进程而言 同步: 针多 php-fpm 而言 异步：针对 swoole 封装的一些io操作而言，比如redis ,mysql ，还有http tcp server， 还有之前的多进程下载的实现，遍历url，每个url都放到task中执行，完美多进程，easy(不要想着在worker 在生成新的process 哦， 官网上说很占资源)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker]]></title>
    <url>%2F2019%2F07%2F06%2Fdocker%2F</url>
    <content type="text"><![CDATA[学习docker主要是因为他部署环境太方便了，相比较传统的傻瓜式yum还有稍微高大上一点的自己编译，docker在搭建环境速度上真的是太快了，而且可以避免一系列的乱七八糟的问题，就比如用安装easyswoole 这个框架，当我们用composer + easyswoole install 生成目录结构的时候或多或少出现一点问题，但是当我们下载easyswoole 提供的Dockerfile 的时候，我们只需要 1docker build . (包含Dockerfile的文件目录) 就能快速生成一个运行着easyswoole框架的环境，但是我不知道怎么把宿主机也就是本机的目录映射到docker app中，虽然通过docker run -v 可以，但是当我docker cp (docker app 中的easyswoole初始目录) (宿主机目录)，我发现总是有些文件夹没有复制出来，问题还没有解决，还有docker compose， docker 多app 分工合作还是没有弄回,慢慢学吧 docker 软件的安装（修改远程仓库的名称）docker 是 cs 结构(类似 mysql, redis 都是，只是docker 客户端和服务端连接用的restful，感觉像走的http协议)，我们安装好docker之后，通过修改docker 的国内镜像，加速docker pull 拉取镜像的速度（如果是yum，修改/etc/docker/damon.json文件，可能重启systemctl reload docker 会报错，是因为systemctl start docker 的时候 -t 指定了resposity远程仓库，我们修改一下，删除这个参数就好了） 镜像(images)docker pull imagesName //从远程仓库拉取镜像(docker hub, 类似github的存在,像阿里云这些都是对docker hub的备份，可能有几秒的延迟，没啥事) docker images // 查看本地所有镜像 docker search imagesName// 查找镜像 (关于镜像名称， 仓库名(所有者)/镜像名称:tag, 要是没有仓库名就是官方镜像，tag 是标签，比如php-7.2:cli,这种细分一下) docker run imagesName (镜像名称) // 默认先从本地找，找不到去远程仓库找 (特别要注意的就是run centos 这种操作系统的时候，我么需要docker run -it 镜像名称 /bin/bash ， 这样才能让这个app一直运行，否则他会立刻断开，没有实际的意义, 像一些简版的centos 比如 alpine 版本，可能没有 /bin/bash, 我们可以 /bin/sh) (还有就是 不同版本的centos 安装软件的方式可能不同，可能是yum,可能是agp-get install, 可能是别的，我们只需要换源，然后百度安装对应resposity库下面的软件就好了) (-r 代表运行结束就删除了， -d 守护进程方式， -p 8000:80 端口 映射， -v /home:/home, 文件夹挂载， -name 给容器取个名字，否则默认分配个名字) docer cp (从宿主机到虚拟机或者从虚拟机到宿主机) docker inspect imagesName // 查看一个镜像的详细信息，比如挂载了哪些目录，暴露了哪些端口 dokcer rmi imagesName // 删除镜像 容器 containerdocker images 启动之后就产生了 container，容器 docker ps //查看运行的容器 docker ps -a // 查看所有运行过的容器 docker exec -it containerid(容器名称) //进入容器内部 docker rm containerId //删除容器 Dockerfile 编写 docker compose]]></content>
  </entry>
  <entry>
    <title><![CDATA[重庆]]></title>
    <url>%2F2019%2F05%2F15%2F%E9%87%8D%E5%BA%86%2F</url>
    <content type="text"><![CDATA[第一次一个人出门，记录一下~ 携带物品all need:身份证，钥匙(不要企图你的室友帮你开门，我们都是独立的个体，自己的事情自己做啦），充电宝(！！！一定要带一个安卓头的充电线，因为你可能需要给充电器充电呀，充电宝要注意实际的毫安大小，避免过大不能携带上飞机的尴尬，知乎上有具体的参数)， 零钱(虽然重庆做公交可以用腾讯小程序乘车码，轻轨也是，但是有的地方轻轨买票好像只能用零钱，但是换100的零钱把，有十元有1元的那种，免去做公交付10元的尴尬)person need: 充电牙刷，牙膏，毛巾，睡衣 坐飞机虽然不是第一次坐飞机，但距离上次坐飞机已经一年了，还是记录下，因为下次坐飞机可能又忘了呢。携程上订的票，提前一个半小时到达机场，到不同航空公司的窗口下办登机牌，登机牌就是把网购的票换成实际的票，可以选位置，托运行李，电脑是不能托运的哦（小su哥说航旅纵横可以直接用电子版的登机牌，下次有空试一下），然后就是找登机口啦，机票上有写，不同机场不一样，比如上海浦东分国内起飞和国外起飞的口，这个口进去实际上是安检，把你身上的电子产品拿出来检查，但是重庆的因为是国内机场嘛，所以会把比如c1~c99走这个口安检，c100~c102 走那个口安检，安检过后才是走去正真的口等飞机排队总结： 网上订票—&gt;特定口办理登机牌—&gt;过安检—&gt;特定口等飞机 出机场：跟着人流走喽，其实就是找地铁或者你需要的交通工具，重庆是江北机场，出了航站楼，有机场大巴（叫k01?忘记了），因为我住在解放碑旁边的大溪沟，所以做机场大巴很方便，15元，直达重庆大致就是这种场景，刚开始看很壮观，后面就习惯了，低头玩手机（重庆是个3D城市，所以我觉得还是自己多走走路比较好，重庆打车很便宜，基本上都是不超过20元，南山那边老城区更便宜） 住宿：我在知乎上查了一下，大家都推荐民宿，名宿相比较七天，速八，同等价位比如200，感觉还是名宿划算点，但其实不是环境，而是位置，给个对比你们看下，网上：实际：没有那么夸张，但我住的地方位置还不错，虽然是瞎选的，出门就是大溪沟轻轨站，还有公交站，重庆的轻轨比较挤，那就打车把，重庆的出租车司机人都挺好的，其实你自己开着导航就知道他绕没绕路了呗。还有！！！一定要注意轻轨的标志，因为重庆的轻轨站在有些地方还是比较少的，所以我上次去鹅岭公园坐轻轨始终找不到，其实就在我旁边，一个绿绿的标志，别到处找上海那个蓝蓝的地铁标志了，哈哈哈，（网红李子坝,体验下，sry ，忘记拍照了，如果从大溪沟去鹅岭二厂就会路过啦）这是我刚下机场大巴看到我住的地方楼基本都是40层 day1:4点下飞机 —&gt; 5点到家—&gt;7点出门—&gt;解放碑—-&gt;八一好吃街—-&gt;洪崖洞—-&gt;千x桥—-&gt;回家解放碑就是带着一个碑的步行街挺小的，如果不购物的话，走不到一个小时吧，中间碰到国家图书馆然后去八一好吃街吃东西，因为我不爱吃辣嘛，所以吃的都是甜的，比如糍粑，冰汤圆，芋头这种东西，吃完了就可以去洪崖洞啦，洪崖洞比较好的观看场景是千x桥，我是周六去的，桥上人不太多，桥也挺短的，我走了个来回这是桥的对面可以在桥的对面玩一下再回去，比如南滨路，大剧院这是洪崖洞你们可以趁早先排队进洪崖洞，晚点的时候人就挺多的了，我当时只是看了远景，没有去洪崖洞里面看，所以9点我的行程就结束了，其实这个时间还早，对于重庆来说，真正的夜生活可能才刚开始 day2:轻轨—&gt;李子坝地铁站—&gt;鹅岭二厂—-&gt;鹅岭公园—-&gt;川美虎溪—&gt;磁器口—&gt;回家–&gt;观音桥第二天应该是我最开心的一天，唯一的遗憾就是出了虎溪我的行程就结束了，所以大概是10点到3点，本来是有个朋友来，所以我在4点之后就回家等他了，可是他临时鸽了，要不然可以更丰富。从李子坝地铁站出来，走到鹅岭二厂可能比在鹅岭二厂玩起来更开心，当时天下着蒙蒙雨，路上没有多少人，跟着百度地图走着盘山公路，差点走过了一条大马路上，开了个小口，忘记叫什么路了，很陡，蛮有意思走了不久，就看到鹅岭二厂啦，原谅我忘记拍logo， 小店老板说晚上来比较热闹，好吧，我是好孩子，10点之后不出门。 鹅岭鹅厂其实就是几栋废弃的楼改造的，出来之后就继续去看鹅岭公园啦 小朋友们在正儿八经的写生，可是你们画的太丑啦，哈哈哈哈 下山做地铁去川美喽（川美虎溪那边比黄那边好挺多，建议时间不够的话去那边，那边还有别的很多大学） 晚上去了观音桥，还有个什么书店来着，忘记了，那就放图吧 这应该是我最喜欢的壁画了 观音桥看到了很多人跳广场舞，然后是观音桥小吃街，卖生蚝的店家真的黑心，不要去 day3:长江索道—&gt;南山一棵树观景台—&gt;南山植物园—&gt;山鬼—&gt;南山书店—&gt;南山书店之小森林—&gt;山下逛了逛—&gt;回家第三天应该是这次旅行最失败的一天，完全可以纳到某天晚上的行程，因为南山那边完全就是看夜景，白天没啥看头，下了长江索道（长江索道不要期望太大，很普通）,因为观光巴士要等很久，所以直接打车上山（长江索道那边可以买套票，还好没有买观光巴士的票），司机师傅是个日语说的很6的男人，在日本呆了挺久，人很好说话，！！！开了那么久竟然只有11元，到了南山一棵树，当时人太少了，所以我一个人不敢上山，还下着雨，所以呢，我花了30的门票就在门口呆了30分钟，上照片 出了门做了一个大叔的车去南山植物园，他收了30元，因为百度地图显示打车25元，所以同意了（真的相比较别的地方景区太良心了），植物园也挺没意思的，主要一个人懒得走，所以也是只是去了室内植物园就出来了， 继续往上走，去找南山书店喽，中途路过山鬼，重庆很多网红地方入口普通的就和不存在一样，比如这个山鬼，小红书上到处种草，可是我路过竟然没发现，（山鬼就是个面朝大山的玻璃屋，哈哈哈），南山的那些网红书店其实也蛮普通的，就是用来拍照的，里面的点心挺普通，虽然我每家都不好意思不点 下山之后就是给网红建筑拍拍照，据说夜景挺好，第三天完全可以一晚上搞定 day4：川美（黄x校区）—&gt;涂鸦一条街–&gt;钟书阁—&gt;坐飞机回家 川美这个老校区很小，没什么人，可能是周二吧，那就上图喽 川美有个门对面是一个创意基地，里面是工作的地方，外面有些涂鸦，那就打卡下吧 涂鸦街就是一条路上房子被涂鸦了，其实也挺一般，有个交通茶馆，哈哈哈，挺难找，因为入口处太普通了，进去了就是老年人的酒吧，因为都是老人，就没有长时间都留了，去钟书阁喽。 钟书阁在一个商场里面，不要跟着百度地图绕着那个商场走，···我真的太傻了，随便进一个商场口，问一下就好了，在三楼，不算大，其实我感觉不管是南山书店还是这个钟书阁，实际意义上更像一个咖啡厅，因为一直有着轻柔的音乐，没有图书馆那么安静 因为下午5点的飞机，我12点就没事了，所以在这个地方看了1小时比赛，1点的时候往飞机场赶，其实能呆更久，但我做事比较着急啦 最后：这次去重庆因为第一次一个人出门嘛，虽然做的事情不多，但是收货还是蛮大的，毕竟只能靠自己，后来我觉得我可能更喜欢泸沽湖那样的地方，有山有水，重庆是一个网红城市，更适合拍照]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>重庆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续交付]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%2F</url>
    <content type="text"><![CDATA[上面要求代码从svn改成git,需要一个私有化的代码管理工具，于是想到了gitlab, 其实我们人这么少，一般一个前端，一个后端，流程简单，svn和git 用起来没啥区别，可是呢上面说了，那就改吧 ！！！上面的是以前的想法，现在的话就是git 无敌~~~ 对于持续交付我现在的理解还不是十分深刻，目前就理解成每个程序员代码的上传到发布整个流程吧。 最开始我们是svn，我不知道svn 有没有分支这个说法。当我们在没有分支的情况下，本地代码只有一份，如果我们想放下手头的工作，去新开一个bug 或者feature ，这都是不允许的，都是要在之前工作的基础上，或者你换一个文件夹。鉴于上面的问题，我们引入了git。 最开始引入git，我是想一个文件夹即用git 管理也用svn 管理，svn 管理的我用来上线，git 管理的用来feature开发，每次上传文件的时候，我都不处理git 管理的那个文件夹，这样既保证了我的线上服务器代码没有改变，也能保证新的代码通过git传输到了另一个地方，于是我在我们阿里云上又安装了一个git仓库。 直到后面到了老东家，我才 意识到我搭建的git 仓库功能其实就是gitlab，而且gitlab相比较会容易安装的多，但是经过手动搭建git仓库，让我更加理解git 了。 上面说的都是代码的上传，共享，那怎么发布呢？像我们之前,就是在对外服务器上装一个git，然后把git服务器上的代码拉下来，完成更新，php这样就好了，对于前端项目，还需要npm run 和 npm install, 然后把dist 目录对外暴露就好了。 上面就是itbasic 的对外访问路径，因为只有一个域名，所以通过文件夹的形式提供类似不同的虚拟站点 gitlab 搭建https://blog.csdn.net/Abysscarry/article/details/79402695慕课网教程上那么复杂是因为配置了本地https唯一一点没有提到的就是自定义域名的文件位置，如果用yum安装的话在 /etc/gitlab/gitlab.rb下面。 gitlab使用默认有个root账户，自己设置密码， 可以创建用户和项目创建项目类似github 上创建项目，后面项目的提交就是git 的使用创建用户的话如上，主要是那个reqular和admin, 这块不是项目权限，应该是类似整个gitlab 的权限， 新建的用户可以给个初始密码，然后用户登陆的时候可以修改，用户提交代码需要把ssh 公钥粘贴到gitlab 上，一切和github类似 配置项目权限 （管理员才有这些权限，比如root） 点击项目，给项目配置人员信息 目前只配置了develop和 master ,develop 是开发者，开发者不能向master 分支提交代码。只能自己开个feature分支，提交之后再gitlab 上面提交merge 申请，这个项目的master 可以merge , 这个项目的master 可以直接向master 分支提交代码 上面的administrator / test , administrator 是用户名， test 是项目名 监控系统信息(感觉这个可以放在一般的管理系统中，掌握服务器情况) 今天新建一个项目的时候总是显示密码错误，主要原因可能是项目建成了private ， 没有解决问题，但发现了另一个问题，我下载项目的时候总是显示password ,那他是怎么识别我的name呢，答案是gitlab 上贴的ssh key，我们的每一个gitlab 用户或者 github 用户都要至少绑定一个ssh key,就是通过这个ssh key 识别我们用户名称的,我们在用gitlab 提交代码时候总是显示要配置用户名和密码，可以全局配置也可以在单个项目中配置，所以这个并不是我们登陆github 或者gitlab 的用户名，这个只是我们提交时候日志上面显示的内容。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 反射]]></title>
    <url>%2F2019%2F03%2F06%2FPHP-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[故事背景：在做文件上传的时候，对图片的上传和视频的上传走的是相同的接口，可是视频和图片有些参数是不同的，于是通过一个基类base,扩展出多个子类，image,video ···上传类，根绝参数的不同调用不同类的upload方法。 简单点说反射的就是让你拥有剖析类、函数的能力。 有的同学可能会问我剖析类有什么用，我为什么要学反射，我只能说不学反射并不会对你实现业务有任何影响，但是如果你想写出结构优雅的程序，想写出维护性和扩展性都很高的程序，学习反射是必不可少的。 Laravel 中依赖注入用的就是反射。参考文章 base类 1234567891011&lt;?phpnamespace App;class Base&#123; public $name = &apos;&apos;; public function upload() &#123; var_dump($this-&gt;name); &#125;&#125; video 类 12345678&lt;?phpnamespace Appclass Video extends Base&#123; public $name = &apos;video&apos;; &#125; image 类 1234567&lt;?phpnamespace Appclass Image extends Base&#123; public $name = &apos;image&apos;;&#125; 反射类 12345678910111213141516171819202122&lt;?phpnamespace Appclass Upload&#123; public static alias() &#123; return [ &apos;video&apos; =&gt; \App\Video, &apos;image&apos; =&gt; \App\Image ] &#125; public fileUpload($type) &#123; $classArr = self::alias(); $className = $classArr[$type]; $reflection = new ReflectionClass($className); // 获取反射对象 return $ref-&gt;newInstance() // 获取类实例化对象 &#125; &#125; 上面代码只是一段很简单的使用反射实现的代码，其中对实例化参数的判断，类是否能实例化等诸多反射的方法都未使用到。 总结一下我在使用easyswoole 写代码过程中的感觉： 首先想熟练的使用easyswoole,必须得熟悉swoole,比如对swoole http server 的配置，举个例子，当上传文件大于easyswoole 默认上传文件总的大小的时候，easyswoole(包括swoole)的tcp 链接会主动断掉，但是swoole的服务器端会打印一个warning ,显示传输文件过大，但是easyswoole 不会，服务器端不报异常，只是客户端建立不了链接，这就很尴尬了，之前还以为是端口号或者自己代码哪里出了问题。（ps:php文件上传和两个参数有关，一个是php.ini 里面的upload size, 一个是post size, 如果是swoole 上传的话，还和swoole 的配置项有关，在easyswoole 中对http server 的配置和swoole 中对http server 配置一样，只是参数修改的位置不一样罢了） 再者是对easy swoole 的使用，之前习惯于查看文档或者手册去学习（比如laravel 和 php 手册），对其中的所有的方法都有详细的解释，我们应该学会通过查看源码去学习其中方法的使用，比如easy swoole 中对获取参数这些都没有doc 文档，我们可以在request 类下面查看有哪些可以调用的方法，或者是通过编辑器补全 说到编辑器补全，之前发现的一个问题就是比如上传类，当可能返回上传类或者null 的时候，通过链式调用，上传类的方法得不到补全，可是我们通过php7的返回结果限制，就能让编辑器自动补全了 123456789101112131415&lt;?phpclass Request&#123; public function uploadFile($name) :?UploadFile &#123; if ($file[$name]) &#123; return $file[$name] &#125; else &#123; return null &#125; &#125; &#125;// ?代表可能是Null 当我们想知道这个结果有哪些可以调用的方法的时候，我们可以直接打印这个结果，查看属于哪个类，然后我们到这个类下面查找，比如我之前想知道反射的 getParamtes 方法返回结果的foreach 中的value 有哪些可以调用的方法的时候，查看这个value 的类，然后查看这个类有哪些方法，比如getClass()-&gt;name, 就是获取参数提示符（这个参数提示符还是蛮奇怪的，Bag 这种自定义的类可以提示， 但是 string int 这种类却不提示） 今天在查看easyswoole源码的时候,发现自己对public protected private 都忘记了,首先public 是最简单的，protected 本类和继承类中可以使用，private只有本类中可以使用 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php class A &#123; public function __construct() &#123; &#125; public function test1() &#123; echo 1; &#125; protected function test2() &#123; echo 2; &#125; private function test3() &#123; echo 3; &#125;&#125;class B extends A &#123; public function test4() &#123; $this-&gt;test2(); &#125;&#125;$b = new B();$b-&gt;test1();$b-&gt;test4();$b-&gt;test2();//$b-&gt;test3(); ​ 下面文章来源 PHP 内置了一组反射类来实现类的反射，常用的有： ReflectionClass 解析类 ReflectionProperty 类的属性的相关信息 ReflectionMethod 类方法的有关信息 ReflectionParameter 取回了函数或方法参数的相关信息 想看全的就翻手册去。 今天先通过一段演示代码简单看下php的反射到底是个什么东西。 例子1： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpclass Hero &#123; protected $name; protected $skills = []; public function __construct($name, $skills = []) &#123; $this-&gt;name = $name; $this-&gt;skills = $skills; &#125; public function attack($hero) &#123; echo &quot;Attack &#123;$hero-&gt;name&#125;&quot; . PHP_EOL; &#125; public function execute($index) &#123; echo &quot;Axecute &#123;$index&#125; skill&quot; . PHP_EOL; &#125;&#125;$ref = new ReflectionClass(&apos;Hero&apos;); // 参数类名if ($ref-&gt;isInstantiable()) &#123; echo &apos;可以实例化&apos; . PHP_EOL; // 判断是否可以实例化，比如单例或者静态类的存在&#125;// 获取类的构造函数$constructor = $ref-&gt;getConstructor();print_r($constructor); //ReflectionMethod E对象//获取属性if ($ref-&gt;hasProperty(&apos;name&apos;)) &#123; $attr = $ref-&gt;getProperty(&apos;name&apos;); print_r($attr); //ReflectionProperty 对象&#125;// 获取属性列表$attributes = $ref-&gt;getProperties();foreach ($attributes as $row) &#123; //row 为 ReflectionProperty 的实例 echo $row-&gt;getName() . &quot;\n&quot;;&#125;// 获取方法if ($ref-&gt;hasMethod(&apos;attack&apos;)) &#123; $method = $ref-&gt;getMethod(&apos;attack&apos;); //$method 为 ReflectionMethod 的实例 print_r($method);&#125;// 获取方法列表$methods = $ref-&gt;getMethods();foreach ($methods as $row) &#123; //这的row 是 ReflectionMethod 的实例 echo $row-&gt;getName() . PHP_EOL;&#125; 想知道上面代码的用途，最好的办法就是执行一下，自己打印一遍(如果用xdebug 对这种脚本式的执行是再方便不过了) 上面例子想表达的效果就是：仅仅通过类名，就能了解类的内部结构，进而去实例化类 例子2： student 12345678910111213141516171819202122232425262728&lt;?phpclass Bag&#123; public function name()&#123; return &quot;学生包&quot;.PHP_EOL; &#125;&#125;class Student&#123; public $id; public $name; public function __construct($id,$name,Bag $bag) &#123; $this-&gt;id = $id; $this-&gt;name = $name; &#125; public function study() &#123; echo $this-&gt;name.&apos; is learning.....&apos;.PHP_EOL; &#125; public function showBag()&#123; echo &quot;My bag have &quot;.$this-&gt;bag-&gt;all(); &#125;&#125; run 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?php require &apos;student.php&apos;;function make($class, $vars = []) &#123; $ref = new ReflectionClass($class); if(!$ref-&gt;isInstantiable()) &#123; throw new Exception(&quot;类&#123;$class&#125; 不存在&quot;); // 感觉这块应该是累不可以实例化 &#125; $constructor = $ref-&gt;getConstructor(); if(is_null($constructor)) &#123; return new $class; &#125; $params = $constructor-&gt;getParameters(); $resolveParams = []; foreach ($params as $key=&gt;$value) &#123; $name = $value-&gt;getName(); if(isset($vars[$name])) &#123; $resolveParams[] = $vars[$name]; &#125; else &#123; $default = $value-&gt;isDefaultValueAvailable() ? $value-&gt;getDefaultValue() : null; if(is_null($default)) &#123; if($value-&gt;getClass()) &#123; // 依赖注入的实现，以这个为例子 // 需要Bag $bag ，却没有传入 bag，自动实例化 // 如果需要参数，直接在vars 里面加，但感觉参数名称不能和原本的冲突 $resolveParams[] = make($value-&gt;getClass()-&gt;getName(), $vars); &#125; else &#123; throw new Exception(&quot;&#123;$name&#125; 没有传值且没有默认值。&quot;); &#125; &#125; else &#123; $resolveParams[] = $default; &#125; &#125; &#125; return $ref-&gt;newInstanceArgs($resolveParams);&#125;// 没有提供name 值try &#123; $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1]); print_r($stu); $stu-&gt;study();&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125;// 提供name 值try &#123; $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]); print_r($stu); $stu-&gt;study();&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125;// 需要 Bag ，却没有传入try &#123; $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]); print_r($stu); $stu-&gt;study(); $stu-&gt;showBag();&#125; catch (Exception $e) &#123; echo $e-&gt;getMessage();&#125; 可以看到构造函数的第三个参数 $bag ,被自动实例化了，然后传递给了 Student 类的构造函数，这个部分很关键，这个地方可以用来实现依赖注入，我们不必在手动实例化对象了，我们可以根据参数的对应的类来自动实例化对象，从而实现类之间的解耦。 // 感觉这个解耦就是不用手动去传参数，避免类修改的时候自己大片代码需要修改 例子3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php// 这个不能算是容器，容器是反射的一种高级应用，下面的只是反射的一种基础应用if (PHP_SAPI != &apos;cli&apos;) &#123; exit(&apos;Please run it in terminal!&apos;);&#125;if ($argc &lt; 3) &#123; exit(&apos;At least 2 arguments needed!&apos;);&#125;$controller = ucfirst($argv[1]) . &apos;Controller&apos;;$action = &apos;action&apos; . ucfirst($argv[2]);// 检查类是否存在if (!class_exists($controller)) &#123; exit(&quot;Class $controller does not existed!&quot;);&#125;// 获取类的反射$reflector = new ReflectionClass($controller);// 检查方法是否存在if (!$reflector-&gt;hasMethod($action)) &#123; exit(&quot;Method $action does not existed!&quot;);&#125;// 取类的构造函数$constructor = $reflector-&gt;getConstructor();// 取构造函数的参数$parameters = $constructor-&gt;getParameters();// 遍历参数foreach ($parameters as $key =&gt; $parameter) &#123; // 获取参数声明的类 $injector = new ReflectionClass($parameter-&gt;getClass()-&gt;name); // 实例化参数声明类并填入参数列表 $parameters[$key] = $injector-&gt;newInstance();&#125;// 使用参数列表实例 controller 类$instance = $reflector-&gt;newInstanceArgs($parameters);// 执行$instance-&gt;$action();class HelloController&#123; private $model; public function __construct(TestModel $model) &#123; $this-&gt;model = $model; &#125; public function actionWorld() &#123; echo $this-&gt;model-&gt;property, PHP_EOL; &#125;&#125;class TestModel&#123; public $property = &apos;property&apos;;&#125; （以上代码非原创）将以上代码保存为 run.php （以上代码非原创）将以上代码保存为 run.php运行方式，在终端下执行php run.php Hello World 可以看到，我们要执行 HelloController 下的 WorldAction, 可以看到，我们要执行 HelloController 下的 WorldAction,HelloController 的构造函数需要一个 TestModel类型的对象, 通过php 反射，我们实现了, TestModel 对象的自动注入， 上面的例子类似于一个请求分发的过程,是路由请求的分发的一部分，假如我们要接收一个请求 地址例如： /Hello/World 意思是要执行 HelloController 下的 WorldAction 方法。 上面的例子有个最大的缺陷就是所有类写在一个文件中，导致没有使用bind 也不会出错 （注意container 中没有自动加载） 发现：感觉依赖注入的类的参数都是空的，都是直接就能实例化的那种 感觉上面那个发现并不多 控制反转：就是通过一个container 容器去解决依赖关系，把类的实例化从类的内部改成从外部传入 123456789class Person&#123; public function buy($obj) &#123; // $obj = new Car(); 改成依赖注入的模式 $obj-&gt;pay(); &#125;&#125; 但是这个obj 我们不希望手动传入，希望可以帮我们自动生成，于是就出现了依赖注入（通过类的反射实例化类，但这个类我们要提前绑定到容器中，要不然可能找不到，我们的容器可没有自动加载机制，容器一般有两个方法bind 和 make, bind 一般是 一个类的标识 和一个匿名函数，make 实例化这个类的标识，执行之前绑定的匿名函数，这就是最简单的container） 能解决的问题： 当我们把依赖类通过注入的方式传入的时候，我们可以只是传入这个类的类型（接口），当我们使用的时候可以在这个容器中为这个类型不同的实体类，达到switch 切换的效果]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>依赖注入</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序]]></title>
    <url>%2F2019%2F02%2F25%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近学习了下小程序的编写，理由： vue 还有 react 没学会，小程序是真的简单 ，类似后台模板引擎 微信不会弹广告，vue或者react 编写的webapp 在一些安卓手机浏览器上，比如魅族自带的浏览器，访问的时候会有很多广告的出现 不用记域名，之前在做itbasic的时候，就发现大家都记不住域名，导致pc端还好，大家可以收藏域名，手机端完全不会去使用 练习js, 熟悉es6这篇文章的目的不是介绍小程序的简单使用，只是想记录下容易忽略的知识点（包括es6中），完成了项目的时候才发现，代码是练出来的，而不是看出来的 目录结构 app.wxss 是全局样式文件，比如我们想让每个page页面的背景色从白色变成灰色，可以在这里面定义，又比如我们对iconfont 的使用。 iconfont 的使用我们在编写前端页面的时候经常会需要小图标，现在比较流行iconfont, 我们在阿里的那个官网上选择好图标然后选择添加至项目 选择项目名称 选择font class ,在线链接，查看线上地址，复制所有css ,保存到本地，然后在这个全局css 中引入，就可以全局使用了1@import &apos;styles/iconfont.wxss&apos;; 我们通过修改font-size 和 color 可以修改图标的大小和颜色（毕竟实际上这些图标都是字体） app.json主要是页面pages 路径的配置，一些基础配置，tabBar (注意tabBar 没有对应的pages ，pages页面上是不会显示tabBar的)， 引入的组件如果想全局使用，也可以在这个页面上配置 components编写的组件位置，其实和pages文件夹差不多，感觉就是组件里面文件一般用index 命名，而pages 里面一般用文件夹名称命名 其他的文件夹都是可以自己定义的，其实小程序只是给了一个标准的最简单的项目目录，很多时候都可以自己定义文件夹，然后引入12345678引入 jsimport &#123;config&#125; from &apos;../config.js&apos;这个config.js 中被引入的内容需要在文件中导出const config = 4;export &#123;config&#125;感觉和PHP 不一样的地方就是php 一般都是include 文件，而不是对具体变量的引入和导出，当然现在很多时候php 一个文件就是一个class,也是类似一个变量的存在 小程序知识wxml页面，wx:if , wx:for 去判断，循环页面元素，rpx 是小程序上的计量单位，没听懂，反正知道通过使用它，可以实现页面的自适应flex 页面布局1234display:flex;flex-direction: row;just-content: (主轴) row 横着排列（横 主 纵 副）column (纵 主 横 副) space-between 等（todo: flex 均分怎么实现）align-item: （副轴） positon12position:relative (相较于自身)position:absolute(因为一般只有固定在底部或者首部用到，所以一般这样定位的话就是相对于页面) 目前用到的元素：view ,image(类似view)绑定点击事件 bind:tap, bind:like引入组件：在该pages json 文件中引入，或者全局json 中引入，（父组件给子组件传值通过属性）然后用组件名称使用，在父组件上定义属性，传入子组件定义的data中（子组件给父组件传值通过事件，子组件抛出事件，触发父组件绑定的事件） jslet 新的定义变量方式，if 或者 for 中定义的，外面获取不到const 不能改变的量onLoad 方法中一般写入初始化的时候对后台接口的请求（蛋疼的就是经常页面加载的时候出现抖动，当返回数据比较慢的时候）自定义的方法就写在最外层就好了data : 定义页面中的值，初始化setData :改变页面中的值wx.getStorage() 感觉这些就是类似调用系统接口，应该安卓和ios 中用的比较多，这是微信封装的，注意其中的同步和异步之分 推荐组件vant 有赞出的小程序组件，只有用过小程序原生组件才会知道vant 用起来有多么方便，npm 安装 值的注意的是：事件 event.detail 能获取到这个组件本身，之前我们经常用event.detail.value 获取组件传递的值，通过event.detail去调用组件自身的一些方法，比如日期picker 上显示的日期大小]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架学习-获取请求参数]]></title>
    <url>%2F2019%2F02%2F25%2F%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[PHP属于一门高级语言，感觉就是那种语言里面偏向于应用层的语言，再加上lnmp架构还有框架的存在，对于http请求过程中的细节封装了太多层，导致我们实际在使用过程中得到的参数已经是面目全非的样子，记录下对其探索的历程 问题出现在很久之前，有一次我用json数据去请求我们itbasic的接口，可惜没法解析，我原本以为是框架的原因，于是我开始打印$_POST中数据(post 方式提交)，可是其中也是毫无结果，算了，不处理了，搞不定，反正用不到~昨天，前端小朋友再次发现这个问题，感觉很简单，为了维护自己的高大形象，就处理下吧。 首先是关于content-type 的理解： 一般是指网页中存在的Content-Type，Content-Type属性指定请求和响应的HTTP内容类型。如果未指定 ContentType，默认为text/html。 上述问题中为什么会出现指定请求和响应的HTTP内容类型，因为content-type 在request中可以设置，在response中也可以设置，在request 中设置代表我发送的请求，在response中的设置代表从服务器返回的内容。 常见的： 123456781.text/html2.text/plain3.text/css4.text/javascript5.application/x-www-form-urlencoded6.multipart/form-data7.application/json8.application/xml 我们在接口调用的时候常用的是后面4个 x-www-form-urlencoded 会将表单内的数据转换拼接成 key-value 对（非 ASCII 码进行编码） 编码方式应该是urlencode 还记得自己刚写php代码时候吗，那时候最基础的功能是实现一个表单提交 12345&lt;form enctype=&quot;application/x-www-form-urlencoded&quot; action=&quot;http://homeway.me/post.php&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;homeway&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;key&quot; value=&quot;nokey&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/form&gt; 然后服务器端就可以用 123&lt;?php$name = $_POST[&apos;name&apos;];$key = $_POST[&apos;key&apos;] 实际接收到的内容（通过swoole rowContent 打印出来，获取原始的POST包体，用于非application/x-www-form-urlencoded格式的Http POST请求，返回原始POST数据，此函数等同于PHP的fopen(&#39;php://input&#39;)） 所以其实$_POST 就是对上述dept_name 进行 &amp; explode, 然后urldecode 一下 multipart/form-data最先接触这个东西的时候是文件上传的时候 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。 postman 中发送请求 平时我测试接口的时候经常用的是form-data, 服务端实际接受到的数据如下(swoole) 12multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件这种方式不会对中文进行编码 既可以上传文件等二进制数据，也可以上传表单键值对， 所以本该用来进行上传文件的请求方式，我平时用它来进行普通接口的测试，通过这种方式提交数据也可以通过PHP 的 $_POST 来获取到 ，上述中的boundary用来分割数据 看到了postman 上面的raw吗 raw 原始类型，可以上传任意格式的文本，比如 text、json、xml、html（中文不进行编码） 其中 json,text,html 都是通过这种方式，然后添加content-type text/xml微信中经常用这种方式，之前在开发企业号的时候经常遇到 123456789101112131415POST http://www.homeway.me HTTP/1.1 Content-Type: text/xml&lt;?xml version=&quot;1.0&quot;?&gt;&lt;resource&gt; &lt;id&gt;123&lt;/id&gt; &lt;params&gt; &lt;name&gt; &lt;value&gt;homeway&lt;/value&gt; &lt;/name&gt; &lt;age&gt; &lt;value&gt;22&lt;/value&gt; &lt;/age&gt; &lt;/params&gt;&lt;/resource&gt; php中$_POST只能读取application/x-www-form-urlencoded数据，$_FILES只能读取multipart/form-data类型数据，(感觉$_POST 也能读取multipart/form-data 中的数据) 要读取那里面的数据只能用最原始的方法(同理json) 12$data = file_get_contents(‘php://input’);$request-&gt;rawContent() // swoole notice: 一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。(我根据这个新增框架中json 数据的解析) 1234567891011121314151617&lt;?php$getArr = static::$request-&gt;get; $getArr = count($getArr) &gt; 0 ? $getArr : []; $postArr = static::$request-&gt;post; $postArr = count($postArr) &gt; 0 ? $postArr : []; //后面的覆盖前面的，所有post写在后面 if (isset(static::$request-&gt;header[&apos;content-type&apos;])) &#123; if (static::$request-&gt;header[&apos;content-type&apos;] == &apos;application/json&apos;) &#123; $rawContent = static::$request-&gt;rawContent() ?: &apos;&apos;; $rawContent = json_decode($rawContent, true); $postArr = array_merge($postArr, $rawContent); &#125; &#125; return array_merge($getArr, $postArr); notice: 千万要注意：不能上来没有判断是json 就对rawContent 取到的内容进行切割，因为只有json 的时候切割才会符合我们预期，别的时候不会 上面就是post方式提交数据的几种情况，接下来我们说get方式（现在的restful api 还有delete put 等方式，我在各个文章上都没找到关于上面内容的解释，猜测一下，是不是delete put 本质上还是属于put 方式） 起因：之所以注意到get请求的这种方式，是因为再一次偶然的过程中发现get 请求的content-type 不存在，想了下确实合乎道理，get的参数都是拼接在url 上面 （file_get_contents(‘php://input’) 只能获取post请求中的输入） 注意就算是urlencode 加密，他们都是有字符编码的限制的，如果字符编码不一致，那么加密出来的结果将会不一样 同理可以联想之前做的aes-128-ecb 加密，为什么有那么多可选项，也是这个原因 这篇文章对于编码的解释很透彻 这篇文章和上面那篇文章都有简单描述urlencode是怎么实现的 (这篇文章中的很多坑我们写的时候没有碰到是因为很多默认配置的原因，比如php 字符集默认配置utf8,页面配置字符集 utf-8) 所以呢在通过get 方式传递参数的时候，我们一定要注意那些中文字符 urlencode 的时候（或者别的编码方式的时候设置的字符集是什么，是gbk 还是utf8,我们忽略这个问题是因为我们经常就默认都设置成utf8 导致很多时候这些细节会被忽略） 同理联想php中也有urlencode 函数，他的字符集是怎么设置的 所以呢，当我们出现乱码的时候我们还可以这样考虑下： 客户端传递过来的数据进行了怎么样的加密（字符集），get方式，post方式中的www-formedate-urlencode 服务端传递过来的数据进行了怎么样的解密（字符集） 在post方法里所要传送的数据也要URL encode，那么他是用什么编码方式的呢？ 在form所在的html文件里如果有段，那么post就会用此处指定的编码方式编码。一般大家都认为这段代码是为了让浏览器知道用什么字符集来对网页解释，所以网站都会把它放在html代码的最前端，尽量不出现乱码，其实它还有个作用就是指定form表单的post方法提交数据的 URL encode编码方式。从这里可以看出对于get方法来说，浏览器对数据的URL encode的编码方式是有浏览器设置来决定(或者在请求之前，我们提前对非asii码进行编码设置，这样决定权就从浏览器变成我们开发者)，（可以用js做统一指定），而post方法，开发人员可以指定。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架，HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密解密]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[作为一个底层码农，其实加密解密平时是用不到的，毕竟平时写的就是cms 的curd, 但随着API的流行以及老大对代码质量的重视，还有和别的部门的交互，于是需要加解密啦。原文 hash( hamc ) 和 加解密hash(hamc) 可以用的算法： md5, sha1, sha256, sha512 加解密：base64, aes 用途： hash 和 hamc ： 因为不能解密，所以一般用在签名过程中，怎么验证是否数据被用户修改了呢，用相同的密钥对于传递过来的数据重新加密一遍，和sign 比对，如果相等，那就没有人修改签名(注意这个密钥一定不能被知道，因为一旦被知道，劫持者可以根据密钥帮修改后的数据生成对应sign, 起不到保护的作用) 这篇文章是关于hamc ，hash 和md5 sha1 关系的讲解 md5: 经常用到，有时候我们需要固定长度的字符串，就可以用md5加密一下,md5 可以生成32位或者64位，依据不同的算法，js 好像经常出64位的，和php对接的时候要注意一下 sha1: 感觉和上面的md5类似（感觉就是两种不同的加密算法） 老李文章中对sha1 的描述： 其实跟前面的MD5同期的还有一个SHA1加密方式的，不过也是算法比较简单，所以这里就一笔带过吧。而这里即将要说到的SHA256 和 SHA512都是来自于SHA2家族的加密函数，看名字可能你就猜的出来了。 hmac: hmac 其实就是用上面两种算法（hmac-sha256, hmac-md5），再加上一个密钥进行加密（这个密钥感觉又类似salt 的存在） 12345678php中md5, sha1 都有直接内置的方法， md5(), sha1(), 用的都是hash 方式，可以如下验证md5(&apos;cy&apos;) === hash(&apos;md5&apos;, &apos;cy&apos;) // truesha1(&apos;cy&apos;) === hash(&apos;sha1&apos;, &apos;cy&apos;) // truesha256, sha512 php 没有内置的方法，需要借助函数 hash(&apos;sha256&apos;, data) 。可以通过hash_algos 查看hash() 支持哪些算法。hash_hmac 是另一种类似 hash 的函数，也支持 md5, sha256, https://www.php.net/manual/zh/function.hash-hmac.php, 常用函数，同样也可以通过 hash_hmac_algos 查看支持哪些算法 hmac 比较官方的描述 散列消息身份验证码 Hashed Message Authentication Code 。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥/秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。HMAC-SHA1简要来说，就是采用sha1算法，与HMAC机制相结合，制造出更加难以破解的加密串。 hash_hmac 在php中hash_hmac函数就能将HMAC和一部分哈希加密算法相结合起来实现HMAC-SHA1 HMAC-SHA256 HMAC-MD5等等算法。函数介绍如下： string hash_hmac(string $algo, string $data, string $key, bool $raw_output = false) algo：要使用的哈希算法名称，可以是上述提到的md5,sha1等 data：要进行哈希运算的消息，也就是需要加密的明文。 key：使用HMAC生成信息摘要是所使用的密钥。 raw_output：该参数为可选参数，默认为false，如果设为true，则返回原始二进制数据表示的信息摘要，否则返回16进制小写字符串格式表示的信息摘要（注意是16进制数，而非简单的字母加数字）。 php 中我们常用的还有下面的密码散列算法，四个方法 其中password_hash 默认算法是bcrypt (也不知道这个密码散列和上面的hash 有啥区别，从目前的bcrypt 上来看，就是把hash次数和salt 的内容都放在加密字符串中) bcryptbcrypt : 关于bcrypt 这里有个解释很清楚， 感觉上其实就是另一种算法的hash 我之前很好奇这种hash, 怎么验证，也不能解密呀，当看到上面这张图片的时候，完全明白了，他的salt 存在了他加密后的字符串中，有了salt 就和以前的md5加解密一样了(注意上面各个字段的意思，10代表hash 10次)，php现在经常用的一种加密密码的方式也很好用 12345md5(‘123456’) e10adc3949ba59abbe56e057f20f883e md5(‘123456’ . ($salt = ‘salt’)) 207acd61a3c1bd506d7e9a4535359f8a sha1(‘123456’) 40位密文 hash(‘sha256’, ‘123456’) 64位密文 // sha2hash(‘sha512’, ‘123456’) 128位密文 // sha2 1234567$str = password_hash(123, PASSWORD_DEFAULT); //默认 bcrypt， PASSWORD_DEFAULT 也代表了 PASSWORD_BCRYPT.二者都是1password_verify(123, $str); // 验证password_hash() – 对密码加密.password_verify() – 验证已经加密的密码，检验其hash字串是否一致. password_needs_rehash() – 给密码重新加密. // 其实感觉没啥必要，主要是因为感觉algo或者cost hash次数改变就会改变password_get_info() – 返回加密算法的名称和一些相关信息. 这篇文章php的password api说的挺好的 urlencode关于urlencode ，这篇文章说到的蛮好的，但是太长了 看看阮一峰老师的文章 , 我大致理解了下，首先php只有一个urlencode , 但是js 有两种，分别是 encodeUri 和 encodeUriComponent, php 的 相当于js 的后者，后者在加密url的时候会破坏url自身的完整性，他只适用于对url中的参数进行加密，因为会对:// 都进行转义，这样就不能当做url请求了 (ps: urlencode 啥作用，比如我发送了一个请求 http://www.baidu.com?url=http://chenye.com&amp;name=11, 我希望的是url参数 中携带着后面的name ，而不是name 和 url 同级别的关系，这时候只能用urlencode 加密特定的参数啦， 记得在express 中好像默认会帮助我们decodeUriComponent 关于http url部分) 加解密：数据 base64:感觉我平时用到最多的地方就是不能识别的二进制（乱码）转换成base64 或者 16进制 hex。 比如之前itbasic 上面图片转换成base64然后传给后端，后端php 再把base64解析成二进制，写入文件，保存成图片。 如果不用base64 上传图片我们还可以通过post 提交，http 协议是纯文本协议，我们怎么上传二进制的图片呢， http 有自己的机制，http 头部的mime 头也设定了该文件是图片，可以百度下怎么用node stream实现一个静态web 服务器。 php中很多加解密都是先生成二进制，然后转换成 base64 或者 16进制 （或者默认生成的就是 base64 ） （因为二进制可能含有不可见字符，复制粘贴都不方便） 这个评论更加深了纯文本协议的理解 base64_encode base64_decode base64 会让传输内容变大， https://www.zhihu.com/question/36306744， base64 出现原理和使用，这篇文章讲解的比较全面 （这个我就在图片处理的时候用到过，一些算法，比如aes， js 有 hex 或者 base64 的方式，感觉就是为了让过滤掉二进制中的特殊字符） 这种最原始的方式，因为不需要密钥，感觉不能算上加解密，确实在各个网站上也是这么感觉的 首先的区分下加解密和hash 的不同，对于md5() 这样加密之后理论上就不能解密的方式，我们一般称之为hash,在我们以往的网站编程中，对于用户的密码保存一般都是通过hash这种方式，通过把用户的密码拼接一个字符串，然后md5下生成的值保存到数据库中，下次用户登陆的时候，再次把用户输入的密码做上次同样的操作，对比和数据库中值是否一致，如果一致说明密码正确，否则密码错误。 加密我们平时生活中遇到最多的应该就是https 解析过程，因为非对称加密太消耗性能，所以我们传输过程需要对称加密（对称加密就是加密密钥和解密密钥一致，非对称反之），而对于密钥的传输我们用的是非对称（非对称因为密钥的不同又有公钥和私钥之分：公钥加密，私钥解密，数据不会被获取；私钥加密，公钥解密，数据不会被篡改）。 对称加密算法一般有AES(itbasic 请求datrix 那边用的就是这种，ecb 没有$iv 偏移量，cbc 有偏移量 ),DES,3DES，非对称有RSA 上图中，123456 就是对称加密过程中的密钥 最一开始的时候，我朝人民一般都是倾向于使用“天王盖地虎”，“宝塔镇河妖”这种加解密技术；然而，美帝用了一种叫做DES的技术进行对称加解密，这玩意一度成为业界通用的对称加解密技术，银行、五角大楼都爱用这玩意，可惜好景不长、世风日下、世态炎凉，这玩意的破解成本越来越低越来越低～～ 于是，为了续命，就又有一些白胡子老头给DES打补丁，缝缝补补搞出来一个玩意叫做3DES，继续用，又不是不能用…这个顾名思义就行了，别打我，真的：3DES就是用DES处理（注意是处理，我没说是加密）了三次的意思。就目前看来，3DES实际上用的可能也并不是十分广泛了，所以如果大家在选择对称加解密技术的时候，尽量避开DES和3DES就可以了。 呵呵，喜新厌旧的沙雕人类…虽然DES已经没人用了，但毕竟也是辉煌过，我觉得还是得动手表演一波儿。我们知道，在php7里，原来的mcrypt系列加解密已经被放弃掉了，官方建议我们使用openssl系列来进行加解密，所以确保你的PHP环境里安装了openssl标准扩展。 上面是原文中对于DES 和 3DES 的描述 1234567891011121314151617// 这个函数打印出来openssl支持的所有加密方法以及模式的组合$arr_ava_methods = openssl_get_cipher_methods(true);print_r( $arr_ava_methods );exit;// 返回值 [123] =&gt; aes-192-cfb8 [124] =&gt; aes-192-ctr [125] =&gt; aes-192-ecb [126] =&gt; aes-192-gcm [127] =&gt; aes-192-ocb [128] =&gt; aes-192-ofb [129] =&gt; aes-256-cbc [130] =&gt; aes-256-ccm [131] =&gt; aes-256-cfb [132] =&gt; aes-256-cfb1 [133] =&gt; aes-256-cfb8 [134] =&gt; aes-256-ctr 其中带有ede的，比如des-ede*这样的就表示是3DES 其中des 有如下几种 1234des-cbcdes-cfb*（注意后面的通配符星号）des-ecbdes-ofb 下面是如何通过des-ecb 的方式加密 123456789101112131415161718// 我们就选用des-ecb方法进行一次des加密$ava_methods = openssl_get_cipher_methods();$my_method = &apos;des-ecb&apos;;if ( !in_array( $my_method, $ava_methods ) ) &#123; exit( &apos;错误的加密方法&apos;.PHP_EOL );&#125;$key = &quot;123456&quot;;$data = &quot;helloMOTO&quot;;echo &quot;明文：&quot;.$data.PHP_EOL;$enc_data = openssl_encrypt( $data, $my_method, $key );echo &quot;密文：&quot;.$enc_data.PHP_EOL;$dec_data = openssl_decrypt( $enc_data, $my_method, $key );echo &quot;明文：&quot;.$dec_data.PHP_EOL;// 输出明文：helloMOTO密文：IbpWiZbAoNMiknX3jdeqmQ==明文：helloMOTO 接下来我们说说aes 的加密方式 12345678910111213$ava_methods = openssl_get_cipher_methods();// 选用aes-128-ecb$my_method = &apos;aes-128-ecb&apos;;if ( !in_array( $my_method, $ava_methods ) ) &#123; exit( &apos;错误的加密方法&apos;.PHP_EOL );&#125;// 加密用的密码$key = &quot;1234567812345678&quot;;// 加密的内容$data = &quot;12345678abcdxxoo12345678abcdxxoo&quot;;$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA );$hex = bin2hex( $enc_data );echo $hex.&apos; : &apos;.strlen( $hex ).PHP_EOL; aes-128-ecb, 其中128代表密钥的长度，多余的长度会被直接街去掉(这个可以通过代码验证下，比如12345 用密钥1234567812345678和12345678123456789分别加密，看结果是否一样，最后再用不满128bit来加密123456781234567 )，128bit 128/8=16 位，aes-192-ecb, aes-256-ecb, 这其中的192 ，256，都是同样的意思。 最后一个参数是OPENSSL_RAW_DATA，如果选用这个option的话，经过加密后的数据会是奇怪的二进制数据，无法直接通过文本方式查看，所以要看的话必须先使用bin2hex函数处理一下。 上面这段话一定要注意理解，反正我第一次没有理解，导致第一次加密数据失败，网上的很多aes-128-ecb 这种加密代码的封装中都携带着自己的逻辑，所以会误导视野。上述opensssl_encrypt(),如果没有用最后一个参数，直接返回的结果是加密结果base64 的结果，如果有了，返回的是一段奇怪的二进制数据数据，这里我们可以理解成原始数据（加密数据最原始的样子），我们可以通过base64或者 bin2hex 转换城对应的base64格式或者16进制格式 123456789101112明文：12345678abcdxxoo12345678abcdxxoo密文：c1391e34caf38f8c2a477cbda3772533c1391e34caf38f8c2a477cbda3772533d96aa42b59151a9e9b5925fc9d95adaf// 上面密文切分的结果c1391e34caf38f8c2a477cbda3772533 | c1391e34caf38f8c2a477cbda3772533 | d96aa42b59151a9e9b5925fc9d95adaf难道说明文“12345678abcdxxoo”被密钥“1234567812345678”加密后后的密文就是“c1391e34caf38f8c2a477cbda3772533”？DES和3DES会将明文以64bit（8字节）作为一个单元进行分组；AES则会将明文以128bit（16字节）作为一个单元进行分组；无论是AES还是DES，当最后一个分组的数据长度不满足分组标准长度的时候，会用某种填充方式进行填充；AES对一个16字节分组加密完毕后，分组大小依然为16字节；DES也一样 上面就是aes ecb 的处理过程 如果我们把加密的内容分组之后稍微修改下分组顺序再解密，可以得到原文分组顺序的不同 ecb太不靠谱了，竟然能修改，出现了cbc 模式 123456789101112131415161718192021222324$ava_methods = openssl_get_cipher_methods();$my_method = &apos;aes-128-cbc&apos;;if ( !in_array( $my_method, $ava_methods ) ) &#123; exit( &apos;错误的加密方法&apos;.PHP_EOL );&#125;// 密钥 和 明文$key = &quot;1234567812345678&quot;;$data = &quot;12345678abcdxxooxxooabcd12345678i&quot;;// 每种方法都有自己需要的iv向量的长度$iv_length = openssl_cipher_iv_length( $my_method );// 根据长度生成相应iv$iv = openssl_random_pseudo_bytes( $iv_length, $cstrong ); // 我就是一直把这玩意当成一个随机的字符串看待的，他真的就是一个随机字符串echo &quot;明文：&quot;.$data.PHP_EOL;$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA, $iv );$dec_data = openssl_decrypt( $enc_data, $my_method, $key, OPENSSL_RAW_DATA, $iv );echo &quot;解密：&quot;.$dec_data.PHP_EOL;// 神器的代码test2(1,$c); // 这样竟让不会报错function test2 ($a, &amp;$b) &#123; var_dump($a+$b, $b);&#125;exit; 今天和我司员工对接cbc模式，~~不出意外，这条产品线的小伙伴也是在网上copy网上代码，结果直接没有给我iv向量，没有iv向量怎么可以解密呢，哈哈哈，其实之前我也不知道解密需要iv，我以为这个iv是包自带的，不需要我们管，但是当我在网上的在线平台使用的时候，发现cbc必须填写iv向量，最少还是16个字节，也就是16个英文字符（吐槽一下php自身生成的那个应该是二进制，需要转换一下，否则根本复制不下来，复制下来也不是16个字符长度），怎么办呢，这时候我逐渐意识到是不是加解密还需要iv,老李代码中反正有， 12$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA, $iv ); // 加密$dec_data = openssl_decrypt( $enc_data, $my_method, $key, OPENSSL_RAW_DATA, $iv ); // 解密 其实老李上面那段代码也写了注释，把iv当做一个随机的字符串，看来真的可能需要iv,这时候就开始翻他的go代码，但是他的go代码中没有传递iv变量这个值呀，看到了下面 1blockMode := cipher.NewCBCEncrypter(block, key[:blockSize]) ~~对了，就是这个 这个key[:blocksS]，这个就是iv,怪不得他不用传递，原来是约定的, 初始化向量(IV)http://blog.csdn.net/xiaohu50/article/details/51682849 初始化向量（IV，Initialization Vector）是许多工作模式中用于随机化加密的一块数据，因此可以由相同的明文，相同的密钥产生不同的密文，而无需重新产生密钥，避免了通常相当复杂的这一过程。 初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。 因为刚做了一个接口的用户信息加解密，加密至URL，然后那边后台解析，一开始IV不一致老是有一个参数解析不了，后来问同事是IV的问题，所以在这边做个记录，对这个还不是很了解。。。 如果加解密的IV不一致的话会导致数据不一致，所以解密失败，IV如果不变的话会导致不安全 上面是我在百度go cbc 加解密的时候看到的， 起初还以为go的cbc加密iv有什么特殊化，看来是我多虑了，就像很多时候aes加密本身不需要base64，但很多时候网上代码都加上了，因为默认约定这样好看点，或者字符长度确定了便于存储 这个传说中的iv向量终于他妈出现了！相对于ECB模式，CBC在加密之前多了一个XOR异或运算的环节，但是第一个明文分组和谁做异或呢？所以这个iv向量就是初始化后给第一个明文分组做XOR异或运算用的，第二个明文分组就与第一个密文分组做XOR异或运算，然后再加密得到第二个密文分组…依次重复下去。 xor 就是异或，相同的取0，不同的取1 总结： AES和DES以及3DES这种加密方式被称为分组密码，分组密码每次只能加密固定长度的明文，所以如果明文很长的话，就需要轮流为每个分组明文进行加密，AES的分组长度是128bit，而DES的分组长度为64bit；如果一旦需要对多个分组进行轮流加密，加入明文被分成了三个明文分组，那么就需要对三个明文进行迭代加密（粗暴理解就是轮流加密），然而会有很多种不同的迭代方式，这种不同的迭代方式专业名词就叫“模式”，这些模式有：ECB、CBC、OFB、CFB、CTR… … 对明文进行分组的方式是固定的，唯一不同的就是分组长度不一样而已；模式是指对多个明文从第一个开始轮流加密到最后一个的这个过程，是怎么轮流执行的。 非对称加解密就不copy了，以后用到的时候再看吧 自己的总结： 其实上面用到的也就怎么用php 进行aes-128-ecb加密，加密出来的数据让别的语言可以解析出来 这其中会遇到很多问题，比如之前曾经遇到过但是没有记录的和java通信过程中的padding 填充问题，以后遇到了再补充吧。 顺带补充一下： https://www.devglan.com/online-tools/aes-encryption-decryption 这个网站以及下面的php代码 123456789101112$data = &apos;陈野&apos;;$key = &apos;1234567812345678&apos;;echo $key.PHP_EOL;$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA);echo $enc_data.PHP_EOL;echo base64_encode($enc_data).PHP_EOL;echo bin2hex( $enc_data ); 默认的填充方式 pkcs5padding or pkcs7padding (不确定) 字符集（utf8） http://tool.chacuo.net/cryptaes 上面这个网站才是真正意义上详细的加密，参数可以选择 今天着重研究了下pkcs5padding 和 pkcs7padding , 网上说的 5p 是7 p的子集， 7p的填充 1 到255 字节都可以， 5p的填充只能 1 到 8字节 ，可是我发现aes 是16字节分组的（不管是 128 还是 256 算法，都是16字节分组），按理说5p只能填充 1到8 那如果只有1个字符的话，怎么填充呢，是填充7个字节还是15字节呢，反正，当我填充15的时候php的openssl nopading 出来的数据和 openssl raw data 出来的数据是一样的，那么应该就是填充15了 网上看到7p和5p的区别大致上都是：5p是7p子集，5p只支持到8的block，7p可以支持到255，所以 这篇文章上说的aes 5p和7p是一样的， 感觉是错的，就是aes没有5p的padding 关于nopadding， 字面意思上就是不填充，对于aes，不填充的话，必须保证是16字节整数倍，否则会加密失败 关于zeropadding, php的 openssl 虽然有这个参数，但是要是不满16字节，仍然是会报错，既然这样，zeropadding 感觉和nopadding 就差不多了，实践了一下，果然zero_padding 就是base64了一下no_padding的结果 关于老版本的加密函数的转换，据说是老版本因为是zero_padding 导致数据出来和新版本不一样，zero_padding ,在末尾填充的是 chr(0), 代表0 这个ascii 对应的 字符，很多网上写的是 \0(很奇怪的是chr(\0) 能得到和 chr(0) 一样的字符，但是这个字符我们键盘是不能表示出来的， chr(\1) 和 chr(1) 却不一样) ，当我们拼凑到16字节之后，再解密，只需要过滤掉\0这个特殊字符就好了 1234567891011121314151617181920212223242526// 这是php 的7padding ,function pad($data, $blocksize = 16)&#123; $pad = $blocksize - (strlen($data) % $blocksize); return $data . str_repeat(chr($pad), $pad);&#125;// 因为最后7padding 最后一个字符肯定是填充的自己长度，所以只需要截取未填充的部分就好 function unpad($text)&#123; $pad = ord($text[strlen($text) - 1]); // 填充的字符 // var_dump($pad); if ($pad &gt; strlen($text)) &#123; return false; &#125; if (strspn($text, chr($pad), strlen($text) - $pad) != $pad) &#123; return false; &#125; return substr($text, 0, -1 * $pad);&#125; 注意一下填充时候的length, 我们计算的时候都是用的strlen, 并不是 中文字符的len 注意一下，我们没填充之前，已经是一个完整的string, 我们每次填充的内容，都是我们肉眼可以识别的字符，或者说是我们可以处理的字符，所以我们可以裁剪substr， 或者trim过滤掉我们添加的字符 总结：hash 和 加解密大致就是上面那些东西了，后面jwt 这些认证方式，其实就是 hash 和 加解密的实际运用，本质上并不是一个新的东西 现在重看， 阮一峰 老师的这篇jwt，讲解的真的好，jwt首先就可以看做一个token,自带token 相比较传统的cookie session,更便于扩展，由客户端自己维持登陆态。缺点token 签发了没法主动让他失效，除非到达失效时间，或者像我们一样添加额外逻辑，token 必须在redis中有对应内容，才能生效。 jwt token ,是由三个字符串base64加密而成, 因为base64解密不需要密钥，所以我们很容易根据base64解密出来 第一段是 alg + type. 算法 + 类型（JWT） 第二段是我们自定义的一个数组，当然可能有些属性是必须的，比如签发时间和过期时间 第三段是sign，为了防止第二段被别人修改，利用的加密算法是前面的alg (可能更确切的说是hash) 综上：所以事先起来感觉很简单，前面两段都是base64, 就是最后一个用hash，之后再base64, 有个问题就是这块的base64不是普通的base64, base64之后再替换三个字符，我的感觉是怕用户把这个字段连接在url后面当做get请求发送，base64中的参数影响到这个url的正确性 当我们明白过程之后，我们就很容易自己实现一个jwt，就不需要用网上的加密包了，我们可以看看php的 firebase/php-jwt 包，蛮简单的，默认hsh256, php 的hash_hmac 很容易实现。 到此为止 ，我们就剩rs256 公钥和私钥没有去研究，以后遇到了再去研究这个firebase的包（从下面也可以看出，hash_hmac 用来hash的函数，openssl 一般是用来加密的函数）]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>API</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP面试题]]></title>
    <url>%2F2019%2F02%2F21%2FPHP%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[收集一些总是考的面试题 Web12345678怎么会导致跨域，为什么会出现跨域schema，或者ip地址，或者端口号 不同都会出现跨域。为了防止前端随意调用别人的后端接口，比如获取别人的某个邮箱文件内容（如果该邮箱网站用的cookie 存储登陆信息，而前端发送请求的时候会自动携带cookie 信息，如果不加以限制，cookie的使用会遭到恶意的攻击，csrf 攻击就是基于这一点，为了防止，让前端主动添加token 作为登陆凭证，调用后端接口）怎么解决跨域jsonp(用的比较少,好像是通过拼凑返回内容,让前端主动调用某个申明好的js文件), cors(通过在返回头中添加header信息,比如允许的域名,允许的调用方法，允许的自定义header参数，是否允许携带cookie (按理说cookie 应该在header 参数之中，但因为特殊，所以单独拿了出来))。什么是简单请求，什么是非简单请求好像是除了get post 之外的跨域请求都属于非简单请求，除此之外携带额外的参数也属于非简单请求。在发送非简单请求之前都会发送一个options请求，options请求没有请求体内容，你只需要把预定的header信息返回就好了，如果返回的header请求信息做了跨域处理，那么后面浏览器就不会屏蔽掉返回内容 12345get post 区别get 可以浏览器收藏，参数会被缓存，post 不可以 ，get 参数只能被url 编码， post 支持多种方式编码 （比如 application/x-www-form-urlencoded， 比如json 格式）get 长度一般由浏览器决定，比较短 ， post 比较长get 传递的参数一般直接显示在url 地址栏， 相比较的话，post会比较安全，get不要放敏感信息， get 参数放在url 中，post参数放在request body 中 123456789101112正则\d 数字\w 字符，字母数字下划线. * ? 组合匹配所有* 匹配0个或者很多歌? 匹配0个或者1个+ 匹配1个或者多个匹配电话号码preg_match_all(&apos;/1[23456]\d&#123;9&#125;/&apos;， 15618014759, $res1);匹配邮箱preg_match_all(&apos;/[a-zA-Z0-9]+[-_.]?[a-zA-Z]@[A-Za-z0-9]+\.[a-zA-Z]+/&apos;, &apos;1967196678@qq.com&apos;, $res2) 1234567891011121314http请求过程浏览器开始在host文件中查找对应网址的ip地址，找不到的话再在本地浏览器缓存中查找，再找不到去dns解析中查找，找到服务器ip地址之后，一般会先去监听的web服务器上，比如nginx，nginx对于静态文件直接返回，对于php类似文件有转发作用，比如转发给9000端口的php-fpm, 或者swoole， 然后他们再交给单个的工作进程中的php处理为什么http请求需要三次握手4次挥手第一次握手，验证cli 可以发消息到 server， server确定cli 可以推送消息，第二次握手，server验证自己可以推送消息，cli知道自己能推送消息并能收到返回消息，此时已经可以发送消息第三次握手，server知道自己可以同送消息，也能接收到消息，于是握手结束第一次挥手，通知sever 我要关闭了第二次挥手，server 通知cli， 好的，你关闭吧第三次挥手，server通知cli第四次挥手，cli告知server， 收到（通过netstat -antp 可以查看tcp 连接（第一个ip端口代表host机器，第二个代表客户端），最好是在同一台服务器上客户端curl ，就能看到两条连接）（tcpdump 可以看到抓包过程） 12345常用的http状态码200 成功300 重定向， 301 永久重定向，302 临时重定向， 304 未修改400 客户端错误，401 未授权（可能是未登录）， 403 禁止访问（没有权限），404 not found 500 服务端错误，502 网关挂掉了, 504 超时 1234567https 和 http的区别https基于http， 有个ssl 包裹住用户信息https加密原理：因为非对称加解密很消耗cpu资源，所以利用对称加解密。怎么传输这个共同的密钥呢，肯定不能直接传输，一般是服务端生成一个公钥和私钥，公钥传输给客户端，客户端拿着公钥加密一个字符，服务端私钥解密这个字符，得到这个传输过程中加密数据的对称密钥，为了防止传输给客户端的公钥被修改。通过拉入第三方机构，第三方机构对（服务端信息 + 服务端产生的公钥） hash 成一个字符串 （相当于签名），然后利用第三方机构的私钥进行加密生成签名，因为不知道ca 的私钥，所以这个hash 不可能被改变，得到hash 值之后，对于证书中包含的 （服务端信息 + 服务端产生的密钥） + hash 算法 是否等于 hash 值进行比对，如果不一致说明公钥被修改了。简单点：1. 对称加密传输数据，需要获得一个别人获取不到的对称密钥？2. 通过非对称加密，由客户端的公钥加密字符，服务端私钥解密字符，这个字符就是对称密钥。客户端怎么获取一个非对称的公钥？3。 ca 证书包含公钥 + ca 私钥 生成的签名，无法修改， ca公钥（每个浏览器或者os 都已经包含了）解密获取签名前的hash， 验证证书内容是否改变，也就是保证公钥的正确性。 123456789101112什么是socket编程Socket 又称网络套接字，是一种操作系统提供的进程间通信机制。工作流程：1. 服务端先用 socket 函数来建立一个套接字，并调用 listen 函数，使服务端的这个端口和 IP 处于监听状态，等待客户端的连接2. 客户端用 socket 函数建立一个套接字，设定远程 IP 和端口，并调用 connect 函数3. 服务端用 accept 函数来接受远程计算机的连接，建立起与客户端之间的通信4. 完成通信以后，最后使用 close 函数关闭 socket 连接。感觉类似swoole, swoole 先开启监听，new 一个server然后写监听事件，用于cli的请求的接受请求处理完，关闭 123456789101112OAuth(Open Authorization) 协议为用户资源的授权提供了一个安全的、开放而又简易的标准，第三方无需使用用户的用户名与密码，就可以申请获得该用户资源的授权。运行流程：1. 用户打开客户端以后，客户端要求用户给予授权。2. 用户同意给予客户端授权3. 客户端使用上一步获得的授权，向认证服务器申请令牌。4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。5. 客户端使用令牌，向资源服务器申请获取资源。6. 资源服务器确认令牌无误，同意向客户端开放资源OAuth 2.0 定义了四种授权方式，授权码模式、简化模式、密码模式、客户端模式，具体的授权流程，请看阮一峰老师的文章理解OAuth 2.0。 123456csrf 攻击防止因为浏览器请求本域名接口自动携带着cookie， 在第三方者在用户没有感知的情况下，调用api。解决办法是携带参数tokenxss 攻击用户输入信息没有做合理过滤，导致让前端页面调用非法的js等内容。用户信息过滤 sql 注入用户输入信息不合法, 导致sql执行用户命令。 用pdo，sql语句预处理功能，或者用户输入过滤。 PHP1234567PHP 位运算符 | 半个或&amp; 同或^ 异或~ 取反 （其实最常见的就是error_reporting(E_ALL ~E_NOTICE)）3 | 5 73 &amp; 5 1 12字符串比较&apos;111aa&apos; == 111 // true 12setcookie(xxx);var_dump($_COOKIE); // 空值，本次还没有携带cookie 123456789101112131415161718192021222324252627282930313233343536常用string ,arr 函数array:array_mergearray_slicearray_valuesarray_keysarray_columnsis_arrayarray_key_existsarray_change_key_casearray_diffarray_intersectarray_fillarray_sumarray_maparray_reducearray_reversekeycurrentnextstring:explodesubstrstrpospreg_splitpreg_matchstrstrsortrsortasortarsortksortkrsortusrot 123array_merge 和 + 的区别+ 同key, 前面覆盖后面 （index 或者 关联）merge 关联后面覆盖前面，数字索引直接扩展开了 // $a = [1 =&gt;2]; $v = [1 =&gt; 3]; array_merge($a,$v); 输出 [2, 3]; 重新排序 12345678910php7新特性1.throwable 分成 error 和 exception，都可以被捕获2.太空舱运算符， 一般usort 里面排序3.三目运算符的缩写， ??4.define可以定义常量数组 (以前好像只有const 可以，const) // const 和 define 的区别，但感觉实际还是define 用的比较多 https://www.jianshu.com/p/a38b814331835.返回值也能严格要求返回类型6.传入参数类型声明的扩展，比如int7.命名空间合并8.closure call 替代bindTo 更加的方便 12php7为什么相较于php5性能有很大提升？减少内存分配次数，优化底层zval 数据结构(64 位减少到24 位)，字符串解析的优化，缓存hash 1234php垃圾回收机制1、以php的引用计数机制为基础（php5.3以前只有该机制）（refcount 是1 的时候就删除， is_ref 是否是引用类型）2、同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题（php5.3开始引入该机制）（为了防止子变量中引用父变量，父变量unset 之后refcount 到不了0 一直得不到回收）其实最简单的防止那种慢性内存溢出的方式就是php-fpm 的连接重启(当然你要是一次性消耗了太多内存，还是会内存溢出的) 1234如何解决php内存溢出问题（phpexcel中经常出现，第二个很管用）1. 增大 PHP 脚本的内存分配（这个不能一劳永逸）2. 变量引用之后及时销毁3. 将数据分批处理 12$z = 0.58;var_dump(intval($z * 100)); 答案是 57，所有语言对于小数的存取都是不精确的， 0.58其实是0.57999999，而且intval() 总是从遇到第一个不是数字开始截取，导致了0.57，比较通用的方法是转成别用intval, 或者用数学函数，bcmath扩展计算 12345678cookie 和 session 的 区别cookie 更像一个钥匙，因为没有加密，所以客户端可以查看和随意更改cookie的数据，cookie 对应的 session 才是服务端真正存储的序列化数据，php 中 cookie 默认名称是 phpsessid , 通过这个值，服务端php能识别客户端对应的用户什么是jwt， jwt 和 cookie, session 的区别jwt 是一种token 的实现方式，由base64 处理过，因为base64可以放解码，所以不要存储重要信息，存放一些基本的辨识用户的信息就好了。他是三段组成的，第一段是签名的加密算法，第二段是用户数据（载体）, 第三段是前面数据的签名，防止用户数据被修改。jwt相较于cookie 和session ,不需要服务端存储用户的基本信息，token下发到client ,完全由客户端保存, 可以防止csrf 攻击。但是jwt 下发之后除非做特殊处理比如服务端，否则不能失效，蛮尴尬的。 12spl_autoload_register和 _autoload 的区别现在的自动加载已经不用_autoload 了，这个只支持一个方法，现在一般用spl_autoload_register, 或者全部用composer， 但composer本质上还是spl_autload_register,他可以支持多个函数 12345判断一个日期是否合法// 思路把一个日期转用strtotime 转换成时间戳再通过 date(), 转换成标准时间，和原先的日期比对是否相同，相同就合法，不同不合法// 注意：错误的时间date 也能转换，只是可能转换成1970 这样的时间// 字符串的比对比较耗时 123单引号，双引号区别单引号解析变量双引号不解析变量 1234include require 区别include 包含文件不存在 warningrequire 错误required_once 12中文截取字符串mb_substr 1234567891011121314151617平时开发用的设计模式单例 保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个，同时这个类还必须提供一个访问该类的全局访问点。（getInstance）工厂 定义一个创建对象的接口，但是让子类去实例化具体类。工厂方法模式让类的实例化延迟到子类中。tp中对于config文件的不同处理，有三个驱动比如 ini,yaml, php, 当我们想读取ini文件的时候，factory 方法中传入的是ini,然后拼凑命名空间，交给 Ini 类处理，方便扩展。还有日志的驱动，用文件还是 socket，cookie 的驱动用文件还是redis注册树 用一个属性保存各个类的实例，需要的时候就从这个属性中取，容器用的就是这种思想门面 方便静态调用. 实际调用的是别的类（感觉主要是这些方法中不需要实例，所以可以静态调用）（如果是多进程，对于那些连接的操作，感觉通过门面不行，因为单个连接实例可能不能用了，得还连接池中别的实例）依赖注入 通过对类中需要以来的对象，直接以参数的形式传入（需要携带参数类型，也就是类名），让容器通过反射自己去实例化，解耦了各个类的依赖，下次以来的类修改的时候，不用我们修改生成依赖类的代码生产者消费者 异步任务或者花费时间多的任务放入队列中,让消费者消费订阅发布 主体对象状态发生改变,与之关联的观察者对象会收到通知，并进行相应操作装饰模式（laravel 的路由，核心 array_reduce） 1234567891011121314151617181920常用的魔术方法__construct 类初始化__destruct 对象销毁的时候__call 调用的方法不能访问 （redis 类封装的时候很好用）__callStatic 调用的静态方法不能访问__get 获取的属性不能访问__set 设置的属性不能访问__isset isset empty 不能访问的属性__unset unset 不能访问的属性__sleep 序列化一个对象的时候__wakeup 反序列一个对象的时候__clone 对象（作为两个实体的存在)__invoke 调用类实例像调用方法那样自动触发，像closure类自带这个方法，php中所有的匿名函数默认都是closure的实例，所以我们执行保存匿名函数的变量自动执行了这个方法魔术变量__CLASS__ 类名__LINE__ 行号__FILE__ 文件名__METHOD__ 类中方法名__FUNCTION__ 普通方法名 12php 错误信息控制error_reporting(E_ALL) 1234567trait Singleton &#123;&#125;多继承的实现class Db&#123; use Singleton;&#125; 1234567891011121314抽象类只能继承， extend ，接口可以实现多个，比如我想我这个类拥有foreach, 之类的功能， implementabstract 抽象类 （基本很少用）抽象类不能实例化抽象类中方法可以有方法体，没有方法体的只能定义abstractabstract 介于 class 和 interface 之间interface 接口interface 中不能用变量,但是可以有常量interface 中方法的访问权限只能是public, 不能是protected或者prviate, 方法不能有方法体，抽象类和接口中但凡没有方法体，子类必须去实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static ,延迟静态绑定，self, parent 调用的方法的时候都是以当前类为标准,static 根据实际调用对象，每当到了static 的 时候调用的上一个确定了调用类的对象方法 (parent self 都不能改变调用对象)（优先调用自己的，如果自己的不能调用，调用父类的）（注意延迟调用的一定要是静态的static）class A &#123; public static function who() &#123; echo __CLASS__; &#125; public static function test() &#123; static::who(); &#125;&#125;class B extends A&#123; protected static function who() &#123; echo __CLASS__; &#125;&#125;B::test(); // 调用不了， 在 a 中调用b的protectedclass A &#123; public static function foo() &#123; static::who(); &#125; public static function who() &#123; echo __CLASS__; &#125;&#125;class B extends A &#123; public static function test() &#123; A::foo(); parent::foo(); self::foo(); &#125; public static function who() &#123; echo __CLASS__; &#125;&#125;class C extends B &#123; public static function who() &#123; echo __CLASS__; &#125;&#125;C::test();A C C 1234567891011121314防止sql 注入sql 注入本质上就是害怕用户拼接sql, 在sql后面携带着用户传入的内容select name from user limit 10 offset . $offset;$offset = &apos; 0; select * from user&apos;;上述代码在pgsql 扩展中可以直接执行， 索然mysqli 中执行不了，handle:最好的方法就是利用预处理语句（那种 绑定??， 不能单纯的理解成嵌套变量进去，如果真的那样那还是防止不了sql注入）参数类型限定我们平时可以通过 转义 str_replace 之类的，但感觉这样很容易误伤，所以干脆还是用pdo的预处理语句吧 123456789101112131415161718192021222324252627282930313233343536373839红包，我能想到比较简单的方法存在一定可能性死循环，就是后面数字的和已经不够一人一个了，已解决，每次计算剩余的最小值至少是每个1分，如果少于，则重新计算// mt_rand 只能产生随机整数，对于现实生活中的分，可以通过扩大100倍来解决// mt_getrandmx() 那个例子产生随机浮点数也是同样的道理// arr 是目前产生的数组// num 是剩余的值function productRand($arr, $num, $leave)&#123; $tmp = mt_rand(0, $num); $leveTotal = $num - $tmp; // 剩余的钱不能少于每个红包1分钱 if ($tmp == 0 || $tmp == $num || $leaveTotal &lt; $leave * 1) &#123; return productRand($arr, $num); &#125; else &#123; $arr[] = $tmp; $num -= $tmp; return [$arr, $num]; &#125;&#125;// $total 代表总数量// $count 代表红包个数function hongbao($total, $count)&#123; $num = $num * 100; $arr = []; $top = $num; for ($i = 0; $i &lt; $cishu - 1; $i++) &#123; $leave = $count - $i - 1; // 剩余红包个数 $res = productRand($arr, $top, $leave); $arr = $res[0]; $top = $res[1]; &#125; $arr[] = $num - array_sum($arr); return $arr;&#125;var_dump(hongbao(11, 4));exit; 123同步，异步区别 阻塞非阻塞区别同步，异步主要是获取返回值内容的时候，同步如果一次性不能获取返回内容，需要不断的轮训获取返回内容，异步返回内容会主动通知（swoole task异步任务， php-fpm模式下同步代码）阻塞和非阻塞主要是进程方面，阻塞api所在进程会被系统直接挂起，直到完成（sleep， io比如redis mysqli pdo 等），非阻塞的时候所在进程不受影响，可以做别的事情（array, string 函数） 1234567ab 测试-n 发送的请求总数-c 并发量ab -n 5000 -c 200 http://www.baidu.com/ (注意末尾的斜线)Requests per second 每秒钟完成的请求数量Time per request 客户端等待时间Time per request 服务端等待时间 12345678910111213yield 感觉就类似分页，有效减少内存的消耗（大数据量一次性读入内存吃不消），注意yield 的使用和数组还是有区别的.就相当于我们值读入部分数据到yield 中，我们还得foreach yield 抛出的数据（iterator 实现了迭代器，所以可以循环），循环去插入 取出yield 中的数据function test() &#123; for($i = 1; $i&lt;5; $i++) &#123; yield $i; &#125;&#125;$data = test();foreach ($data as $value) &#123; var_dump($data-&gt;current(),$value);&#125; exit; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546自带的接口iterator // 可以循环，下面的那些方法都是为了foreach能正确数据准备的class test implements Iterator&#123; public $arr = []; public $keyArr = []; public $keyP = 0; public function __construct($arr) &#123; $this-&gt;arr = $arr; $this-&gt;keyArr = array_keys($arr); &#125; public function rewind() &#123; // TODO: Implement rewind() method. reset($this-&gt;arr); $this-&gt;keyP = 0; &#125; public function current() &#123; // TODO: Implement current() method. return pos($this-&gt;arr); &#125; public function next() &#123; // TODO: Implement next() method. $this-&gt;keyP++; return next($this-&gt;arr); &#125; public function key() &#123; // TODO: Implement key() method. return $this-&gt;keyArr[$this-&gt;keyP]; &#125; public function valid() &#123; // TODO: Implement valid() method. return isset($this-&gt;keyArr[$this-&gt;keyP]); &#125;&#125; 123456789php 进程间通信的方式第三方，比如redis消息队列， 也可以属于第三方共享内存， 不如swoole_tablesocket 文件管道 （应该类似 grep ）信号 字进程结束给父进程结束信号，请求回收tcp 12345几个预定义接口 spl标准类库ArrayAccess , 让类可以类似数组方式访问Countab , 让类可以被 count()iterator 让对象能循环，几个必须实现的方法（current, 当前key, key, 就是 key 的名称， next 往下走， rewind, 重置，valid 是否有效，本身php 的数组就包含上述的实现，$arr[$key], key,next, reset, isset）iteratorAggregate 感觉就是方便的创造一个迭代器比较方便（官网上直接调用spl 的一个标准库, ArrayIterator(这是类，不是预定义接口), 数组对象转成 Iterator 方便） 1234567891011121314151617181920212223php 多进程写入同一个文件file_put_contents() // 添加第三个参数ex_lock对文件加锁，并对锁设置超时时间（类似给redis 那种锁 sex 锁， setnx 不能同时设置锁的时间，不具有原子性，这里面的锁，其实就是一个key-value）$resource = fopen(&apos;./tmp.log&apos;);$try = 0;while(!flock($resource, LOCK_EX) &amp;&amp; $try != 100) &#123; $try++;&#125; if ($try == 100) &#123; return false; // 测试太多失败&#125;fwrite($res, &apos;ceshi&apos;);fclose($res); // 一般就能删除锁， 或者 flock($resource, UN_LOCK);return true;关于php这种锁，进程结束了就自动消失了，文档上说是脚本结束了，其实是一个意思（想一下我们用redis实现的锁，也是这样的，redis要是挂了，锁是不是没了）（当我用用了排它锁，我们再打开文件就是空的）(感觉写文件也不是直接往磁盘文件中写，而是写入一个缓存中，之后合并，因为当我用排它锁锁定一个文件的时候，fwrite 能立刻写入成功，虽然此时文件还没有修改) Laravel1234567laravel 调优1. 开启Opcache 2.关闭debug 3.缓存配置 php artisan config:cache 4.缓存路由 php artisan router:cache 5.类映射加载优化 php artisan optimize 6.根据需要只加载必要的中间件 1laravel 生命周期 1loc ,facade, contract, 服务提供者是什么 1laravel 和 其他框架的区别 Mysql1234mysql 性能优化1. 建立索引，优化索引 (最左前缀，覆盖索引，联合索引)2. 读写分离 （怎么保证一致性）（先删缓存，再插入数据，容易读到旧的内容，因为插入数据比较慢，中间容易被介入，可以插入数据之后，暂停几ms 删除缓存，这个ms 是根绝自身写入缓存的逻辑时间）（或者先插入数据，再删除缓存，因为插入数据比较慢，所以插入数据和删除缓存之间很难有空隙介入）3. 保证单表数据量，分库分表 12345mysql 乐观锁，悲观锁，共享锁，排它锁，行锁，表锁乐观锁自己实现：每条数据后面都有个version, 读取version的内容，更新的时候观察这个version 是否改变，可以通过where 中加version 条件，如果version 改变了，则修改失败，如果version 没改变，则修改成功悲观锁 ，数据库自带。悲观锁又分为共享锁 lock in share mode 和排它锁 for update。共享锁锁住，不能更新，只能读取。排他锁锁住，也是不能更新，但是能读取行锁：innodb 引擎表锁： myisam 引擎 12345678mysql 的隔离级别读未提交读已提交可重复读可串行化默认的可重复读。并发事务中容易出现的问题，脏写(当前事务中写的内容被另一个事务回滚了)，脏读（读取的内容是一个未提交事务中内容），不可重复读（多次读取获取的内容不一致），幻读（后读取的内容多读了之前不存在的）。脏写大家都能防止，读未提交不能防止脏读，读已提交可以防止脏读，但不能防止不可重复读，幻读，因为他在一个事务中获取的视图可以是不一样的，但凡事务提交了，他就能获取该事物产生的新的试图，可重复读在事务过程中获取的视图始终唯一 12int(1) 和 int(11)的区别都是占用 4个字节，1 和 11 代表显示长度，除非添加 zerofill 要不然没区别 123varchar 和 char 区别 (括号中是字符数)varchar 会根据内容长度确定大小，最大长度是定义的长度 * 3,varchar 中会存储字符的长度char 是固定大小， 1234567891011hash索引和b+索引的区别hash 索引只能用来进行等值匹配, 也不能排序，b+索引能用来排序，可以范围取值什么是聚簇索引索引本质上是树，聚簇索引的叶子结点是用户记录普通索引普通索引的叶子结点是主键(id), 索引字段， 主键主要是为了回表，通过id 去 聚簇索引中查找用户记录覆盖索引因为回表属于不连续的io， 比较耗时，如果不用回表，索引字段包含select 的内容，那就会很快，这种索引就叫覆盖索引联合索引给多个字段建立索引，联合索引是最左原则，得在前面的字段是等值的情况下，后面的字段才能符合要求（比如前面的字段是范围索引，那么取出来的数据是无序的，在无序的情况下，联合索引第二个字段是起不到排序的作用的） 12345innodb 和 myisam 存储引擎的区别innodb 是行锁，myisam表锁innodb 支持事务，myisam不支持innodb 数据和索引存储文件一样，myisam是分开的 innodb 中的聚簇索引的叶子结点就是数据记录或者主键，myisam中叶子结点只是数据的存储位置，所以肯定需要回表（感觉可以和第三点合并） 123什么样的字段适合建立索引 （索引建立的标准）区分度大的字段，查找起来更容易确定具体的记录，减少回表的内容对于字符串，需要先确定首部字符串，才能匹配类似字符串 12常见的索引主键， 唯一索引，复合索引，普通索引 12mysql_fetch_row, mysql_fetch_assoc, mysql_fetch_array 区别row 好像是数组，assoc 关联数组， array 是前面二者的结合体 12345678910111213141516171819202122limit, left join ,order by ,group by, where , select , from ,having select left joinwhere group by havingorder bylimit执行顺序： 先连接，再筛选，再分组，再having, 再select, 最后order byFROMONJOINWHEREGROUP BYWITH CUBE 或 WITH ROLLUPHAVINGSELECTDISTINCTORDER BYTOP Nginx 12404 最长匹配原则，但是只能匹配到 a500 ~* 不区分大小写， 权重比 / 高 1234567891011nginx 负载均衡（属于反向代理）upstream prox_pass关键字轮询（默认）权重ip_hashurl_hashupstream test&#123; server 127.0.0.1:8081 weight=1; server 127.0.0.1:8082 weight=2;&#125;prox_pass http://test # 还可以配置back 备胎机器 Redis1234redis 和 memecached的区别1. 更丰富的数据结构，除了缓存，更多的使用场景2. 单进程，只能利用单核3. redis 可以持久化 ,memcached 重启数据会丢失 123redis 怎么持久化AOF 记录每条命令，后面重新执行一遍RDB 类似快照，把缓存中数据都存储下来（利用back，防止始终阻塞） 123456redis 的常用数据类型string key value 形式hash 数组，关联数组，索引数组list 队列，set 集合sort set 有序集合 1234redis 的使用场景点赞，利用 incr排行榜，有序集合，分数sorce 作为排序标准api 限流（sort set 滑动窗口） 12 Linux1234567891011121314151617181920linux 常用命令cd 进入ls -la 展示tar 解压缩mkdir -p 新建文件夹touch 新建文件rm -rf 删除文件夹vim 编辑文件tail -f 动态查看文件变化netstat -antp 查看tcp 连接ps -ef 查看进程free 查看系统资源top 查看系统进程消耗资源df -h 查看系统盘alias -p 查看取别名find / -name 查找locate 查找chmod 修改权限chown 修改用户组用户wc -l 统计行数 12git rebase 变基，比如把当前分支的分叉点移动到主分支最新节点，为的就是log日志中不产生分支git push origin master:master 推送本地master分支到远程master分支 12awk 的使用awk -F &apos; &apos; &#123;&apos;print $1&apos;&#125; ./access.log |sort|uniq|wc -l uniq只能合并相邻的不同的，所以要先排序 算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576774种排序从小到大1. 冒泡 (核心：每次一个数据到达最终位置，第一次确定最大的数字) $arr = [20, 19, 88, 76, 43, 1];function maopao($arr) &#123; $count = count($arr); for($i=0; $i &lt; $count -1; $i++) &#123; // 最后一个数不用变动，位置自动确定 for ($j= 0; $j &lt; $count - 1 - $i; $j++) &#123; // 每次上浮的数字都要和没有确定的比较 if ($arr[$j] &gt; $arr[$j+1]) &#123; list($arr[$j+1], $arr[$j]) = [$arr[$j], $arr[$j+1]]; &#125; &#125; &#125; return $arr;&#125;2.选择排序 (和冒泡的区别，这个每次选出一个最小的数，和冒泡一样，但是不移动数据，只是最终和确定的数组比较，如果不一致，才会移动)function xuanze1($arr)&#123; $count = count($arr); for($i= 0; $i &lt; $count - 1; $i++) &#123; $p = $i; for ($j = $i; $j &lt; $count; $j++) &#123; if ($arr[$j] &lt; $arr[$p]) &#123; $p = $j; &#125; &#125; if ($i != $p) &#123; list($arr[$i], $arr[$p]) = [$arr[$p], $arr[$i]]; &#125; &#125; return $arr;&#125;3.插入排序 (核心，前面排好序的字段不断扩展，用来容纳新插入的数据)function charu($arr)&#123; $count = count($arr); for ($i=1; $i &lt; $count; $i++) &#123; if ($arr[$i-1] &gt; $arr[$i]) &#123; $tmp = $arr[$i]; for($j=$i-1; $j&gt;=0 &amp;&amp; $arr[$j] &gt; $tmp;$j--) &#123; $arr[$j+1] = $arr[$j]; &#125; $arr[$j+1] = $tmp; &#125; // var_dump($arr); &#125; return $arr;&#125;1. 快排：以一个数为基准，分原数组成两列，递归调用 function quick($arr) &#123; if (!$arr) &#123; return []; &#125; $tmp = $arr[0]; $left = $right = []; $count = count($arr); if ($count &gt; 1) &#123; for ($i = 1; $i &lt; $count; $i++) &#123; if ($arr[$i] &lt;= $tmp) &#123; $left[] = $arr[$i]; &#125; else &#123; $right[] = $arr[$i]; &#125; &#125; return array_merge(quick($left), [$tmp], quick($right)); &#125; else &#123; return $arr; &#125; &#125; 123456789101112131415161718192021查找 （注意查找的算法都是在排好序的基础上）1.二分查找function search1($arr, $num, $min, $max) &#123; if ($min == $max &amp;&amp; $num != $arr[$min]) &#123; return false; &#125; $tmp = ceil(($min + $max) / 2); if ($num == $arr[$tmp]) &#123; return $tmp; &#125; else &#123; if ($num &lt; $arr[$tmp]) &#123; $max = $tmp-1; &#125; else &#123; $min = $tmp + 1; &#125; return search1($arr, $num, $min, $max); &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471000000个数字的整数， 大小是0 到 999999， 找出其中重复的数字.1. 最简单的。先排序，排序玩比较相邻数字是否相同，相同就添加进结果集。（二分 nlogn）2. 利用hash, 时间复杂度n, 空间复杂度n. 我们知道php 的数组就是一个hash, 我们可以遍历这个大的原始数据，然后把其中的数字都往一个预先的hash 里面塞，如果之前有值就代表重复.3. 因为大小是0 到 99999， 所以我们可以foreach ,然后把对应数据换算到我们要的位置上来，如果最后没有调回来，代表这个数字重复$arr = [2,3,1,0,2,5,3];// 转变过程// [1,3,2,0,2,5,3]// [3,1,2,0,2,5,3]// [0,1,2,3,2,5,3]// 2, 3 入结果集// foreach 的时候，如果 &amp;value,可以改变这次遍历的内容，单单$arr[$key] 只能改变下次遍历时候的$arr function chongfu($arr)&#123; $chongfu = []; foreach ($arr as $key =&gt; &amp;$value) &#123; if ($value == $key) &#123; continue; &#125; else &#123; jiaohuan($arr, $chongfu, $key); &#125; &#125; return $chongfu;&#125;function jiaohuan(&amp;$arr, &amp;$chongfu, $key)&#123; if ($key != $arr[$key]) &#123; // var_dump($key, $arr[$key]); $value = $arr[$key]; if ($value == $arr[$value]) &#123; $chongfu[] = $value;//var_dump($chongfu, $key, $value); &#125; else &#123; list($arr[$key], $arr[$value]) = [$arr[$value], $arr[$key]]; //var_dump($arr, $key); jiaohuan($arr, $chongfu, $key); &#125; &#125; else &#123; return ; &#125;&#125;var_dump(chongfu($arr));exit; 1广度优先算法 123567123, 怎么找出1// 看到有序，想到查找算法，比如二分// 随机找到一个数，比如6，5比6 小， 3比6大，说明1 在3到6 中间，再在 3和 6 中间取一个数字 项目1订单系统 1100件商品高并发，先到先得 1234530w 的ip地址,类似如下10.23.25.0 10.23.25.255 湖南省 长沙市请设计出一个实现方式,可以给某个IP找到对应的省和市。要求效率尽可能的高。利用redis的zset, 把ip地址变成数字作为score 存储，然后把各个省市的最大ip和最小ip存储，利用 zset 的范围，取到第一个最大的城市就是该城市 123456.请设计一个投票系统,满足如下要求a.一个用户10分钟内对一个投票只能成功完成一次。b.一个用户每个自然日最多只能成功完成50个不同的投票。每次投票成功， 就往set 里面塞入一个投票类型，每次投片前都检测下，有没有超过50利用redis, userid_投的票 =&gt; 时间，如果 时间 + 10 分钟 &gt;= 现在时间就给投票 12345678910111213141516171819202122232425262728293031323334.用php写一个函数，获取一个文本文件最后$n行内容，要求尽可能效率更高，并可以跨平台使用利用exec 执行 tail -f , 主要就是tail -f 没有停止，会持续获取，但也没关系，手动停了就好了，注意的是这块没停止的话，进程一直阻塞着，不能去往下执行，打印 exec 执行后的内容$filename = &apos;/opt/httpd/logs/access_log&apos;;$xie = &apos;./xie.log&apos;;function kan($line, $file, $xie)&#123; $line = $line -1; $x = fopen($xie, &apos;a+&apos;); $res = fopen($file, &apos;a+&apos;); $postion = -2; $str = fgets($res); while ($line) &#123; fseek($res, $postion, SEEK_END); $tmp = fgetc($res); $postion -= 1; if ($tmp == PHP_EOL) &#123; $str .= fgets($res); $line -= 1; &#125; &#125; var_dump($str);exit; fwrite($x, $str);&#125;kan( 5, $filename, $xie);exit; 1234567891011121314有两个文本文件 A.txt B.txtA.txt 3000万行，userid唯一，userid和username以空格分隔，如下所示：userid username1 yi2 er3 san... ...B.txt 3000万行，userid唯一，userid和realname以空格分隔，如下所示：userid realname1 一2 二3 三感觉可以把 a读入一个数组中，然后遍历 b ，往b中写入相应数据 。 a可以看做一个hash，所以查找一个数据就是1， 然后遍历 b文件，n， 所以总的复杂度是 n.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[laravel 核心技术读书笔记]]></title>
    <url>%2F2019%2F01%2F03%2Flaravel-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[关于laravel 框架核心技术一书的阅读感受 ###1.关于命名空间我理解的命名空间是文件中的namespace 可以定义成任意的值，但是composer 的自动加载因为符合psr4 ，所以要求命名空间和文件路径一致，文件名和类名保持一样。当我们不适用composer的自动加载的时候，就可以随便指定文件中的namespace是多少了，比如12345&lt;?phpnamespace test;class test&#123;&#125; 可以保存在任意位置任意名称的文件中，但是不能写在composer autoload 驱动的框架中，除非改成别的方式加载，比如map还记得我们在控制器中引用别的类吗，通过use,然后就能直接使用new classname()了，但是我们在脚本中使用的时候，我们一定要用到include 先去包含这个文件12345678910111213141516171819202122232425262728&lt;?phpnamespace test;include &apos;test2.php&apos;;use test2\test5;class test &#123; public function test2() &#123; test1(); &#125;&#125;function test1()&#123; echo 1;&#125;$a = new test();$a-&gt;test2();$b = new test5();$b-&gt;test3(); 可能你在想，既然我们都include 了，那为啥还要使用use，use在这个地方的作用是什么，当你使用 use test2\test5的时候，你在使用 new test5(), 它实际new 的是 test2\test5(), 如果没有 new test5(), 当前命名空间下的test5类，所以你明白了use 并不是导入包含文件，只是引入一个类的前缀，想不适用前缀，那就 new \test5() ，绝对路径吧，如果想使用当前命名空间下的 test5(),那就把外来引入的换个名称吧，比如 as。现在想想，其实我们平时同一个文件夹下面命名空间一样，本质上是写在一个文件中的，只是我们为了方便好看，才把分到多个文件中，但是我们互相引用的时候，同一个命名空间下面，不用use，因为默认就在当前文件夹下面找。 当我接触use 的时候，书中还有一句话，use只能引用类，并不能引用常量，函数··！！难道还可以这样12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace test;//include &apos;test2.php&apos;;use test2\test5;class test &#123; public function test2() &#123; test1(); &#125;&#125;/* class test5&#123; public function test3() &#123; echo 1; &#125;&#125; */function test1()&#123; echo 1;&#125;function autoload($class) &#123; echo $class; include &apos;./test2.php&apos;;&#125;spl_autoload_register(&apos;test\autoload&apos;);$a = new test();$a-&gt;test2();$b = new test5();$b-&gt;test3(); 对，你没看错，class 的外面还能定义function, 然后我们当前命名空间中可以直接使用，如果是不同的命名空间，需要加前缀 ###2.spl_autoloadregister 和 __autoload\_autoload已经被废弃了，在7.2 中。__autoload 如果在一个库中出现多次，会出错的，虽然是魔术方法，但可以不在类中定义，spl_autolad_register ，可以绑定多个自动加载，还可以删除，composer的自动加载机制中就用到了删除。他是类似一种方法的执行，可以写在任意地方，可以直接是方法名1spl_autoload_register(&apos;test\autoload&apos;); 可以是面向对象的方式1spl_autoload_register([$this, &apos;autoload&apos;], true, true); 第二个参数true 代表异常可以捕获，__autoload 就不行，第三个参数说实话不知道咋用，队列头部和队列尾部，就是先加载哪个自动加载函数的意思呗？]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LBS 和 redis mongodb]]></title>
    <url>%2F2018%2F12%2F24%2FLBS-%E5%92%8C-redis-mongodb%2F</url>
    <content type="text"><![CDATA[LBS,刚听起来挺高大上的，其实简单理解就是附近的人。其实这个需求蛮常见的，比如大众点评中搜索摸某一个店铺按照离我当前位置距离进行排序，又或者某些社交软件中的附近的人，实现的方式有很多，php + mysql ， php + redis ， php+ mongodb， 其中mysql 的话，就是把所有的点的坐标保存下来，然后通过编写sql语句，直接通过sql去查询每个点离我们的距离，然后排序返回，但数据量大的时候，可能不太好，所以就有了后面的nosql ， redis 和 mongodb 的相关应用，其中 mongodb 在这方面应该是我听得最多的，当初想试这个功能也是因为想教一下前端朋友mongodb的相关功能，方便他面试，但后来发现其实还是redis 实现比较方便，因为php的mongodb扩展 mongo(php5） 和 mongodb(php7) 接口一点都不一样，而且中文文档比较少啦。其实通过es 也是可以实现的，方法很多.详细见这篇文章 Redis(参考)redis 自从3.2就有了对于经纬度的处理，但注意并不是新增了一个一个数据结构，这个经纬度是在 有序集合zset 的基础上发展而来的，所以我们对于zset 的操作都能对经纬度使用，比如123zrange key 0 10 # 把key 中所有的member 都取出来 zrange cy1 0 10zcard key # key 中有多少个member, zcard cy1zsore key member # key 中具体的member 的score，对于经纬度这个取出来看不懂 穿插一句：刚开始使用redis 的时候，虽然他的api很简单，便于理解，但是和sql编程还是不同的，为什么我们一个对象有了member 这个名称还需要key 呢，你想啊，我么需要从一个集合中获取离这个点比较近的点，这个集合的名称就是 key,这个是事先我们往集合中塞就定好的，后面我们可能变化的是member 的名称，需要我们从外边传入。关于php使用redis, 大致分成两种方法，有通过编译c扩展，还有就是通过composer 安装predis,这是两种方法，我们不要混淆了，平时我们大部分用的是c扩展额，然后自己封装其中基本的方法和连接方式，需要注意的是关于重连啊，或者单例模式是的使用啊之类的，还有就是其中__call方法的使用，如果有那些我们没有封装的方法，但是自己还使用了，默认就会调用这个方法。一般很多时候调用方法正确的放回是0和1，所以我们不能根据0和1来判定方法是否执行成功，很多时候他代表着影响的行数，比如新增返回1，修改返回0。还有c扩展方式安装的，比如 geoRadiusByMember, 不知道这个方法的参数都是啥，也不知道在哪能找到，只能凭着redis的使用去猜测，比如最后一个option 应该传数组，但其实如果传错的话，也有提示，感谢扩展报错信息的详细 geoadd: 增加地理位置的坐标。geodist: 获取两个地理位置的距离。geohash: 获取地理位置的GeoHash值。geopos: 获取地理位置的坐标。georadius: 根据给定经纬度坐标获取指定范围内的地理位置集合。georadiusbymember: 根据给定地理位置获取指定范围内的地理位置集合。 georadius 和 georadiusbymember 的参数 WITHDIST: 同时返回地理位置与给定位置的距离WITHCOORD: 同时返回地理位置的经纬度坐标WITHHASH: 同时返回Redis内部的GeoHash值（非标准算法值），一般用于debugASC|DESC：结果按距离升降序排序STORE|STOREDIST: 结果存到新的有序集合中，前者以GeoHash值做score，后者以与指定位置的距离作score，该选项与WITH[DIST|COORD|HASH]选项冲突 1234567891011121314151617181920212223242526272829303132333435363738public function addLocation() &#123; $redis = new Redis(); //var_dump($redis-&gt;geodist(&apos;cy1&apos;, &apos;a&apos;, &apos;b&apos;));exit; $lnt = Request::instance()-&gt;post(&apos;lnt&apos;); $lat = Request::instance()-&gt;post(&apos;lat&apos;); $name = Request::instance()-&gt;post(&apos;name&apos;); // 1 成功 新增 // 0 也可能是成功 修改 $res = $redis-&gt;geoadd(&apos;cy1&apos;, $lnt ,$lat, $name); // 相同的名称就直接替换了 return $res; &#125; public function dist() &#123; $member1 = Request::instance()-&gt;post(&apos;member1&apos;); $member2 = Request::instance()-&gt;post(&apos;member2&apos;); $redis = new Redis(); var_dump($redis-&gt;geodist(&apos;cy1&apos;, $member1, $member2)); &#125; public function fujin() &#123; $radius = Request::instance()-&gt;post(&apos;radius&apos;); // 多少半径 $member = Request::instance()-&gt;post(&apos;member&apos;); // 点的名称 $unit = Request::instance()-&gt;post(&apos;unit&apos;); // 单位 $option = [&apos;withdist&apos;, &apos;withcoord&apos;]; $redis = new Redis(); var_dump($redis-&gt;georadiusbymember(&apos;cy1&apos;, $member, $radius, $unit, $option )); &#125; 验证方法，通过求得两个点的距离之后按照多少米之内半径调整圆的大小，来观察另一点是否在圆圈内来验证. Mongodb关于mongodb的安装就看菜鸟教程吧，也是解压完就能用，类似redis,然后服务端启动是 mongod, 客户端shell是 mongo(然后据说是js shell，不知道需不需要node的支持，反正我的服务器上node 是必须的，因为vue 啊 或者 hexo 啊 都需要node), 启动的时候要设置 dbpath 和 log path,直接写到配置文件中就可以 mongod启动了。 小插曲：因为这个mongo启动的时候输了一堆的信息，然后又看不懂，所以就像通过检查端口号来看是否启动成功，这又到了用ps 和 netstat 的时候了。先通过ps -ef|grep 27017 没有，是不是这个命令本来就不输出端口号呢？ps -ef |grep nginx,果然没有端口号，于是netstat -antp|grep 27017,看到了，害怕这个应用层服务不是基于tcp (也许是多虑吧)，我把t 去掉了，查到了。完事之后自己思考了下，ps 主要是用来检查进程的，netstat 是用来检查网络连接的，拿nginx 来举例，他可能有一个manage 进程，然后有个master 子进程，然后每个master还有worker进程，然后他监听了 80 ，443 等端口，所以ps 查出来的只能是进程相关，netstat 查出来的才是各种提供的服务和端口号。 mongodb 和 redis 同属于nosql，拿现在比较流行的话说，他也是对标mysql的产品，很多教程拿他和mysql做对比，确实也更容易理解 我们刚开始进入shell :show dbs 显示有哪些数据库，默认 local 和 admin可是默认我们在test 下面，为什么test 没有显示，因为test 中没有内容呀，但凡我们插入数据，就可以有了 数据库use test 切换数据库，如果没有就新建 db 显示当前数据库 db.dropdatabase 删除当前数据库 表db.runoob.drop 删除当前表/collection show tables 显示当前数据库中有哪些表 show collections 同上 db.createCollection(‘test’) 创建表 db.createCollection(“mycol”, { capped : true, autoIndexId : true, size : 6142800, max : 10000 } ) 创建表 插入db.runoob.insert({“name”:”菜鸟教程”}) 插入数据 ，这个runoob 是表的名字，在mongodb 中是文档的意思，然后mongo 中table 中 field 不需要统一 db.col.insert({title: ‘MongoDB 教程’, description: ‘MongoDB 是一个 Nosql 数据库’, by: ‘菜鸟教程’, url: ‘http://www.runoob.com‘, tags: [‘mongodb’, ‘database’, ‘NoSQL’], likes: 100}) // 往col 表里面插入数据 查找db.col.find({title:’cy’, sex:’boy’}) //查找col 表里面数据,and 条件db.col.find().pretty() 更好的显示出来 更新db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}}) db.col.save({ “_id” : ObjectId(“56064f89ade2f21f36b03136”), “title” : “MongoDB”, “description” : “MongoDB 是一个 Nosql 数据库”, “by” : “Runoob”, “url” : “http://www.runoob.com“, “tags” : [ “mongodb”, “NoSQL” ], “likes” : 110}) save 的话，保存id 就是更新，没有id 的话就是新增 默认的话只能更新一条，如下可以更新多条，因为第二个布尔值代表多条的意思 db.col.update( { “count” : { $gt : 3 } } , { $set : { “test2” : “OK”} },false,true ); 删除db.col.remove({‘title’:’MongoDB 教程’})db.col.remove({‘title’:’MongoDB 教程’}， 1) // 只想删除一个，just one 参数设置为1 条件db.col.find({likes : {$lt :200, $gt : 100}}) typedb.col.find({“title” : {$type : 2}}) 分页db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER) 排序db.COLLECTION_NAME.find().sort({KEY:1}) 索引db.col.createIndex({“title”:1})db.values.createIndex({open: 1, close: 1}, {background: true})，第二个是参数，前面的1是升序，-1是降序 未完待续····（坑爹的php 的 mongodb扩展，感觉不知道咋用呀）]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的接口(-)]]></title>
    <url>%2F2018%2F12%2F07%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[关于登陆，现在的网站有第三方登陆（qq,微信，微博）， 手机号登陆，用户名密码登陆，sso登陆，找回密码，注销 感觉其实都差不多 第三方登陆其实国内的大多数第三方登陆都是基于oauth 2.0的变种，同理还有微信上消息more按钮点击能跳转到公司网站同样实现登陆都是基于这个，那什么是oauth2.0呢，阮老师这篇文章讲解的很清楚oauth2.0，而我们用的更多的又是其中的授权码模式，大致逻辑如下 其中比较重要的两点就是用户授权code和access_token, code作用代表用户同意登陆了，access_token 代表这个用户资源（有时候像之前的小程序，是拿着用户同意之后返回的code 去换回openid, 这个openid 类似这个access_token, 他在每个应用中是唯一的，代表了一个用户，如果我们想把不同app上同一个微信用户绑在一起，需要我们去微信联合平台绑定需要处理的app，然后下次请求的时候会返回一个unit id ，这个对于同一个微信用户在不同的app内部是唯一的） for example 微信消息跳转itbasic网站1.引导用户点击授权链接，微信给的授权链接上会有参数绑定回调地址和state参数，当用户点击的时候，微信会重定向（注意不是回调）填写的会掉地址，并携带参数state,还有code ,也就是用户授权码，下面是我们的重定向地址代码2.1234567891011121314151617181920212223242526272829303132public function dologin($req) &#123; $code = $req-&gt;param(&apos;code&apos;); # 用户授权码 $state = $req-&gt;param(&apos;state&apos;); # 自己定义的参数，比如这次登陆来自微信，或者登陆之后需要跳转的地址 $accesstoken = $this-&gt;getAccessToken(); # 微信这块的access_token不需要用户的授权即可获取，但后面获取用户信息还是需要授权码，所以原理和上面是一样的 $url = &apos;https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=&apos;.$accesstoken.&apos;&amp;code=&apos;.$code; $res =$this-&gt;http($url); #获取用户信息 if (!array_key_exists(&apos;UserId&apos;, $res[&apos;result&apos;])) &#123; // 记录错误信息（微信）到日志,获取用户信息出错 &#125; // 根据实际业务处理，我这块是登陆 // 你可以根据返回的用户名称，判断是新用户，还是老用户，新用户的话会往数据库插入数据 $user_model = Box::getObject(&apos;user&apos;, model); $res = $user_model-&gt;search($res[&apos;name&apos;]); if (!$res) &#123; // 记录错误信息（itbaisc） 到日志，查找用户失败 &#125; $userinfo = $res; $userinfo = [&apos;userid&apos; =&gt; $userinfo[&apos;id&apos;], &apos;username&apos; =&gt; $userinfo[&apos;username&apos;], &apos;status&apos; =&gt; $userinfo[&apos;status&apos;], &apos;deptsid&apos; =&gt; $userinfo[&apos;deptsid&apos;], &apos;postsid&apos; =&gt; $userinfo[&apos;postsid&apos;], &apos;role&apos; =&gt; $userinfo[&apos;role&apos;], &apos;long&apos; =&gt; true]; Session::set(&apos;userinfo&apos;, $userinfo); //实现登陆 $state = urldecode($state); // 之前我们自己绑定的参数，因为url在http参数中需要加密，防止多余的http这些参数 header( &quot;Location: $state&quot; );exit; &#125; 手机号登陆首先生成验证码,存入缓存中，手机号=》验证码（过期时间，离开当前页面让其失效，只能使用一次），然后调用第三方接口发送给手机上这个验证码，用户收到验证码之后调用新的接口进行验证，我们在缓存中寻找手机号验证码是否匹配，如果匹配代表成功，后面是登陆啊，还是绑定啊看自己的业务需求 sso登陆一处登陆处处登陆，一处注销，处处注销(itbasic的原理类似oauth2。首先用户验证是否在的登陆中心登陆，如果没有，先登录，登陆中心成功后返回一个access_token,重定向到你来时候那个地址，相当于帮你发出请求，你拿着这个access_token获取用户信息，干啥都是你自己的事情。下次用户再来的时候，验证中心已经登陆上了，直接返回access_token然后重定向)（注销，我们在每次去验证中心验证的时候，都记住有哪些来的网站，注销的时候都请求他们注销的地址就好了，这个时候可以直接请求，不用重定向，因为不用种cookie,直接销毁服务端数据就好了） 找回密码通过邮箱。首先填写用户名和邮箱（为了防止别人恶意找回用户），确保用户名和邮箱和登陆的时候绑定一致，才发送修改密码的邮件，邮件内容是 这样其实就足够了，这个token 是我们之前发送邮件时候生成的，我们只需要保证 用户名 =&gt;token,当用户请求这个接口的时候（注意一定是get请求，因为是点击），我们通过这个token,知道是哪个用户就好了，然后返回一个界面让用户修改密码就可以了. 熟悉了几个函数的使用 http_query_build ,拼接http请求参数（这个对url 好像还会进行urlencode加密） parse_str, 把上面的拼接内容分开 当然上面各个案例的解决方案很多，比如找回密码用手机而不是用邮箱，只是简单记录下常用的方式]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日志 awk sed]]></title>
    <url>%2F2018%2F11%2F28%2F%E6%97%A5%E5%BF%97-awd-sed%2F</url>
    <content type="text"><![CDATA[日志很重要 日志可以进行数据挖掘，分析用户的喜好，比如什么资源被用户频繁访问（对应面试题：取出访问量前20的网址） –来自百度某朋友 你线上要是有错误怎么办，你们平时是不是都不看日志，只有错误了才解决，··balabal （一顿嘲讽） –来自平安好房某专家表哥 为啥本地开发的时候，错误信息能输出在页面，线上环境直接就是个500页面，好奇怪，好奇怪 –来自17年的me ###了解日志我们itbasic用的其实是lamp, 通过apache的模块处理php, php的错误日志可以在虚拟域名里面进行配置lnmp,nginx 起到静态文件处理的作用，php 转给php-fpm 进行处理，虽然网上说nginx 记录不了错误日志，但其实当我在虚拟站点里面配置error-log的时候，也是有记录的，和php-fpm中是一样的。php-fpm 中开启日志需要修改php.fpm 的配置文件（还可以添加慢查询日志，据说很重要，有空的话可以把itbasic改成lnmp,有空的话看看php-fpm 中各个参数的作用，） 特别是这块，php_flag和php_value 的作用是一致的，不知道为什么要搞两个一样的，还有就是他们的使用是这样1php_flag[error_reporting] = 0 来覆盖代码中的error_reporting ,····原先以为还有什么作用呢 ###分析日志 我不会告诉你最开始接触sed和awk 是因为面试题，很多时候，当我们分析一个大日志文件的时候，我们甚至都打不开这个文件，因为太大了， 但是我们可以通过这些文本处理工具对数据加以筛选。 awk（参照阮一峰老师，很可惜，没有出sed 入门） 基本用法12345678# 格式$ awk 动作 文件名# 示例$ awk &apos;&#123;print $0&#125;&apos; demo.txt$ echo &apos;this is a test&apos; | awk &apos;&#123;print $0&#125;&apos;this is a test print 和 echo 都是标准输出，stdin ,这个东西最近经常看到，感觉就是输出在控制台上，比如php cli 模式下，普通php 脚本中 echo, print, var_dump都可以打印在控制台上（但好像记得之前子进程中输出好像只有父进程中才能看到，不记得是return 还是 输出了），这种标准输出好像都可以通过管道进行连接然后进行处理上面的分割， \$1 代表第一个元素，$0 代表整体元素123456789# 练习（test.log）：root:x:0:0:root:/root:/usr/bin/zshdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/sync# 想输出第一个字符的话cat test.log|awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos; 想一下，我们通过cat ,是不是能把文件默认输出在页面上，然后我们通过awk去处理，设置分隔符号 ‘:’,默认的分隔符符号是 ‘ ‘. 123# 练习：提取nginx 500 日志，并统计总数# 78.181.37.209 - - [28/Nov/2018:15:01:56 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&quot;cat access.log|awk -F &apos; &apos; &apos;if ($9 == 500) print $0&apos; | wc -l 注意这个分隔符号是空格，即使双引号里面有空格，也会把切割开， wc -l 可以统计行数 变量内置一些变量，比如行数NR，这一行有多少个字段NF(这两个应该是最常用)，123456FILENAME：当前文件名FS：字段分隔符，默认是空格和制表符。RS：行分隔符，用于分割每一行，默认是换行符。OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。OFMT：数字输出的格式，默认为％.6g。 12345678练习： 2 345 2 123 1 789 1 1234awk &apos;&#123;print NR&quot; &quot; $2&#125;&apos; log # 行数 第二个字段中间用空格连接awk &apos;&#123;print NR&quot; &quot; $(NF)&#125;&apos; # 行数 最后一个字段中间用空格连接，运行的时候中间的值会被替换 函数1234567tolower()：字符转为小写。length()：返回字符串长度。substr()：返回子字符串。sin()：正弦。cos()：余弦。sqrt()：平方根。rand()：随机数。 条件1234awk &apos;条件 动作&apos; 文件名awk &apos;条件 动作&apos; 文件名awk -F &apos;:&apos; &apos;/usr/ &#123;print $1&#125;&apos; demo.txtawk -F &apos;:&apos; &apos;NR % 2 == 0 &#123;print $0&#125;&apos; demo.text #输出偶数行awk -F &apos;:&apos; &apos;&#123;if (NR % 2 == 0) print $0; else print &quot;error&quot; &apos;&#125;&apos; demo.text 12345678910练习[例]：有如下文件test,请统计每个网址出现次数，用一句shell实现。a [www.baidu.com] 20:00b [www.qq.com] 14:00d [www.baidu.com] 23:00e [www.qq.com] 20:30f [www.360.com] 20:30 cat url.txt|awk &apos;&#123;print $2&#125;&apos;|sort|uniq -c|sort -rn# cat 查看文件内容， 输出第二行的内容，排序，因为 uniq 只能把连接在一起的文件重复文件合并，然后再倒序 uniq -c 把重复的行数显示在前，但是只能合并连续的sort 排序， -rn r是倒序，n是按照数字处理head -n 5 取出前五行，这也是查询的时候经常要用到的 补充一下1234# 取出cpu 或者内存占用前五，top 查看占用ps -aux|sort -k3rn|head -n 5# sort 自带切割，# ps -aux 可以查看所有进程， 比如之前我想查看我的一个脚本 server.php,可以通过 ps -aux|grep server.php, 相比较netstat -antp|grep 9000,查看端口占用情况， ps -aux 查看更加清楚，比如swoole 的进程，1个 master ,1个manage,剩下的work ，所有的进程都能查看到，但是netstat 只能查看到一个 统计某接口的调用次数 1cat access.log| grep &apos;GET /app/kevinContent&apos; | wc -l 统计报错接口 1cat access.log| awk &apos;&#123;if ($9 == 500) print $0&#125;&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP常用工具]]></title>
    <url>%2F2018%2F11%2F23%2FPHP%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP的感觉]]></title>
    <url>%2F2018%2F11%2F12%2FThinkPHP%E7%9A%84%E6%84%9F%E8%A7%89%2F</url>
    <content type="text"><![CDATA[学习，为了更好地适应未来的工作。简单的解除了下tp和laravel，总体来说tp比laravel简单多了，封装的也没有那么深，所以用起来还是很方便的，用的是5.0，5.1和5.0区别就挺大了，不如有了门脸，又是一个使用类不知道到底用哪个命名空间下类比较好的时候了，还有获取参数的方式，5.1已经没有getInstance()这种东西了，记录一下这几天的感觉,方便交流 目录结构 首先是模块的创建，主要是为了方便后台模块和 api 模块的分开 后台模块， 这个项目中主要是通过接口能返回html 模板 但是 api 模块，单单只用返回json 数据 Controller关于api 模块的json 返回，我们只要调用json() 方法就可以了，不需要做进一步的配置， 我们还可以通过json 方法的进一步封装，让调用起来更加方便 [图片上传失败…(image-14c2c0-1542018168779)] 这种方法其实就是在返回头上加上个别的信息 这种公共的方法我们可以写在 common.php 文件中 控制器中获取传过来的参数 有个坑就是5.0 和 5.1 通过request 获取参数的方式竟然就不一样了， 5.0 中 其中一种 Request::instance()-&gt;get() 5.1 Request::get() (5.1中已经开始出现faceade这种看不懂的东西了) 其实用助手函数就没有上述问题了，···但无奈我不喜欢用，但感觉助手函数的话对不同版本的tp代码都是通用的 对于put 参数，我们在用postman 提交代码的时候需要通过第二种方式提交，第一种方式是获取不到的，可能是因为表单默认屏蔽了put delete 提交方式 这个header 头信息是真的坑，解决这个办法就是先把$header 信息保留成数组，然后再通过数组去寻找这个变量 讲道理，还是有点不明白_initialize 和 __construct(） 的区别 关于文件的定义，基本上除了配置文件，剩下的都是class 文件，按照psr4 ,类名要和文件名一样，我之前有过类名和文件名不一样，导致文件加载失败 异常处理那块，当调用父的 异常处理函数，需要return ,否则会报错，感觉和调用模板也需要return 是一个道理 Router关于 tp 的路由，好久之前就知道被吐槽pathinfo 模式，虽然我不知道是因为什么被吐槽，除了pathinfo 还有别的模式吗？ 除了默认的pathinfo, 我们对于api 接口（admin 那种返回html 的可以不用管），可以使用路由注册的形式，就是在route.php 中进行路由注册，他会首先匹配,没找到的会使用pathinfo 模式，这块需要我们在配置文件中进行配置 （可以完全关闭pathinfo 或者 路由注册的形式） （关于路由注册这块，tp 的路由注册和laravel 的还不一样，他不是使用命名空间的形式，用的是感觉自己定义的形式， 但感觉因为这个方面，路tp的路由方面应该不能单独拆出来给别的项目使用），但其实也挺好理解， 注意 完全路由匹配，还有路由参数的限制 参照： https://www.jianshu.com/p/73ed6e42d389 Config今天因为不太知道config() 助手函数都是从哪里获取的数据，查了一下，这篇文章写得还是蛮好的 https://www.jianshu.com/p/cd8b68143fde 比如我们那个api模块的接口需要很多额外的参数，我们只需要在application 最外层定义一个extra 的目录，然后会自动引入里面的文件 我们配置文件的数据返回大致如下 通过 config() 可以看到全局的配置参数 DBmodel 最近用的都是orm,不管是后台admin 还是api接口，都可以公用，所以新建了一个common模块，在里面写入了model,通过model() 或者命名空间的方式都能使用（我比较喜欢用命名空间的方式去使用，tp的orm可以分离出来去别的项目中使用，当然model()方法引入model类就不可以了，只能通过命名空间的方式） 题外话 ：关于为什么用model() 就能引入common 模块下的model，我们可以理解成约定俗成，甚至可以理解成1 + 1 = 2， 之前我纠结这些问题很久，但其实他就像我们使用别的约定俗成的概念是一样的，只是这个可能是由于框架的封装，在我们的印象中很难站住脚 ，或者没有看到官方给的白纸黑字的文档，能做的就是看源码，model 是怎么执行加载的，表哥说过，你可以画上 1年半载去弄懂框架的源码，但如果你弄不懂的话，你也可以通过专注业务区提升自己的能力，有些东西能用就好了。 基本的方法: 通过在数据库配置文件中设置表前缀，默认类名称是 ‘表前缀_类名’ ， laravel 是表名单数 查询 select 获取集合 ，这个直接json 返回外面就是array ,在项目里面打印是 是object ,这个项目里面转换成 array 需要 collection($arr)-&gt;toArray()， 这个Db:: 用select , 查出来竟让也是 object ,想变成 array,可以通过toArray() find 只能获取一条 ,这个直接 就是数组 column, 查询单列 value 查询单个值（那种集合的查询调用 value 也是只返回一个值） field 获取哪些对应字段,还可以给字段取别名（感觉很强大，还能用函数 sum(score)） order 同上 limit 5 size page 1 页码 (感觉这个page 还是和limit 分开来使用比较方便) 查询方法 where =&gt; [‘id’=&gt; 1, ‘status’=&gt; 1], 多条件等于情况， [‘id’, ‘status’] 代表两个column where =&gt; [‘id’ =&gt; [‘&gt;’, 3]] id 大于3的情况 whereOr 插入 insert insertAll 批量插入 insertGetId 插入成功之后返回id getLastInsID 返回最新插入的id 更新 update setField 更新某个字段 setInc 自增 setDec 自减 删除 delete 关于链式操作，注意select() ，table 这些不属于链式操作，所以需要放在最后面，剩下的那些链式操作没有顺序要求 alias 给表取别名 groupby 分组 having （最好在group by 中使用count这种的聚合函数） 子查询和 union 基本不用 distinct 唯一不同的值，不同的值，比如这个返回admin和chunice count 这个好像需要放在 where 条件后面，要不然也会报错 orm 之所以能调用这些db的方法是因为orm 的基础是db 自动写入时间戳都是针对orm 这种操作可以的，db 操作是不可以的， 上面的操作都是db 的操作 注意用Db 进行操作的时候，命名前缀已经失效了，记住要用表的全名 关于join 表，老师和表哥说都不要join ,因为数据多的时候join会出问题，对于用户和用户名的对应的时候，利用先找出所有数据，再把userid 取出来进行in 的查询，再通过遍历之前需要处理的数据，把username 链接进去，这样是可以的，但是对于zan这种，可能不存在这条数据 这几种join是当初面试的时候经常问的 comment 给sql语句增加注释（··感觉好没用啊） fetchSql 返回sql 语句 （ 感觉挺好，可以知道执行了什么，但用with 那种关联关系，只能返回第一条语句···，太废物了） ORM其实，感觉：查询出来的是object 对象，还是纯种的array ,就是看调用者，如果是 Db::table 调用，就是 数组 如果是 User:: 这种方式调用，就是 object， object 又有 user 和 collection 之分 新增 save 插入 这个不能用静态方法，只能实例化调用 saveAll 批量 返回值是受影响的行数，我们想获取到自增id ,可以通过 $user = new User() $user-&gt;save([]) echo $user-&gt;id ,这种方式获取到，因为save 不能非静态化的调用， save() 返回值是受影响的行数 批量新增 saveAll() create 静态调用 User::create() , 返回值是自增id 修改 save ,需要传入主键 saveAll 批量 update 静态调用 ,这个方法也可以直接调用，Db和模型都有这个方法 据说通过 -&gt;where-&gt;update() 这种就不能使用tp模型的事件功能（什么是事件功能？就是那种更新表前会有什么操作，类似钩子） 感觉这个方法除了静态调用，就不知道有什么比较方便的地方了，感觉那种直接通过模型只使用update() 方法不太好，不太直观，感觉很多时候应该是不止是就是用一个update 方法这么简单 删除 delete 删除，也是模型和Db 都能使用的 destroy 删除 查询 get （条件） ，find 感觉查询的功能真的是各种强大，慢慢学习吧 获取器的重要作用： 其实我们在平时的开发中总会遇到类似的问题，就是数据库中对于status 存储着各种数字，然后给前端展示的时候，循环结果，把结果中的每条数据的status 对应的中文取出来，然后再加上，读取器就是为了这个产生的，我们在读取一个 attr 的时候，类似定义一个钩子，他会自动帮我们把取到的数据进行修改（其实有两个参数的，第一个是这个值，第二个是整条数据的值） all (条件) select () 软删除 这种事很常用的，我们平时使用的时候通过加入一个标志位，然后tp中也是使用标志位，delete_time ,但筛选数据的时候不用我们处理，仿佛真的就删除一样，可是在管理工具中还是能看见 关于orm 的执行日志，或者是说sql日志，统一的开启数据库调试模式，然后直接在log中查看就好了 notice : 就是很灵活，因为orm 也是基于数据库的，所以数据库中的很多方法在orm 中也可以用，甚至同名，比如update,但返回的内容不一样，orm 的update 返回的是更新的实例，数据库的update 返回的是兽影响的行数 感觉就是模型的话要是不用with 这些关联属性，意义会小很多，可是后来发现，那些处理orm 查出来的的数据，确实会方便很多 关联： 1对 1 ： 虽然感觉有时候反着写也是对的，但最好还是遵从 （虽然七月老师说是二者是不对等的，比如 user 和 userinfo ,userinfo 有 userid ,但user 找不到 userinfo ,但如果是 1对 1 ，是真的都能通过定义 hasOne 和 belongsTo 去获取对方） （按照编辑器的推荐，确实 hasOne 更准确点） （user hasOne userinfo 这个也更符合我们的习惯） 感觉上反正很怪，如果编辑器能提醒就好了，但只能提醒是主键还是外键，并不是提醒是哪种表的主键，那张表的外键 user -&gt; info user 中定义 hasOne $this-&gt;hasOne(‘info’, ‘user_id’,’id’），这个提示比较符合大众的想法 info 中定义 belongsTo $this-&gt;belongsTo(‘user’, ‘user_id,’id’) 单个模型还能通过 $banner-&gt;hidden([‘update_time’, ‘delete_time’]); 来隐藏对应的字段 感觉最好还是在model 的定义的时候隐藏 注意select () 这种查找出来的都是数据集合 collection 看一下这个例子，通过嵌套关系，可以实现images 内部数据的排序，所以关联关系也是可以嵌套的 Cache自己新建的缓存文件不要和 thinkphp里面的字段名称一样，否则回报错误 Exception配置文件中开启debug 模式，要不然总是 ‘tp 专为api而生，十年磨一剑’的错误信息 开启之后还需要处理，因为我们前台只需要json数据，我们需要考虑程序上线之后如果发生错误了我们该怎么处理，其实没法处理，因为我们不知道什么时候会发生，想象一下如果我们知道他会发生，那我们为什么不去阻止而让他发生呢，此时我们需要一个监听全局异常事件的东西，当php抛出异常的时候我们只要去捕获他，然后处理就好了，类似前端的钩子 。 知道吗 ？在我们原生的php当中，其实有个专门对全局异常进行处理的函数，可以自己定义，可是呢··我没有自己去试过，首先是异常自己理解的比较浅，再者对于框架的使用比较少， tp的全局异常处理应该也是这个原理，本质上应该还是修改这个函数，当我们在tp中想改变全局异常处理函数只需要修改配置文件中的异常处理函数名称，改成自己需要配置的就好了 接下来我们重写下全局异常处理函数，让他更符合我们的要求 首先需要继承tp自带的异常处理，然后重写他的render 方法，，为什么？因为我们在bug模式的时候需要tp给我们提示错误信息，总比我们自己看 $e-&gt;getMessage() 方便详细的多 接下来， Basci Exception 是自己默认定义的exception， 既然是自己定义的错误，自然不用tp的异常处理，直接返回前台json 数据就好了，因为自己定义的错误，一般是手动抛出，自己了解错误的原因 然后是非自己定义，首先要是判断是否开启了debug 模式，如果开启了，说明在调试，直接使用tp自带的就好了，千万注意要加上return ,要不然会报错，毕竟是html 页面的返回（类似可以想象一下tp中模板的返回） 再者是如果是上线环境，只需要告知前台服务器错误就好了，定义个固定的数组，返回给前端，然后记日志 （记录日志也是很简单的，log::error(), 写在runtime的log下面） 异常处理定义完毕，就要开始定义异常类了。使用异常类的原因就是告别传统的遇到错误的返回方式，还记得之前我们在嵌套函数中执行错误后怎么返回的吗，只能层层往上抛出，到了最外层的controller 返回，可是异常就不一样了，当异常处理检测到这个地方抛出的异常，就能直接进入异常处理函数中，多方便。 （还有一点我觉得定义异常的好处，就是之前我们对错误信息的输出总是 code =&gt; message =&gt; ,有时候为了规范我们通过写一个方法，通过code 去获取message ，但你想象一下，当你写完接口之后，满屏的 code ，你也不知道这个code 代表的啥意思，当然我们可以约定code的规范，如果我们通过throw new ParamErrorException([code=&gt; , message=&gt;]), 我们就会知道这个错误大致属于前端参数的错误） notice :1.不管是什么框架，我们定义的异常都一定继承于最原始的php \Exception 2.常用的方法 $e-&gt;getMessage(),获取错误信息 3.注意异常类因为继承自exception，我们一定不能定义exception中有的属性，比如我之前在异常类中定义过一个message属性，这个属性是exception 中的protected，然后在参数验证那块会出现莫名其妙的异常错误 Validate说实话，我到现在还没有明白验证器的具体作用，平时那种 new Vdalidate() -&gt;bitch()-&gt;check() 感觉就能符合需要，可是要是真的每次在valiate里面写上同样的验证规则， 确实可能会有重复定义的嫌疑 但我感觉要真的发挥验证器的作用，必须介乎scene() 场景来使用，一个validate 对应一个类，或者model，这个validate有各个属性的校验，通过定义scene ，让我们不会定义过多的validate 类 在 $rule 里面 有各个报错信息 $message = [‘id.require’ =&gt;] 这种细致的分层，让错误信息准确的定位，或者直接 id =&gt; ,这样可能id对应多个验证规则的时候，需要把错误信息都加上，如果出错了，不知道具体是哪条规则出错了 scene ,对应场景，可能某个实体过来了，我需要验证其中valdiate 类中的某几个属性，我就用scene 去细分，如果不用scene 的话，想象一下，这个地方比如user 模型需要name 和 sex ，另一个地方需要 name 和 img ，难道我们需要为此定义两个validate ，感觉一点都不灵活（exception如果遇到这种通过向里面传入不同的参数来解决） 重写validate 和 重写 exception 不一样，重写valdiate ，其实是对传统 validate check 方法的封装，和 定义方法的更多加入，因为check 之后，所有的错误信息都会储存在 error 这个属性中（或者 $this-&gt;geterror()来获取），然后通过异常把这个错误信息抛出去给前台页面 其他 laravel 中也有相似功能，感觉就和路由中间件一样，在执行到这一步之前都会先执行这个验证操作 感觉这个比那个__initze() 什么方法方便多了 总结还有太多太多我不会用的，所以后面的路还很长啊，只是 为了更好的入门 ###]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 关于blade]]></title>
    <url>%2F2018%2F10%2F10%2FLaravel-%E5%85%B3%E4%BA%8Eblade(%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E)%2F</url>
    <content type="text"><![CDATA[其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。 itbasic 用的也是模板引擎，名twig，其实和blade没有多少不同的地方，只是自己发现的twig新功能还比较少，只是一直在原先的基础上堆代码，感觉上在模板引擎里面还是不要做过多的逻辑判断，否则后面会越写越复杂，而且难于维护。 对于web网站，我们有很多页面，但这些页面大部分都是相同的？因为我们的布局需要相同，这个其实在写itbasic的时候应该能感觉到，我们似乎只需要填充中间的content部分就好了 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;@yield(&apos;title&apos;,&apos;测试&apos;)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; @yield(&apos;content&apos;) &lt;/body&gt;&lt;/html&gt; 什么是yield ,就是让继承者可以填充的东西，继承者通过 123456@extends(&apos;layout.blade&apos;) //继承上一个模板@section(&apos;title&apos;, &apos;cy&apos;) //填充数据@section(&apos;content&apos;) //这种方式填充数据要有结束符号 &lt;h1&gt;222&lt;/h1&gt;@stop 12@include(&apos;default.ce&apos;) // 包含额外的页面//传递变量，include(&apos;default.ce&apos;, [&apos;user&apos;=&gt;$user]) 123456789//判断@if ($a &gt; 0) &lt;h1&gt;cc&lt;/h1&gt;@endif//循环@foreach($counts as $count) &lt;li&gt;&lt;/li&gt;@endforeach]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站升级https]]></title>
    <url>%2F2018%2F09%2F11%2F%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7https%2F</url>
    <content type="text"><![CDATA[升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。 https原理HTTPS采用共享密钥加密(对称加密)和公开密钥加密(非对称加密，比较出名的有RSA)两者并用的混合加密机制。在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式之所以传输过程中用对称加密，是因为非对称很浪费资源 (hash加密是单向的，例如md5,不能解密)和对称加密还有非对称加密都是不一样的，不管是对称加密还是非对称加密，通过秘钥都是能解密的，但是hash，只能维持 hash(内容)之后的值保持一致，这也是我们数据库中只保存用户密码加密后的值就可以验证用户的密码是否正确了，因为我们可以每次获取到用户信息之后只要hash一下，然后和数据库中做下对比就可以了。 https ,首先让服务器和ca交互，获取服务器的公钥，这个过程是非对称加密，获取到公钥 https升级过程中遇到的问题: 不允许脚本调用http，可以先把接口转发到我们本地的服务起的https上，然后通过nginx转发到别人网站上的接口，因为本身调用外来接口接口比较少，这样能符合我们的需求 https证书申请无效（每个域名都需要申请单独的证书，之前以为只要申请一个www.chenye2017.cn证书就可以了，chrome直接显示https不安全，其实通过微软的edage浏览器访问，能清楚的看到证书不匹配的原因） （证书申请是通过腾讯云，腾讯云上有详细的教程，唯一不足的是没有给文件夹权限，导致第一次访问403） （https配置虚拟主机应该就和我们在vhost文件里面配置虚拟主机一样，现在是在ssl配置文件里面写）（话说我现在的服务器，域名用的是阿里的，服务器用的是京东的，https证书用的是腾讯的，zz）（还有不知道是hexo的原因还是github page 的原因，我的网站上有http的资源竟然不会显示https错误，不知道他是怎么解决这种http资源不出错的，有空可以了解下） https和http的区别 简单看就是 https = http + SSL SSL的运行机制，可以参考阮一峰老师的文章，我对上面的一些内容做了些自己理解的笔记 其中加密传播是因为我们的传播内容都是通过生成一个第三方不知道的公钥，这个公钥是怎么来的呢，首先通过ca证书，因为系统内容ca的公钥，ca用私钥加密文件内容（私钥加密，公钥解密，不被篡改），我们获取服务器的公钥，这个公钥是干什么的呢，并不是用来进行数据的加密的，而是用来加密传递的数据给服务器（公钥加密，私钥解密，不被获取），服务器接收到客户端的数据进行生成公共密钥，这个密钥是我们以后加密数据用来传递的(感觉只要记住证书里面的内容都是能保证绝对正确就好了) 具有校验机制，是因为我们的证书具有这个作用，比如我上次把我从www.chenye2017.cn 上获取的证书放到虚拟站点blog.chenye2017.cn就直接报错 配备身份证书，估计也是这个意思 所以ssl 和 tsl 是一样的意思嘛 感觉这个握手不是tcp的那个三次握手，这个开始的时候tcp那个三次握手应该都搭建好了，而且这个也是4次握手 剩下的内容就是4次握手的详细内容了，为什么要4次握手，写的都很详细，就不再补充了，总之这个生成传输加密内容的秘钥也是通过非对称加密，再后面就是http了。 总结一下： 通过CA 证书，发送服务器公钥，利用的是非对称加密算法，用的公钥和私钥来自CA（证书的作用是为了保证服务器公钥的正确性，不被篡改） 通过CA得到的服务器公钥，大家都可能有，但是我们通过公钥加密，私钥才能解密，和服务器交互，让两端都能生成一致的对称加密算法钥匙（随机因素可以通过客户端利用服务器公钥加密传给服务器） 利用生成的公共密钥进行对称加密，传输数据（这个公共密钥在每次连接的时候生成，别人不知道）]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于git]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%85%B3%E4%BA%8Egit%2F</url>
    <content type="text"><![CDATA[公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨 首先是分布式（不需要联网，本地就是一个完整的环境）和集中式（需要联网，否则运行不了）的区别 分布式就是在每个人的个人电脑上都有仓库，称作本地仓库，本地仓库也会保存整个项目的提交记录，让我们在不连网的情况下也能进行代码的提交，当我们可以连网的时候，再把代码推送到远程仓库，远程仓库只是一个让我们各个工作者可以相互交换提交记录的中转站，我们的提交在git commit 的时候已经完成(我们唯一的提交信息就是在commit 时候写的)，也就是在git log 历史里面已经占据了位置，我们在push 的时候只是用本地的提交记录去覆盖远端的提交记录。而集中式代表着我们在不联网的情况下完全工作提交不了代码，那个中央仓库才是我们的唯一仓库，往里面提交代码才会产生log。所以我们在用集中式的时候，查看log都是通过查看远端log，对比diff也是，所以断网的情况下完全用不了,而分布式完全没有这个问题。 查看分支也是同样的道理，git branch -all , 可以查看本地的所有分支，包括远程分支 。这里提到的远程分支并不是远程仓库上的实际分支，而是你上一次git pull 的时候下载到本地的分支，如果这时候别人新推送了分支到远程仓库，你必须git pull 重新下载一次，否则还是看不到他提交的远程分支。 git add . 我们每次修改代码之后都需要git add 文件名(. 代表所有文件)添加到暂存区，当我们添加一次之后，又修改了文件，还得git add 一次，因为git add 只是把当前文件现在的修改添加到了暂存区，如果后面修改了，还得重新添加一次，这个可能和svn 的只需要add 这个文件到管理文件夹内，后面修改直接commit 有点不同， git add 每次添加的是文件修改内容，而不是整个文件 up-to-date 最新的，有的时候可能显示before one commit 这种，代表你要给远程分支push啦、 git init 把本地文件夹变成git 仓库 git remote add origin git 地址 为本地仓库添加远程仓库 git remote -v 查看配置的远程仓库 git clone 做了两件事情 下载了.git 本地仓库，然后把当前目录当做工作目录，把master 最新的提交内容填充当前目录 .git .git 就是本地仓库，下面的index 代表了暂存区 git comment -m git comment 是实际的提交，会产生log 日志，像我在做itbasic 的时候经常一个功能提交多次，因为有的代码忘记提交了，可以把comment 合并，产生一个log git comment –amend ,修正上次的提交，很方便，可以合并多个提交内容到同一个comment (也就是同一个log 点) git push 推送本地log 覆盖线上log (覆盖的时候会自动检测，如果没有冲突，直接合并。如果有冲突，比如 节点不能往前推进，会让先git pull) git 提交流程 git add . git commit -m git pull 冲突发生的地方，pull 只会把需要的内容拉下来，并不能把你之前提交到本地仓库的内容push, 所以pull 之后还是需要push的（感觉这个pull还是挺智能的，在pull的时候如果有冲突，比如修改了同一个文件，还是没有提交到暂存区的那种，需要你先commit 或者废弃（感觉不要动不动就pull, 现在每次开发新的内容，都自己新建一个分支，然后直接在当前分支开发，开发完了把当前分支推送到远程，最后统一合并到master上）。想象一下pull 中包含merge 操作，merge 操作的对象是线上的commit 和 你最新的commit，所以如果有未提交的内容，一定要注意啦，别被覆盖了，但是如果没有关联的文件修改，pull的时候有没有commit 没关系） git branch branch 字面上是分支的意思，其实就是一次提交的引用，类似head, master （远端分支head 一定指向master， 可是我们本地head 可以切换到别的分支上呀，而且对应的好像是这个分支的最新提交） 因为branch 是一个引用，所以我们删掉任何的branch ，都不会删除commit 自己的分支，因为回退之类的不能修改，那就强行 ， git push origin branch1 -f ，但这种只针对自己吧 （千万别在master 上强行push） git checkout git checkout -b feature, 我们新建一个分支并切换到这个分支上面，想把本地分支提交到远端只需要git push origin feature：feature 就好了 还有就是注意我们在切换分支的时候一定要commit ,想象一下，如果我们没有commit ，在下次切换回来的时候，很多内容是不是就没有了，因为切换到的是这个分支最新的commit 上面 (我还是觉得切换分支的时候一定要commit， 想象一下切换分支的那个动图) git checkout -b feature origin:feature , 注意一下这个和上面的区别，上面的feature 其实还是基于master搞出来的，但是这个是基于远程的feature 搞出来的，有本质上的不同 git rebase主要是用来分支合并的，比如之前在master 分支上开出来的feature 分支，开发完了再合并到master分支上，这时候master分支已经不是原先的master了，可能有向前的提交，就会出现分支的合并，如果不希望出现多条分支合并的情况，可以通过切换到feature分支上，然后git reabase mater, 以新的master分支作为起点 （git rebase 之后，只会把master 分支多加commits, 并不会切移动head, 但是能把当前分支的点移动到master 上，也不会把master 主动移动，需要我们主动切换head 到master 上，master merge 提升head 和自身（master））后续操作：git checkout master, git merge feature, git reset –hard commitId git reset –hard 目标commit 到达任意一个commit ，我觉得直接用sha-1码很方便，小册中说的回退，但是用sha-1码的话，我感觉能到任意一个commit （回滚） git 和 github 的互动 git 在我们日常生活中用的最多的就是github，当我们一台崭新的电脑希望从github 中clone 代码的时候（比如git clone xxxx），我们需要ssh 连接到github 上，不做任何处理的情况下会被告知ssh 连接失败，我们需要做的就是在本地电脑上先生成ssh 公钥和私钥（如果没有的话），然后把公钥贴到github 上，公钥的生成过程中需要一个email， 这个其实随便填都是可以的（既然email 是随便填的，但怎么识别这个公钥对应这个用户呢，我觉得应该是这个公钥被贴到对应用户的账号setting处，所以github能识别这个ssh key 对应这个用户，这里有篇文章写得https 和 ssh 之间的区别）。(这个email便于区分贴的ssh public key 是谁的)。 我们在仓库的提交过程中也需要配置email 和 用户名，其实这个只是代表着你显示在git log 日志上的用户名和email ，并没有实际的作用 今天给easy swoole 提交pr ,详细过程阮一峰 (要注意的核心就是我们提交的pr 具体是哪一个分支，不能只会使用master 分支) 首先是从fork代码从easyswoole 到自己仓库中的时候，注意fork的是哪个分支（好像不能把所有的分支都fork下来），然后git clone 到本地仓库，这时候通过编辑器打开，可以把fork 的所有版本都打开，通过 编辑器右下角的切换，可以在本地创建对应分支 123git branch 本地分支git branch -a 远程分支git branch -vv 分支对应情况 通过编辑器切换可以自动添加分支关联，如果想手动关联不同分支，查看这篇文章 总结：所以 git push origin master , 这个master代表的就是分支名称喽 （git push origin master:master 其实是这样的，origin 代表的是远端仓库名称，两个master 分别代表本地的和远程分支名称） git 只能记录纯文本的修改，不能记录word 这些二进制文件的修改，对于这些二进制文件的修改，只能知道他大小的具体变化，不能知道具体修改的内容，所以我们平时的文档都用md格式？ git 除了支持 ssh 协议，还支持 https协议 （但是https 协议下载的时候总要输入用户名和密码，所以一般还是走ssh吧） 虎扑代码发布 提交流程 自己本地新建分支用于开发，基于远程master 分支, 写完了，推送到远程分支，和develop 分支合并（自己有合并权限） // git checkout -b cheney/test origin:master 通过远程master 分支新建分支 （因为我本地master分支有些没用的东西， 所以本地master 分支不要做任何的事情吧） 还是不要用上面的新建分支的命令吧，容易出错。用git fetch origin chenye/test:chenye/test, 新建本地的分支 对于分支切换的时候的错误，是在不行就 git add . git commit -m 。但这样以后千万不要随便提交，比如我本地的master分支 对于我熟悉的分支切换时候的错误，就git stash ,git stash pop 恢复吧 给master 分支提交的时候一定要记得merge， git pull origin master:chenye/test, 我曾经收到一个这样的提示 这个原因是master 和 我本地分支完全一样，没必要merge (而且本地有提交， 如果本地也没有提交，如下) git push origin chenye/test:chenye/test 推送本地分支到远程分支 测试完develop 分支，再把自己的分支和realease分支提交合并请求，此时并不用拉取 master分支 realease 分支测试完，给master分支提交，一定要提前和远程master分支合并，也是给master提交 pr （并不用和release 还有 develop 合并，因为我们只需要把我们的分支提交给master就好了，release 还有 develop 上面可能有很多别人尚不稳定的内容） git pull origin master: chenye/test 拉取远程master 分支和本地分支合并 （git fetch 更安全点，和 pull 的区别 ？） ！！！注意，我们在用sftp 连接远程代码的时候，本地分支的切换并不能保证远程代码的切换，所以为了不出错，需要我们自己手动切换分支 本地某个分支写了很多，但没有提交，所以切换的时候就容易出错，首先如果可以的话，我们git stash 暂存，如果是untracked ，可以通过 git add. ,再git stash，按理说前面两种就能解决所有问题了，实在不行最后只能git add ., 然后 git commit ，但这样以后千万不能在这个分支是 git pull 所有的代码拉取都是 可以跨分支，分支的推送都不跨分支，所以合并都是通过pr 方式， git 撤销操作 对于已经add 的内容 （一般显示绿色） 通过 git reset 撤销，撤销完了之后还需要通过 git checkout (因为上面的操作只是撤销暂存区内容，所有内容都返回工作区，所以还得对工作区内容进行处理) 对于 没有add 的内容（一般显示红色），但是 tracked 的 文件，通过 git checkout . 撤销 git checkout 文件名，可以撤销具体的文件 对于没有add, 也没有 tracked 的 文件，通过 git clean ， git clean -n 先预览删除哪些文件，防止误删除， git clean -f 删除具体的文件。（clean 的话下面这些蛮好用的，注意加上n, 查看会删除哪些文件，对于编辑器产生的内容，不想删除，可以直接添加到.gitignore, 提交之后看看有什么变化，其实编辑器产生的内容没啥影响，直接删除就好了，下次又会自动产生） git 文件在checkout 或者提交的时候，如果是跨平台，可能遇到 \r\n (win) 和 \n(linux) 的问题，一般情况下 git bash 都配置好了，只有那些比如我远程代码linux 下，sftp 到本地 win 下，才会出现这种问题 （git 自身的兼容只有在 checkout 或者 pull的时候，如果是通过别的方式比如sftp，好像不行），目前尚未解决 原先我调试代码的方式是虚拟机里面clone， 然后phpstorm 远程连接上去，本地代码拉取一份，这样本地代码修改，远程可以直接自动修改，唯一缺点就是上面的crlf 不能实现兼容（本地拉完代码，git status 就会发现大量代码的modifyed），如果是mac 的话，应该蛮好处理上面的问题, 因为他们的换行符是一致的 后面我是本地clone代码，然后sftp 到远程，这样就能避免上述换行符问题。唯一需要注意的就是本地分支切换和远程分支都得手动切换 关于phpstorm 切换分支，远程目录也切换分支，如下 所以我们就把 sftp 和 ftp 当做一种远程同步代码的方式就好了 还有要注意的点就是我们配置了Configuration（远程文件夹位置的配置） ，也要注意一下options， options 对我们的保存操作（是否改动就上传），哪些文件需要被同步会有配置（.git 文件一定要上传，方便我们切换分支）]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于单点登陆的那些事]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.单点登录：简单理解成一处登陆，到处登陆，一处登出，各处登出。其实在生活中的应用还是满广泛的。比如你登录淘宝的网站，可能当你跳转到天猫上，也不需要登陆，光从界面上看，也能分辨这是两个网站，这两个网站肯定有各自的登陆机制，其实内部就是用了单点登录的原理，让用户无感知的情况下实现一个账户在各个网站下的登陆登出。后来在写的过程中，发现这个单点登录也有点第三方登陆的意思，这个第三方就是sso登陆中心。很多人广从字面意义上看，可能会觉的单点登录应该是这样：一个用户在这个地方登陆了，比如手机上或者上海登陆了，当在电脑上登陆或者安徽登陆了，之前登陆过的账号会下线，但这并不是单点登录哦，想了下，上述功能实现起来也挺简单，比如我们经常存取 token =》 用户信息这样的登陆凭证，又或者是session_id =&gt; session 信息（用户信息）这样的登陆凭证，不妨我们在用户登陆的时候，再存储一封 用户id =&gt; 用户信息，这样我们可以很方便的统计有哪些在线用户，哪个用户是否在线（前面第一种的话需要遍历所有的session文件取出用户id）。当我们登陆接口产生了一个新的token =》 用户信息的时候，我们检测下这个用户是否在已登录列表，如果有，我们服务端直接让之前的token失效就可以了，就能实现前面账号的下线。回归正题，关于单点登录单点登录的原理大致就是上面了：1.先登录普通web1，web1后台检测是否登陆了，如果登陆过，直接跳转到web1,如果没有登陆，跳转到sso登陆中心。sso中心检测这个用户是否登陆过，如果没有登陆，跳转到sso登陆界面，输入用户名和密码（之前为什么说单点登录很像第三方登陆呢，因为接入单点登录的web1也不知道即使能登陆到他这个平台上的用户的用户名和密码，用户登陆的操作逻辑都是sso 这个第三方维护的，web1只是在登陆sso成功之后维护一个用户和web1的登陆态，比如web1派发给用户一把钥匙，以后拿着这把钥匙就代表你是web用户了），用户成功登陆sso这个中央站点后（用户和sso之间的登陆成功搭建成，之前我是通过jwt的方式维护用户和sso之间的，jwt相比较传统的cookie和session就是通过签名的方式能防止用户篡改已登录人的信息），sso会回调web1站点上提前设置好的接口（这个我当时是在跳转到登陆中心的时候附带在url后面参数，其实这个可以提前设定好，然后通过传入一个参数web1，sso去后台查找需要的会掉地址），传给他一个参数，可以理解成一个ticket，web1拿着这个ticket可以换取正在登陆的用户的用户信息，拿到之后web1就能实现自己的业务逻辑了，比如检测这个用户是不是第一次登陆，如果是第一次登陆的话需要绑定用户信息之类的，然后维护用户和web1之间的登陆状态建成。上面需要注意的点就是客户端如何接受服务端生成的登陆凭证.首先是用户和sso中心，这个好解决，因为我们的登陆页面可以可以当做一个静态页面，我们可以在上面写js，这就方便了，我们发送一个ajax请求给sso，成功后把返回的登陆凭证放在cookie中，每次调用sso接口比如验证用户是否登陆的时候都会携带着这个cookie，！！！千万要注意，携带这个中在客户端浏览器的cookie的前提是通过ajax之类的访问，你别通过curl之类的访问，curl需要自己手动设置cookie，并不会像浏览器一样自动添加上，所以我们在后台一般要用header location之类的跳转，而不是curl.web1和用户之间登陆态的维护：这块我没有使用header location跳转，用的是ajax返回给前端页面，前端页面去跳转，之所以这么做，好像是用第一种好像有点问题，没有去研究了，因为时间赶啊！！！前端拿着这个ticket，哈哈哈，你是不是担心不安全，我也担心呢！！而且我这块直接用的url跳转，为什么呢，因为我的后台是获取用户信息之后直接跳转，并不需要ajax那种返回了，如果这里用返回，首先是前台页面并不知道维护好登陆信息之后需要挑战的地址（这个静态页面是sso的），然后呢，如果通过ajax，后台跳转可能有些错误，之前那个sso登陆成功后台跳转不到web1，可能就是这个问题。web1的回调地址里面通过ticket拿到用户信息之后可以做很多自己事情了，比如绑定用户，比如验证用户是否合法等等 2.单点退出一处退出，处处退出。我是这样做的，当登陆成功后，会在数据库中写入，这个用户的登出地址，当我们登出的时候，查询数据库，所有用户的登出地址，循环调用，需要注意的是我们传给用户的是只能是user_id之类的公有信息，各个子网站接收到之后，需要拿这个信息获取用户的登陆凭证，然后让其失效。我是这样做的：redis中存储着phpsessid（我们用的传统的cookie session）,然后curl 模拟请求的时候cookie带上这个，··然后就实现啦 思考：如果我们模拟请求的时候带上完全一样的头信息，是不是就能达到和浏览器一样的效果了，··有些能，比如上面的登出，但是设置cookie不可以，明明就是header加上点信息嘛，为什么不可以呢，因为cookie只能在浏览器上使用？还有很多优化的空间，比如回调多个登出接口，用的消息队列，如果一个出错，是记日志吗，还是什么zzz每个网站需要自己的登陆界面嘛，这样每次未登录定位到登陆界面之后就只有个登陆按钮，点击之后才能进入sso输入用户名和密码，相比较之前略麻烦，但是如果sso登陆之后，我们点击就能直接跳转到我们的网站，感觉这样更符合单点登录。而且住校之后我们可以定位到普通网站的登陆界面，而且点击因为可以加回调地址，我觉得还是不能省略的。代码就不放了，放些接口的函数吧sso :login :检测是直接跳转到登陆页面还是检测cookie是否有效，有效回调web1站点地址，无效跳转到登陆界面（看了下仿佛ajax中header location 就是有点问题）logout web1:login: 判断是去sso还是直接登陆logout:退出，需要回调 sso 的logout, 注销sso还有各个子网站ssologin:回调登陆地址ssologout：回调登出地址 关于上面跳转的问题： 今天看到群里面说的header 跳转不了疑问，其实我之前也遇到过，当时说是ajax 里面不给跳转，验证一下： 首先我们在一个接口中调用header跳转成功，说明接口没问题，ajax中调用，跳转不了。console.log 中报错 123Response to preflight request doesn&apos;t pass access control check: Redirect is not allowed for a preflight request对预检请求的响应未通过访问控制检查：预检请求不允许重定向 也就是options 请求没有带回我们想要的内容，其实这个options请求是对于我们header的那个url 的返回，和我们ajax的url 返回没啥关系，所以我把那个header 那个url 链接从原来的baidu改成我可以控制返回内容的请求，这下果然访问成功了，可是出现了新的问题页面没有改变，打开network ，发现有请求新的url,开始考虑原因: 我们在地址栏输入的api 接口可以看做是全局的，整个页面显示的是他的返回，ajax是局部的请求，他只能得到一个值，页面并不能跟随他的返回而改变，毕竟ajax是啥时候返回我们并不知道，我们平时看见的局部改变是我们根据ajax的返回主动修改页面内容的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于nginx的那些事]]></title>
    <url>%2F2018%2F08%2F20%2F%E5%85%B3%E4%BA%8Enginx%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[lnmp 是php最常用的模式，工作中经常要自己搭建环境，nginx 的学习少不了，记录生活中经常用到的，方便查找 常用命令 123456nginx -s reload 让配置文件生效，并重启nginx -s stop 快速关闭nginx -s quit 平滑关闭nginx -t -c nginx.conf 测试配置文件是否有语法错误nginx -v 查看版本nginx -V 查看编译信息，可能有时候要添加一些新的扩展 http ​ server 复杂均衡 http层upstream (session 需要分布式，可以考虑用redis ,或者jwt token) server 层 proxy_pass 轮训 权重都是1 加权轮训 weight 最少连接 ip hash 普通hash 虚拟主机， 所有匹配的location 是同一级别，都需要配置root nginx 处理跨域，其实等同于php 处理跨域，只是nginx 那个语法还不太熟悉 允许访问的域名 允许访问的方法 允许携带的参数 对于options 请求的处理 nginx 的调试 通过写日志 // 这个比较方便，return 的话很多内容不能记录 通过return 内容 curl 直接调试 -H ‘host: xxx.com’ 添加请求头 其实这个比较容易看出来的，host 在寻址找到服务器之后，域名已经不重要了，只是起到header 中一个变量的作用 默认第一个server 是匹配不到走的server (当然可以指定default server)]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 数据库相关操作]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel seeder 数据填充]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-seeder-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel migrate 数据迁移]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-migrate-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[虽然表哥说他们都不用这种方式，但这种方式确实很方便的解决了团队合作的时候数据库表的同步问题，像我们itbasic 就每次上线或者给队友同步数据库的时候都得自己手动去处理，而且这种方式更多的把sql语句转换成php语言处理，不知道建索引那些会不会很方便. 文件位置和命名： database/migrations/2014_10_12_000000_create_users_table.php 通过artisan 命令能直接生成对应目录下的文件 注意up 和 down 方法，分别是的执行的时候，还有回滚的时候的执行 注意create 和 update 表结构的时候的区别 自增：increment 字符串： string ， 方法的第二个参数限制最大长度 唯一： unique，感觉就像数据库的唯一索引 创建时间和修改时间，通过 timestamps 就能生成 记住我： rememberToken, 虽然一直不太清楚这个干啥的 create =&gt; dropIfExists() , 创建 回滚的时候对应 删除]]></content>
  </entry>
  <entry>
    <title><![CDATA[Laravel]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel-router%2F</url>
    <content type="text"><![CDATA[关于Laravel 的一些学习 Router1234&lt;?phpRoute::get(&apos;/&apos;, &apos;StaticPagesController@home&apos;)-&gt;name(&apos;home&apos;);Route::get(&apos;/help&apos;, &apos;StaticPagesController@help&apos;)-&gt;name(&apos;help&apos;);Route::get(&apos;/about&apos;, &apos;StaticPagesController@about&apos;)-&gt;name(&apos;about&apos;); 这个name是用来命名的，命名有什么用，看下面 route(‘help’) =&gt; 这个help 是路由命名，user.help 更为准确 route(‘help’,[1,2]) =&gt; 多个参数传递数组 这个函数的参数，通过下面这个函数，配合配置得环境变量，可以生成前端可以访问路径的，如果很直白的写url，以后url改动的时候但凡用到的地方，都需要改动 InputValidatorValidator 调用的是facade ， facade 调用是 validator 的factory 类， 其中的make方法生成一个validator 实例，我们可以调用validate 方法去验证，抛出Validation 异常，我们可以通过对validate方法捕获异常，或者判断validator实例执行validate方法之后， 再调用errors()-&gt;all() 方法获取错误信息 123456789101112131415161718$validator = Validator::make($request-&gt;all(), [ &apos;title&apos; =&gt; &apos;bail|required|string|between:2,32&apos;, &apos;url&apos; =&gt; &apos;sometimes|url|max:200&apos;, &apos;picture&apos; =&gt; &apos;nullable|string&apos;], [ &apos;title.required&apos; =&gt; &apos;标题字段不能为空&apos;, &apos;title.string&apos; =&gt; &apos;标题字段仅支持字符串&apos;, &apos;title.between&apos; =&gt; &apos;标题长度必须介于2-32之间&apos;, &apos;url.url&apos; =&gt; &apos;URL格式不正确，请输入有效的URL&apos;, &apos;url.max&apos; =&gt; &apos;URL长度不能超过200&apos;,]);try &#123;$validator = $validator-&gt;validate(); // 注意不要链式调用，我们需要的是实例对象&#125; catch (ValidationException $e) &#123; &#125;// dingo api 对这个异常处理了// 默认的web 也会有自带的异常处理机制，默认最基础的是绑定信息到模板变量$errors 中， 这个变量内容其实就是 $validator-&gt;errors(), 通过 $errors-&gt;all() 我们可以获取所有的错误信息 为了实现请求验证和控制器的解耦，laravel 把请求单独成requests，直接在controller中传入这个 request 就能实现自动验证，可这样的话，就不知道request 验证什么时候执行的，怎么捕获这个异常，那只能在统一定义异常处理那进行处理 (web 和 api 还不在同一个位置好像，还有怎么在除了控制器的地方直接返回数据给前端，而不接着往下走) Exception handle]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel学习]]></title>
    <url>%2F2018%2F07%2F29%2FLaravel%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[关于Laravel 的一些学习，主要是对一些知识点的理解，不包含用法，具体用法参考laravel-china, wiki ,真的是太详细了 目录结构传统的mvc 中只要注意下面几个文件夹就好了，可能很多人和我当初刚接触laravel 一样，对于 controller和model不放在一层感觉很奇怪，routes 在更外层，其实我们这里面可以这样理解，http更相当于我们传统的controller，为了实现控制器中逻辑处理和参数验证分开，我们分出了request 和 controller，中间级。和 http 同层的还有model (模型)， jobs(队列任务)，listeners之类的，暂时用的还很少，以后再补充 设计模式依赖注入: 我们平时写的代码大部分包括以下几种模式 我定义的函数，我调用 框架定义的函数，我调用 我定义的函数，框架调用 第一种很好理解，第二种我们在调用框架定义的函数的时候注意一定要传入完备的参数，否则会报错（很多时候我们在直接修改框架源码的时候一定要注意这点，因为框架定义的函数，如果你没搞清楚框架在哪些地方调用了，直接修改，也没给参数默认值的话，很容易出错，我们可以通过phpstorm去查找这个函数的调用地址，当然如果是那种没有命名空间的函数的话，很容易找不到，比如itbasic中） 我们这里主要讲一下第三种，我定义的函数，框架调用，主要有两种。一种是路由中callable, 比如klein 路由中都是匿名函数执行的形式，他默认有4个参数，\$request, \$response, \$service, \$app, 剩下的就是路由参数了，我对这种执行方式的猜测就是执行的时候直接传入这4个类实例，再merge 路由参数 一起传入我们的匿名函数中，因为php在定义的函数中没有对应参数，执行的时候传入，不会报错，这就方便了我们可以随意的传入前面4个参数，用到的就传入，不用到就不传入，但是坏处就是对于后面的路由参数，只能在前面传入4个参数之后加上，参数值和参数顺序完全对应！！！！ 而依赖注入就不需要，laravel的路由有两种方式可以实现，一种和klein一样是匿名函数的形式，另一种指定函数中方法名，注意这和我们itbasic中klein一点都不一样，itbasic中调用控制器中方法本质上还是在匿名函数中实例类，再调用方法，并传入参数，你会发现itbasic控制器中参数的顺序并不能改变，但是laravel中却可以，只要类名对应上，底层应该是用反射类获取参数名称，然后实例化，传入，所以依赖注入的核心应该是就是反射 ，之前我的想法总是总是容器，或者是方法名中可以直接使用request 和 response对象就是依赖注入，其实这都是错误的想法，你随便在一个不是路由对应方法的函数中定义request和response对象，调用的时候一定会报没有传入对应参数的错误 Routerlaravel 包含了两种请求方式的处理，一种是类似前后端不分离的形式，传统的web开发，一种是专门用来处理api, 两种请求处理过程有哪些不同还没有研究，现在发现的是一个http请求，会先走web.php, 再走api.php 1匿名函数形式 12345// 类名，方法名&lt;?phpRoute::get(&apos;/&apos;, &apos;StaticPagesController@home&apos;)-&gt;name(&apos;home&apos;);Route::get(&apos;/help&apos;, &apos;StaticPagesController@help&apos;)-&gt;name(&apos;help&apos;);Route::get(&apos;/about&apos;, &apos;StaticPagesController@about&apos;)-&gt;name(&apos;about&apos;); 这个name是用来命名的，命名有什么用，看下面 route(‘help’) =&gt; 这个help 是路由命名，user.help 更为准确 route(‘help’,[1,2]) =&gt; 多个参数传递数组 这个函数的参数，通过下面这个函数，配合配置得环境变量，可以生成前端可以访问路径的，如果很直白的写url，以后url改动的时候但凡用到的地方，都需要改动 InputValidatorValidator 调用的是facade ， facade 调用是 validator 的factory 类， 其中的make方法生成一个validator 实例，我们可以调用validate 方法去验证，抛出Validation 异常，我们可以通过对validate方法捕获异常，或者判断validator实例执行validate方法之后， 再调用errors()-&gt;all() 方法获取错误信息 123456789101112131415161718$validator = Validator::make($request-&gt;all(), [ &apos;title&apos; =&gt; &apos;bail|required|string|between:2,32&apos;, &apos;url&apos; =&gt; &apos;sometimes|url|max:200&apos;, &apos;picture&apos; =&gt; &apos;nullable|string&apos;], [ &apos;title.required&apos; =&gt; &apos;标题字段不能为空&apos;, &apos;title.string&apos; =&gt; &apos;标题字段仅支持字符串&apos;, &apos;title.between&apos; =&gt; &apos;标题长度必须介于2-32之间&apos;, &apos;url.url&apos; =&gt; &apos;URL格式不正确，请输入有效的URL&apos;, &apos;url.max&apos; =&gt; &apos;URL长度不能超过200&apos;,]);try &#123;$validator = $validator-&gt;validate(); // 注意不要链式调用，我们需要的是实例对象&#125; catch (ValidationException $e) &#123; &#125;// dingo api 对这个异常处理了// 默认的web 也会有自带的异常处理机制，默认最基础的是绑定信息到模板变量$errors 中， 这个变量内容其实就是 $validator-&gt;errors(), 通过 $errors-&gt;all() 我们可以获取所有的错误信息 为了实现请求验证和控制器的解耦，laravel 把请求单独成requests，直接在controller中注入这个 request 就能实现自动验证，可这样的话，就不知道request 验证什么时候执行的，怎么捕获这个异常（后面可以看request源码中的验证过程），那只能在统一定义异常处理那进行处理 (web 和 api 还不在同一个位置好像，还有怎么在除了控制器的地方直接返回数据给前端，而不接着往下走return) Exception handle]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于composer]]></title>
    <url>%2F2018%2F07%2F29%2F%E5%85%B3%E4%BA%8Ecomposer%2F</url>
    <content type="text"><![CDATA[composer,php的包管理工具，类似nodejs的npm，类似python的pip，因为很多时候我们需要接入外来的服务，可能自己的能力不足，又或者是别人有更好的解决办法，不是有说过站在巨人的肩膀上能看的更远么。 composer require 当我们需要安装一个外来服务的时候，注意这个不是安装php的扩展模块，两者有本质上的区别，php的扩展模块是c写的，需要我们源码编译到php中, 而通过composer接入的是php封装的内容。 之前我经常把需要的模块通过手动写入composer.json文件中，然后通过composer install 或者 composer update 这种方式更新，这都是不对的 composer install 会依据composer.lock 文件进行安装，如果没有这个lock文件按照composer.json进行安装 composer update 会依据composer.json 进行安装（composer.lock 和 composer.json 的区别lock文件中会严格规定版本号） composer init 初始化一个项目被composer 管理（很少用, 一般是手动编写一个composer.json文件，然后install） composer 还有文件夹管理的功能，现在一般用的是psr-4,原先项目组织有psr-0,现在废弃了，二者区别就是psr-4通过命名空间更能代表文件位置composer的自动加载有psr-4,我们那个api服务中有使用，注意定义了一个顶级之后，下面的子命名空间可以自动寻找，而不需要你的人为干预files 可以加载配置文件之类的，不用一直includeclassmap可以不遵循psr-4规范，会扫描指定文件夹，加载里面的类（一般的类名首字母大写，然后类名和文件名一样）当我们修改了composer的自动加载，通过composer dump-autoload来更新 我们php的框架和python 这种框架有挺大的区别，写了点python，还有问了写python的同事，得到的就是他们写python的时候还用的是面向过程的方式，他们的框架flask感觉更像是php中的包的概念，通过import方式导入，没有各个文件夹的内容规定，给了很大的自由给用户，我们通过composer 安装的文件一般在这个项目文件的vendor目录下，但是我们python 通过pip安装的一般是全局安装，就算是用了pipenv 或者vrtualenv 也是在全局下面然后分成各个子文件夹（仿佛是虚拟站点让php变得这么方便？） composer需要注意的东西： 修改源，下载东西更快 linux 下安装（composer.phar 就是 php composer, 只是单独使用的话需要composer.phar 需要执行权限 chmod a+x composer.phar） 使用composer 发布一个自己的扩展包 编写项目用的是超哥的脚手架工具 12composer global require &apos;overtrue/package-builder&apos; --prefer-sourcepackage-builder build ./login ##后续查看是否要修改一些composer.json 文件 可能也许是因为我在packages 上的登陆用的是github的，所以自动配置了扩展包的自动更新(可以自行测试，修改readme 文件，github上的，看packages 上是否自动修改，如果没有自动修改，谷歌自动更新的方法 同步方法 完整的发布流程 总结 ：其实就是去package 上面注册一下，然后把自己的项目地址(git 仓库地址)粘贴上去就好了，能自动识别，(而且感觉还会自动配置自动更新，否则去项目的setting 下面自己设置) 遇到的问题： package上面有，composer require 不到 脚手架自动生成的read me 上的composer require 有问题，别用那个自动生成的，（之前怀疑是源的问题， 虽然用的是中国源，但是更新的也是很快，接近实时，所以package上面有，composer require 不到，是自己的问题， 版本号写错了） （超哥那个自动生成的md文件会被package 上面 直接显示（嵌入的毫无痕迹，我还以为是package 网站生成的，于是我就直接使用read me 上的composer require 语句 ，报错） 我们的composer require 语句应该和composer.json 相匹配]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于框架操作数据库的几种方式]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%85%B3%E4%BA%8E%E6%A1%86%E6%9E%B6%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[其实第一次有这方面的思考是来自七月老师的tp教程，他起了个头，他那个课程的核心就是为了提倡大家使用orm，后来在工作中开始留意这方面的知识.(如果没有那个引子，估计我会把builder query和orm弄混淆吧，因为真的挺相似，调用方法都是链式，orm对于bq方法的使用，又因为区别在于orm的面向对象这个特性上，而且现在基本都不用bq了，就算使用也是可以DB直接调用,而不用像orm那样需要定义一个model类，很难找出bq相对于orm的差别，换句话说因为本身orm就是基于bq的，所以我们需要发现的orm相对于bq的改变，但这个改变刚好是面向对象这种思想上，加上bq的少使用，这个改变很难发现) 看了下php关于linux方面的知识，pdo， builder query ，orm，我这种基础不好接触面不广的人经常混淆。在pdo之前应该是直接利用mysql 和 mysqli进行数据库连接操作，这种的只需要php开启对应的mysql或者mysqli扩展就好了（mysql已经废弃了），这还是我刚学习php的时候书上经常写的，后来在工作中这种的用的就比较少了，主要用的就是pdo了，个人感觉pdo和mysqli用起来查询那些操作还是差不多的，不管是函数还是查询到的结果集，感觉差别最大的还是 一个是new pdo一个是 mysqli_connect吧，:smile:。（pdo使用的时候除了安装pdo扩展，还要开启对应的驱动哦，比如 mysql_pdo）。 还记的我在学习慕课那个高性能api接口时候接触到的dao层吗，其实dao后来理解起来感觉是不是只有在那种处理比较麻烦和严谨的时候使用 &lt;?php class DB_user extends DB_base { public function find($username) { $query = self::$db-&gt;prepare(&quot;select count(*) as c from yaf_user where username = ?&quot;); $query-&gt;execute([$username]); $count = $query-&gt;fetchAll(); if ($count[0][&apos;c&apos;] != 0) { list(self::$errno, self::$errmsg) = Err_map::getCodeMessage(1004); return false; } return true; } 看这种，查询一个结果要写这么多，肯定需要独立出来呢。 后来是builder query，其实和orm是很像的，毕竟orm是基于builder query的，但二者不同之处在于orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例(虽然我们在使用bq的时候可能也是这样想的，但orm不止是想这么简单，他是具体的实现了，比如下面同样调用all方法，虽然查出来的数据类型可能都是collection，但是展开看下，一个下面是关联数组，一个是对象，有具体的public 和private属性)。因为orm基于bq嘛，所以bq的那些方法orm都可以使用，所以我感觉方法的混用也是容易把orm和bq混淆的原因。但你是否还记得bq使用的时候调用的类是 DB,以laravel举例，DB是库facade下面的，但是orm使用的时候我们调用的类是继承model的那个类名字 DB::table(&apos;student&apos;)-&gt;all() Student::all() 当我在学习yii的时候还接触到一个概念AR，其实AR只是实现orm的一种方式，比较常用的有AR和··mapper，laravel（Eloquent）和yii现在orm实现方式都是AR，所以不要把这个当做yii和laravel的区别啦。 AR和mapper的区别在于，mapper把数据对象和数据持久化分开了（啥叫持久化，就是数据存储啊笨蛋···zz，心痛的感觉），mapper中对于数据的保存需要用类似bq中一个统一的类去实现，比如 //伪代码,方法名纯属虚构，因为懒得去查了 $student = new Student(); $student-&gt;name = &apos;cy&apos;; $student-&gt;age = 19; DBMAPPER-&gt;config($student); DBMAPPER-&gt;refresh($student); 现在水平太低，也不知道这样的好处是啥：说是为了把数据对象独立出来，让他的作用就是在各个层中传递. 大致就这些了吧，最后来一个laravel中最基础的model定义，让我们来更能理解orm的那几个定义 //orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class Test extends Model { //定义表名 protected $table = &apos;test&apos;; //禁止更新时间戳，默认会更新created_at和updated_at public $timestamps = false; //可以批量赋值的属性，什么叫做批量赋值，就是我们可以通过create方法插入的，不是save那种，create是直接传入一个索引数组， //save 是通过给实例的属性一个个赋值，就这点看来，确实有批量赋值的意思 protected $fillable = [&apos;name&apos;]; } ​ laravel 中orm的实现用了很多PHP的特性（魔术方法等），比如属性，写的挺好的，在laravel核心框架技术解析中有写到。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux搭建git仓库]]></title>
    <url>%2F2018%2F07%2F24%2FLinux%E6%90%AD%E5%BB%BAgit%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[！！！ linux 搭建git 仓库最方便的就是gitlab了，因为以前不知道，所以自己搭建了linux git 仓库，也没个图形化界面，是真的难用，但对git 的理解更加深刻了。（强烈推荐还是直接用gitlab 吧） 故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。后来老大希望测试下我写的代码，看看需要哪些参数，给了另一台服务器。刚开始想到直接把修改好的代码打个包放上去，后来想了下不是长久之计，因为我的水平肯定要经常修改代码，不能每次修改下就打包一下，太麻烦了。又想到可以通过配置itbasic服务器上的svn，当svn up 的时候忽略掉特定文件夹的更新，百度了下方法，大部分以下几种情况：windows下忽略文件夹，提交代码的时候忽略掉文件夹，很少有更新代码的时候忽略掉文件夹的解决办法。（有，但自己试验失败）。后来想到不如利用git吧，首先大部分都是我一个人操作，我经常向github提交代码，操作已经很熟悉了，再者毕竟用git也能跟上时代的潮流嘛。 先来介绍一点基础知识：当我们想下载github上的代码（或者说远程仓库的代码），我们可以通过123456git clone git@ip地址：git远程仓库的地址//例如git clone git@github.com:chenye2017/zerg.git//当需要下载github上的仓库的时候，直接去这个项目首页，会有个clone or download的选项，注意不要选择use https，因为选了那个每次提交代码额时候都要输入密码//winodows用户可以直接下载zipgit clone git@192.168.56.10:/home/resposity/bbs.git 新建一个目录，自定义名称进入到这个目录内，执行上述操作，就能把项目目录中的代码下载下来。 但上面仅仅只是下载项目，我们为了和远程仓库进行联动，我们需要在本地的这个文件夹建造一个git仓库，然后和远程仓库的某个分支比如master进行绑定，当我们修改完成的时候进行代码推送到远程的时候，别人下次再次clone或者pull就能收到我们提交的修改。下面就是创建本地仓库的实例代码 1234567891011cd dir//进入上面执行git clone的文件夹git initgit add. //把修改的文件夹都添加进来git commit -m &apos;init&apos; //提交到本地代码库git remote -v //查看远端仓库//如果有远程仓库，可以进行删除git remote rm origingit remote add origin git@192.168.50.16:/home/resposity/bbs.git //添加远程仓库git push origin master //和远程仓库的master分支绑定，以后提交只需要git pushgit pull origin master //同上，以后使用也只要git push 就好了 当我们提交代码的时候肯定是不成功的，提示我们需要输入密码，···而且每次都会提示，怎么办呢，可以通过一个命令1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 在windows中，生成密钥位置会在C:\Users\admin 下面，这个下面有.ssh文件夹，进去复制末尾是.pua 也就是公钥的文件，粘贴到你的git仓库所在的服务器的git 主目录下，比如我的是 /home/git/.ssh/authorized_keys,粘贴到文件末尾即可，如果还不能提交代码，重启下sshd服务，netstat -antp|grep sshd, kill, /usr/bin/sshd 启动如果还不行，可以查看这篇文章修改下配置 https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873 一直提交需要填写密码其实是个很常见的问题，收集了几篇文章，因为之前一直不成功，但后来成功了，但其实不是下面这几个问题，是我对git远程仓库理解出现了问题，所以操作不对.https://www.jianshu.com/p/9dbb1dea5929， （文件夹权限），https://ruby-china.org/topics/14182 （ssh真的出问题了，需要查看日志） 最后也是最终的要一步，按理说这应该是第一步的，就是linux上远程创建git仓库。本身应该 1. 创建远程仓库 2 git clone 3. git push这也是我们平时使用github 的主要步骤，但因为这一步最重要所以我放在了最后。 git创建远程仓库 http://www.runoob.com/git/git-server.html 菜鸟教程上已经说得很清楚了，只是我们需要区别一下两行代码12git initgit init --bare 第一个我们经常用到是实例化本地仓库，第二个是创建一个裸库，什么意思呢，就是这个裸库就是我们平时那个 git clone ip地址后的路径，这个仓库装的都是我们的提交记录，本身是并没有代码的，但我们通过git clone能生成最新的代码，以我的服务器为例123/home/resposity //专门用来放远程仓库的文件夹/home/resposity/bbs.git //我的bbs远程代码库/home/code/bbs 这是我的服务器上实际项目代码，也是被人访问我的项目的路径 当我本地修改好了代码（windows下），提交到远程仓库中，然后在服务器的/home/code/bbs (线上项目文件夹)下进行更新git pull最新的代码,别人就能访问到我本机的最新代码了。 对了，还记的我们当初svn代码更新提交失败，提示svn clean也不行的时候怎么处理的吗，就是清除.svn 下面两张表里面的数据 (通过Navicat建立连接).当时刚开始是不会这种方法的，同事告诉我直接删除.svn这个文件夹，说svn管理这个文件夹都是通过他，现在想起来挺有道理的，但没有试过（以前直接是删除了svn这个软件，然后肯定不成功啦，现在想想这和svn半毛钱的关系都没有撒，但感觉不能删除.svn,因为删除了，那些diff都找不到了）git应该也是通过.git这个文件管理的。 对了，关于免密码登录，当我们通过命令生成的ssh密钥linux下，一般在这个用户目录下面，比如root用户，在/root/.ssh 下面，我们需要把这个公钥粘贴到需要进行提交的git远程仓库的服务器中git的安装目录下面的ssh的auth···——key，里面，追加在文件末尾，注意着这两个地方文件名虽然类似，但一定要分清把那个粘贴到哪个上面，分清主从关系。 关于忽略文件夹，编辑.gitignore 文件，在项目根目录下面，因为windows下面不能这样命名文件，可以在linux下面编辑保存，编辑之后这个文件就是untracked形式,以后的提交就不会把这个文件保存在内，即使用了git add. 但是之前把.idea这个文件夹包含进去了，怎么办呢，git remove -n -r –cached –cached 只是git仓库删除了，本地不会删除，-r 类似删除文件夹的时候递归删除， -n 先列出来要删除的文件，真正想删除的时候不要加这个参数。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站部署随笔]]></title>
    <url>%2F2018%2F06%2F20%2F%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。 好久之前在阿里云上买过一个域名，29一年，chenye2017.cn,主要这个名字和我的github账号也是一致的，比较好记。当我想绑定域名到服务器上的时候，其实有点担心，我在阿里云上买的域名能绑定到服务器上吗？ 试试吧。首先需要对域名进行实名认证，域名的实名认证其实挺简单的，填下身份证号和联系电话就好了，后面需要备案，这点需要注意的是，我绑定的是京东云，所以需要在京东云上备案。之前对于域名的购买，我的理解是购买一款厂商的产品，但其实不是这样的，试想一下我们购买域名的时候是不是只要先构思一个自己想要的域名，然后查询域名是否在使用，如果没有使用就可以进行购买，这个凭空想象出来的域名厂商不可能提前为我们准备好，他能做的就是通过域名解析器dns把我们的域名注册进世界的万维网当中，当世界中的某个人通过浏览器进行访问的时候，dns能把域名解析成ip地址找到我们的服务器，既然这样，那我们是不是只需要在我们的服务器上搭建一个域名服务，就能不通过购买他的域名，直接使用自己注册的域名就可以了呢？理论上是可以的，但我没有去实践过。 备案未完成… 之前帮前端同事部署过一个vue项目，其实和部署一个php项目 极为相似，甚至更简单，都是通过找寻唯一入口文件，因为前端项目都是静态文件，而且apache默认找的文件夹下面的第一个文件就是index.html,所以都不需要进行特殊的设置（php的话因为要找index.php,所以要做更多的设置），唯一需要注意的就是前段项目的很多路径都是绝对路径，他本质上是相对网站的根目录来的，也就是默认项目部署在网站的根目录下，如果网站没有部署在根目录下，比如itbasic bbs，需要我对引入的静态资源路径进行适当的修改。比如给需要找的静态资源建立个软链接ln -s ,到新的静态资源目录下。 因为之前是根据网上教程搭建的hexo，其实不懂他的实现原理。 而且在教程的开始，就说了要使用node，对于我这种js都不好的人，看到node，首先就觉的完了。其实很多前端项目用到node，并不是用到nodejs的语法，而是用nodejs搭建了一个web服务，承载前端项目，然自己置身于一个联网的状态中，就能发出类似ajax这样的联网请求，因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。 我看了下上传到github上的文件夹，和我本地的项目代码结构还是有挺大区别的，我的理解就是把本地代码进行了打包，打包好的文件上传到github上了（类似vue代码的发布），上传到github上的文件夹全是静态目录结构，我惊喜的发现了index.html,于是大胆的假设了下如果把那个目录放在我的站点根目录下，是否也能进行访问了呢，我就不用通过chenye2017.github.io去访问，而是通过我自己的站点去访问呢，毕竟服务器在国内，访问速度也比较快。 结果是成功的，印证了我的假设。 在网站部署的时候还遇到了几个问题，比如源码编译apache2.4,在之前还需要安装apr,apr-util,之类的文件，apache2.4的改文件访问权限和之前的apache还不一样，还有文件夹名字结尾不能有空格，否则识别不出来，加载vhost.conf,启动apache失败，修改server localhost之类的apache配置文件，还有apachectl restart开始不管用，需要自己手动配置脚本····]]></content>
  </entry>
  <entry>
    <title><![CDATA[无限递归]]></title>
    <url>%2F2018%2F06%2F13%2F%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。 以部门举例，我们在使用的过程中，需要找到这个部门的相关父级部门（子孙树），或者我们需要知道某个部门是否属于某个部门，我们既可以用家谱树去实现，也可以用子孙树去实现，用子孙树去实现的一个好处就是，当我们知道父级节点，一次性求出这个父级节点的所有子孙，通过判断子节点是否在这个父级节点的子孙中，就能知道是否满足条件。但如果我们通过家谱树，我们需要每次根据子节点，去求一次家谱，然后来判断家谱树中是否有这个父级节点存在，来判断是否符合条件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php$address = array( array(&apos;id&apos;=&gt;1 , &apos;address&apos;=&gt;&apos;安徽&apos; , &apos;parent_id&apos; =&gt; 0), array(&apos;id&apos;=&gt;2 , &apos;address&apos;=&gt;&apos;江苏&apos; , &apos;parent_id&apos; =&gt; 0), array(&apos;id&apos;=&gt;3 , &apos;address&apos;=&gt;&apos;合肥&apos; , &apos;parent_id&apos; =&gt; 1), array(&apos;id&apos;=&gt;4 , &apos;address&apos;=&gt;&apos;庐阳区&apos; , &apos;parent_id&apos; =&gt; 3), array(&apos;id&apos;=&gt;5 , &apos;address&apos;=&gt;&apos;大杨镇&apos; , &apos;parent_id&apos; =&gt; 4), array(&apos;id&apos;=&gt;6 , &apos;address&apos;=&gt;&apos;南京&apos; , &apos;parent_id&apos; =&gt; 2), array(&apos;id&apos;=&gt;7 , &apos;address&apos;=&gt;&apos;玄武区&apos; , &apos;parent_id&apos; =&gt; 6), array(&apos;id&apos;=&gt;8 , &apos;address&apos;=&gt;&apos;梅园新村街道&apos;, &apos;parent_id&apos; =&gt; 7), array(&apos;id&apos;=&gt;9 , &apos;address&apos;=&gt;&apos;上海&apos; , &apos;parent_id&apos; =&gt; 0), array(&apos;id&apos;=&gt;10 , &apos;address&apos;=&gt;&apos;黄浦区&apos; , &apos;parent_id&apos; =&gt; 9), array(&apos;id&apos;=&gt;11 , &apos;address&apos;=&gt;&apos;外滩&apos; , &apos;parent_id&apos; =&gt; 10), array(&apos;id&apos;=&gt;12 , &apos;address&apos;=&gt;&apos;安庆&apos; , &apos;parent_id&apos; =&gt; 1) );function test($data, $pid)&#123; static $arr = []; foreach ($data as $key=&gt;$value) &#123; if ($value[&apos;id&apos;] == $pid) &#123; $arr[] = $value; test($data, $value[&apos;parent_id&apos;]); &#125; &#125; return $arr;&#125;var_dump(test($address, 4));// 上面方法在多次循环获取的时候因为static变量的原因会出现一直叠加的错误// 下面是改进的方法function test1($data, $pid, &amp;$arr)&#123; foreach ($data as $key=&gt;$value) &#123; if ($value[&apos;id&apos;] == $pid) &#123; $arr[] = $value; test($data, $value[&apos;parent_id&apos;]); &#125; &#125; return $arr;&#125;var_dump(test($address, 4, [])); 1庐阳区，合肥，安徽 子孙树的实现 12345678910111213141516171819202122232425262728function test1($data, $id, $level = 1， &amp;$arr)&#123; foreach ($data as $key=&gt;$value) &#123; if ($value[&apos;parent_id&apos;] == $id) &#123; $value[&apos;level&apos;] = $level; $arr[] = $value; test1($data, $value[&apos;id&apos;], $level + 1); &#125; &#125; &#125;//level主要用来显示是几级的儿子// 上面这种方式其实不能实现层级结构，只能用level来表示，因为从开始往下面读的话，开始的数据先计算出来，是不能改变的，所以为了实现层级结构只能从后往前读// 不借助 &amp;$arr来实现function children($id) &#123; $self = self($id); $children = getChildrenByPid($self[&apos;id&apos;]); if ($children) &#123; foreach($children as $value) &#123; $slef[&apos;children&apos;][] = children($value[&apos;id&apos;]); // 这个地方很重要，如果想不出来的话，可当做是最后一层 a-&gt;a1,a2-&gt;a3, 我们怎么返回a这个node节点的结构&#125; &#125; else &#123; $self[&apos;children&apos;] = [];&#125;return $self;&#125; 还记得我们在大学学习数据结构的时候，因为递归对于效率有影响，所以经常需要把递归改成迭代，上述家谱树容易修改，子孙树需要用到栈，自己不是很理解 1234567891011121314151617181920212223242526272829// 家谱树递归的修改成普通方式function test2($data, $pid， &amp;$arr)&#123; while ($pid != 0) &#123; foreach($data as $key=&gt;$value) &#123; if ($value[&apos;id&apos;] == $pid) &#123; $arr[] = $value; $pid = $value[&apos;parent_id&apos;]; break; &#125; &#125; &#125; return $arr;&#125;var_dump(test2($address, 4));//迭代和递归的转换主要就是靠迭代找到那个停止往上找的条件// 今天看了别人的代码 https://github.com/chenye2017/china-divisions// 更加理解递归，我们只需要保存当前的状态并返回，可以不借助 &amp;地址 符function ancestors($id)&#123; $slef = self($id); //获取自己信息 if ($info) &#123; $parent = ancesotrs($id); $parent[] = $self; // 保存当时环境(只需要考虑当前环境就好，不用考虑递归)，并传递给上一个调用者，用来叠加 return $parent;&#125; else &#123; return []; // 相当于&#125;&#125; 大致就是上面这些，像面包屑导航，不要看着从左到右，其实他也是一棵家谱树，因为他从始至终就只有一棵树。 还有就是移动各个部门位置问题： 想象一下，一棵树，我把某个分支截取下来放到另一个分支上是很正常的事情，但问题是有时候，我会出现把父亲节点的父亲设置成自己的子节点，这样树枝就断了，这样是不可取的，除此之外，任意移动都是可以的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>无限递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域 cookie]]></title>
    <url>%2F2018%2F06%2F06%2F%E8%B7%A8%E5%9F%9F-cookie%2F</url>
    <content type="text"><![CDATA[cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。 cookie,对于传统的lamp架构，在服务器端想获取可以通过$_COOKIE[]数组获取到，但是对于swoole这种自己搭建web服务的东西，只能通过request请求获取，其实lamp里面本质也是这样，也是把apache或者nginx获取到的请求内容放到了php的\$_COOKIE里面，类似的\$_SERVER, \$_GET,这些在swoole里面都是永不了得，你可以把http-&gt;request-&gt;get 的值在请求到来的时候给与\$_GET数组，这样就能在swoole搭建的web服务里面和普通的lamp架构一样使用\$__GET数组了。正因为swoole的这些特性，像如果在swoole里面使用session登录机制需要自己去实现，还有对于一些框架的集成，因为外部传入的参数不在那些数组中了，所以需要对框架进行修改，让框架能获取到对应的参数，保证框架的运行，比如：swoole集成slime框架(swoole在客户端设置cookie也得用它自带的方法而不是setcookie)。 回归正题，通过上述，我们也只cookie是一个数组，那其中哪把钥匙是用来打开session的呢，答案是PHPSESSID,这个值是可以设定的，在php.ini,或者通过php的session函数来获取到。 对于session，我觉得他更像是一个模块的扩展，他不仅仅是提供一系列的简单的函数，这些函数其实还有具体的活动的封装。比如开启session的时候，session_start(),他做的东西有很多，首先检测客户端是否有 phpsessid，如果没有，通过函数setcookie，在客户端种植，其实底层就是通过在返回的header头信息中加入set-cookie，如果已经有phpsessid，会通过寻找客户端对应的session，获取里面的信息。那问题又来了，这个phpsessid的cookie是怎么传送给服务端的呢，我不记得我有加入这个cookie啊，一般情况下，在发送http请求的时候，默认都会带上浏览器的cookie。如果禁用了还可以通过url传递哦，话说从url中获取phpsessid也是在session_start()函数中实现的，可见这个函数的复杂性，和普通的函数还是不一样的，里面有具体的逻辑。 对于cookie的设置，也是有跨域问题的，a.test.com下的cookie,在b.test.com下面不能获取到，但是如果在test.com下面就能获取到了，为什么呢？看看跨域吧。不信？你可以设置下，在/path页面下设置另一个path的cookie，然后去对应的path下刷新，看是否有，答案是肯定有的啦。所以cookie的设定。path是不影响的。 既然能设定，自然就能删除，设定和删除可以归为一类操作（直接把过期时间设定成当前时间-100就可以删除了，注意cookie有max-age存在的时间和expire过期时间之分，php的setcookie设定的时间是expire时间，所以需要在过期时间+time()!!之前就犯了这个错误） 其实php的setcookie也能验证这点。在控制器中调用setcookie，如果不传path，默认是当前path，但也可以加path,比如/。 但需要注意的是不同path下面不能相互读取!!!怎么试验呢，可以在chrom的application下面写,然后在当前path写同一个域名下的另一个path，刷新cookie，发现另一个页面下面的有这个设置的cookie，请求的时候也能带上，但是自己这个设定页面没有，所以有时候如果setcookie没错误，但也没出现cookie，可以考虑下是不是设置路径错误了，虽然设置上了，但是看不见。这种情况特别容易出现在前后端分离的情况下，前端在80端口下，后端在8080端口下，后端api设定cookie是装在了8080那个域名下面，所以你无论怎么刷新前端页面都不会有这个cookie，但是没关系，当你请求后端接口的时候，请求会自动加上！！但要注意，请求的时候，http请求只能把他当前能看到的cookie带上，对于他看不见的肯定不会带上。]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2F2018%2F06%2F06%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。 关于浏览器同源策略的原因，可以网上查看各种资料，阮一峰的博客是个很好的选择。 什么时候会出现跨域 12345http://www.example.com/dir2/other.html：同源http://example.com/dir/other.html：不同源（域名不同）http://v2.www.example.com/dir/other.html：不同源（域名不同）http://www.example.com:81/dir/other.html：不同源（端口不同）组成一个域名（协议号：//ip地址：端口号）三者任意一个不同就会出现跨域 如果解决跨域呢，自己主要了解的有两种，分别是cors和jsonp,自己平时用的主要是cors。 cors可以让后端代码不用做过多的变动，只需要对返回的内容多添加些头部信息即可。 jsonp主要是通过script，img标签这类不存在跨域，回忆一下，是不是通过img加载过百度的图片，通过script的src加载过cdn上的jquery。 通过script返回的内容因为在script标签内部，所以可以执行script代码，所以当我们传给后端我们定义好的方法名，然后让他们把我们需要的数据放进去，再返回来，类似 1showData(&#123;&quot;1&quot;:&quot;boy&quot;&#125;); 上面的返回结果在script代码中自动执行，就能得到我们想要的结果（需要注意的是传入的数据必须是json类型哦，毕竟后端和js是不同的语言类型，然后我们只需要在showData里面对json数据进行转换成js能识别的数据即可）。 对于jsonp，我用的比较少，因为很多时候不想特别写专门用来跨域的api接口，所以如果要用jsonp，后端逻辑代码需要更改（百度php如何配合jsnop完成数据传输）。 对于前端，像jquery有对jsonp的封装，可以自定义函数，然后传入，返回的数据会先走定义的函数，然后来到success函数里面，注意success传入的参数data是不包括后端返回的内容中的函数，而是函数的参数们。 juqery默认传的自定义函数名称是jquery带一长串数字，具体的用法可以百度查看，我没咋用过。 还有哦，jsonp只能支持get请求。 重点鉴于上面诸多的麻烦，我用的主要是cors。 首先我们需要知道浏览器将跨域请求分成了简单请求和非简单请求，什么是简单请求， http 方法： head, get,post http 头部： Accept,Accept-Language,Content-Lanuage,Last-Event-ID Content-type 仅能是下列之一： application/x-www-form-urlencoded，multipart/form-data，text/plain 不是简单请求，那就是非简单请求 大部分情况下我们的请求都是非简单请求，因为很多时候我们需要的content-type application/json。 对于非简单请求，会先在正式请求之前发送一个options请求，当有跨域请求的时候，我们可以看下Chrome的控制面板，很清楚的能看到。对于返回信息，我们需要加以下头信息 1234$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); //允许的ip$response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;); //允许的方法$response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, token, Authorizon&apos;);//自定义的头部信息, 比如jwt 需要传递Authorizon 这个头部的时候 notice: options 请求只是个探针请求，我们并不需要他执行业务处理，他的功能只是获取我们response中的一些头部信息，而且因为他有些信息不回携带，别入header 中不会有Authorizon 这个属性，所以很多业务他也走不通，比如对于Authorizon 中数据的验证，当options 请求成功后，后面才会继续发送真正的请求，这时候我们才是真正的逻辑处理，所以很多时候web server 比如nginx 直接过滤掉了options 请求，我们在swoole 中这么处理 123if ($request-&gt;server[&apos;request_method&apos;] == &apos;OPTIONS&apos;) &#123; return $response-&gt;end();&#125; 其实上面那样设置header 中允许的请求域并不是太好，没有太多的安全限制，一般可以给个白名单，而且还有个问题就是如果设置成* 并不能允许携带cookie 123456789101112131415161718客户端：xhr.withCredentials = true;报错信息：Access to XMLHttpRequest at &apos;https://itbasic.datatom.com/bbsapi/datatalk/develop/perMonthProductIncome&apos; from origin &apos;http://localhost:64331&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. The credentials mode of requests initiated by the XMLHttpRequest is controlled by the withCredentials attribute.处理方式：String origin = req.getHeader(&quot;Origin&quot;);if(origin == null) &#123; origin = req.getHeader(&quot;Referer&quot;);&#125; resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); 更好的处理方式添加如下代码 if (origin in array[xxx]) &#123; resp.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); // 这样会更加安全&#125; 更多详细的cors 跨域参考这篇文章 大致只需要做这些处理，一般像php，只需要在router的 end（返回具体信息）之前加上上面的信息就可以了。 像node，或者swoole都在启动web服务的文件处加上即可。 ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP opcache]]></title>
    <url>%2F2018%2F05%2F25%2FPHP-opcache%2F</url>
    <content type="text"><![CDATA[opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。 原理：大概的意思就是把php的脚本一次性全存入内存中，然后每次读取脚本直接从这里面取，而不用每个连接都读取一份脚本。 但这样就存在修改数据后服务器识别不到，可以配置参数，多少秒服务器检查一次，但一般生产环境直接把配置成0，就是间隔时间是0，单位是s，然后停止检查，而开发环境参数配置成1，一直检查，这样就不会存在修改文件，没有效果了。 还可以手动清除，必须脚本中写入 1opcache_reset() 但需要注意的就是不同模式下储存脚本是在不同的内存空间中，比如cli下执行脚本文件，和通过浏览器这种mod_php清除是不一样的，所以浏览器访问的话就通过浏览器的方式去执行脚本吧。 当然，如果和我们swoole那样，每次修改代码后重启web服务器，那是根本不存在这种情况的。 话说偶然间发现代码的不同方式发布 121.类似前端代码那种，每次新代码的发布都会重新打个包，然后把站点目录通过软连接指向这个新包2.我们现在用的，通过在服务器上更新svn上的代码，来发布新的代码 首先运行环境是php7.014,线上环境是php5.6,效果不是十分明显，还有opcache_reset() byte-code不是十分好用。 首先得开启这个扩展，在phpinfo中查找opcache或者 php -m 中查找opcache，其实直接php -m就好了，会有个很显眼的ZendOpcache, 安装方法就是因为默认编译的时候大部分都有–enable-opcache,或者phpinfo页面上可以看见编译的参数，直接在php.ini 里面开启zend_extension=opcahce.so就好了，或者下载文件源码编译。 或者重新编译一下php（这个忘记了） 或者可以像pgsql那样去php源码包里面找源文件进行编译？这样可行吗，没有试过。 参数 12345opcache.validate_timestamps=1 //是否检测修改opcache.revalidate_freq=0//单位时间opcache.memory_consumption=64 //memory_consumption 这个参数很好理解，代表这块内存区开辟的大小，另外需要注意不同 PHP SAPI 内存区不是共享的，就是说同一个 PHP 文件，运行在命令行模式或者 PHP-FPM 模式下，对应的 byte-code 会存储在不同的内存区中。opcache.max_accelerated_files=4000 //如果命中率不搞，可以适当提升这个值，直到1。opcache.opcache.fast_shutdown=1 //modern php上面说这个写1就可以了 （opcache_get_configuration()和 and opcache_get_status()）获取配置信息和运行信息，比如了解那些文件被缓存了、使用了多少内存、内存命中率等等。 感觉就是基于这两个函数出了两个opcache的项目，一个是单页面，一个比较复杂 1.PeeHaa / OpCacheGUI 2.rlerdorf / opcache-status 单页面的部署直接放在网站根目录下就好了，就理解成phpadmin那种网点就好了，利用的就是php的函数获取php的运行环境，然后可视化展示出来 opcache_invalidate()，这个函数就是更新特定的文件缓存，没去试验过，因为项目小啦，直接重启web server。]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP yield]]></title>
    <url>%2F2018%2F05%2F25%2FPHP-yield%2F</url>
    <content type="text"><![CDATA[yield，生成器(generator)，蛮重要的，各种语言中都有，比如js, 实际工作中用的比较少~~ 关于yield这种数据类型，还有迭代器，还有collection，都是能用foreach进行循环遍历的。 1234567891011121314function productNum($length)&#123; $data = []; for ($i=0; $i&lt; $length; $i++)&#123; $data[] = $i; &#125; return $data; &#125;$data = productNum(100000000);foreach ($data as $key=&gt;$value) &#123; var_dump($value); &#125; 用php执行上端代码会报出超出分配给php的内存错误 123456789101112131415function productNum($length)&#123; //$data = []; for ($i=0; $i&lt; $length; $i++)&#123; //$data[] = $i; yield $i; &#125; //return $data; &#125;$data = productNum($100000000);foreach ($data as $key=&gt;$value) &#123; var_dump($value); &#125; 能执行成功，其实这个时候打印$data变量，可以看出来他是一个类。 每次foreach 去$data中取数据，上面的那个for循环就会执行一次，再次输出一个变量\$i。 so，如果使用yield的内容，每次也得循环使用吗 （对的，核心就是生产的时候要循环生产，消费的时候也要循环） yield定义的内容不能有返回。 下面写一个读取文件，再往另一个文件中写入内容的例子，其实这个例子不具有实际价值，其实就是一个copy文件，用shell_exec执行linux命令就可以，或者file_get_contents,file_put_contents这样就好了，使用yield分多次，唯一可以想到的好处就是控制对内存占用的大小。 123456789101112131415function getContent($file)&#123; $resource = fopen($file); while (feof($resource) === false ) &#123; yield fgets($resource); &#125;&#125;$content = getContent($file);$res = fopen(&apos;/home/itbasic/3.pdf&apos;, &apos;a&apos;);foreach ($content as $c_key=&gt;$c_value) &#123; fwrite($res, $c_value);&#125;fclose($res);echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;; //使用: 362640B 用传统方式 123$res = file_get_contents($file);file_put_contents(&apos;/home/itbasic/1.pdf&apos;, $res);echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;; //使用: 39875608B 显然超过一个数量级，yield就是把一个结果集分批的给你，你什么时候问他要下一个结果集，他什么时候给你。 js 版的yield 使用 123456789101112131415// 产生一个连续的 idx= 1;function* nextId()&#123; while(true) &#123; yield x; x++; &#125; &#125;var f = nextId()while (true)&#123; console.log(f.next().value)&#125; 需要注意的点蛮多的 1.function的命名 2.函数本身执行一次 3.next() 多次循环执行 PHP 版本类似代码 1234567891011121314151617function pr()&#123; $x = 1; while(true) &#123; yield $x; $x++; &#125;&#125;$a = pr();for ($i=1; $i &lt; 3; $i++) &#123; var_dump($a-&gt;current()); $a-&gt;next(); // php 的生成器的这个方法返回值是空，所以不能链式调用&#125;exit; PHP 的 yield 本身产生的就是一个生成器，而这个生成器自身也是可以循环的,所以上面的代码还可以改造成 12345678910111213141516function pr()&#123; $x = 1; while(true) &#123; yield $x; $x++; &#125;&#125;$a = pr();foreach ($a as $value) &#123; var_dump($value); // 注意这个直接就是值，不是generator， 本身也不需要通过 next() 接口主动循环&#125;exit;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[框架学习0]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A00%2F</url>
    <content type="text"><![CDATA[想了下，还是把框架的基础知识也记录下来。 首先我们需要认识到框架也是一个脚本，不要因为现代的框架都是oop而忽略了面向过程。框架的入口文件其实可以看做框架的处理文件，就是一个php文件，只是因为框架把对于问题的处理发送到内部的面向对象库中去了，所以我们才会忽略框架本身的面向过程，这就经常会让小伙伴不知道比如记录用户的访问信息，如果不写在登录接口中应该写在哪呢。 框架中对于常量的定义，对于辅助函数的定义（没有用命名空间，类似原生php函数的使用）我们经常只是在框架定义好的文件中添加，但忽略了为什么在这个地方写就能这样使用，其实本质上都是因为在入口文件出有include 这个文件才会这样。 一般入口文件只写一些文件加载，像返回数据的处理之类的一般写在route之中，我们那个bbs写在了入口文件中，添加返回头信息啊之类的，感觉也还行。对于异常的捕获处理一般也写在最外层的入口文件处，这样很暴力，这样每当我们有错误的时候想立刻终止可以通过马上抛出异常，而不用执行到脚本的末尾。]]></content>
  </entry>
  <entry>
    <title><![CDATA[框架学习1]]></title>
    <url>%2F2018%2F05%2F21%2F%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[对于框架源码的学习，可以帮助我们以后快速学习一个框架的使用，虽然同样的效果同样可以使用多学习几个框架，比如你把tp学完你学习laravel和yii发现很多时候都是一样的，但这仅限于你对框架的使用，增删改查的使用，当你想去修改一个框架的时候（不包括把框架中常量提取出来放在一个文件中，给框架增加一个validate等等这种情况）而是类似于把框架原来的隐式路由改成显式路由这种情况，如果你没有动手搭建过框架，你会不知所措。 我们这里对于框架的搭建还不是从头到尾写一个框架这种情况，composer（php的包管理工具，类似前端的npm），我们可以像拼接乐高积木那样搭建一个框架，那用什么来充当积木间的凹槽呢，我觉得命名空间可以充当凹槽之一。 命名空间在我的理解中就是把项目代码看做一个文件夹，然后名称是/,然后下面的各个文件夹名称就是命名空间，为了区分不同文件夹下的相同文件夹名称，我们需要把文件夹名称的路径记录下来。如果我的文件放在文件夹中的目录结构比较深，那么外层的文件夹名称是否可以不要呢，答案是肯定的，我觉得这也是文件夹相对于使用路径的好处之一。 上文说到了composer，我们要怎么使用这个工具呢。在项目的根目录下（注意不是网站的根目录下，网站的根目录往往是入口文件的根目录）执行composer install，linux下需要时php composer.phar install,他会找composer.json文件，第一次可能没有，我们可以通过composer require xxx/xxxx 来安装一个依赖，这时候会多出composer.json , composer.lock, vendor 目录，我们在入口文件出只需要include vendor/autoload.php, 就能使用vendor中的依赖了。我们项目中自定义的文件夹也可以通过composer 的autoload来实现自动加载。php的psr-4和psr-0都有对命名空间的规定，但是0废弃了，现在大家都是用4，比较下0和4，比如 \controller\test.php, 12&lt;?phpnamespace controller; 123456789101112131415//psr-0&#123; &apos;autoload&apos; : &#123; &apos;controller//&apos; : &apos;&apos; &#125; &#125;//psr-4&#123; &apos;autoload&apos; : &#123; &apos;controller//&apos; : &apos;controller&apos; &#125; &#125; psr-0会把规定的路径再拼上命名空间当做相对路径去文件夹下找，而psr-4会直接把规定的路径当做命名空间去寻找，上面的例子只是针对简单的一层命名空间，还是看不出什么效果，多层的更容易看出0是多么的脑残。 还有当注册了controller文件夹，controller的子文件夹的命名空间默认注册。 我们在修改命名空间的时候只需要修改composer.json文件就可以了，对于composer的具体怎么加载的其实不用管的，他应用这么广泛，一般不会出现什么问题。 todo: use 的时候命名空间顶层不用加\,但是new的时候如果顶层写要加\，不是十分理解。 来自modern php 首先use 的时候默认的是来自绝对，默认会在前面加上\ 同一个命名空间下的类相互引用，不用引入命名空间，比如我同一个controller下面代码的相互使用 xxx/xxxx,这种的一般第一个 xxx是厂商的命名空间，顶层命名空间，比较重要，第二个xxxx是子命名空间。 仅仅use 其实默认用了as取别名，只是类名和别名一样 Exception默认是php自带的，应该在顶层命名空间下，用\，如果使用的时候不加，他会默认在当前命名空间下寻找，会出现错误]]></content>
  </entry>
  <entry>
    <title><![CDATA[cookie和session的思考]]></title>
    <url>%2F2018%2F05%2F18%2Fcookie%E5%92%8Csession%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[最近新开了一个bbs的项目，因为也有登录和退出，但问题来了，和大多数的公司内部项目一样，如果每个项目都有自己的登录名和密码，都得注册，每次去不同的项目用户都需要进行登录，估计用户会疯吧。其实这个问题很久之前就遇到过，当时是别的部门的项目希望通过我们这边保存的用户信息进行登录，老大的想法是写一个接口给他们使用，但是如果项目越来越多，每次写接口肯定不太合适，那位同事和我说过单点登录，趁着这次机会，自己也了解了下。 首先是 /的理解。 关于相对路径和绝对路径，一般的解释是以/开头的就是绝对路径，以./开头的就是相对路径，没有这个开头的其实也是相对路径。 这个在linux中是绝对正确的, /这个在服务器中指代的就是/目录。 但这个理论也用在前端代码中，难道我们src = ‘/assets/xxx’,是去服务器根目录下assets目录下查找文件吗，显然这个理论是不正确的，所以这个/在前端代码中的意思是网站的根目录，对！！比如这个前端网站是itbasic.datatom.com,那么这个/指代的就是apache里面配置的root文件夹，所以前端代码中的这个/是由apache或者nginx等之类的web server 部署的时候决定的。 todo: itbasic中view文件夹不在/目录下，但是里面引用的文件相对路径却是相对/路径的，这是个很奇怪的问题。 php中有个函数setcookie,这是个在客户端种植cookie的函数，比如我们为了维持http的有状态，所以使用了session机制，通过在客户端的记录phpsessid ，然后服务器端（我用的是apache 的模块加载，默认是放在/tmp目录下）sess_(phpsessid)这个文件，这个文件中会保存你想让这个连接保存的相关信息。 那什么时候服务器端会在客户端记录phpsessid呢，是在start_session() ，这个函数调用的时候，php已经为我们封装好了对应的方法，注意setcookie，本质上是通过给浏览器头部发送消息，可以看下你调用setcookie这个方法的response，他的返回头中会有set-cookie，我的理解是如果想要返回头信息，在这之前不能有任何的输出，所以才会在start_session()之前不能有任何的输出。 setcookie函数可以看下，默认是在 当前文件所在路径下种植cookie，可以改成/,就可以在根域名下种植了，根域名下种植的好处就是下面的所有文件都能访问和删除这个cookie，如果你是在某个文件下种植的，只有当前文件才能放访问到，比如/bbs/dist,只有这个路径下的文件才能访问到。 还有放在/下的好处就是，/就在发送请求的时候他会自动的放在请求头部信息中，但是 如果你是放在/bbs/dist下面，他只会在请求/bbs/dist下的时候会携带，当访问/home之类的时候就不会携带。 还有个问题是关于重定向的，之前遇到的重定向就是爬取页面的时候会返回304，其实还有别的作用，比如cookie的种植。当今时代，api盛行，感觉这就是我忽略重定向的原因，我曾想着通过请求接口的方式进行setcookie，但好像是失败的，只能通过header（）这种方式。 关于单点登录： 使用场景：其实是一个很常见的情况，公司有很多系统，但用户基本信息只用一个就好了，虽然可以通过在各个系统中通过读取同一个数据库中的同一个表来实现登录，但如果每次用户使用公司的各个系统都得登录，这种体验真是太差了，最简单的方法，如果是在相同的域名下，可以通过在根域名下种植一个cookie信息，然后每次登录检测这个信息，这样其他域名也能检测到，这样就实现了统一登录和注销。 其实itbasic就是用的这个原理，所有的同一个域名下都可以使用这个原理，itbasic稍有不同就是登录原理的不同，一个是用cookie，一个用的是token。 其实最方便扩展的还是单点登录，对于单点登录就是独立出一个登录系统，虽然各个界面都有自己的登录，但每次登录之后都会在中间系统注册一下，然后每次登录都会去中间系统检测下是否登录，如果登录了，就不用再登录了，如果没有登录，首先在自己的系统中实现登录，再去中间系统中保存已登录状态。注销的时候也是，首先在中间系统中实现注销，然后遍历删除各个子系统中的登录状态。 单点登录因为没有去实现，所以理解还不是很深刻，只知道中间的登录系统最好用https。 还有对于session，传统的是以文件的形式保存，遇到的一个bug就是itbasic服务器内容满了，导致session写入一直失败，而bbs中token的作用类似session，但是他是放在redis中存储的，就不会有这个问题，感觉这也是session用redis和memcahe实现的好处之一，而不用file实现。]]></content>
  </entry>
  <entry>
    <title><![CDATA[验证器]]></title>
    <url>%2F2018%2F04%2F25%2F%E9%AA%8C%E8%AF%81%E5%99%A8%2F</url>
    <content type="text"><![CDATA[验证器应该是我们在使用TP,Laravel这些框架的时候经常遇到的,英文名Validate,为什么要验证器呢？数据验证应该是所有web api的第一步，通过校验前端数据的是否合法，来进行数据的接下来的操作，如果数据不合法，直接退回给前端，而不用执行。 Laravel 123456//验证数据的正确性 $this-&gt;validate($request, [ &apos;name&apos;=&gt;&apos;required|max:50&apos;, &apos;email&apos;=&gt;&apos;required|email|unique:users|max:255&apos;, &apos;password&apos;=&gt;&apos;required|confirmed|min:6&apos; ]); TP 12345678910protected $rule = [ &apos;name&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;mobile&apos; =&gt; &apos;require|isMobile&apos;, &apos;province&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;city&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;country&apos; =&gt; &apos;require|isNotEmpty&apos;, &apos;detail&apos; =&gt; &apos;require|isNotEmpty&apos; ];$result = $this-&gt;batch()-&gt;check($param); 其实两个很类似，就是通过传入验证条件和接受到的参数，来进行对应规则的验证. 自己 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Libs;use Framework\Exception\ClientException;use Framework\Exception\ServerException;class Validate&#123; static $res = true; static $errMsg = &apos;&apos;; /** * @param $arr, 传入的验证规则 * @param $params, 请求的数据 * @throws ClientException */ public static function validate($arr, $params) &#123; foreach ($arr as $a_key=&gt;$a_value) &#123; $funcArr = explode(&apos;|&apos;, $a_value); foreach ($funcArr as $f_key=&gt;$f_value) &#123; if(is_callable([__CLASS__, $f_value])) &#123; call_user_func_array([__CLASS__, $f_value], [$a_key, $params]); &#125; else &#123; throw new ServerException(&apos;&apos;, &apos;你的验证函数名不存在啦&apos;); &#125; &#125; &#125; if(self::$res == false) &#123; throw new ClientException(&apos;&apos;, self::$errMsg); &#125; &#125; public static function required($key, $arr) &#123; if (!key_exists($key, $arr)) &#123; self::$res = false; self::$errMsg .= $key.&apos;不存在 | &apos;; &#125; &#125; public function __call($name, $arguments) &#123; throw new ServerException(&apos;&apos;, &apos;你的验证函数名不存在啦&apos;); &#125;&#125; controller调用 12$validate = [&apos;comment_id&apos;=&gt;&apos;required|test&apos; ,&apos;sex&apos;=&gt;&apos;required&apos;];Validate::validate($validate, static::params()); 需要注意的点是： 上面验证器的使用过程中并不是检测到错误就立刻返回，而是检测出所有的错误再返回，所以我定义了两个static用来存储数据，当标志位是false的时候再把存储的错误信息一起返回。 is_callable函数的使用，验证函数是否能执行，如果是类中，[‘类名’， ‘方法名’]， 都是字符串，注意这个类名用__CLASS__,之前我直接写的Validate，这样肯定是不行的，同理call_user_func_array这个也是，相比较于call_user_func,这个是后面传入函数中的参数要以array的形式，如果是非静态函数，就传入类名，静态的话要传入对象哦，$this,或者new一个对象吧。call_user_func_array is_callable 需要注意static的使用，用的self哦，一般的使用用的this(都是在类中)，在类的外面的话，static 是 类名::,非static用的是 object-&gt;func. __call 是类中不存在这个方法的时候调用会自动执行，传入的两个参数第一个是调用的方法名，第二个参数是参数.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>框架</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIME TYPE的作用]]></title>
    <url>%2F2018%2F04%2F23%2FMIME-TYPE%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[其实本来不用单独写这篇文章的，可以放在http协议中，因为他本来就是关联这个http请求和返回信息中的content type，但其实用的还挺多，主要就是上传文件这块和php不借助插件而是通过输出html表格元素让页面按照excel来解析的方式生成excel。 一、 首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的，例如:Content-Type: text/HTML表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。(现在不用xml，而是用json，一般在返回头中都有) 12&gt;$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;);&gt; &gt; 注意这个content type，不仅在response中有，在request中也有， 123&gt;application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）&gt;multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）&gt; &gt; 上面的两种应该是我们平时最常见到的，一种是普通的表单提交，一种是当表单中有上传文件的时候进行的提交方式中content type的设置(好像默认的表单提交就是第一种，不用设置，只有上传的时候需要特殊设置，像我们itbasic上面，大部分时候用的是ajax进行提交，而不是表单，content type在ajax中应该封装成了text/json) 1234567&gt;&lt;form action=&quot;http://192.168.33.10:56732/bbs/login/test&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&gt;&lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt;&lt;br&gt;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&gt;&lt;/form&gt;&gt; &gt; 当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。 更详细的介绍https://www.cnblogs.com/jsean/articles/1610265.html 因为这篇文章复制有很多重复的部分（▄█▀█●），复制下来改很麻烦。 认识的几点就是：服务器端要存储文件后缀名和mime type的对应关系，我是这样理解的，虽然在linux下文件后缀名并没有什么卵用，感觉这都是content type的作用，但在windows下起了很大的作用啊，在服务器端保存文件的使用，需要通过content type对应的mime type 转换成文件后缀名，然后保存（虽然感觉直接读上传的文件名就可以了，感觉也许是兼容那些没有文件后缀名的情况吧，linux？） response 里面content type的作用很明显是通知客户端怎么解析这个文件。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2018%2F04%2F23%2FRedis%2F</url>
    <content type="text"><![CDATA[像虎扑这类电商网站，基本上所有的数据都塞到redis 里面 ！！！ 缓存，对于现代web很重要，首先他比较快嘛，因为是在内存中的，像很多功能也是通过缓存来实现的，比如点赞功能之类的，记录下常用的redis命令。因为是写php的，所以举得例子大部分还是以php的redis扩展为参照，其实大部分都一样。php 利用redis 有两个扩展，一个是php redis ,用c 写的，比较常用。一个是 predis , 用php写的一个redis 扩展包。 端口号：6379 密码：可以设置，也可以不设置。itbasic上没有设置，但只允许本机才能连接服务器上的redis。 $redis-&gt;auth(); 一般好像不需要用户，或者用户名: 密码 这样。 启动：安装目录下的redis-server,最好后台挂起，要不然这个cmd就没法用了 连接： 安装目录下的redis-cli , 这个客户端可以连接各地的redis-server, redis-cli -h 配置ip地址 -p 配置端口号 -a 配置密码 常见数据类型：1.string 2.hash 3. list 4. set 5.sorted set 通用命令： keys * : 获取所有的key Stringget(),根据key值获取 12345678910class \Lib\Redis extends \Redis //因为这个继承于php自带的扩展，所以命名空间在\下&#123; public function __construct() &#123; 建立连接 &#125;&#125;$redis = new \Lib\Redis();$redis-&gt;get($key); set,设置值 1$redis-&gt;set($key, $value,) hashhash类型不能像string的set方法中设置系统key的过期时间，可以通过调用expire来设置时间。 1$redis-&gt;expire($key, 7*24*60*60); hset: 设置hash的filed的值,这个key意思就是这个hash对象的唯一标识 1$redis-&gt;hset($key, $filed, $value) hmset: 给这个对象进行赋值, $arr是关联数组 1$redis-&gt;hmset($key, $arr) hgetall: 获取这个hash对象所有的内容 1$redis-&gt;hgetall($key) 坑： 之前很傻，因为接触到redis的时候，听到的好处就是相比较于mecache这种，多了很多的数据类型，memcache这种只有string，然后redis又在原先5中数据类型的基础上增加了表示地理坐标的新的数据类型。当时遇到一个问题就是想一个键值既能对应string，也能对应hash，想有没有这种数据类型。其实当时的思路是完全跑偏的，完全可以通过先构造一个比如token=&gt;string,string=&gt;hash两个类型，第一个是string，第二个是hash，通过token既能得到简单的string，也能得到hash。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理其实是我一直很少接触的，之前是因为异常处理相比较于php的基础知识更高一层，大学时就有个习惯，越到后面的内容看的越少，比如c语言的指针，每学期的专业课，都是只能讲完前面的语法部分，运算符？if？else？for循环？后面就没了。 但当我学习tp5的时候，发现tp5的所有错误都会以异常的形式抛出，然后在7月老师的指导下，认识到了AOP思想，了解了统一异常处理类的时候，我才逐渐重视了这个东西。 新项目中：因为我希望把每个函数写的尽量短些，虽然以后追踪问题的时候可能会跳来跳去，但如果单单只靠函数的名称就能了解到函数的作用，这将是多么美好的一件事，于是产生了一个问题：一般只有最外层的函数才能决定最终抛给客户端的内容，但如果我们在内部自己调用的函数中也这么写，比如 12345678910111213141516public function father()&#123; $res = $this-&gt;children(); return [ &apos;code&apos; =&gt; 200, &apos;msg&apos; =&gt; $res ]&#125;public function children()&#123; return [ &apos;code&apos; =&gt; 500, &apos;msg&apos; =&gt; &apos;你有毒&apos; ]&#125; 这个样子返回的结果肯定不是我们希望的，你可以说我可以处理啊，但其实如果层次深了之类的，处理是很麻烦的，如果我能立刻把结果给到前端，那该多棒啊，这时候就可以通过抛出异常，最外层统一对异常进行处理，比如抛出异常的时候 1throw new ControllerException(404, &apos;controller not exist.&apos;); 这个ControllerException 是继承于基本的\Exception，php自带的。然后我们在最外层进行捕获 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?phpdate_default_timezone_set(&apos;Asia/Shanghai&apos;);include_once(&apos;vendor/autoload.php&apos;);include_once &apos;./Libs/Eagles/Document.php&apos;;define(&apos;SWOOLE_PORT&apos;, 56732);define(&apos;SWOOLE_ERROR_LOG&apos;, &apos;/var/log/swoole_error.log&apos;);define(&apos;EAGLES_SERVER&apos;, &apos;211.144.114.26&apos;);define(&apos;EAGLES_PORT&apos;, &apos;17200&apos;);// error_reporting(0);// http服务的配置$http = new swoole_http_server(&quot;0.0.0.0&quot;, SWOOLE_PORT);$http-&gt;set([ &apos;worker_num&apos; =&gt; 20, // cpu 6核 默认启动6个, 1-4 倍合适 占用：40M内存*20 // &apos;task_worker_num&apos; =&gt; 6, //开启task功能 // &apos;daemonize&apos; =&gt; true, // 守护进程 &apos;log_file&apos; =&gt; SWOOLE_ERROR_LOG, &apos;buffer_output_size&apos; =&gt; 8 * 1024 *1024, // 8M 缓冲区。占用 8*12M,api接口可最大返回8M的数据内容 &apos;package_max_length&apos;=&gt; 5 * 1024 * 1024, // 最大数据块是5M。上传可上传4M大小文件 // 配置静态文件根目录 // &apos;enable_static_handler&apos; =&gt; true, // &apos;document_root&apos; =&gt; &apos;/home/projectx/server/upload&apos; // &apos;daemonize&apos; =&gt; true, // &apos;pid_file&apos; =&gt; __DIR__.&apos;/server.pid&apos;]);use Framework\Base\Route as Router;use Framework\DB\ConnectionManager as ConnectionManager;use Framework\Log\Logger as Logger;$config = include_once(&apos;config/config.php&apos;);Logger::logfile($config[&apos;logfile&apos;]);ConnectionManager::db_config($config[&apos;db&apos;]);$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123; try&#123; if ($request-&gt;server[&apos;path_info&apos;] == &apos;/favicon.ico&apos; || $request-&gt;server[&apos;request_uri&apos;] == &apos;/favicon.ico&apos;) &#123; return $response-&gt;end(); &#125; $param = $request-&gt;server[&apos;request_method&apos;] == &apos;POST&apos; ? @$request-&gt;post : @$request-&gt;get; $data = \Libs\Common::getCallData(@$request-&gt;header[&apos;www-authorization&apos;], $request-&gt;header[&apos;host&apos;], $request-&gt;server[&apos;request_uri&apos;], $param, $request-&gt;server[&apos;remote_addr&apos;], $request-&gt;server[&apos;request_method&apos;]); //\Libs\ElasticSearch::setIndexTableDoc(&apos;projectx_log&apos;, &apos;call_log&apos;, $data[&apos;doc_id&apos;], $data[&apos;data&apos;]); $allow_method = [&apos;POST&apos;, &apos;GET&apos;, &apos;OPTIONS&apos;]; if(!in_array($request-&gt;server[&apos;request_method&apos;], $allow_method))&#123; $response-&gt;status(405); return $response-&gt;end(); &#125; //如果需要设置允许所有域名发起的跨域请求，可以使用通配符 * $response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); $response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;); $response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Origin, X-Requested-With, Content-Type, Accept, www-authorization&apos;); $uri = $request-&gt;server[&apos;request_uri&apos;]; $uri = $uri; $res = Router::dispatch($uri, $request, $response); @$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;); @$response-&gt;end(json_encode($res)); &#125;catch(\Framework\Exception\ControllerException $ce)&#123; $status = $ce-&gt;getStatusCode(); $response-&gt;status($status); $errorcode = $ce-&gt;getErrorCode(); $msg = $ce-&gt;getMsg(); $response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); $response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;); $response-&gt;end(json_encode([&apos;code&apos;=&gt;$errorcode, &apos;msg&apos;=&gt;$msg])); &#125;catch(\Framework\Exception\RouteException $re)&#123; $status = $re-&gt;getStatusCode(); @$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); @$response-&gt;status($status); @$response-&gt;end(); &#125;catch(Exception $e)&#123; @$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); @$response-&gt;status(500); @$response-&gt;end(&apos;exceptions:&apos; . $e-&gt;getMessage()); &#125;&#125;);echo &quot;server start listening port:&quot; . SWOOLE_PORT . PHP_EOL;$http-&gt;start(); 看见了嘛，最外层的几个catch就是对他的捕获，注意最大的要写在外面哦，因为前面的如果捕获了，后面的就不会处理了呢。 其实通过上面的例子我们还能了解到其实一个php项目说到底还是一个脚本，上面代码是我用swoole搭建的webserver时候的启动脚本，其实用swoole能更好的帮助phper理解web是怎么样运行的，当服务器监听到request过来的时候，我们通过这个 1Router::dispatch($uri, $request, $response); 去执行对应的项目里面的代码，这就是我们平时经常写的工程，大部分用的是面向对象的思想，定义一个类啊，方法啊，因为这里面就像一个仓库，是我们用来取东西的，所以没有那种流程的概念，唯一的流程概念应该在我们这个启动脚本里，这也是我们把try catch 写在这里面的一个原因（这也是我找php统一异常处理的方法应该定义在哪的时候发现的），后来继续思考了下，感觉不管是我之前做的那个itbasic，还是现在这个bbs，其实都是脚本+类库合在一起的，因为很多时候我们往往都是在写类库，而忽略了脚本的存在（一般都是写好的，很少需要改），甚至把一个项目就当做一个面向对象，而忘记了面向过程的存在，之前群里面有个朋友不知道在哪定义通过哪个搜素引擎查找到自己网站的网上百度的方法，根源也是因为不理解一个项目的脚本到底存在于什么地方。 其实类比自己接触的两个框架，tp和laravel,为嘛他的入口文件index.php和路由文件分开了呢，:sweat: 其实本该分开，路由是个类库，入口文件是个脚本呢，之所以产生这种坑爹的想法是itbasic的route.php即是入口文件，也是路由类定义的地方。 观察server.php, 观察config目录，发现set.php 是定义的常量，这样在使用的时候可以直接使用，但是config.php 是返回的数组，项目里面想用这里面的值是不可以直接使用的，那数据库是怎么连接的呢，发现 1ConnectionManager::db_config($config[&apos;db&apos;]); 这个类和普通的类不一样，这个直接在入口文件中就有加载，这个是把config里面的值保存到他的类变量中了，所以在项目里面可以直接使用。 还有上次那个exception，其实子类继承了父类，父类中变量和子类中变量重名，但他们是各自的，子类继承了父类，用了父类获取自己errorcode的方法，那个其实是获取父类的，而并非是获取子类的，这点要注意。 子类继承父类的初始化函数的时候不要忘记传参数了哦。 wait: 1.异常处理的细节 2.还记得之前在学习aop思想的时候，觉得既然在最外层套一个比如index.php文件那块 try catch 就能捕获所有的异常（异常在throw 的时候如果没有捕获就会继续往上抛出，可以理解成类似冒泡那样，层层函数传递出来）,那为啥看见别人在代码中还是要写 try catch呢，其实是为了立刻捕获异常，让程序还能往下执行，如果我们throw了一个异常，没有捕获，而是在最外层的index.php捕获，那么代码会立刻在throw的地方终止，这可能是我们不想的结果，比如在一个foreach循环处理数据的过程中，其中一条数据处理有问题，我们只需要把对应结果置为空或者记录下来后面再分析就好了，如果停掉程序真的没必要，也不太合适。这时候我们就可以 try catch 代码块，catch中处理异常，千万注意不要 return~也不要再次throw，这两个都会让代码停止执行 notice: 所以有时候我们看到代码 try catch ,catch块是空的时候不要觉得没意义（之前表哥diss过），哪怕是空的不写，也能让程序运行下去 123456789101112foreach ([1,2,4] as $value) &#123; try &#123; throw new \Exception(&apos;11&apos;); &#125; catch(Exception $e) &#123; var_dump(&apos;handle&apos;); &#125; var_dump(&apos;haha&apos;);&#125;exit; 3.自定义异常处理 php手册中有对异常处理重写的详细讲解，重写的exception 都必须继承到php原本自带的exception上面，所以我们在用扩展包的时候，如果偷懒的话只需要捕获php最现实的exception就好了，但是为啥看到别人的代码块中经常套了好几层catch 呢，这是因为exception 的 code， 和 errorMsg 都是 protected 的，也就是子类不能重写，然后getCode 和 getMessage都是final，也不能重写，所以我们虽然能捕获exception，但是不能控制输出的code 和message 内容(我们在调用任何包的时候，本质上还是调用php代码，比如guzzle 封装的http，可能他本质上就是调用的curl库或者file_get_contents库，对于400的http返回，原生的exception 直接把 状态码这些全都封装在了 errorMessage 中，这是我们不想要的，所以我们才会在原生exception 的上层补上自定义的exception，我们可以在自定义的exception ，自己封装想要的errMsg,比如上面的那个例子中去掉400状态码,然后捕获这个异常，再输出这个errMsg) 4.另一类的异常（itbasic的数据库查询出错，不抛出异常，而是以errorMsg这个私有变量来提示，参考go的异常）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信开发]]></title>
    <url>%2F2018%2F04%2F18%2F%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>微信</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[postgresql常见问题总结]]></title>
    <url>%2F2018%2F04%2F17%2Fpostgresql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[本来是不想写这篇文章的，因为感觉自己对于postgresql理解不够深入，但因为生活中对于postgresql有些问题总是遇到，所以记录下来，方便以后查找。 1.navicate连接postgresql 第一次建立连接肯定会报错啦 上面初始数据库的意思并不是数据库的名称。毕竟这次连接成功后，里面有一堆的数据库 The server doesn’t grant access to the database: the server reportsFATAL: no pg_hba.conf entry for host “192.168.0.123”, user “postgres”, database “postgres” FATAL: no pg_hba.conf entry for host “192.168.0.123”, user “postgres”, database “postgres” 谷歌翻译 服务器不授予对数据库的访问权限：服务器报告FATAL：主机“192.168.0.123”，用户“postgres”，数据库“postgres”没有pg_hba.conf条目FATAL：主机“192.168.0.123”没有pg_hba.conf条目，用户“postgres”，数据库“postgres” 其实字面意思就很容易理解，虽然我还是百度的错误答案。我自己理解就是入口不被允许,就觉办法如下 PostgreSQL数据库为了安全，它不会监听除本地以外的所有连接请求，当用户通过JDBC访问是，会报一些如下的异常： org.postgresql.util.PSQLException: FATAL: no pg_hba.conf entry for host 要解决这个问题，只需要在PostgreSQL数据库的安装目录下找到/data/pg_hba.conf,找到“# IPv4 local connections:” 在其下加上请求连接的机器IP host all all 127.0.0.1/32 md5 //坑爹，那里面对于192.168.23.10当做192.168.23.1 32是子网掩码的网段；md5是密码验证方法，可以改为trust 一个服务器，有内网ip（类似192.168这些，有外网ip 211.这种，有127.0.0.1 这种，如果要包括所有的，就得用0.0.0.0，感觉如果你访问一个服务器用的是内网ip，应该意思就是你们在同一个局域网中吧。很奇怪的一点是，之前说vagrant会把ssh的22端口映射到host的2222端口，导致了127.0.0.1:2222或者192.168.23.10:22都能访问，其实不太懂这个原理，但好像这是由两个不同的网卡决定的，我好像把itbasic那上面一个网卡禁止了，导致127那种ssh访问不了，感觉就是虽然内网ip和外网ip可以对应同一个端口，但也可以对应不同的端口） 2.导入导出数据库 导出：/opt/pgsql/bin/pg_dump -U postgres itbasic &gt; /home/itbasic/itbasic.sql pg_dump 是postgresql安装之后的一个命令，-U 指定用户 postgres, itbasic,是数据库名，postgresql好像只能用postgres这个用户执行操作，itbasic这个数据库名一定要指定，还有pg_dump 这个命令所在目录没有加入系统变量的话，一定要加上路径，后面 &gt;/home/itbasic/itbasic.sql,代表数据导出到具体的文件中。 导出 数据库的导入必须要先创建这个数据库 postgresql安装之后的命令会有createdb，但用这个创建数据库感觉挺麻烦，直接 12341. /opt/pgsql/bin/pgsql -U postgres itbasic //进入pgsql 客户端2. create database project x //创建数据库3. \q //退出pgsql客户端4. /opt/pgsql/bin/pgsql -U postgres projectx -f /home/itbasic/projectx.sql //导入数据库 3.导入导出表 导入导出表和导入导出数据库的最大区别是导入导出数据库需要先建立一个数据库，而表则不用，最好还先把这张表删除了 导出 /opt/pgsql/bin/pg_dump -U postgres itbasic -t dt_admin &gt; /home/itbasic/admin.sql 导入 /opt/pgsql/bin/psql -U postgres itbasic -f /home/itbasic/admin.sql 4.数组类型 array_remove 会把出现的元素全都移除掉，而不是只移除一个 love=array_remove(love, chen.ye) array_append love= array_append(love, chen.ye) 如果元素不存在，也不会报错，只会接着往下执行 any() chenye = any(love) love这个字段中是否有陈野 5.今天在到处数据的时候发现了一个不得了的问题，就是通过命令导出的数据的时候当文件一定大的时候，会自动停止，但是导出语句不会报错，这就坑爹了，也就是说我每天备份的那些文件都没有任何的意义 可以通过 1/opt/pgsql/bin/pg_dump -U postgres itbasic -t &apos;(dt_user|dt_user_login|dt_userinfo)&apos; &gt; /home/itbasic/t4.sql 分表导出 表名的话可以通过 1select tablename from pg_tables where tablename like &apos;dt_%&apos; 筛选出来再连接，果然定义成有前缀好处颇多，要不然筛选出好多自带的无用的表 6.感觉要多看看别的项目是怎么进行数据备份的，之前的那种一次性导出的方式不行，当数据量大的时候，单表备份可能都不行。]]></content>
      <categories>
        <category>postgresql</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache简单配置]]></title>
    <url>%2F2018%2F04%2F16%2Fapache%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于apache的配置文件。不管是xampp安装的lamp环境，还是自己在linux下面搭建的lamp环境，之前关于apache的配置都是直接copy网上的，用的虚拟域名，本质是还是不够理解的，关于.htaccess 也只是刚开始学习tp的时候看到过，后来因为配置虚拟域名能解决问题，就没有过多的了解这个.htaccess了。 首先说一下之前遇到的问题。某次，帮助交付的一个同事配置xampp环境，他当时对多站点的配置文件都写在了apache的主配置文件中，httpd.conf,当时因为已经了解了虚拟域名，所以我在同级目录extra下面的httpd-vhost.conf中帮他写了新的配置，当时用的是不同域名分发到不同文件夹下的方式，其实这在实际生活中也是这样的，因为如果靠的是端口号的话，因为web服务默认是80端口，如果用了别的端口号，比如http:\\www.baidu.com:800, 这样访问百度的web服务，这对广大用户是不友好的，因为对于非程序员来说，根本不知道:800是什么。如果不想用域名开进行分发，端口号也是可以的，但为了不让用户去记忆端口号，可以通过nginx来帮忙。比如itbasic.datatom.com和bbs.datatom.com虽然绑定的是同一个服务器，但是通过nginx的转发，到了不同的端口，一个因为是从itbasic.datatom.com+ 80端口来的，所以转发到本服务器的8080端口，一个是从bbs.datatom.com+80端口来的，所以到了8081端口。我就是通过上述两种方式之一的域名不同来帮那个同事写的vhost配置的，可是呢，当我输入域名的时候，他虽然能访问，但是访问的还是之前他的一个网站，fuck！！！算了，配置文件写的这么乱，我就没找原因了，直接帮他copy了以前主配置文件里面写的一个站点配置。 其实后来我差不多知道原因了，大概是直接在主配置文件里面写了 1234567891011121314151617181920212223242526272829ServerName localhost:80DocumentRoot &quot;F:/www&quot;&lt;Directory &quot;F:/www&quot;&gt; # # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;, # or any combination of: # Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews # # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot; # doesn&apos;t give it to you. # # The Options directive is both complicated and important. Please see # http://httpd.apache.org/docs/2.4/mod/core.html#options # for more information. # Options Indexes FollowSymLinks Includes ExecCGI # # AllowOverride controls what directives may be placed in .htaccess files. # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords: # AllowOverride FileInfo AuthConfig Limit # AllowOverride All # # Controls who can get stuff from this server. # Require all granted&lt;/Directory&gt; 问题的关键就是那个server name，因为是localhost：80，但凡是host（windows下）里面127.0.0.1 用的80端口，统一转发到这个目录下，造成了上述结果。其实itbasic的服务器配置上也是这么写的，但之外的那些bbs，51dana用的却是虚拟域名，为啥那个能正常访问呢，在于配置文件上面定义了server name itbasic.datatom.com。其实itbasic那个也是可以通过域名来进行分发的，主要在每个vhost里面加个server name 就可以了。itbasic那个完全也可以不用端口进行转发，完全可以通过域名，在每个vhost里面加上server name就可以了 先说一下关于vhost的配置方法吧 打开apache的配置文件 htppd.cnf。分别打开重写扩展和虚拟主机扩展： LoadModule rewrite_module modules/mod_rewrite.so 这句前面的 注释 # 去掉 Include conf/extra/httpd-vhosts.conf 这句前面的 注释 # 去掉 但现在一般apache都是默认开启的 12345678910111213141516171819&lt;VirtualHost *:80&gt; //包裹的内容代表虚拟主机，端口号80 DocumentRoot &quot;D:/wamp/www/testphp/&quot; //项目的根目录 ServerName php.iyangyi.com //域名 ServerAlias www.pptv.cn #可省略 //这个是我们的虚拟域名的别名，可以不要，他的出现场景就是我们希望另外一个域名也往这个目录下调整。比如 www.pptv.cn 我们也希望跳到这里来，就可以这样做，但是前提是 www.pptv.cn 也要绑定host 127.0.0.1 ServerAdmin stefan321@qq.com #可省略 //这里填 服务器管理员的邮箱，也可以不要，当服务器出现故障后，如果提前有配置邮箱的话，会往这个邮箱发邮件，或者是显示在网页的错误信息当中。一般我们可以不填。 ErrorLog logs/dev-error.log #可省略 //当访问出现错误的时候，就会记录到这里，注意：logs/dev-error.log 这个文件路径是apache的安装目录下的logs 目录 。可以不要。 CustomLog logs/dev-access.log common #可省略 //这里填 访问日志，用来记录每一次的请求访问，可以不要。注意：logs/dev-access.log 这个文件路径是apache的安装目录下的logs 目录 。记住：路径后面加common。 ErrorDocument 404 logs/404.html #可省略 //这里填 403,404等错误信息调整页面，用来访问出现404页面等情况时的错误页面展示，比较有用，也可以不要。注意：/404.html 这个文件路径是项目的根目录，不是apache的目录。 &lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Order Allow,Deny Allow from all RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L] &lt;/Directory&gt;&lt;/VirtualHost&gt; 一般配置的时候，上面写了可省略的都不会配置。 1&lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt; 是最重要的一步了，这里也是填本项目的路径，然后所有的rewrite规则都是在里面完成。所以这个是很重要的。 1Options Indexes FollowSymLinks 作用我访问php.iyangyi.com，如果文件根目录里有 index.html(index.php)，浏览器就会显示 index.html的内容，如果没有 index.html，浏览器就会显示这文件根目录的目录列表，目录列表包括文件根目录下的文件和子目录。 到底是优先显示index.php还是index.html 有apache的配置决定的： 123&lt;IfModule dir_module&gt; DirectoryIndex index.html index.htm index.php index.php3 &lt;/IfModule&gt; 这个是单独写出来的，而不是写在上述标签之内。这个感觉应该是统一定义一个就行了，或者是在vhost里面直接写directoryindx 这个标签，如果没写默认是index.html或者是index.php 之前遇到一个问题就是public文件夹因为是统一对外开放的嘛，不做处理的话，比如itbasic.datatom.com/userpic,可以访问服务器上public下面这个userpic文件夹，为了不让用户访问，我们可以去掉 1Options Indexes FollowSymLinks 的indexes,用户就不能访问了。 Order Deny,Allow Allow from all这2个一般是组合在一起用。用来设置访问权限 ，设置哪些ip可以访问这个域名, 哪些ip禁止访问。 所以order是设置这2个的组合排序, 不区分大小写，中间用,分开，中间不能有空格。 所以order是设置这2个的组合排序, 不区分大小写，中间用,分开，中间不能有空格。Order Deny,Allow ：表示设定“先检查禁止设定，没有设定禁止的全部允许” Order Allow,Deny : 表示设定“先检查允许设定，没有设定允许的全部禁止” 而且最后的访问结果有第二参数决定！ Deny from All Deny from 127.0.0.1 禁止访问的ip， all 表示全部 Deny from All Deny from 127.0.0.1 禁止访问的ip， all 表示全部Allow from All Allow from 127.0.0.1 允许访问的ip， all 表示全部 我们看几个他们2个组合的例子。 这个例子： 12Order Deny,AllowDeny from All 表示先检查允许的, 没有允许的全部禁止。但是下却没有Allow，那么就表示是无条件禁止了所有的访问了。 123Order Deny,AllowDeny from allAllow from 127.0.0.1 上面表示 只允许127.0.0.1访问 123Order Allow,DenyAllow from allDeny from 127.0.0.1 192.168.1.51 上面表示禁止127.0.0.1和192.168.1.51访问，其他都可以！ 所以这个的组合就可以达到很多的过滤访问效果。 但现在一般不用那个了 1Require all granted 才能解决，要么一直都是403。 RewriteCond 与 RewriteRule 指令格式配置详解上面花了大量的时间讲述VirtualHost 里面的一些配置参数的写法和作用，接下来就是rewrite的重点了，3个核心的东西：RewriteEngine，RewriteCond，RewriteRule RewriteEngine RewriteEngine这个是rewrite的总开关，用来开启是否启动url rewrite，要想打开，像这样就可以了： RewriteEngine on RewriteCond 和 RewriteRule RewriteCond 和 RewriteRule表示指令定义和匹配一个规则条件，让RewriteRule来重写。说的简单点，RewriteCond就像我们程序中的if语句一样，表示如果符合某个或某几个条件则执行RewriteCond下面紧邻的RewriteRule语句，这就是RewriteCond最原始、基础的功能。 先看个例子： 123RewriteEngine onRewriteCond %&#123;HTTP_USER_AGENT&#125; ^Mozilla//5/.0.*RewriteRule index.php index.m.php 上面的匹配规则就是：如果匹配到http请求中HTTP_USER_AGENT 是 Mozilla//5/.0.* 开头的，也就是用FireFox浏览器访问index.php这个文件的时候，会自动让你访问到index.m.php这个文件。 RewriteCond 和 RewriteRule 是上下对应的关系。可以有1个或者好几个RewriteCond来匹配一个RewriteRule RewriteCond一般是这样使用的 1RewriteCond %&#123;XXXXXXX&#125; + 正则匹配条件 那么RewriteCond可以匹配什么样的数据请求呢？ 那么RewriteCond可以匹配什么样的数据请求呢？它的使用方式是：RewriteCond %{NAME_OF_VARIABLE} REGX FLAG 123RewriteCond %&#123;HTTP_REFERER&#125; (www.test.cn)RewriteCond %&#123;HTTP_USER_AGENT&#125; ^Mozilla//5/.0.*RewriteCond %&#123;REQUEST_FILENAME&#125; !-f 上面是常见的3种最常见使用最多的HTTP头连接与请求匹配。 HTTP_REFERER HTTP_REFERER这个匹配访问者的地址，php中$_REQUREST中也有这个，当我们需要判断或者限制访问的来源的时候，就可以用它。 比如： 12RewriteCond %&#123;HTTP_REFERER&#125; (www.test.cn)RewriteRule (.*)$ test.php 上面语句的作用是如果你访问的上一个页面的主机地址是www.test.cn，则无论你当前访问的是哪个页面，都会跳转到对test.php的访问。 再比如，也可以利用 HTTP_REFERER 防倒链，就是限制别人网站使用我网站的图片。 123RewriteCond %&#123;HTTP_REFERER&#125; !^$ [NC]RewriteCond %&#123;HTTP_REFERER&#125; !www.iyangyi.com [NC]RewriteRule \.(jpg|gif) http://image.baidu.com/ [R,NC,L] NC nocase的意思，忽略大小写。第一句呢，是必须要有域名，第一句就是看域名如果不是 www.iyangyi.com 的，当访问.jpg或者.gif文件时候，就都会自动跳转到 http://image.baidu.com/ 上，很好的达到了防盗链的要求。 REQUEST_FILENAME REQUEST_FILENAME这个基本是用的最多的，以为url重写是用的最多的，它是匹配当前访问的域名文件，那哪一块属于REQUEST_FILENAME 呢？是url 除了host域名外的。 1http://www.rainleaves.com/html/1569.html?replytocom=265 这个url，那么 REQUEST_FILENAME 就是 html/1569.html?replytocom=265 看个例子： 123RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteCond %&#123;REQUEST_FILENAME&#125; !-dRewriteRule ^room/video/(\d+)\.html web/index\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L] -d 是否是一个目录. 判断TestString是否不是一个目录可以这样: !-d -d 是否是一个目录. 判断TestString是否不是一个目录可以这样: !-d-f 是否是一个文件. 判断TestString是否不是一个文件可以这样: !-f 这两句语句RewriteCond的意思是请求的文件或路径是不存在的，如果文件或路径存在将返回已经存在的文件或路径。一般是这样结合在一起用的。 上面RewriteRule正则的意思是以 room开头的 room/video/123.html 这样子，变成 web/index.php?c=room&amp;a=video&amp;r=123 $1 表示匹配到的第一个参数。 RewriteRule 写法和规则RewriteRule是配合RewriteCond一起使用，可以说，RewriteRule是RewriteCond成功匹配后的执行结果，所以，它是很重要的。 来看一下 RewriteRule的写法： 1RewriteRule Pattern Substitution [flags] Pattern是一个正则匹配。Substitution是匹配的替换 [flags]是一些参数限制； 我们看几个例子： 1RewriteRule ^room/video/(\d+)\.html web/index\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L] 意思是 以 room开头的 room/video/123.html 这样子，变成 web/index.php?c=room&amp;a=video&amp;r=123 1RewriteRule \.(jpg|gif) http://image.baidu.com/ [R,NC,L] 意思是以为是访问.jpg或者gif的文件，都会调整到 http://image.baidu.com 所以，掌握正则级是关键所在了。以后，我会专门搞一个正则的篇章来学习下。 我们再看看[flags]是什么意思？ 因为它太多了。我就挑几个最常用的来说说吧。 [QSA] qsappend(追加查询字符串)的意思，次标记强制重写引擎在已有的替换字符串中追加一个查询字符串，而不是简单的替换。如果需要通过重写规则在请求串中增加信息，就可以使用这个标记。上面那个room的例子，就必须用它。 NC nocase(忽略大小写)的意思，它使Pattern忽略大小写，也就是在Pattern与当前URL匹配时，”A-Z”和”a-z”没有区别。这个一般也会加上，因为我们的url本身就不区分大小写的。 R redirect(强制重定向)的意思，适合匹配Patter后，Substitution是一个http地址url的情况，就调整出去了。上面那个调整到image.baidu.com的例子，就必须也用它。 L last(结尾规则)的意思，就是已经匹配到了，就立即停止，不再匹配下面的Rule了，类似于编程语言中的break语法，跳出去了。 其他的一些具体的语法，可以参考以下资料： http://www.skygq.com/2011/02/21/apache%E4%B8%ADrewritecond%E8%A7%84%E5%88%99%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D%E8%BD%AC/ http://www.2cto.com/os/201201/116040.html http://www.cnblogs.com/adforce/archive/2012/11/23/2784664.html .htaccess文件的使用.htaccess文件是啥呢？我们前面说了这么多的配置和修改，都是针对于apache的配置文件来修改的。.htaccess文件就是它的一个替代品。为啥呢？因为你每次修改apache的配置文件，都必须重启apache服务器，很麻烦不说，有些共享apache的服务器，你还没权限修改和重启apache。所以，.htaccess文件就应运而生了。（不用重启apache,是真的挺方便的） .htaccess分布式配置文件。它文件名字比较奇怪，没有文件名，只有一个文件后缀就是.htaccess。所以一般在windows下还没法新建这个文件，因为windows不允许文件名是空的，比较蛋疼。但是我相信你总归会有办法新建这个文件的。（在linux下新建一个，下载到windows中呗） .htaccess同时是一个针对目录的配置，你可以把它放到项目的根目录下，那么它就多整个项目其效果，如果你把它放到一个单独的子目录下，那么它就对这个子目录其效果了。 .htaccess文件如何生效呢。上面讲配置的时候，我讲过了AllowOverride All这个配置，它就是启动.htaccess文件是否可以使用的。AllowOverrideAll表示可以。AllowOverride None表示禁止使用。还是蛮简单的。 那.htaccess文件里的语法是怎么写额呢？ 其实和上面说的一模一样的写法。可以完全的搬过来用。没问题。 12345678910 &lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt; Options Indexes FollowSymLinks AllowOverride All Order Allow,Deny Allow from all RewriteEngine on RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/Directory&gt; 上面的apache的`里的这一块就可以完全的搬到.htaccess`文件中来，且效果一模一样。 上面就是vhost文件里面的配置的大致写法，其实httpd.conf里面也是这么写的，毕竟vhost最后还是包含到主配置文件里面。 documentroot 其实自己一直好奇为啥和directory参数一样其实本质上该项目文件夹下只有这个document root能访问，所以重写规则也好，针对的都是这个document root，导致了二者之间的相同。 有一点要注意的就是，如果通过开不同的端口号转发到不同的文件夹，需要早配置文件的开头写上Listen 127.0.0.1：8080 这样，开启端口号。]]></content>
      <categories>
        <category>apache</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>apache</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel ORM]]></title>
    <url>%2F2018%2F03%2F30%2FLaravel-ORM%2F</url>
    <content type="text"><![CDATA[orm并不是一个新兴的概念，他出现很久了，只是刚开始学习的自己并没有接触到，他能帮我们少写很多代码，让我们能以更面向对象的方式来处理关于数据库的操作。 Eloquent 是laravel的orm，我们通过 123php artisan make:model Userphp artisan make:model Models/User //放在文件夹models里面php artisan make:model Models/User -m //顺便把迁移文件也创建了 生成的类虽然是继承Model，但本质上都是继承这个Eloquent，他把我们每张表看做一个类，表里面的数据看做一个实例，我们对其进行操作的时候，更类似于面向对象的操作 1234$user = User::find(1);$user-&gt;name = &apos;cy&apos;;$user-&gt;city = &apos;shanghai&apos;;$user-&gt;save(); 更便于理解。 生成的model很简单，大致 1234567891011&lt;?phpclass Article extends \Eloquent &#123;protected $table = &apos;my_article&apos;; //自定义表名protected $fillable = [];protected $hidden = [];&#125; 关于表名：基本都是小写，然后多个单词用_连接（php的类是首字母大写的驼峰命名法） 这个fillable里面就是可以批量操作的字段，批量操作在我之前的文章里面有提到过，我觉得更通俗的理解是可更新的字段。主要是create方法时的那种批量更新，会用到。 hidden 就是对一些用户数据的隐藏，还记得我们经常取数据时候的select * 吗，容易把用户的身份证号，密码都取出来，这样不太好 只需要继承一下 Eloquent 类，就可以干 ‘first() find() where() orderBy()’ 等非常非常多的事情，这就是面向对象的强大威力。 通过 1php artisan tinker 可以开启一个交互环境进行orm的调试，其实我感觉不止是orm，别的代码也都是可以执行的，只是方便了orm的打印操作，能很方便的看到执行结果。有一点需要注意的就是tinker是基于当前代码的，如果代码重新修改来了，我们需要重启tinker来加载新的代码。 还有我们会利用composer安装laravel-debugbar，来进行orm的调试，当我发现在别的项目中使用不了这个插件的时候，我改变了对composer的看法，他安装的东西更类似于代码，而不是软件，我们如果要在不同的项目中也使用这个插件，我们同样需要在另一个项目目录线面进行composer安装 介绍几个常用的函数 find() 12345678User::find(1)App\User &#123;#764 id: 1, name: &quot;cy&quot;, email: &quot;1967196626@qq.com&quot;, created_at: &quot;2018-03-30 01:42:40&quot;, updated_at: &quot;2018-03-30 01:59:51&quot;, &#125; 这个1是主键 first() 12345678User::where(&apos;id&apos;, &apos;&gt;&apos;, 1)-&gt;first()App\User &#123;#771 id: 2, name: &quot;Bella Lebsack&quot;, email: &quot;cristobal58@example.net&quot;, created_at: &quot;2018-03-30 01:59:51&quot;, updated_at: &quot;2018-03-30 01:59:51&quot;, &#125; save() save 能新增用户，通过构建一个new 的User 对象(不需要设置model里面的fileable，create需要设置)，或者更新一个对象 12345678910$user = new User();$user-&gt;name=&apos;cyc&apos;;$user-&gt;email = &apos;199@qq.com&apos;;$user-&gt;notification_count = 0;$user-&gt;password = bcrypt(&apos;12345&apos;);$user-&gt;save();exit;$user = User::find(10);$user-&gt;name=&apos;cy&apos;;$user-&gt;save(); update()更新 12$user = User::find(10);$user-&gt;update([&apos;name&apos;=&gt;&apos;Aufree&apos;]) ​ ​ 上面两个获取的内容都是对象，可以直接使用 get() 获取的是一个collection 123456789101112 User::where(&apos;id&apos;, &apos;&gt;&apos;, 1)-&gt;where(&apos;id&apos;, &apos;&lt;&apos;, 3)-&gt;get()=&gt; Illuminate\Database\Eloquent\Collection &#123;#773 all: [ App\User &#123;#778 id: 2, name: &quot;Bella Lebsack&quot;, email: &quot;cristobal58@example.net&quot;, created_at: &quot;2018-03-30 01:59:51&quot;, updated_at: &quot;2018-03-30 01:59:51&quot;, &#125;, ], &#125; all() 获取的是一个collection ​all的使用好像不能加条件 ​上面的collection可以通过toArray() 方法转换成数组，但其实我们平时用的时候没用toArray也是可以的 上面需要注意的点就是： 所有的中间方法如 ‘where()’ ‘orderBy()’ 等都能够同时支持 ‘静态’ 和 ‘非静态链式’ 两种方式调用，即 ‘Article::where()…’ 和 ‘Article::….-&gt;where()’。 所有的 ‘非固定用法’ 的调用最后都需要一个操作来 ‘收尾’，本片教程中有两个 ‘收尾操作’：’-&gt;get()’ 和 ‘-&gt;first()’。 每一个继承了 Eloquent 的类都有两个 ‘固定用法’ ‘Article::find($number)’ ‘Article::all()’，前者会得到一个带有数据库中取出来值的对象，后者会得到一个包含整个数据库的对象合集。 Builder 1Article::where(&apos;id&apos;, &apos;&gt;&apos;, 10)-&gt;where(&apos;id&apos;, &apos;&lt;&apos;, 20)-&gt;orderBy(&apos;updated_at&apos;, &apos;desc&apos;)-&gt;get(); 这段代码的 ::where()-&gt;where()-&gt;orderBy() 就是Builder。用面向对象的方法来理解，可以总结成一句话：创建一个对象，并不断修改它的属性，最后用一个操作来触发数据库操作。 12User::orderBy(&apos;id&apos;, &apos;desc&apos;);=&gt; Illuminate\Database\Eloquent\Builder &#123;#817&#125; 这个get() 就是那个最后的方法。 值的思考的一个问题 如果直接用 :: 来访问某个 function，无论这个 function 是否为 static，构造函数 __construct() 都不会被调用，那么创建对象是如何实现的呢？请看：https://github.com/illuminate/database/blob/master/Eloquent/Model.php#L3354 所谓 “终结者” 方法，指的是在 N 个中间操作流方法对某个 Eloquent 对象进行加工以后，触发最终的数据库查询操作，得到返回值。 first() get() paginate() count() delete() 是用的比较多的一些 “终结者” 方法，他们会在中间操作流的最后出现，把 SQL 打给数据库，得到返回数据，经过加工返回一个 Article 对象或者一群 Article 对象的集合。 all() 方法好像不是，因为all() 好像不能跟着条件 12 User::orderBy(&apos;id&apos;, &apos;desc&apos;)-&gt;all();BadMethodCallException with message &apos;Call to undefined method Illuminate\Database\Query\Builder::all() 关系 1 对 1 关系 做了个试验，发现如果通过传统的生成迁移文件，生成model，进行数据填充真的挺麻烦的，不如在数据库中快速建表来的容易 123456789public function hasOne1() &#123; return $this-&gt;hasOne(TestOneToOne::class, &apos;user_id&apos;, &apos;id&apos;); &#125; public function belongsTo1() &#123; return $this-&gt;belongsTo(TestOneToOne::class, &apos;id&apos;, &apos;user_id&apos;); &#125; 这是User 中的两个方法 User::with(‘hasOne1’)-&gt;find(1) User::with(‘belongsTo1’)-&gt;find(1) 获取的数据是一样的，说一下我的记忆方法。hasOne 的时候，对方表中的字段在前面，belongsTo的时候自己表中的数据在前面。（我一般喜欢用with表示模型的结合） 还有第一个参数注意一下，话说这个::class出现好久了，而我却很少用，真的很方便哦。 还有默认的orm模型名称都是表名的单数，这个是一定要注意的哦。除非自己重新定义。（many 都能识别成功manies,牛逼） 1对多 这个时候的belongsTo 只有一种了，和上面的一样，hasMany() 和上面也类似。值的注意的一点就是那个表::with就成主体了，还有一点的就是使用with的时候并不是和我们传统的那种使用left join，而是先计算出主表，再根据主表中的数据，就算从表中对应数据in() 这个集合中，我不能理解的一点就是这样通过in，怎么完成了数据的连接。 多对多 这个时候经常需要第三张表来存储数据，值的注意的一点就是第三张表往往不需要生成model。 第三张表值记录对应关系，感觉默认的就是主键id 1234public function belongsToMany1() &#123; return $this-&gt;belongsToMany(\App\User::class, &apos;test_many_to_many&apos;, &apos;user_id&apos;, &apos;test_id&apos;); &#125; 上面是一种我的粉丝，比如我是users 表中的一员，我的粉丝也是这张表中的数据，注意存储数据关系的表不要用::class，因为不存在这个class，还有如果要加where条件，里面的条件用调用主题的字段，比如users中的字段id。]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
        <tag>orm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 数据填充]]></title>
    <url>%2F2018%2F03%2F30%2FLaravel-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85%2F</url>
    <content type="text"><![CDATA[作为一个phper，Laravel的学习是必不可少的，可是这个框架的学习成本还是挺大的，有些东西现在可能不明白，但至少记录下来，慢慢的成长。 在laravel的学习中，感觉挺好用的相比较于我们现在，数据填充是一个很不错的功能，能生成一大堆假的数据把页面填充起来，让他更有实际的样子。 数据填充，和数据库相关，自然去database下面。seeds目录，databaseseeder,这个文件主要是让我们在运行 1php artisan db:seed 的时候，执行哪些数据填充的文件，其参数可以让我们执行哪些填充文件 1234567public function run() &#123; // $this-&gt;call(UsersTableSeeder::class); Model::unguard(); $this-&gt;call(UsersTableSeeder::class); Model::reguard(); &#125; 上面就是基础的database seeder 里面的内容，前面两个主要是接触限制（官方叫批量赋值，就是默认model里面只有fileable的字段可以填充，为什么要规定这个呢 1234567891011public function create(Request $req)&#123; $this-validate($req, [ &apos;name&apos; =&gt; &apos;required|min:5&apos;, &apos;password&apos; =&gt; &apos;required|confirmed&apos; ··· ]) $name = $req-&gt;name; $password = $req-&gt;password; User::create(compact(&apos;name&apos;, &apos;password&apos;));&#125; 这样填充数据太麻烦了，比如我之前在itbasic上面填充数据，一个合同二十多个字段，这样往方法里面插入，一般这样 public function create(Request $req) { $this-validate($req, [ &apos;name&apos; =&gt; &apos;required|min:5&apos;, &apos;password&apos; =&gt; &apos;required|confirmed&apos; ··· ]) User::create($req-&gt;all()); } req的all方法获取的是一个关联数组，可是这样插入会导致一个问题，比如现在的表的字段的越来越规范了，比如admin字段 is_admin,这样当用户传入is_admin 1， 就完了，所以设置批量赋值，用来规定哪些字段可以传入，哪些字段不可以传入，filable 代表可以传入的，guard 代表这些不能传入。 当我们进行数据填充的时候，可能不需要字段限制，所以才会有了开始的解除限制和后面的开启限制。 接下来就是种子文件。 1php artisan make:seeder UsersTableSeeder 也是只有一个run方法，这个UsersTableSeeder,只是命名规范，其实并不用，因为我们在写run方法的时候，就是在写普通的插入语句 public function run() { DB::table(&apos;articles&apos;)-&gt;delete(); for ($i=0; $i &lt; 10; $i++) { \App\Article::create([ &apos;title&apos; =&gt; &apos;Title &apos;.$i, &apos;body&apos; =&gt; &apos;Body &apos;.$i, &apos;user_id&apos; =&gt; 1, ]); } } 这种方法就太没有意义了，因为我们可以通过写一个接口，来进行插入，我们希望的是更真实的数据，laravel中一般使用的用工厂模式生成批量化的对象，然后进行数据填充。 查看database 下面的factory文件夹， factory-&gt;define(App\User::class, function(Faker faker) { static $password; return [ &apos;name&apos; =&gt; $faker-&gt;name, &apos;email&apos; =&gt; $faker-&gt;unique()-&gt;safeEmail, &apos;password&apos; =&gt; $password ?: $password = bcrypt(&apos;secret&apos;), &apos;remember_token&apos; =&gt; str_random(10), ]; }); 这里面只是定一个一个model对象，然后在seeder里面批量化的生成这个对象 public function run() { // factory(App\User::class)-&gt;times(50)-&gt;create(); $user = App\User::find(1); $user-&gt;name = ‘cy’; $user-&gt;email = ‘1967196626@qq.com’; $user-&gt;password = bcrypt(‘123456’); $user-&gt;save(); }综上： 通过factory ，定义批量化的实例对象。 通过seeder 去实例化生成对象，然后插入数据库中。]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP闭包]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[咱是写PHP的，可是PHP的很多特性咱都不是很熟，比如trait，闭包，咱不能只局限于表单的操作，不能只局限于面向过程的写法，记录下来那些年很少接触的特性。就从PHP的 闭包 开始咯 1).闭包和匿名函数在PHP5.3中被引入。2).闭包是指在创建时封装函数周围状态的函数，即使闭包所在的环境不存在了，闭包封装的状态依然存在，这一点和Javascript的闭包特性很相似。3).匿名函数就是没有名称的函数，匿名函数可以赋值给变量，还可以像其他任何PHP对象一样传递。可以将匿名函数和闭包视作相同的概念。4).需要注意的是闭包使用的语法和普通函数相同，但是他其实是伪装成函数的对象，是Closure类的实例。闭包和字符串或整数一样，是一等值类型。 第一次接触闭包还是在js中，后来是在python中，最后才是php中！！!深刻的怀疑我是不是做php的。 js 中闭包 12345678910111213function out() &#123; var a = 1; var b = function(name) &#123; console.log(a); console.log(name) &#125; return b; &#125; var a = 2; var name = &apos;cy&apos;; var c= out(); c(name); // 输出 1， cy 上面这段代码虽然简单，但是包含了几个重要的知识点： js的闭包主要是靠两层函数的嵌套，然后通过调用外层的函数返回内层的函数，内层的函数可以调用外层函数中的变量，内层函数的执行可以通过后来调用的时候传入参数。 php 中匿名函数和闭包是同一个意思，所以下面过程中说到php匿名函数可以自动脑补成闭包，或者说到php闭包可以自动替换成匿名函数。 我觉得之所以php中匿名函数等同于闭包，是因为php中匿名函数完全符合闭包的定义，php中的匿名函数默认都是预定义接口closure 的一个实例，闭包本身是保存运行状态，他默认保存的是对象是预定义closure, 然后其他变量通过use 引入!!!这点很关键，看下面php 和 js 的代码，来看看php匿名(闭包)和js匿名函数(非闭包)，体会下区别 12345678910111213141516php&lt;?php$a = 1;$b = function () use ($a) &#123; var_dump($a);&#125;;$a = 2;$b(); // 1jsvar a = 1;var b = function () &#123; console.log(a);&#125;;var a = 2;b(); // 2 use 关键字让php匿名函数保存了当时变量状态，但是js的匿名函数却不行 相较于js 的闭包对象不可控，总是变（es6中有语法可以绑定）,php中的bind和bindto 方法是真的很方便，可以把匿名函数绑定到任何对象上，bind 属于 closure的静态方法（匿名函数, 对象，类名）， bindto（对象，类名）不是。 1234php.netClosure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。需要注意的是，我们绑定之后会返回一个新的closure，新的closure才是绑定对象的 （之前不知道为啥要绑定类名，为的是让匿名函数中可以用$obj 类似在绑定类中使用，要不然只绑定对象的话，是不能调用protected 和 private 方法的，蛮好理解的） (如果匿名函数在类中定义，匿名函数中的$this 指代的就是这个类对象， 要是在类外面定义指代的就是closure对象，要是在匿名函数没有绑定对象（定义在类外面并且没有用bind绑定对象），匿名函数中就不能直接使用 \$this 了) (虽然php中匿名函数可以绑定对象，但是就算绑定了新对象，他还是closure 的实例，只是有些属性改变了，如果不相信，可以直接打印这个实例, 正因为还是closure 实例，我们仍然可以给这个闭包绑定新的对象) 说了这么多，看一下实际代码中的闭包 12345678910111213141516class Foo&#123; public function __call($method, $args) &#123; var_dump(111); // else throw exception &#125; &#125;$obj = new Foo(&apos;Sam&apos;);$obj-&gt;say = function () &#123; return &apos;Hello World&apos;;&#125;;echo($obj-&gt;say()); // 111 ，触发 Foo __callecho(($obj-&gt;say)()); // Hello World, 触发 closure __invoke 分析一下执行过程：当执行的say() 方法不存在的时候会自动执行 $obj所在类 的__call魔术方法，然后method 传入是字符串’say’，这里面args 因为是空(say())，所以自动传入为空。输出 111 当执行(\$obj-&gt;say)(), 并没有触发\$obj 所在类的方法，而是触发closure类的方法 php中匿名函数保存的变量能直接执行都是因为一个魔术方法__invoke, 这个魔术方法是在把类实例当做方法调用的时候会自动触发，因为php的匿名函数本质上都是closure类的实例（这个closure类中有四个方法 __invoke _construct static bind bindTo）,所以当我们 var(), 这样的时候，自动触发closure 的 \_invoke，(猜测这个__invoke 的作用就执行后面的匿名函数)所以匿名函数就被执行了。 12345678910111213141516171819class Foo&#123; private $name; function __construct($name) &#123; $this-&gt;name = $name; &#125;&#125;$obj = new Foo(&apos;Sam&apos;);$cl = function() &#123; return &quot;Hello &quot; . $this-&gt;name;&#125;;$cl = $cl-&gt;bindTo($obj, $obj); //第二个$obj 感觉类名好点，这个实例的话也是通过反射获取类名的吧echo($cl()); 下面这段台湾大佬的话感觉就是说明了一个意思，bindto的第二个参数或者bind的第三个参数是让代码的执行类似在绑定的类中,第二个参数就是扩大第一个参数的类的使用权限问题。但仅仅在于扩大原始的不能访问的protected和private，并不扩大注入对象没有关系的或者说注入对象所在类不能访问到的变量。 我們不再執著該closure一定要動態成為 $obj的method，但要存取$obj property的目標不變，程式也不變，一樣使用$this。假如我們能將$obj以手動注入的方式，讓closure內部的$this改指向$obj，我們就能達到如JavaScript的效果了。$cl = $cl-&gt;bindTo($obj, $obj);bindTo()如同__invoke()一樣，是closure物件內建的method，它的目的就是讓我們能手動注入一個物件，讓closure物件的$this指向手動注入的物件$obj。因為在closure中我們有$this-&gt;name，經過bindTo()去手動注入 $obj後，$this已經改指向$obj，所以$this-&gt;name就相當於$obj-&gt;name。根據bindTo()文件 :若要讓closure物件只能存取其他物件的public變數，只傳第1個參數即可。若要讓closure物件存取其他物件的private或protected變數，就要傳第2個參數。bindTo()對於第2個參數的要求不嚴，有幾種傳法 :傳進欲存取物件的class名稱，是字串。傳進欲存取的物件也可以，bindTo()會自動得知該物件的class名稱。在此就一併傳進與第一個參數相同的$obj。echo($cl());因為$obj已經透過bindTo() 手動注入進$cl()，此時$this已經指向$obj，所以執行$cl()就可順利存$obj的property bindto 实例代码 接下来我们来看看bindTo方法，通过该方法，我们可以把闭包的内部状态绑定到其他对象上。这里bindTo方法的第二个参数显得尤为重要，其作用是指定绑定闭包的那个对象所属的PHP类，这样，闭包就可以在其他地方访问绑定闭包的对象中受保护和私有的成员变量。你会发现，PHP框架经常使用bindTo方法把路由URL映射到匿名回调函数上，框架会把匿名回调函数绑定到应用对象上，这样在匿名函数中就可以使用$this关键字引用重要的应用对象：class App { protected $routes = []; protected $responseStatus = ‘200 OK’; protected $responseContentType = ‘text/html’; protected $responseBody = ‘Hello World’; public function addRoute($path, $callback) { $this-&gt;routes[$path] = $callback-&gt;bindTo($this, __CLASS__); } public function dispatch($path) { foreach ($this-&gt;routes as $routePath =&gt; $callback) { if( $routePath === $path) { $callback(); } } header(&apos;HTTP/1.1 &apos; . $this-&gt;responseStatus); header(&apos;Content-Type: &apos; . $this-&gt;responseContentType); header(&apos;Content-Length: &apos; . mb_strlen($this-&gt;responseBody)); echo $this-&gt;responseBody; } }这里我们需要重点关注addRoute方法，这个方法的参数分别是一个路由路径和一个路由回调，dispatch方法的参数是当前HTTP请求的路径，它会调用匹配的路由回调。第9行是重点所在，我们将路由回调绑定到了当前的App实例上。这么做能够在回调函数中处理App实例的状态：123456$app = new App();$app-&gt;addRoute(‘/user’, function()&#123; $this-&gt;responseContentType = ‘application/json;charset=utf8’; $this-&gt;responseBody = &apos;世界你好&apos;;&#125;);$app-&gt;dispatch(&apos;/user&apos;) Laravel中对闭包的使用IoC 容器匿名函数可以从父作用域继承变量，而这个父作用域是定义该闭包的函数（不一定是调用它的函数）。利用这个特性，我们可以实现一个简单的控制反转IoC容器：12345678910111213141516171819202122232425262728293031323334353637383940414243class Container&#123; protected static $bindings; public static function bind($abstract, Closure $concrete) &#123; static::$bindings[$abstract] = $concrete; //如果还需要container自身的一些方法的话 //可以这么写： static::$bindings[$abstract] = $concrete-&gt;bindto($this, $this); &#125; public static function make($abstract) &#123; return call_user_func(static::$bindings[$abstract]); &#125;&#125; class talk&#123; public function greet($target) &#123; echo &apos;Hello &apos; . $target-&gt;getName(); &#125;&#125;class A&#123; public function getName() &#123; return &apos;World&apos;; &#125;&#125; // 创建一个talk类的实例$talk = new talk(); // 将A类绑定至容器，命名为fooContainer::bind(&apos;foo&apos;, function() &#123; return new A;&#125;); // 通过容器取出实例$talk-&gt;greet(Container::make(&apos;foo&apos;)); // Hello World 上述例子中，其实并不是很能说明bindTo的特性，为什么呢，分析一下执行流程（分析这个例子主要是因为当时不太懂闭包的时候网上找的）： 首先是把一个匿名函数绑定到一个类的属性中，然后获取这个属性的时候直接调用匿名函数，因为上面的匿名函数就是获取一个类的实例，根本用不到 this 相关的东西，所以和给这个closure 绑定对象毫无关系 上面的写法其实转换一下就和下面一样 1234567891011121314151617181920212223242526&lt;?phpclass A &#123; public function getName() &#123; return &apos;cy&apos;; &#125;&#125;$app = [];$app[&apos;foo&apos;] = function () &#123; return new A();&#125;;class Talk&#123; public function talk1 ($obj) &#123; var_dump(&apos;hello &apos;. $obj-&gt;getName()); &#125;&#125;$t = new Talk();var_dump($t-&gt;talk1(($app[&apos;foo&apos;])()));exit; 今天说一下对于闭包的重新认识： 首先是array_map里面的内容。array_map 用到了闭包的知识，函数作用：通过对传入的数组进行自定义的函数处理，传入的数组多少个，自定义的函数接受的参数就要多少个 1234&lt;?phparray_map(function($i, $z) &#123; var_dump($i+$z);&#125;, [1,2,3], [2,3,4]); 但如果我们想传入额外的参数呢 12345&lt;?php$z = 100;array_map(function($i, $z) use ($z) &#123; var_dump($i+$z);&#125;, [1,2,3], [2,3,4]); 通过use 这和我之前看到的内容都是一致的，只是这次我希望不要把这个use和bindto绑定的参数作用弄混淆了，bindto的目的是修改closure类里面this对象. 对了php的闭包很类似于js的万物皆是对象的概念，function也是对象 对的php中的匿名函数，也就是闭包，他也是对象，他是closure类的实例 但和js不同之处，php的对象不能改变，所以匿名函数中的this指向的是closure这个实例（但是可以改变比包中this 的指向），这个实例除了——invoke和 bind（静态方法）bindto() 一无所有 但是我们可以通过bind，我的理解是让两个实例互相拥有对方的属性，其实不是 12345678910111213141516171819202122class Foo&#123; private $name; function __construct($name) &#123; $this-&gt;name = $name; &#125;&#125;$obj = new Foo(&apos;Sam&apos;);$cl = function() &#123; var_dump($this instanceof Closure); //false var_dump($this instanceof Foo); //true return &quot;Hello &quot; . $this-&gt;name;&#125;;$cl = $cl-&gt;bindTo($obj, $obj);echo($cl()); zzz,感觉绑定之后这个closure的实例就有了家的感觉，就变成了那个被绑定的类了（明明打印出来还是closure 类，但却是绑定的类的实例）。 额外说一点： 我们在使用闭包的时候，function(){}，这种只是定义了一个变量，并没有使用，我们想使用的话，比如function() {} (),这样，或者是 function(){} -&gt;__invoke(); 这个可以理解成 function(){} 是一个对象，当我们调用他的时候就自动触发了Closure类里面的__invoke方法，所以上述是等价的结果。(但感觉不要这样用吧，很少调用魔术方法) 正因为匿名函数定义的时候没有调用，总是在需要的时候调用，所以容易造成异步的假象 关于匿名函数的应用： 匿名函数在laravel 中或者很多现代框架中大量使用，我们千万要注意， 我们在写匿名函数的时候，只是在定义这个函数，实际调用是框架自身决定的，所以我们在匿名函数function() 中传入的参数是由框架执行的时候决定的，我们可以不传，没关系，因为php 可以在函数定义的时候没有参数，执行的时候有参数也不会报错，但是我们要是传了参数，就会和框架中执行的时候传入的参数对应上，也就是预定义参数，一般情况框架使用文档上都会有，拿laravel路由举例 （特别注意，但是我们不能执行的时候没有穿, 定义的时候却有，除非是可变参数，否则都不可以） 12345678910111213141516171819202122232425// 下面4种定义匿名函数都没有关系// 对于传入额外参数我是这样猜测的，获取非匿名函数定义的参数，和预定义参数合并，然后去执行$route-&gt;get(&apos;/&#123;id&#125;&apos;, function($id) &#123; var_dump($id);&#125;);$route-&gt;get(&apos;/&#123;id&#125;&apos;, function() &#123; &#125;);$route-&gt;get(&apos;/&#123;id&#125;&apos;, &apos;TestController@index&apos;)class TestController &#123; public function index(class1 $a, class2 $b, $id) &#123; &#125; 或者 public function index(class1 $a, class2 $b) &#123; &#125; 或者 public function index(class1 $a, class2 $b, $name) &#123; // 这里面的$name 等值于 $id&#125; &#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>匿名函数</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP魔术方法和魔术变量]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%92%8C%E9%AD%94%E6%9C%AF%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[有些东西如果不是经常使用，很容易忘记，比如魔术方法和魔术常量。最主要是当看一些基本原理的代码的时候经常用到，比如闭包的时候，希望自己在学习过程中能对文章中的内容进行补充，改造，而不是单纯的靠这些简单例子来记忆&gt; 魔术方法(Magic methods)PHP中把以两个下划线__开头的方法称为魔术方法，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct()，类的构造函数 __destruct()，类的析构函数 __call()，在对象中调用一个不可访问方法时调用 __callStatic()，用静态方式中调用一个不可访问方法时调用 __get()，获得一个类的成员变量时调用 __set()，设置一个类的成员变量时调用 __isset()，当对不可访问属性调用isset()或empty()时调用 __unset()，当对不可访问属性调用unset()时被调用。 __sleep()，执行serialize()时，先会调用这个函数 __wakeup()，执行unserialize()时，先会调用这个函数 __toString()，类被当成字符串时的回应方法 __invoke()，调用函数的方式调用一个对象时的回应方法 __set_state()，调用var_export()导出类时，此静态方法会被调用。 __clone()，当对象复制完成时调用 __construct()和__destruct()构造函数和析构函数应该不陌生，他们在对象创建和消亡时被调用。例如我们需要打开一个文件，在对象创建时打开，对象消亡时关闭 1234567891011121314&lt;?php class FileRead&#123; protected $handle = NULL; function __construct()&#123; $this-&gt;handle = fopen(...); &#125; function __destruct()&#123; fclose($this-&gt;handle); &#125;&#125;?&gt; 这两个方法在继承时可以扩展，例如： 123456789101112&lt;?php class TmpFileRead extends FileRead&#123; function __construct()&#123; parent::__construct(); &#125; function __destruct()&#123; parent::__destruct(); &#125;&#125;?&gt; __call()和__callStatic()在对象中调用一个不可访问方法时会调用这两个方法，后者为静态方法。这两个方法我们在可变方法（Variable functions）调用中可能会用到。这个方法和is_callable经常配合调用，注意是callable，不是callback， 不是回调。callback 回调更多的可以理解成一种使用方式，而匿名函数则是用来满足这种使用方式的一种途径，还有别的方式能满足callback,比如直接定义一个函数，传入函数的名称（字符串，如果是匿名函数的话，要把这个匿名函数对应的变量传进去，二者还是有些不同的），只是这种方式使用起来比较麻烦，比较少而已 12345678910111213141516&lt;?phpclass MethodTest &#123; public function __call ($name, $arguments) &#123; echo &quot;Calling object method &apos;$name&apos; &quot;. implode(&apos;, &apos;, $arguments). &quot;\n&quot;; &#125; public static function __callStatic ($name, $arguments) &#123; echo &quot;Calling static method &apos;$name&apos; &quot;. implode(&apos;, &apos;, $arguments). &quot;\n&quot;; &#125;&#125;$obj = new MethodTest;$obj-&gt;runTest(&apos;in object context&apos;);MethodTest::runTest(&apos;in static context&apos;);?&gt; __get()，__set()，__isset()和__unset()当get/set一个类的成员变量时调用这两个函数。例如我们将对象变量保存在另外一个数组中，而不是对象本身的成员变量var_dump($this-&gt;aa)$this-&gt;aa = ‘pp’isset($this-&gt;aa)empty($this-&gt;aa)值的注意的是 isset 和 empty 触发的魔术方法好像只能返回true和false123456789101112131415161718192021222324&lt;?php class MethodTest&#123; private $data = array(); public function __set($name, $value)&#123; $this-&gt;data[$name] = $value; &#125; public function __get($name)&#123; if(array_key_exists($name, $this-&gt;data)) return $this-&gt;data[$name]; return NULL; &#125; public function __isset($name)&#123; return isset($this-&gt;data[$name]) &#125; public function unset($name)&#123; unset($this-&gt;data[$name]); &#125;&#125;?&gt; __sleep()和__wakeup()当我们在执行serialize()和unserialize()时，会先调用这两个函数。例如我们在序列化一个对象时，这个对象有一个数据库链接，想要在反序列化中恢复链接状态，则可以通过重构这两个函数来实现链接的恢复。（还没有用到过）例子如下： 1234567891011121314151617181920212223242526272829303132&lt;?phpclass Connection &#123; protected $link; private $server, $username, $password, $db; public function __construct($server, $username, $password, $db) &#123; $this-&gt;server = $server; $this-&gt;username = $username; $this-&gt;password = $password; $this-&gt;db = $db; $this-&gt;connect(); &#125; private function connect() &#123; $this-&gt;link = mysql_connect($this-&gt;server, $this-&gt;username, $this-&gt;password); mysql_select_db($this-&gt;db, $this-&gt;link); &#125; public function __sleep() &#123; return array(&apos;server&apos;, &apos;username&apos;, &apos;password&apos;, &apos;db&apos;); &#125; public function __wakeup() &#123; $this-&gt;connect(); &#125;&#125;?&gt; __toString()对象当成字符串时的回应方法。例如使用echo $obj;来输出一个对象 123456789101112&lt;?php// Declare a simple classclass TestClass&#123; public function __toString() &#123; return &apos;this is a object&apos;; &#125;&#125;$class = new TestClass();echo $class;?&gt; 这个方法只能返回字符串，而且不可以在这个方法中抛出异常，否则会出现致命错误。 __invoke()调用函数的方式调用一个对象时的回应方法。如下 12345678910&lt;?phpclass CallableClass &#123; function __invoke() &#123; echo &apos;this is a object&apos;; &#125;&#125;$obj = new CallableClass;var_dump(is_callable($obj));?&gt; __set_state()调用var_export()导出类时，此静态方法会被调用。注意var_dump很强大，直接输出了，并不会触发。 12345678910111213141516171819&lt;?phpclass A&#123; public $var1; public $var2; public static function __set_state ($an_array) &#123; $obj = new A; $obj-&gt;var1 = $an_array[&apos;var1&apos;]; $obj-&gt;var2 = $an_array[&apos;var2&apos;]; return $obj; &#125;&#125;$a = new A;$a-&gt;var1 = 5;$a-&gt;var2 = &apos;foo&apos;;var_dump(var_export($a));?&gt; __clone()当对象复制完成时调用。例如在设计模式详解及PHP实现：单例模式一文中提到的单例模式实现方式，利用这个函数来防止对象被克隆。 1234567891011121314151617181920&lt;?php public class Singleton &#123; private static $_instance = NULL; // 私有构造方法 private function __construct() &#123;&#125; public static function getInstance() &#123; if (is_null(self::$_instance)) &#123; self::$_instance = new Singleton(); &#125; return self::$_instance; &#125; // 防止克隆实例 public function __clone()&#123; die(&apos;Clone is not allowed.&apos; . E_USER_ERROR); &#125;&#125;?&gt; 魔术常量(Magic constants)PHP中的常量大部分都是不变的，但是有8个常量会随着他们所在代码位置的变化而变化，这8个常量被称为魔术常量。 __LINE__，文件中的当前行号 __FILE__，文件的完整路径和文件名 __DIR__，文件所在的目录 __FUNCTION__，函数名称 __CLASS__，类的名称 __TRAIT__，Trait的名字 __METHOD__，类的方法名 __NAMESPACE__，当前命名空间的名称 这些魔术常量常常被用于获得当前环境信息或者记录日志。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP函数]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[工作的久了，反而基本功没有原先好了，也许要记得东西很多，内存中不够放置那些无规律的参数位置，但至少不要混淆哪些是框架自带的，哪些是PHP原生的。 String str_repeat（’cy’, 10） //把cy这个字符串重复10次 12var_dump(str_repeat（&apos;cy&apos;, 10）) //注意一定要打印，这个函数的作用只是构成一个字符串string(20) &quot;cycycycycycycycycycy&quot; var_dump 和 var_exportvar_dump 经常用在我们调试的时候，可以打印出参数类型var_export 不能输出参数类型，比如 [‘a’ =&gt; 1], 只能输出这个数组，不能支出 1 是 intvar_export 第二个参数给true, 他会把这个变量的值存储起来，可以用于赋值，相当于 printf 和 sprintf ， sprintf 会把变量格式化之后保存起来，而不会输出 但是当变量是resource的时候，返回的总是null,但是此时var_dump 虽然也不能打印出来，但是能 123resource(2) of type (stream) NULL$a = var_export([2,3], true); strtr 经常用在简单替换 (两种用法，是真的很方便) 123var_dump(strtr(&apos;&#123;userna&#123;me&#125;&apos;, &apos;&#123;&apos;, &apos;A&apos;));string(11) &quot;AusernaAme&#125;&quot; 123var_dump(strtr(&apos;&#123;username&#125; age&apos;, [&apos;username&apos; =&gt; &apos;cy&apos;, &apos;age&apos; =&gt; 18]));string(7) &quot;&#123;cy&#125; 18&quot; compact (把两个变量组装成数组) 12345678910$a = 5;$b = 6;var_dump(compact(&apos;a&apos;, &apos;b));array(2) &#123; [&quot;a&quot;]=&gt; int(5) [&quot;b&quot;]=&gt; int(6)&#125; ​ func_get_args ( 调用这个方法传入的参数) 1234567// 这个获取的是你实际传入的参数，和函数定义时候的参数没有什么关系test(&apos;www&apos;, &apos;ww&apos;);function test()&#123; var_dump(func_get_args()); // www ww&#125; ​ floor 1234&lt;?phpecho floor(4.3); // 4echo floor(9.999); // 9echo floor(-3.14); // -4 glob (返回一个包含有匹配文件／目录的数组。如果出错返回 FALSE。) 1234567&lt;?phpforeach (glob(&quot;*.txt&quot;) as $filename) &#123; echo &quot;$filename size &quot; . filesize($filename) . &quot;\n&quot;;&#125;funclist.txt size 44686funcsummary.txt size 267625quickref.txt size 137820 DIRECTORY_SEPARATOR, 经常用在代码中分隔符的获取 rename （重命名文件） basename （文件自身的名称） dirname (上一层文件夹的名称) ​ Array array_fill (生成某种类型数组) 123456789101112var_dump(array_fill(0, 4, &apos;ss&apos;));array(4) &#123; [0]=&gt; string(2) &quot;ss&quot; [1]=&gt; string(2) &quot;ss&quot; [2]=&gt; string(2) &quot;ss&quot; [3]=&gt; string(2) &quot;ss&quot;&#125; ​ 面向对象 is_callable()与method_exists() //method_exists 只能判断方法是否存在，但如果比如父类的方法是protected这种，没权利执行也会返回true，这种情况就得callable了，他会返回false12345678910111213141516171819202122232425&lt;?phpclass Foo &#123; public function PublicMethod()&#123;&#125; private function PrivateMethod()&#123;&#125; public static function PublicStaticMethod()&#123;&#125; private static function PrivateStaticMethod()&#123;&#125;&#125;$foo = new Foo();$callbacks = array( array($foo, &apos;PublicMethod&apos;), array($foo, &apos;PrivateMethod&apos;), array($foo, &apos;PublicStaticMethod&apos;), array($foo, &apos;PrivateStaticMethod&apos;), array(&apos;Foo&apos;, &apos;PublicMethod&apos;), array(&apos;Foo&apos;, &apos;PrivateMethod&apos;), array(&apos;Foo&apos;, &apos;PublicStaticMethod&apos;), array(&apos;Foo&apos;, &apos;PrivateStaticMethod&apos;), );foreach ($callbacks as $callback)&#123; var_dump($callback); var_dump(method_exists($callback[0], $callback[1])); var_dump(is_callable($callback)); echo str_repeat(&apos;-&apos;, 10); echo &apos;&lt;br /&gt;&apos;;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP知识点]]></title>
    <url>%2F2018%2F03%2F26%2FPHP%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[PHP中很多稍微高级的知识点自己都不是很熟悉，trait, 闭包，又或者composer等， 记录下来，成为现代phper。 PHP中闭包 PHP 时间处理(DateTime) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 打印当前时间$a = new DateTime();echo $a-&gt;format(&apos;Y-m-d H:i:s&apos;);// 打印特定的时间（接受一个特定的时间，反应出周边信息，感觉通过DateTime 这个类就能获取一个时间点的所有资源）$a = new DateTime(&apos;2019-02-21&apos;);echo $a-&gt;format(&apos;U&apos;); // 转换成一个unix 时间戳$a = new DateTime(&apos;tomorrow&apos;); // strtotime 的所有功能都能实现(既能接受日期，也能接受string)echo $a-&gt;format(&apos;Y-m-d&apos;)$a = new DateTime(&apos;+2 days&apos;)echo $a-&gt;format(&apos;Y-m-d H:i:s&apos;)// 还可以在获取到一个事件之后进行时间的修改$a = new DateTime();$a-&gt;modify(&apos;+1 day&apos;)echo $a-&gt;format(&apos;Y-m-d&apos;)$a-&gt;setDate(2018,1,19)echo $a-&gt;format(&apos;Y-m-d&apos;)$a-&gt;setTime(9,9,9);echo $a-&gt;format(&apos;Y-m-d&apos;)// 转换时间戳$date = new DateTime(&apos;@1408950651&apos;);$date-&gt;setTimezone(new DateTimeZone(&apos;Asia/Shanghai&apos;)); // 这个时区很重要，影响转换的内容echo $date-&gt;format(&apos;Y-m-d H:i:s&apos;);echo &quot;\n&quot;;// 比较日期差额$date1 = new DateTime();$date2 = new DateTime(&apos;2014-09-15&apos;);$diff = $date1-&gt;diff($date2);echo $diff-&gt;format(&quot;The future will come in %Y years %m months and %d days&quot;);// 比较日期大小$date1 = new DateTime();$date2 = new DateTime(&apos;2014-09-15&apos;);if($date1 &lt; $date2) &#123; echo $date2-&gt;format(&apos;Y-m-d H:i:s&apos;) . &apos; is in the future&apos;;&#125;总结对比：这个new DateTime() 能接受的参数有很多，很方便$a = new DateTime(&apos;2019-2-21&apos;); // 在这之前想实例化任意一天需要 strtotime(),普通的date(&apos;Y-m-d&apos;, time()), 后面的参数默认是当前时间戳，time() 获取的也是当前时间戳，不能根据自定义获取时间戳echo $a-&gt;format(&apos;Y-m-d&apos;); // 格式化时间echo $a-&gt;format(&apos;Y-m-t&apos;); // 某个月结束日期，开始日期直接 —01-01 ​ todo: 时间戳转换，格式化日期，当前时间，修改当前日期，每个月结尾（30号还是31号），循环每周四，时间前后比较， PHP7 新特性的使用 12345678910$a = $a ?? 9;$a = isset($a) ? $a : 9;// 上面的三元表达式在变量的判断中使用的还是比较少的，更多的是用在判断数组的key 是否存在，因为如果不存在的话是可以直接使用的，但是会给warning,这样也是不好的$a = $a ?: 9;if ($a) &#123; $a = $a;&#125; else &#123; $a = 9;&#125;// 这个是很久就出来的写法，三元表达式的简写 PHP 数组操作 array_slice() 截取数组，对于关联数组和索引数组都能截取，因为关联数组没有顺序，所以array_pop 那些数组头部尾部的操作不能生效，这时候array_slice 就有用了，比如获取排行榜前5位 PHP 常用函数 sprintf(‘%02d’, 9) 对于 1 显示成01 这样很方便 number_formate() 1234.45 显示成 1,234.45 很方便 感觉除了foreach 外，while 比for 好用 123456789101112$month = 5;$num = 5;$res[$month] = $num;$tmpM = $month;while ($tmpM - 1 &gt; 0) &#123; $join = 2; $quit = 1; $num = $num - $join + $quit; $tmpM = $tmpM - 1; $res[$tmpM] = $num; &#125;var_dump($res);exit; // 虽然tmpM 也可以设置成临界变量 continue 调出本次循环， foreach 继续； break 跳出(终止)整个foreach 循环 ​]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hi , swoole]]></title>
    <url>%2F2018%2F03%2F23%2Fhi-swoole%2F</url>
    <content type="text"><![CDATA[学习目的：想让自己从增删改查，做web，表单的生活中调出来。 swoole的安装 swoole作为PHP的一个扩展，用c语言开发，在使用他之前我们当然需要有php的基础环境。这里我们并不需要传统的lamp或者lnmp的架构，仅仅只要安装好php就行了。网上都说php最好编译安装，虽然我倒现在还不知道编译安装的好处，我看慕课上的那个教程也仅仅只是指定了php的安装文件夹。首先要搭建我们的虚拟环境，强烈推荐vagrant，真的很方便，虽然他把镜像都放在了c盘，我也懒得改了，但其实自己平时练习的话一个镜像就够了，剩下的只要操作这个镜像就好了，我用的centos7。安装好vagrant和vitrual box后去网上找镜像吧，http://www.vagrantbox.es/,挺快的，详细说明也有，我是先用迅雷下载到本地，然后再添加的。123vagrant box add centos7 d:/centos7.box //把这个box文件装到系统中，之后这个box文件可以直接删除vagrant box list //查看系统中是否有这个box文件的镜像vagrant box remove centos7 //如果这个镜像没用了，可以直接移除，节约c盘空间 加入镜像后，就是去一个文件夹装载你的虚拟环境，他的底层是操作virtual box嘛，我的感觉就是和vitrual box那样找个文件夹存储这个虚拟环境。1234567d:cd virtual //这是我平时虚拟环境统一放置的目录mkdir centos7 //为了区别开，这是我这次试验放置的目录，centos7代表镜像的名称cd centos7vagrant init centos7 //初始化虚拟环境，后面这个是上面添加进系统的镜像名称（这时候文件夹会生成vagrant的虚拟环境）修改vagrant file //配置共享文件夹，开启ip地址vagrant up //启动虚拟机（会重启加载上面配置文件的内容） 几个命令很长时间使用哦12345vagrant halt //关闭虚拟机vagrant suspend //挂起虚拟机vagrant resume //唤醒虚拟机，对应上面的挂起，这样就不用每次启动了，就和linux永不关机都可以一样vagrant destroy //摧毁虚拟机，没用的即使删除，虽然感觉也不占多大地方vagrant reload //这个我用的不多，主要是不记得他是否会重新加载配置文件了 上面的一些坑就是： 把镜像纳入系统的时候，默认会放在c盘，virtual box 也有些文件放在c盘，导致c盘越来越小。 加入镜像的时候，镜像的名称最好取得有点意义，比如ubuntu1604 这种，以后用起来的时候方便，时间长了，自己都忘记了。 不要用ubuntu16.04这种，之前用过这种，虽然添加镜像的时候没有啥问题，但是后面启动虚拟机的时候会报错。 挂载文件夹的问题。之前下载了ubuntu的box文件和centos56 的box文件，ubuntu能挂载上，centos挂载不上，网上说是vitrualbox的原因，可我都升级到2.0了都没法解决，仔细看了报错信息，说可能是这个box文件的问题。后来新下载了centos7的box文件，reslove。 1vagrant ssh //进入虚拟机，注意要在上面建立的装载虚拟环境的文件夹下使用 上面就是基础环境的搭建，可以理解成系统的搭建，剩下的就要我们去虚拟机中进行处理了。 首先是php的编译安装这篇文章里面写的很清楚，源码是我去php.net上面下载的。然后去swoole.php上面下载swoole的源码。phpize,这是php源码编译后的一个命令，按照上面那篇博客应该是在/usr/loca/php7/bin 下面，这是因为swoole的源码包下面没有configure文件，产生后./configure,可能会报找不到php-configure,注意这里面不是php 的配置文件，而是php7那个文件夹bin命令下面有个php-configure，直接写这个地址就可以了。 遇到的坑。编译出错，直接执行make，显示找不到configure文件，··其实./configure那时候就报错了，我不知道，直接执行make，然后显示找不到目标，注意一下报错信息，其实这些编译的时候都没什么错误，或者把错误信息粘贴去百度google，很容出来。注意要在php.ini 里面开启扩展 extension=swoole因为我们这没有lamp环境嘛，不要想着在页面访问phpinfo,直接php -m,查看加载的扩展。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>swoole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己的http记录]]></title>
    <url>%2F2018%2F03%2F07%2F%E8%87%AA%E5%B7%B1%E7%9A%84http%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[上周老师让我们写一个关于http的总结，记录下这些天来的自己关于http的认识。 1.http请求动作 移动互联网时代，不像之前web时代，实现了前后端的分离，前端请求后端接口从之前基于soap变成调用基于rest的restul api接口，restful api是基于资源，他对于不同的http请求方式有不同的含义，最常见的get，post，put，delete, option,。传统的get和post区别主要是一个是url明文传递，另一个是加密后传递更安全。但是restful api中常见的4中请求动作分别代表一下含义get ： 对于资源的请求post ： 对于资源的创建put ： 对于资源的更新delete ： 对于资源的删除例如 : get /users/1 代表获取用户1的信息post /users/1 创建put /users/1 更新delete /users/1 删除这样的好处之一就是更有利于语义化，而且更能指定统一的标准, 比如laravel里面Route的resource方法就能根据资源users统一生成一堆的url，而不是通过不同的方法名来区分。但比如传统表单提交只能实现get 和 post方式，如果我们直接修改提交方式会报错 1&lt;form action=&quot;/posts/62&quot; method=&quot;POST&quot;&gt; 我们只需要在里面增加一个隐藏的input1&lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;PUT&quot;&gt; 就可以改变原先的form表单提交方式了 2.content-type的作用 对于接口返回数据的处理 以python flask为例 12345678910from flask import Flask, make_responseapp = Flask(__name__)@app.route(&apos;/hello&apos;)def hello(): response = make_response(&apos;&lt;html&gt;&lt;/html&gt;&apos;) return responseapp.run(host=&apos;0.0.0.0&apos;, debug=True) 默认浏览器是按照html的格式解析的，上面当我们访问/hello的时候输出是空，因为html标签里面什么也没有 1234567891011app = Flask(__name__)@app.route(&apos;/hello&apos;)def hello(): headers = &#123; &apos;content-type&apos;:&apos;text/plain&apos;, &#125; response = make_response(&apos;&lt;html&gt;&lt;/html&gt;&apos;) return responseapp.run(host=&apos;0.0.0.0&apos;, debug=True) 但这样就能输出 1&lt;html&gt;&lt;/html&gt; 因为我们让浏览器按照字符串的形式来解析 itbasic中也对header信息做了设置 123$response-&gt;header(&apos;Content-Type&apos;, &apos;text/json&apos;); $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); return json_encode($res); 这就是为什么我们每次调用接口的时候返回的都是json数据的原因 但是当我们输出模板的时候，观察控制台返回的 1Content-Type: text/html; charset=UTF-8 应该是模板在哪里进行了处理 常见的输出图片 content-type 属于返回内容的一部分，主要是用来告诉浏览器返回的数据应该怎么解析，比如你访问 homestead.app/1.jpg,并不是根据文件的后缀名解析的成相应的文件，而是根据resresponse headers里面的内容，常见的mini type。例如php输出一张图片 1234&lt;?php$fileres = file_get_contents(&apos;./1.jpg&apos;);header(&apos;Content-type: image/jpeg&apos;);echo $fileres; 不使用插件导出excel文件 其实这个作用还是挺大的，比如我们经常输出的excel，虽然php有个很强大的插件phpexcel，但是那种东西经常就内存溢出了，我们可以通过修改header，直接输出csv文件，而不用使用任何插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 导出excel(csv) * @data 导出数据 * @headlist 第一行,列名 * @fileName 输出Excel文件名 */function csv_export($data = array(), $headlist = array(), $fileName) &#123; header(&apos;Content-Type: application/vnd.ms-excel&apos;); header(&apos;Content-Disposition: attachment;filename=&quot;&apos;.$fileName.&apos;.csv&quot;&apos;); header(&apos;Cache-Control: max-age=0&apos;); //打开PHP文件句柄,php://output 表示直接输出到浏览器 $fp = fopen(&apos;php://output&apos;, &apos;a&apos;); //输出Excel列名信息 foreach ($headlist as $key =&gt; $value) &#123; //CSV的Excel支持GBK编码，一定要转换，否则乱码 $headlist[$key] = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $value); &#125; //将数据通过fputcsv写到文件句柄 fputcsv($fp, $headlist); //计数器 $num = 0; //每隔$limit行，刷新一下输出buffer，不要太大，也不要太小 $limit = 100000; //逐行取出数据，不浪费内存 $count = count($data); for ($i = 0; $i &lt; $count; $i++) &#123; $num++; //刷新一下输出buffer，防止由于数据过多造成问题 if ($limit == $num) &#123; ob_flush(); flush(); $num = 0; &#125; $row = $data[$i]; foreach ($row as $key =&gt; $value) &#123; $row[$key] = iconv(&apos;utf-8&apos;, &apos;gbk&apos;, $value); &#125; fputcsv($fp, $row); &#125; &#125; 文件的上传 之前在调用datrix的上传接口的时候，他要求传过来的数据文件得是form表单的g格式，可以通过 1var writeData = new FormData(); 3.http是无状态的协议（cookie 和 session）无状态的协议代表我们在登录网站后，浏览器不知道我们在不同的网页间是同一个个体，这就得靠session和cookie了。session和cookie都能保存用户信息，只是一个存储在客户端，另一个存储在服务器端。存储在客户端就说明用户可以进行修改，不安全，所以一般开启session后，服务器返回给用户一个session id,下次用户登录的时候，拿着这个session id 去服务器端获取session文件。php里面默认的cookie 名字是PHPSESSID 里面装的是sessionid的内容(这个名字是可以改的，比如laravel框架里面默认的是laravalsession,这个也是可以通过配置文件改的)，只要拿着这个去服务器端sess + sessionid的内容（这个存储地址在php.ini里面有配置），就能找到对应的session，session里面的内容是序列化后的（如果客户端禁止了cookie，也可以把session id 放在url里面带过来）。默认这个session id的cookie是种在 域名下。比如 itbasic.datatom.com,这个域名下的所有网页都可以访问（只有同一个浏览器，如果是不同的浏览器，就获取不到这个cookie了··） 文件1 ：12345&lt;?phpsession_start();$_SESSION[&apos;username&apos;] = &apos;cy&apos;; 文件2123&lt;?phpsession_start();var_dump($_SESSION); notice: 这个获取session的时候也要调用session_start（）函数，有时候因为框架的或者函数的封装，很容易忽略 4.http 状态码http状态码表示这个请求的状态，常用的有200成功 ，3xx 资源的重定向，4xx客户端的错误（404 请求的文件找不到 403 没有权限 401 没有登录）， 5xx服务器端错误（500 经常代码的错误 502 网关，经常nginx出错）。然后现在的restful api在我们返回客户端的请求内容的时候经常也会携带着一个状态码，比如 12345return json_encode([ &apos;errorCode&apos;=&gt;10001, &apos;errorMsg&apos;=&gt; &apos;xxx&apos;, &apos;result&apos;=&gt;[]]) errorCode一般是我们内部定义的错误状态码，可以展示给用户看，让用户更能清楚的了解问题的所在，举个例子就是文章的创建，可能title不合法，过长了，文章删除的时候没有传递id，都可以以一个具体位数开头的错误码，归于一类。不管是http状态码，还是我们传递给用户的状态码，都是可以改变的，比如tp里面的json方法，第一个参数就是http状态码的参数，第二个参数才是要返回的具体的内容。 location也是返回信息中的一个字段，虽然状态码和我们的返回信息没有关系，即使正常调用接口我们返回一个404也是可以的，但是location必须得配合30x才能实现页面的跳转。 5.无连接无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。记得之前好像看过一篇文章说现在的http协议支持长连接了 1Connection:keep-alive 在请求头里面包括这个东西，虽然自己平时好像从来也没感受到，但还是记录下 6.url url组成 统一资源定位符。比如http://itbasic.datatom.com:80。http 是网络协议，默认端口80，如果不是80，需手动添加，比如我本地的xampp修改了http默认端口8080，访问的时候itbasic.app:8080才能访问，除了http，还有https 443， ssh默认端口22，访问这些服务的时候都要加上端口号，除了域名之外。其实域名只是为了让人们更好的记住，其实它本质上是翻译成ip的，打开cmd，ping itbasic.datatom.com 就能看到ip地址。ip地址代表服务器，一个服务器上可能提供多种服务，比如web服务，为了识别出不同的服务，我们用端口号进行标识，这和之前说的刚好吻合。 域名解析 其实当我们在浏览器中输入itbasic.datatom.com 的时候，浏览器会先去找比如windows host文件（经常我们本地测试的时候，瞎写的域名能访问就是这个道理，他不会去网络上进行解析，而是根据hosts文件中的配置进行ip地址转换，可以测试一下把www.baidu.com ip地址换成itbasic的，当然只有自己这台电脑访问百度会显示的是itbasic的主页），如果找不到，寻找浏览器缓存，再找不到会进行DNS域名解析，最终找到服务器，给他发送http请求，如果是传统的lamp架构，apache接受到请求会把通过模块加载的形式把关于php的内容传递给php进行解析，php会把其中关于数据库的内容，交给数据库处理，返回来的数据处理后统一返回给apache，再返回到浏览器进行渲染。现在lnmp，利用nginx，fpm对php请求进行统一处理，自己关于这方面内容现在还不足，了解还不是很深。 跨域 itbasic.datatom.com中 com是一级域名，datatom是二级域名，itbasic是三级域名，同属于datatom,这个二级域名下还会有很多，比如blog.datatom.com,51dan.datatom.com,域名的不同会导致出现跨域的问题，之前看网上处理方式主要分为两大类，一种是jsonp,另一种是返回的请求头中添加 1&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos; 7.请求头1234567GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 第一行get代表请求方式， 后面那个是请求的资源，最后是http的版本号，话说http 1.0 和 http1.1 使用时间好长第二行host 代表主机名第三行 表示 访问的主机的系统，还有浏览器，经常通过这个来判断是手机还是电脑登录。其实这个在服务器端也是可以获取的，通过打印 $_SERVER 数组。第四行第五行 上一个链接地址，经常用来进行回退。这个请求头和后面传递的数据需要空一行。这个请求头里面还可以放置很多别的数据，比如laravel里面表单为了放置csrf攻击，在里面放置了额外的参数1&lt;meta name=&quot;csrf-token&quot; content=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt; 请求的时候建立连接还会有4次握手 你在吗 我在 那我给你发数据了 好的，你发吧虽然到今天还没用上过 8.返回信息12345678910HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt; 这个和上面的请求消息差不多，断开链接需要3次握手 我要断开链接了 好的 （我不发送数据） 我也要断开连接了（这下两条都断开了） 9.https https 默认端口443，其实他不是一种新的协议，他还是http协议，只是在外层包裹了ssl。 https传输数据比http安全大家都知道，但原因呢，是由于数据进行了加密。很早之前有种协议talent，他也是通信协议，默认端口23，但现在这个端口默认都被禁止掉了，原因就是他传输数据的过程是明文传输，导致别人用抓包工具抓到了请求，或者监听这个端口，直接就能获取客户端传递过来的数据。想象一下，钓鱼网站如果用这个，很容易就能获取到用户的密码，太不安全了，于是ssh诞生了（我猜的）。ssh用的地方很多，比如我们用xshell时候建立的连接，还记得我们第一次连接新的服务器的时候的弹窗吗 一次性接受密钥 这是什么东西？这其实就是服务器的公钥。你发给服务器的内容，用服务器的公钥进行加密，服务器接收到你的内容用私钥进行解密，保证了数据传输的安全性（你发送的数据只有服务器能查看到，别人永远不能查看，因为你加密的媒介是计算机的公钥，能解密的只用服务器的私钥，而服务器的私钥只有你自己有，so，数据绝对安全。但有一点，数据的不可变性，就是数据的被篡改性不能得到保证）。或者你是否记得第一次对github进行提交的时候，或者换新的机器对github进行提交的时候，需要在github上贴你的公钥，为什么呢？因为我们git clone代码的时候，需要让github用我们的公钥加密，然后我们用自己的私钥进行解密（git clone 的时候的地址有ssh和https之分） 上面说的公钥加密，私钥解密舒服非对称加密，记得有RSA算法之类的。但是我们在数据通信的过程中如果一直用非对称方式进行数据传输，消耗会很大。于是我们用了另一种对称加密。对称加密顾名思义就是：同一种密钥进行加密解密，简单。可问题来了，这个密钥如果被获取到，加密就毫无意义了，我们该如何传递这个密钥给客户端。我们不能预先在所有的客户端都放置所有的密钥吧，这样不现实，也不能变动。 上面说的第一种非对称加密是公钥加密，私钥解密，保证数据的安全性。其实我们还可以通过私钥加密，公钥解密的方式，这样虽然不能保证数据的安全性（指的是被别人获取，因为公钥的公开性），但可以保证数据的不被篡改，因为私钥的私密性，一旦篡改内容，我们没法复原到私钥加密前的状态，我们只需要在私钥加密的内容中添加一些公共的东西，比如一个值，一个算法，这个值经过算法加密后的值，当我们通过公钥解密后这这个值加密后不等于这个算法加密后的值，那我们就能发现文件内容被篡改。]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F02%2F27%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>工具</tag>
        <tag>正则表达式</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于token]]></title>
    <url>%2F2018%2F02%2F07%2F%E5%85%B3%E4%BA%8Etoken%2F</url>
    <content type="text"><![CDATA[关于token。故事背景：itbasic用vue做了个手机版，之前是用jquery识别是手机还是web实现页面上元素的尺寸变化，实现兼容，但是页面其实还是同一个。所以通过dom元素绑定的后台请求ajax，api接口可以通用。现在用了vue，这种mvvm模式的框架，需要后台返回纯json格式的数据，并不需要之前接口中可能返回的html，实现页面元素的变化，这样一来，很多接口得重写。之前的itbasic更像是远古时代的web，调用接口的基本权限控制用的是session里面存储的登录用户信息，而itbasic的web端更像是现代的web网站，调用接口不需要用户登录，而是通过令牌，也就是token进行身份认证。 token肯定要保存的啦,保存的内容有哪些？从上面可以看出token的作用就和之前的session作用是一样的，因为session中存储了用户的基本信息，我们可以通过解析session数组，从中获取自己有用的东西，但我们的token一般只是一串无意义不重复的数字，所以光靠token是实现不了用户的区分的，所以我们一般在缓存中保存（为什么是缓存呢，我觉得首先返回给客户端的token信息不重要，并不用都保留下来，还有就是频繁的调用api接口，如果我们每次都去数据库中取缓存，太多的与数据库的交流并不好）。那我们需要保存的内容有哪些呢？最基本的用户的uid，因为我们一个token需要区分一个用户，我们得通过token知道这个用户是谁，当然你可以保存的不单单是uid，你可以理解成token是session数组的session_id,session数组就是我们token可以对应的内容，你可以在里面存放用户权限，登录时间，等一些常用的信息，这样就不需要为了取一些常用的信息的时候，先通过token找到用户id，再通过数据库查找这个用户的相关信息，再返回。token对应的内容只要你乐意，随便存储什么，但最基本的应该有个uid哦。 ​总结：token保存在缓存中，并不用记录在数据库中，保存的内容是和uid 的对应关系。 token的产生其实之前我一直纠结怎么生成一个token，网上有很多算法，后来呢，感觉如果安全性不用太高的话。取一堆字符串，从中随机取个，通过mt_rand()，然后拼接下，你也可以再拼接个你自己的盐，再加上时间戳这种的东西，再md5（）加密下。(js,php这些都有md5加密的，同样的内容，不管通过什么语言md5加密应该是一样的）。总结：方法很多，自己想吧，别太纠结了 token有过期时间和session一样啦，不能请求一次就一直可以使用啦。 token一般放在cookie里面，这样请求接口的时候就不用一直带上这个参数了。 token的申请。token需要和用户相对应，这种对应关系怎么知道呢。在之前做的微信小程序登录接口中是这样做的。 首先用户通过登录小程序获得一个code码（还记得我们每次进入小程序的时候都有个允许授权吗），这个码可以换取对应这个用户在这个小程序里面的一个独一无二的openid，可以理解成类似uid的东西，我们一旦获取到这个openid，意味着就相当于我们多了个用户uid，我们在自己的用户表中存储这个openid。（为什么要用code换区openid呢，可以理解成openid比较重要，包含用户的重要信息，而且类似uid，永远不会变，一旦获取，就代表永远知道了，这个不能用来表示身份，或者说通过openid不能换取表示身份的token，所以还是放在服务器端吧。古代的用户密码登录因为有只有自己知道的密码，所以可以通过固定不变的大家可能都知道的用户名换区session_id,现在通过变化的code同样的道理，code理解成密码，服务器端给这个密码给微信，微信通过自身维护的code和openid的对应关系，把用户openid返回给你，注意这个code只能用一次哦） 服务器收到这个openid， 生成和这个用户相匹配的token，存储对应关系在缓存中，再返回给客户端token。客户端拿着这个token再来服务器端请求数据，服务器端看token是否存在和token是否失效，如果没有，可以访问。如果过期了，需要重新走上面的流程生成新的token。可这个时候就不用在用户表里面添加新的用户了，因为用户已经存在了，可以生成新的key=》value对应关系，key=》代表新生成的token。 大致就这些了吧··· 关于app接口设计的token，有signature签名的作用：主要是为了放置提交数据的安全性，token：1.第三方access_token,调用第三方接口的凭证。2.自己用的token，作用就相当于用户登录的密码，参见链接:https://blog.csdn.net/qq_26291823/article/details/53337518]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>token</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP文件操作]]></title>
    <url>%2F2018%2F01%2F29%2FPHP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[上篇文章里面写了关于文件上传。其实在做文件上传的功能的时候遇到很多php关于文件的处理，记录下来。其实文件处理在我们刚开始学习php的时候肯定学习过，可后来因为项目当中，做网站的时候关于文件的操作很少，所以很容易忘记这部分的内容，毕竟其实也挺枯燥的。1.遍历文件夹下的所有文件。在做大文件切割的时候，本来想用php做，可是php的fopen好像最多只能接受8000多个字节，就是8000B，而我们上传文件大小一般能达到4m,如果按照8000B的切割也就太多小文件了，于是用linux新建个文件夹，在文件夹中split -b 4m 文件名 （还有个参数代表切割文件的名称，我没有仔细看，使用的默认的，就会产生xaa,xab···这种的文件），然后删除原始文件，遍历文件夹下的所有文件，每次上传一个，像服务器上刚开始创建好的文件持续写入，这样就能实现php的大文件上传php:1234567891011&lt;?php$dir = &apos;/root/test&apos;;$handle = opendir($dir);$fileArr = [];while($filename = readdir($handle)) &#123; if ($filename != &apos;.&apos; &amp;&amp; $filename != &apos;..&apos; &amp;&amp; !is_dir($filename)) &#123; array_push($fileArr, $filename); &#125;&#125;//var_dump($fileArr);exit; 2.遍历文件夹下所有文件这个是面试题中经常考得一道题 php1234567891011121314151617181920212223242526272829function listDir($dir, &amp;$a)&#123; if(is_dir($dir)) &#123; if ($dh = opendir($dir)) &#123; while (($file = readdir($dh)) !== false) &#123; if((is_dir($dir.&quot;/&quot;.$file)) &amp;&amp; $file!=&quot;.&quot; &amp;&amp; $file!=&quot;..&quot;) &#123; echo &quot;&lt;b&gt;&lt;font color=&apos;red&apos;&gt;文件名：&lt;/font&gt;&lt;/b&gt;&quot;,$file,&quot;&lt;br&gt;&lt;hr&gt;&quot;; listDir($dir.&quot;/&quot;.$file.&quot;/&quot;, $a); &#125; else &#123; if($file!=&quot;.&quot; &amp;&amp; $file!=&quot;..&quot;) &#123; $a[] = $file; echo $file.&quot;&lt;br&gt;&quot;; &#125; &#125; &#125; closedir($dh); &#125; &#125;&#125;//开始运行$a = [];listDir(&quot;./nowamagic&quot;, $a); 上面两个场景大致差不多，主要就是几个函数的使用。首先要明确读取文件夹的内容和读取文件的内容是不一样的。 is_dir 判断该文件是否是文件夹，注意的一点事一定要跟上文件名的前缀··，否则不能找到指定文件，会有奇怪的错误发生。 is_file 判断是否是文件 对于文件名和文件夹名称的判断一定要带上路径，要不然他可能在php 脚本所在的地方查询文件，容易造成奇怪的问题，所以还是用绝对路径 读取文件夹的内容，首先要打开文件夹,opendir() ,会产生一个资源型的数据类型，句柄，readdir() 会循环遍历文件夹的内容。closedir()读完文件之后关闭。 读取文件 fopen(), 也会产生一个资源型句柄，怎么理解上面的句柄，当做类似光标的东西，我们可以操作他，比如读文件，读取了一行，他就往前移动一行，feof() 可以判断这个句柄(光标是否在文件尾) 注意每个文件夹下的两个特殊文件’.’ 和 ‘..’ fopen打开一个文件，返回一个句柄，其实和上面打开一个文件夹是一样的，只是这里面多了几种模式。这个句柄可以理解成连接数据库时候的资源文件，每次关于数据库的操作都得用到这个文件 12345678&quot;r&quot; （只读方式打开，将文件指针指向文件头）&quot;r+&quot; （读写方式打开，将文件指针指向文件头）&quot;w&quot; （写入方式打开，清除文件内容，如果文件不存在则尝试创建之）&quot;w+&quot; （读写方式打开，清除文件内容，如果文件不存在则尝试创建之）&quot;a&quot; （写入方式打开，将文件指针指向文件末尾进行写入，如果文件不存在则尝试创建之）&quot;a+&quot; （读写方式打开，通过将文件指针指向文件末尾进行写入来保存文件内容）&quot;x&quot; （创建一个新的文件并以写入方式打开，如果文件已存在则返回 FALSE 和一个错误）&quot;x+&quot; （创建一个新的文件并以读写方式打开，如果文件已存在则返回 FALSE 和一个错误） 这个模式也可以分成指针指在文件头部还是尾部来记忆。 filesize() 判断文件大小，不需要在fopen() 之后执行，你想一下这个函数也不用句柄，为啥要在fopen 之后呢，千万注意，w打开文件，关闭之后或者脚本结束，文件内容就没了，！！千万注意 fgets读取一行文件，也会移动光标到下一行（可以通过fseek 重置光标位置），注意这个不能读二进制文件比如照片，二进制文件还是用fread 来读取吧 fgetc 读取一个字符，(注意比如 \n 属于一个字符) 怎么理解 $handle, 连接资源。感觉可以理解成一个光标，比如我们 a+ 打开，光标在末尾，所以我们写入文件也在末尾 fseek(\$handle, \$position, SEEK_END) 我们把光标移动到末尾，然后可以倒着读取单个字符，遇到 PHP_EOL 也就是一行 fclose关闭文件 (怎么理解关闭文件，想象成一个tcp连接，我们如果不及时关闭这些连接，会造成资源浪费，而且如果有锁的话，还可能让别的写入进程等待，但是我们连接要是释放了，资源也就释放了) fgetcsv 与 fgets() 类似，不同的是 fgetcsv() 解析读入的行并找出 CSV 格式的字段，然后返回一个包含这些字段的数组。 fread(), 读取指定大小的文件，但是需要传大小限制 （直接filesize (文件名称)就好了），可以用来读取二进制文件，这点比fgets强 fwrite() 也可以用来写入文件，也是有个写入大小参数限制,同上，可以用来写入二进制文件（fputs 的别名） 1234567891011理解二进制文件和普通文件我们读取照片内容，输出的都是一堆我们看不懂，感觉可以理解成二进制，对于md文件或者html，这些我们读取之后输出，或者我们可以直接编辑的，感觉可以理解成普通文件对于二进制文件，比如照片，在腾讯云的上传那块，我们可以直接利用流的上传，然后保存文件，我们指定一下文件后缀，就能用了(我的感知就是反正文件内容完全保存了嘛，然后指定一下后缀，让我们的操作系统比如windows 能识别)看了腾讯云上传那块还有字符串上传，说是上传内存中的字符串，当时不太理解字符串，后来想到了对于文本文件比如html 这些本质上就是一个字符串，然后我们上传的时候直接指定文件名文件后缀，以后在本地系统上查看的时候就能识别出来，因为本质上系统还是根据这些后缀识别成mini type（或者是文件系统信息中保存了type 类型）, 然后调用相应系统工具展示给我们看（像linux 那种如果不用展示给我们看，他们甚至都不用文件后缀），如果不指定文件后缀，我们保存的文件不能查看，但是还是好的文件，因为我们把文件内容已经写入了。照片虽然是二进制文件，我们也能用字符串表示，还记得吗? base64 ,但是保存的时候我们需要解码，然后再保存进文件，不知道腾讯云支持不~~~（那个统一的string 上传肯定不支持啦）(还有我们不要把file_get_contents 读出来的照片当做字符串，虽然那个在php上来看也是string，fwrite和file_put_contents 都能写，所以字符串上传估计也能支持，但我们不要忘记他本身是个流，也能通过流上传，(既能字符串上传也能流上传))发现腾讯云字符串上传的时候返回的是文件地址，但是流上传不会返回哦，需要自己拼接访问地址 之前用脚本处理博客，所有图片地址换成腾讯云发现，那个guzzle 感觉不是发送一个请求成功之后再发送另一个，感觉是并发，我的文件名用的是时间，结果重复的太多了相互覆盖了(因为两边都是并发，客户端并发就是多个用户（这个例子中就是我的多个请求），服务端并发就是多个进程比如php-fpm启动的多个进程来处理请求，蛮常见的场景。如果服务端用时间戳的话，同一时间的并发获取的时间戳字符串蛮容易重复的，所以可以利用微妙时间 + 一个随机字符串 来命名文件，官方的名称就是uuid) 多进程还是用起来，真的处理起来太快了！！！ 上面代码还需要注意的一个地方是对于&amp;的使用，我们只需要在函数定义的时候给上就好了，并不用在函数的使用的是时候也加上，这个比较static的优点就是在多个文件夹都需要遍历的时候的好处，static 会把一次程序的执行所有的这个变量的值都叠加，但是取地址符每次修改的时候都是这个变量的值，举个例子吧，网上对于无限递归的处理 123456789101112131415161718192021222324252627$dept = [ [ &apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;爷爷&apos;, &apos;parent&apos; =&gt; 0 ], [ &apos;id&apos; =&gt; 2, &apos;name&apos; =&gt; &apos;爸爸&apos;, &apos;parent&apos; =&gt; 1 ], [ &apos;id&apos; =&gt; 3, &apos;name&apos; =&gt; &apos;姑妈&apos;, &apos;parent&apos; =&gt; 1 ], [ &apos;id&apos; =&gt; 4, &apos;name&apos; =&gt; &apos;表哥&apos;, &apos;parent&apos; =&gt; 3 ], [ &apos;id&apos; =&gt; 5, &apos;name&apos; =&gt; &apos;我&apos;, &apos;parent&apos; =&gt; 2 ]]; function getParent($allparent,$we) { static $p = []; /* if ($we[‘parent’] == 0) { array_push($p, []); } else { */ foreach($allparent as $key=&gt;$value) { if ($we[&apos;parent&apos;] == $value[&apos;id&apos;]) { array_push($p, $value); getParent($allparent, $value); } } /* } */ return $p; } $res = getParent($dept, [ &apos;id&apos; =&gt; 5, &apos;name&apos; =&gt; &apos;我&apos;, &apos;parent&apos; =&gt; 2 ]);$res1 = getParent($dept, [ &apos;id&apos; =&gt; 4, &apos;name&apos; =&gt; &apos;表哥&apos;, &apos;parent&apos; =&gt; 3 ]);var_dump($res1); // 改进function trueParent($allparent, $we, &amp;$p){ foreach($allparent as $key=&gt;$value) { if ($we[&apos;parent&apos;] == $value[&apos;id&apos;]) { array_push($p, $value); trueParent($allparent, $value, $p); } } return $p; } $res3 = [];trueParent($dept, [ &apos;id&apos; =&gt; 5, &apos;name&apos; =&gt; &apos;我&apos;, &apos;parent&apos; =&gt; 2 ], $res3);$res4 = [];trueParent($dept, [ &apos;id&apos; =&gt; 4, &apos;name&apos; =&gt; &apos;表哥&apos;, &apos;parent&apos; =&gt; 3 ], $res4 ); var_dump($res3, $res4);exit;​123456 运行下上面的程序，你会发现$res是正确的，但是$res1其实也能获取到，只是res1会附带上res的结果，根本原因是static 变量的问题，而且static还不能释放掉，unset没有效果，但这种情况还是挺常见的，比如当我既要获取我的祖先还有表哥的祖先，当我们循环获取的时候，这时候&amp;地址符就能解决我们的问题3.php合并文件思路：其实就是打开一个文件，不断往里面写入。关于打开fopen() 参数很多，感觉很多都是遇到的时候再看吧，二进制文件记得加b。php $fb = fopen(‘/root/1.css’, ‘wb’);foreach ($fileArr as $key=&gt;$value) { fwrite($fb, file_get_contents(‘/root/test/‘.$value));}fclose($fopen);```每次的写入都是从尾部开始写入的。（相比较打开文件夹，他少了个readdir这种循环遍历文件夹的函数，好像fgets也有这种功能，但是用的不多，就没细看了）。 4.还有一些关于文件的函数，比如获取文件内容file_get_contents,写入file_put_contents,获取fgets这种的好像是按照行获取的，一般读操作用file_get_contents,能读取全部的内容。 文件读写是经常进行的一个动作，读取文件的函数真是千千万万个，复杂的有，简单的也有。最常用方便的有file_get_contents(),file_put_conents()，不需要进行打开文件，关闭文件的操作。但是对超大文件进行读取时，file_get_contents()会把内容都读取进内存，造成内存溢出，最好是循环按行读取。fgetcsv()用来读取一行csv文件，fgets()用来读取一样普通文件。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传]]></title>
    <url>%2F2018%2F01%2F26%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[今天遇到一个问题，关于大文件的上传。其实不管是大文件的上传，还是普通的文件上传，一直都是迷迷糊糊的，今天对其进行整理下。首先，最基本的，文件大小单位 1KB等于1024B，B是英文Byte(比特，字节)的缩写,KB即kilobyte,字面意思就是千比特。byte是文件大小的一个计量单位，大家都知道在计算机里面，文件都是以二进制方式存储的，这样一个最小的存储单元（譬如10、11、01、00）叫做一个bit(位，位元)，八个位元等于一个比特。转换关系：8bit=1b1024byte=1kb1024kb=1mb1024mb=1gb1024gb=1tb以上单位k指千、m指百万、g指10亿，t指万亿，大小写均可。因为1024≈1000，所以1024b,也称为1k，以下类似。 简单点说就是 1G =1024M 1M = 1024K 1K=1024B B之后就是位了，8位是1B，一般都是B为计量单位。 菜鸟教程这里面有对最基本的php文件上传的demo html :123456789101112131415&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 这个是以最基本的表单提交方式，当点击提交的时候文件就直接飞到upload_file.php那边了，注意接受的变量以表单控件的name字段的内容为变量名（$_POST[]）数组里面（想了下，其实框架的路由都是从这些大数组里面获取变量的信息）。这个 enctype 很重要 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。 标签的 type=”file” 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。 不仅是这块，当用curl模拟文件上传的时候，也有相关的参数设置1curl_setopt($ch, CURLOPT_POSTFIELDS, $params); 这个param如果是普通的post数据提交，要拼接成&amp;这种string方式，如果是文件上传，直接是传输组参数就可以了。 php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php// 允许上传的图片后缀$allowedExts = array(&quot;gif&quot;, &quot;jpeg&quot;, &quot;jpg&quot;, &quot;png&quot;);$temp = explode(&quot;.&quot;, $_FILES[&quot;file&quot;][&quot;name&quot;]);echo $_FILES[&quot;file&quot;][&quot;size&quot;];$extension = end($temp); // 获取文件后缀名if ((($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/gif&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/jpg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/x-png&quot;)|| ($_FILES[&quot;file&quot;][&quot;type&quot;] == &quot;image/png&quot;))&amp;&amp; ($_FILES[&quot;file&quot;][&quot;size&quot;] &lt; 204800) // 小于 200 kb&amp;&amp; in_array($extension, $allowedExts))&#123; if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0) &#123; echo &quot;错误：: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br&gt;&quot;; &#125; else &#123; echo &quot;上传文件名: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件类型: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br&gt;&quot;; echo &quot;文件大小: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; kB&lt;br&gt;&quot;; echo &quot;文件临时存储的位置: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] . &quot;&lt;br&gt;&quot;; // 判断当期目录下的 upload 目录是否存在该文件 // 如果没有 upload 目录，你需要创建它，upload 目录权限为 777 if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;])) &#123; echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在。 &quot;; &#125; else &#123; // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下 move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]); echo &quot;文件存储在: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]; &#125; &#125;&#125;else&#123; echo &quot;非法的文件格式&quot;;&#125;?&gt; 之前一直以为这是框架的内容，其实这是php自带的，框架可能只是对他的封装和安全性的校验。如果有时候实在上传出错，试试这个数组。 几个要注意的点： 临时上传文件的地址可以通过phpinfo() 查看，但如果你真到那个文件夹下是找不到的，通过move_uploaded_file 函数移动到你需要的位置。因为我们itbasic之前的上传都写好了，导致我以为上传直接上传到指定的文件夹。 几个函数 is_dir 判断文件夹是否存在，file_exists,判断文件是否存在，move_uploaded_file 移动文件。注意创建文件夹的时候给权限755. 移动到新的地址直接返回新的地址给前端就可以了。 注意一下我们平时比如itbasic上表单的提交都不是以form这种格式，都是直接通过按钮触发click事件，然后获取页面内容进行提交，这种方式是上传不了文件的，我们可以利用jq，12var writeData = new FormData();writeData.append(&apos;object&apos;, objid); 然后往里面添加属性，通过append 之前还上传过base64格式的image图片，其实这个要比前面的文件上传简单很多，这个与其说是上传文件，不如说是保存数据内容。 一个image的base64格式码：1data:image/png;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCABPAFgDASIAAhEBAxEB/8QAGwAAAQUBAQAAAAAAAAAAAAAAAAECAwQGBQf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbvbIA1B7alwUwuyLDRxUFCaSOQRHRmJ6VXHHe9DyusEUCqASyMeJRs8Y5uTu9cbqMohvlyGwKgoTRySGL6Wg55i2dBh3+15fuzpTNcVQCZ0MRaoTBbSqhJw+yFxtVB5EH/8QAKBAAAAYABQMFAQEAAAAAAAAAAAECAwQFEBEUMzQGFTESEyFBRCBC/9oACAEBAAEFAj3fH8fePkfpPd84LWTaGJceSP8AT96uPPZdJ9keAfJPdHnDtS4trY2KEtwH6yO6PGB8k93BaUrQ7W1iTr3o7L0O0hOPYnyT3c/nP5elRUBXY0nXSo8V3vyUCFNTNZzGfz+k90zIiN5pIk9rfVarhJBWrDUBjqLJtfUihAvCkvg+Se6+y3IaLpxn1opYSAiM5XSbGyjvxauDo4eWYJpslA+Se7g9OixidtZM0N9P5s+7YU7sCc3YM4HyT3QpJLSivhtgiyL7fYbktV1WqBIwPkuK9CikIIalA1KBqUDUpGpSNSgalA1CDCFe4/8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAwEBPwF3/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAgEBPwF3/8QAMBAAAQMCBAQFAQkAAAAAAAAAAQACAxEhEBIxcQQTUXIiIzJBYYEFIDAzQ1JigpH/2gAIAQEABj8CGxV/wLIdqGxxc91mtFSvJla7498JI8jHxNNLapsoDgHDRwviO1DY40KjmicBBmqammX4XLg4mIF2r61y/wCJoDZJZT+o5ipiO1DY4lrtCjzJsu8qJ4qMPZTpW6EMMJiLtPAPuDtQ2xMU0sY6tcVfl/SpUjp4s4Itaq8ngrb0WcMcw1oQcRshsVcq8jB/ZVnfAXD+d1E3ggyouXNWRsodxGT1NjpdUnizO6t914OGA3chDNHkc7QjAbIbFGKVtWlXnfl6UQ8rN8ucpJZ+CE0R0Lbhv0Qi4WOmb1eGlFR35j7uVwFmEbQetMB2obHCi8yZoPStSuV9nwvp+9HnSnnG9RoFkcas9gbtKJAo4epvRUwHahsVZFrhY6rw8NH9RVUCojHK2rSpXczMxwoOuF0O1B3tRaFaOWjlo5aFaOWjlo5aFZh0X//EACcQAQACAAQFBAMBAAAAAAAAAAEAESFBUfAQMWFxkYGh0fEgweGx/9oACAEBAAE/Id21IZFjl+C4TUfweYWOccNrnNm1IgKYLaPmJTYJV0E5qvOj/jnLwHRmFOxydWPeXG0FARWwPMAFE23WbNqcEpTMNa9c5XJ7QoZ9UA2OCuHQtjGixVBL6F2S7sOOsClHDbdZs2pxNeypxqIIrL+mM5HlzG7IitqVF+Pw23WOu7/0lcGPiVwY+I03JQXJ1JfNvpvaYcaCGj6wFS72RKBZQs+8rdY+JXBj4ju9Zs2pLEAas90wErs/lT2MKvKi+Mc5ThUWBp5ka9jyejuuJ8hf+oChFPsXThtes2bUma45LBTfAAfP8lWG9Q+3KWdQogL5/wBS05eQgZYQgMU7eh6fMpYcSnC5DfDbdZs2pwu1HnSLAZl9gRhCWCzH0yINBX8wn7lUzok9NIqbDs+XaXSLzrw23WbNqRtwXd0l9w6GsUuzr+1AIADIJeHoYdz2nUlDdY1qz4FmC7Os23WXMLYNekAo8Z8z6A+Z9AfM+gPmYmX2J9MT6A+Z9AfMQU+MlICBTGf/2gAMAwEAAgADAAAAEMOMPOMFLGOPAJPGEJMFGDBNAELPBODP/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAwEBPxB3/8QAFBEBAAAAAAAAAAAAAAAAAAAAQP/aAAgBAgEBPxB3/8QAJhABAAEDAwMEAwEAAAAAAAAAAREAITFBUWFxgaEQkbHwINHhwf/aAAgBAQABPxASF94zS7DKmURIb812q21dqUKEKnWyfutXWrV2pWMCJRMDtzRhS4Z1u9NLgJJmos2Lg1/tN9k3QErBdsaUcxclABvOIdqWWcKPZP3RED2SaBkUYlppmj1GYExc7dyGoM2bq0/v3rGCCZrwHy9dJpgawLcRZbh7Ubx4KgBZCSETZvu6Wx2KwEqWNtyi5XAAnTXUheaS1gEIMf2jDAUV4D5fhplJMMrOpc6lR5ihK3ZMjrUlzpSgSMg3za1R/KYNmL2G2pFAGI7evgPlQSxZEgX2aRlJzGce8RSEpPGce8RUDB7UhqaI6lX/ANwB0JHtUAjlvNMkwKNE7oJOi/NXyMTQytCEvm3IUhbn1x7xFQCM1DOPeIpyd7HJy9FKAzykBRUj/YloGVIvo2U170QmDpjAHLU3nzRKRKp6B0WCUmL0sOQAE4YPSZ4i6CXrLn2B81JAwpTCG5w37Vonivv8vTSPg0KwiNkTCN5oLAWJTm8aXIdfxonhWu+0wUEMWgwjfc9x17AEGCrtoc0CuDF5RZdQeWk7OAYITpvQnBowdwmivAfL0070z8yFxSxllujmZO5Vq+JwbynurO0NEgmFkkszec3ZLlt2dwLKec57EdzdbzkgUzAdVDDbDQWDKWVCvAfL0UsUQzH0ZqVhLJsSHFRAMgKO4XzQQ2ggAUsMQKe0fuhzvccrRNHmjGJypZKdEmJMy2KSf8p2Wsx9Ga+xyqHmS0klWrxUNM9z8BAgQYcWTOSbRr1rL9Dv6kCD1MfpmgES45yu/Nf/2Q== 图片在使用的时候只用image src=”” 等于上面这串内容就可以了。像wangeditor里面，写的内容，两种保存图片的方式：1.base64， 直接把这个image src = base64格式保存在html中 2.把文件上传到服务器上，然后获取链接地址。 base64 php处理代码：12345678910if (preg_match(&apos;/^(data:\s*image\/(\w+);base64,)/&apos;, $src, $result))&#123; $type = $result[2]; $body = str_replace($result[1], &apos;&apos;, $src); $filename = $path.date(&apos;YmdHis&apos;, time()).&apos;.&apos;.$type; if (file_put_contents($filename, base64_decode($body)))&#123; &#125;else&#123; return [&apos;code&apos;=&gt;CODE_ERROR, &apos;msg&apos;=&gt;&apos;文件保存失败&apos;]; &#125; &#125; 大致说下一下，type 获取的是正则 （\w+）里面内容，代表图片的格式，body 获取的正则的内容，注意看表达式最外面的（）括号，result[0]代表的是完全匹配内容。 php获取到图片base64加密后的内容，通过解密，file_put_contents 写入文件，返回文件地址。 上面是通过前端 js + 后端php，实现的文件上传，其实完全可以通过 php + php 实现，下面分别介绍通过这两种方式实现的大文件上传。 客户端php代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150#!/usr/bin/env php&lt;?phpconst DATRIX_URL = &quot;http://211.144.114.26:19980&quot;;//const DATRIX_URL = &quot;http://192.168.50.229&quot;;const DATRIX_UID = &quot;itbasic&quot;;const DATRIX_PUID = &quot;itbasic&quot;;//const DATRIX_DATA_DIR = &quot;9bbd816d16ff589aee0ffe0ce68323ba&quot;;//const DATRIX_DATA_OBJ = &quot;20180126/09/9bbd816d16ff589aee0ffe0ce68323ba&quot;;const DATRIX_DATA_DIR = &quot;4bb4db1235077fb2ba6ea2b9a0220693&quot;;const DATRIX_DATA_OBJ = &quot;20180125/16/4bb4db1235077fb2ba6ea2b9a0220693&quot;;const DATRIX_EXECUTE_ID = &quot;itbasic&quot;;const DATRIX_CREATE_URI = &quot;/api/sw/file/create&quot;;const DATRIX_WRITE_URI = &quot;/api/sw/file/write&quot;;const DATRIX_FINISH_URI = &quot;/api/sw/file/finish&quot;;$filename = substr(date(&apos;Ymd&apos;), 2).&apos;.sql.tar&apos;;$trueFileName = &apos;/var/dataitbasic/&apos;.$filename;function http_post_data($url, $params = array(), $string = 1)&#123; if (is_array($params) &amp;&amp; $string) &#123; $params = http_build_query($params, null, &apos;&amp;&apos;); &#125; $ch = curl_init(); curl_setopt($ch, CURLOPT_POST, 1); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_ENCODING, &quot;&quot;); curl_setopt($ch, CURLOPT_POSTFIELDS, $params); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $response = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); curl_close($ch); return [$httpCode, json_decode($response,true)];&#125;$param = [ &apos;filename&apos;=&gt;$filename, &apos;filesize&apos;=&gt;filesize($trueFileName), &apos;createuid&apos;=&gt;DATRIX_UID, &apos;parentuid&apos;=&gt;DATRIX_PUID, &apos;dirid&apos;=&gt;DATRIX_DATA_DIR, &apos;parentobj&apos;=&gt;DATRIX_DATA_OBJ, &apos;city&apos;=&gt;&apos;上海&apos;, &apos;district&apos;=&gt;&apos;&apos;, &apos;gps&apos;=&gt;&apos;121.48789949,31.24916171&apos;, &apos;isperdir&apos;=&gt;&apos;true&apos;, &apos;userid&apos;=&gt;DATRIX_EXECUTE_ID, &apos;debug&apos;=&gt;true];function uploadToDatrix($createParam, $trueFileName)&#123; $block = 4*1024*1024; $create = http_post_data(DATRIX_URL.DATRIX_CREATE_URI, $createParam, 1); $objid = $create[1][&apos;result&apos;][&apos;objid&apos;]; if ($create[1][&apos;code&apos;] == 200) &#123; if (filesize($trueFileName) &gt; $block) &#123; $dir = DIR.substr(date(&apos;Ymd&apos;), 2); $handle = opendir($dir); $fileArr = []; while(($filename = readdir($handle)) !== false) &#123; if (!is_dir($filename) &amp;&amp; $filename != &apos;.&apos; &amp;&amp; $filename != &apos;..&apos;) &#123; array_push($fileArr, $filename); &#125; &#125; closedir($handle); $offset = 0; foreach ($fileArr as $key=&gt;$value) &#123; $writeParam = [ &apos;object&apos;=&gt;$objid, &apos;bucket&apos;=&gt;DATRIX_EXECUTE_ID, &apos;length&apos;=&gt;filesize($dir.&apos;/&apos;.$value), &apos;debug&apos;=&gt;true, &apos;filedata&apos;=&gt;file_get_contents($dir.&apos;/&apos;.$value), &apos;offset&apos;=&gt;$offset ]; $writeResult = http_post_data(DATRIX_URL.DATRIX_WRITE_URI, $writeParam, 0); $offset += filesize($dir.&apos;/&apos;.$value); &#125; $finshData = [ &apos;objectid&apos;=&gt;$objid, &apos;createuid&apos;=&gt;DATRIX_UID, &apos;userid&apos;=&gt;DATRIX_EXECUTE_ID, &apos;fileid&apos;=&gt;$create[1][&apos;result&apos;][&apos;fileid&apos;], &apos;debug&apos;=&gt;true ]; if ($writeResult[1][&apos;code&apos;] == 200) &#123; $finish = http_post_data(DATRIX_URL.DATRIX_FINISH_URI, $finshData,1); &#125; if ($finish[1][&apos;code&apos;] != 200) &#123; echo date(&apos;Ymd&apos;); &#125; &#125; else &#123; //$file = fopen($trueFileName, &apos;rb&apos;); //$content = fread($file, filesize($trueFileName)); //$content = fgets($file); $content = file_get_contents($trueFileName); //echo &quot;filesize:&quot;.filesize($trueFileName); $writeParam = [ &apos;object&apos;=&gt;$objid, &apos;bucket&apos;=&gt;DATRIX_EXECUTE_ID, &apos;length&apos;=&gt;filesize($trueFileName), &apos;debug&apos;=&gt;true, &apos;filedata&apos;=&gt;$content, &apos;offset&apos;=&gt;0 ]; $writeResult = http_post_data(DATRIX_URL.DATRIX_WRITE_URI, $writeParam, 0); $finshData = [ &apos;objectid&apos;=&gt;$objid, &apos;createuid&apos;=&gt;DATRIX_UID, &apos;userid&apos;=&gt;DATRIX_EXECUTE_ID, &apos;fileid&apos;=&gt;$create[1][&apos;result&apos;][&apos;fileid&apos;], &apos;debug&apos;=&gt;true ]; if ($writeResult[1][&apos;code&apos;] == 200) &#123; $finish = http_post_data(DATRIX_URL.DATRIX_FINISH_URI, $finshData,1); &#125; if ($finish[1][&apos;code&apos;] != 200) &#123; echo date(&apos;Ymd&apos;); &#125; &#125; &#125;&#125;uploadToDatrix($param, $trueFileName); http_post_data 是通过curl封装的post方法，需要注意的点是，传的post参数不要组装成string（post三种传递数据方式，string， 表单还有一种），其实我们平时可以通过观察控制台，发现我们itbasic的每次提交都是post方式，但是数据组装方式，有string，表单两种类型。还有注意我之前一直file以为传文件名就可以了，··坑爹啊··这样传服务端怎么获取内容，用file_get_contents()获取文件内容。（今天偶然碰见，file_get_contents()不能获取itbasic.app这种本地定义的域名哦）。 php读取指定文件大小 完整的php接受大文件上传 上传大文件 js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167var uploadToDatrix = function(fileObject, fileId, fileText, type, dirid, dirobj, pro, button) &#123; //参数是上传文件对象 if (button) &#123; $(&apos;#&apos; + button).attr(&apos;disabled&apos;, &apos;disabled&apos;); &#125; for (var i = 0; i&lt;fileObject.files.length; i++) &#123; var file = fileObject.files[i]; //具体的文件 var filename = file.name; var fileSize = file.size; console.log(file); var data = &#123; filename: filename, filesize: fileSize, createuid: DATRIX_UID, parentuid: DATRIX_PUID, dirid: dirid, parentobj: dirobj, city: &apos;上海市&apos;, gps: &apos;121.48789949,31.24916171&apos;, isperdir: true, userid: DATRIX_EXECUTE_ID, debug: &apos;true&apos; &#125;; $.ajax(&#123; url: DATRIX_URL+DATRIX_CREATE_URI, type: &quot;POST&quot;, dataType: &quot;json&quot;, data: data, success: function (data) &#123; var back = data.result; console.log(back); /* var writeData = &#123; object: back.objid, bucket: &quot;itbasic&quot;, length: fileSize, offset: 0, debug: true &#125;*/ fileWrite (fileSize, back.objid, fileSize, file, 0, back, fileId, fileText, type, button); &#125;, error : function(error) &#123; showAlert(&apos;上传失败&apos;, &apos;danger&apos;); &#125; &#125;); &#125;&#125;;var fileWrite = function(uploadSize, objid, trueSize, file, start, back, fileId, fileText, type, button) &#123; var writeData = new FormData(); if(uploadSize &lt;= 2 * 1024 * 1024) &#123; var fileSize = uploadSize; &#125; else &#123; var fileSize = 2 * 1024 * 1024; &#125; var end = start * 1 + fileSize * 1; var func = (file.mozSlice ? &apos;mozSlice&apos; : (file.webkitSlice ? &apos;webkitSlice&apos; : &apos;slice&apos;)); var uploadFile = file[func](start, end); writeData.append(&apos;object&apos;, objid); //var writeData = new FormData(); writeData.append(&apos;bucket&apos;, &apos;itbasic&apos;); //上传文件用户id writeData.append(&apos;length&apos;, fileSize); //filesize,上传文件内容 writeData.append(&apos;offset&apos;,start); //文件开始点 writeData.append(&apos;debug&apos;, true); writeData.append(&apos;file&apos;, uploadFile); //文件内容 console.log(start, fileSize, uploadSize); $.ajax(&#123; url: DATRIX_URL+DATRIX_WRITE_URI, type: &quot;POST&quot;, dataType: &quot;json&quot;, data: writeData, processData: false, contentType: false, async : false, success : function(data) &#123; //console.log(data); uploadSize = uploadSize - fileSize; console.log(uploadSize); if (uploadSize*1 &gt; 0) &#123; fileWrite(uploadSize, objid, trueSize, file, end, back, fileId, fileText, type, button); return ; &#125; var finishData = &#123; objectid:back.objid, createuid:DATRIX_UID, userid:DATRIX_EXECUTE_ID, fileid:back.fileid, debug:true &#125; $.ajax(&#123; url: DATRIX_URL+DATRIX_FINISH_URI, type: &quot;POST&quot;, dataType: &quot;json&quot;, data: finishData, async : false, success : function() &#123; $(&apos;#&apos;+button).removeAttr(&apos;disabled&apos;); if (pro == 1) &#123; var f = &#123;&apos;fname&apos;:back.filename,&apos;fid&apos;:back.fileid, &apos;objectid&apos;:back.objid&#125;; uploadContractFile.push(f); console.log(uploadContractFile); &#125; else &#123; if (fileId) &#123; var file_id = $(&apos;#&apos; + fileId).val(); var upload_text = $(&apos;#&apos; + fileText).val() || &apos;&apos;; if (!file_id) &#123; file_id = back.fileid + &apos;,&apos; + back.filename; $(&apos;#&apos; + fileId).val(file_id); &#125; else &#123; file_id = file_id + &apos;,&apos; + back.fileid + &apos;,&apos; + back.filename; $(&apos;#&apos; + fileId).val(file_id); &#125; if (!upload_text) &#123; upload_text = back.filename; $(&apos;#&apos; + fileText).val(upload_text); &#125; else &#123; upload_text = upload_text + &apos; , &apos; + back.filename; $(&apos;#&apos; + fileText).val(upload_text); &#125; &#125; else &#123; var upload_text = $(fileText).find(&apos;.upload_text&apos;).val() || &apos;&apos;; var html = &apos;&lt;a href=&quot;javascript:;&quot; class=&quot;primary-link preview&quot; data-filename=&quot;&apos;+back.filename+&apos;&quot; data-fileid=&quot;&apos;+back.fileid+&apos;&quot; data-objid=&quot;&apos;+back.objid+&apos;&quot;&gt; &apos;+ back.filename +&apos; &lt;/a&gt;&apos;; $(fileText).find(&apos;.file_preview&apos;).append(html); if (!upload_text) &#123; upload_text = back.filename; $(fileText).find(&apos;.upload_text&apos;).val(upload_text); &#125; else &#123; upload_text = upload_text + &apos; , &apos; + back.filename; $(fileText).find(&apos;.upload_text&apos;).val(upload_text); &#125; &#125; Model.addupload(&#123; fileid: back.fileid, filename: back.filename, type: type, objectid: back.objid &#125;, function (res) &#123; if (res.code === CODE_SUCCESS) &#123; &#125; else if (res.code === CODE_ERROR) &#123; showAlert(res.msg, &apos;danger&apos;); &#125; &#125;) &#125; &#125;, error: function() &#123; showAlert(&apos;上传失败&apos;, &apos;danger&apos;); &#125; &#125;) &#125;, error : function() &#123; showAlert(&apos;上传失败&apos;, &apos;danger&apos;); &#125; &#125;)&#125; 没维护了，以后接着看吧。 php 文件处理，主要包括文件的分割和合并 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function file_split($file,$block_size= 2 * 1024 * 1024)&#123; $block_info=[]; $size=filesize($file); $i=0; while($size&gt;0)&#123; $block_info[]= [ &apos;size&apos;=&gt;($size&gt;=$block_size?$block_size:$size), &apos;file&apos;=&gt;$file.&apos;.&apos;.$i++ ]; $size-=$block_size; &#125; $fp = fopen($file,&quot;rb&quot;); foreach ($block_info as $bi) &#123; $handle = fopen($bi[&apos;file&apos;],&quot;wb&quot;); fwrite($handle,fread($fp,$bi[&apos;size&apos;])); fclose($handle); unset($handle); &#125; fclose ($fp); unset($fp); &#125; function file_combine($file,$save_file=&apos;&apos;)&#123; $filename=basename($file); $filepath=dirname($file).&apos;/&apos;; $block_info=array(); for($i=0;;$i++)&#123; if(file_exists($file.&apos;.&apos;.$i) &amp;&amp; filesize($file.&apos;.&apos;.$i)&gt;0)&#123; $block_info[]=$file.&apos;.&apos;.$i; &#125;else&#123; break; &#125; &#125; if($save_file)&#123; $fp = fopen($save_file,&quot;wb&quot;); &#125;else&#123; $fp = fopen($file,&quot;wb&quot;); &#125; foreach ($block_info as $block_file) &#123; $handle = fopen($block_file,&quot;rb&quot;); fwrite($fp,fread($handle,filesize($block_file))); fclose($handle); unset($handle); &#125; fclose ($fp); unset($fp); &#125; php上传大文件有种就是先用php进行文件分割成小文件，然后小文件上传，然后上传到服务器上进行大文件合并。但有个问题就是php读取文件的fopen就8192字节，也就是8192B，一般上传文件都是4mb的上传，所以用的linux split分割文件后，放入文件夹里面，然后遍历文件夹，读取内容，写入操作的时候传入同一个objectid，往同一个文件里面写入]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStorm开启断点调试]]></title>
    <url>%2F2018%2F01%2F22%2FPHPStorm%E5%BC%80%E5%90%AF%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[关于xdebug。作为一个phper，相信大家平时的调试用的都是var_dump,echo之类的，像我之前不知道var_dump可以打印出多个变量，在写代码的时候，经常为了打印多个变量，要写很多var_dump,后来无意间解除了xdebug，虽然现在还是经常用var_dump,但我感觉这类的辅助工具都是为了更好的，更高效率的完成工作，得变通，什么方便，什么自己用的舒服就用什么。平时的我感觉xdebug对于框架的学习，和自己平时不熟悉的代码的时候用的方便，var_dump,我一般用来进行简单的调试。1.原理没去看了 2.安装首先得安装xdebug的php扩展。相比较windows和linux, 在他们各自下面安装扩展的方式不同，windows下需要考虑的难点就是thread safety 等因素对源码包的影响，我们该如何选择dll文件，linux下面就是源码编译安装啦。 这个xdebug的官网(百度他的网站，http://xdebug.org/wizard.php)对xdbug的windows安装简直是更加友好，因为对于别的扩展，我们可能需要自己去网上查询windows下下载对应php扩展需要关注的一些信息，但是xdebug他的官网上只需要我们把你的安装的php的pathinfo() 的内容粘贴过去，她能自动帮你选择扩展版本，我们只需要把php的扩展放到对应的路径下就好了，然后修改php.ini。(关于linux下呢，同之前的文章linux下安装别的扩展，软件是一样的。先下载源码包，pecl上下载，然后查看是否包括 configure 文件，没有的话phpize生成，然后 make &amp;&amp; make install, 需要指定php版本的话通过 with-php-configu=路径/php-config)。安装完成之后查看pathinfo，搜索xdebug，或者php -m 查看xdebug是否安装成功。这里注意下我们通过xampp这类软件安装的lamp其实不是lamp，这个l linux根本不存在，我们用的是w，windows。 (如果没有在官网上找到如何帮你选择dll文件，可以看这篇文章 帮xdebug选择合适的安装版本) 3.phpstorm的配置之前的配置在网上找吧，因为懒得截图了简书上的这篇文章对安装方法写的很详细 4.注意事项 首先是关于断点的位置。代码会在断点之前结束，所以如果想要获取断点处的内容，务必在该内容之后打上断点。记得老师在将课程的时候甚至在这个方法结束处的 } 打了断点。 之前遇到的一个问题就是多个断点，只是执行了其中的几个断点，并没有执行完所有的断点，以为是使用的方法不对。后来发现其实是两个断点之间的代码有bug，导致后面的端点没有执行，··所以其实还是自身的问题。 断点调试的时候，所以的端点前面会有 √ 的标志，断点执行的那行代码会有颜色加深的标志。断点执行完，所有的 √ 的标志会没有。只要断点执行完了，接口才会有输出，并不是执行到哪个断点，哪个端点前面会有 √的标志。 代码可以一行一行的执行，也可以从这个断点直接跳转到下个断点，这样的好处是，对于复杂的框架可以知道代码是怎么执行的，然后断点间的跳转也可以迅速定位解决问题。但好像不同php文件断点间跳转，只有一个页面那个地方会对变量有输出。 变量的输出在下面那个debug tab标签处，开启断点调试，会在页面的url路径后面有xdebug_session 标志，把这个标志粘贴到不同的url，就能对不同的api进行测试，其实感觉这个就像一个接口一样，只要传递这个参数，就能执行这个debug接口的服务功能。 断点调试的关闭，··关闭那个phpstrom上方的类似电话的监听按钮肯定能关闭的，现在想了下，关闭下方tab肯定也是可以的，记得我每次close tab 他都会提醒是否close connect，断点调试的开始按钮是phpstorm的那个小瓢虫的标志。 7.对于windows下xdebug的配置和linux下还不一样 1234567xdebug.idekey = &quot;vagrant&quot; // 这个要和phpstrom中添加的内容保持一致xdebug.default_enable = 1xdebug.remote_connect_back = 1xdebug.remote_port = 9001 // 和phpstrom中保持一致xdebug.remote_enable = 1 // 调试vagrant中的项目属于远程调试xdebug.remote_autostart = 1xdebug.remote_handler=&quot;dbgp&quot; 这个是php.ini 中需要添加的内容 我们在调试部署在windows下的php代码的时候，属于本地调试，但我们调试部署在vagrant中的内容的属于远程调试，所以当我在查询如何安装xdebug的时候一定要加上vagrant或者是linux，因为有些小细节还是不一样的。 notice: 1zend_extension = /opt/php/lib/php/extensions/no-debug-zts-20151012/xdebug.so 注意是zend_extension,要是extension的话，可能找不到 详细的（配合vagrant）配置方案，防止以后找不到： 这个地方的server就是上一步新建的server，我们这个地方需要新建PHP HTTP Request 或者是PHP Web Page，我一般用的都是PHP web page，这两个有什么不同呢，感觉简单的说就是一个是页面，一个是api接口，web page 会在每个url地址后面加上参数，但是api接口不用，web page通过安装一个xdebug的插件，可以让自己不用每次请求都手动添加那个参数。 我们想调试，必须打开这个监听端口，也就是第二个按钮打开后，我们就要开启调试了，点击第一个按钮第三个按钮肯定就是停止这次调试的意思啦 第一个感觉就是重置的意思，比如重新打了断点，重新从头开始debug,相比较点击那个小瓢虫，感觉就是不会新开一个debug的框框，但是xdebug那个参数还是会变的第二个就是类似脚本执行，一步一步往下走第三个就是显示每一步代码的执行过程第四个就是每次跳转到光标处，如果两个端点之间没有光标，会跳转到下一个端点处 凯哥说第一个还挺好用，但其实自己用的比较少，第二个可以展示当前执行到那个文件了，第三个控制是否展示空的数组内容，感觉还是显示吧，否则有些想用的变量都找不到 2.首先我们需要在setting 目录配置php的解释器， 虽然我们用的是vagrant，但最好不要选那个，因为默认是127.0.0.1：2222连接，但这个ssh是连不上我们的那个vagrant，但我又不知道如何修改这个默认连接，所以只能通过第二个。第二个的远程配置和我们通过修改本地代码实现线上同步是一个道理，都是通过sftp协议，然后注意要选择custom，因为这样我们就可以不通过用户名和密码，而是密钥的形式进行远程连接了（之所以这样，是因为很多服务器我不知道密码啊，只有密钥） 3. 接着是端口，和前面php.ini 中保持一致，注意php-fpm 是9001，别冲突了 4. 还记得之前php.ini中的设置吗，需要和这上面保持一致 5. 这个注意下我红圈标注的地方就好了 6. notice: 我们每个项目中配置的xdebug，只能在该项目中使用，类似我之前在laravel 当中配置的sql语句调试工作，也只能在本项目中看见 windows 下调试遇到的错误 phpstorm报错：Remote file path ‘XXX’ is not mapped to any file path in project（本地调试不要勾选） 下面是简单脚本的调试 https://www.cnblogs.com/yjken/p/8435018.html 今天凯哥教了一种脚本断点调试的方法，直接右键，debug 就好了，非常方便，我以前是按照上面的为每个脚本配置一个，很不方便 凯哥平时跑的python 都是cli 模式 php 除了cli 平时用的比较多的还是php-fpm 模式（之所以xdebug 那么难调整，是因为在php-fpm 下面比较难调整），对于php cli 下面还是和python 一样简单]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
        <tag>工具</tag>
        <tag>调试</tag>
        <tag>Xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lamp 和 lnmp 源码编译]]></title>
    <url>%2F2018%2F01%2F19%2Flamp-%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[lamp的源码编译安装。！！！注意哦，这里面是lamp，不是lnmp。之前的lamp中，apache和php的交流主要是apache把php作为自身的一个模块，而ngixn是通过cgi，php-fpm进行管理进程（这段话有待考证，因为apache也能使用php-fpm进行管理，并不是php-fpm和apache绑定的。我们那个lamp环境搭建的时候安装好apache,编译php 的时候要指定apxs的位置，–with-apxs2=/app/httpd24/bin/apxs ,这之间的交互过程还不是特别清楚）。 所以lamp的编译安装是有顺序的，因为php在编译的过程中需要指定apache的apxs模块位置。 apahce 的编译安装apache2.4之后编译安装之前需要apr和apr-util的支持（这两个文件下载位置，百度，好像在apr.apache.org下面，首页上面只是展示最新的，注意有个archive.download.sit,点击他，你会发现新世界的大门）apache在httpd.apache.org下面下载（讲道理我不知道他们之间的搭配有没有版本限制，so 下载的时候都下载最新的？比较靠谱的办法就是网上再找一份教程上面有apr apr-util apache的版本，对照着做就好啦··我的文章只是自己的思路呢）。 12345[root@localhost src]#pwd/usr/local/src[root@localhost src]#tar zxvf apr-1.6.2.tar.gz [root@localhost src]#tar zxvf apr-util-1.6.0.tar.gz [root@localhost src]#tar zxvf httpd-2.4.27.tar.bz2 安装apr-util之前得先安装apr，因为需要配置 （–prefix==/usr/local/apr），上面的三个编译安装或者 说所有linux的软件编译安装都是一个套路 : 1.进入解压目录，./configure 配置参数，百度吧 2.make 3.make install 4.查看 需要注意的就是可能安装的时候要安装额外的包，其实刚开始没安装也没什么大事情，后面编译肯定通过不了，所以就百度，一下子就能出来答案。 还有就是 configure 文件不存在，怎么办？一般目前我遇到这种情况主要是在编译安装php扩展的时候，可以通过 phpize(这个命令在php安装生成的bin目录下的一个指令),运行后会生成configure脚本，然后再像上面一样执行 参考文章：centos7 源码编译httpd7其实这一块都不用lamp中安装apache和单独安转apache没啥区别。 notice : （而且后来发现一个问题 apachectl start 这些用不了，应该是按照上篇博客中安装出现的问题，其实还是要解决下，因为在lamp中，刚开始修改php.ini 是很常见的，每次修改都需要apachectl restart 一下还是很方便的) ​httpd -k start 这戏好用 ​其实ps -ef|grep httpd ,也能看到这个httpd 的命令 把apachectl 添加到环境变量中，我一般通过的方法是 1234567vim /etc/profile HTTP=/usr/local/apache/bin$PATH=$HTTP:$PATHexport $PATH需要注意的是我们在使用变量的时候会从前往后找的，比如http 和 path 中都有 apachectl,但是http 在最前面，会使用前面的http中的apachectl, 通过 which apachectl可以查看这条命令来自哪里（yum安装的软件可能把命令自动加到/usr/bin 里面去，卸载的时候也删除不掉，这个很坑爹，需要注意下，经常用的时候不是你想用那条命令，所以一直加在前面可能会避免一些这样的事情发生）source /etc/profile 让他生效echo $PATH 看是否包含了你需要的路径 我在正常启动apache 之后，外网总是访问不了，通过查看配置文件的日志 access_log 是空的，error_log中有内容，但其实是notice 级别的错误，一直以为是这个原因导致外网不能访问，百度了好久这个错误信息，都没有找到解决办法，问同事，演变成apache正常启动，外网访问不了的问题，先通过curl 127.0.0.1:80 来尝试访问，得到内容， it works 说明服务器没有问题，想到防火墙，看了下服务没有开启，想了下selinux 也没有开启，最后是阿里云的锅，zzz,其实问题很简单，解决过程也很简单，只是自己很笨，不知道怎么去排查问题 虚拟主机的配置，测试外网是否能访问，需要修改配置文件，需要注意的点 开启httpd-vhost,需要包含，然后再那个配置文件中写入 开启apache rewrite模块 开启端口监听，Listen 0.0.0.0:8080，注意0.0.0.0 默认查找Index.php，除了在虚拟主机的virtual host 中配置，在外层的配置文件中也要配置 开启php文件处理，主配置文件中修改， 这时候在apache的根目录下访问phpinfo这种文件还是不幸的，需要支持对php的mime类型解析，（想了下框架不能处理json输入是因为框架原因，还是web server原因）1AddType application/x-httpd-php .php 默认apache 运行用户是daemon,当我们在php 中运行写日志的比如seaslog,默认写入是/var/log,daemon用户没有写入这个文件夹的权限，我们需要修改文件夹权限或者新建新的文件夹或者修改运行用户等 nginx 编译安装参考网上 nginx -s reload 重启 nginx -t -c conf 检查配置文件的语法，并不会执行 mysql 编译安装失败，用的yum安装（直接下载编译好的二进制码比较好，比如subline下载之后直接就能使用，不用安装，这些java写的东西啊，好用，但是mysql不行，即使是编译过的二进制码，还要执行一些脚本） postgresql 的编译安装（网上的教程很详细）这个下载速度很快，可以考虑源码安装 有两个配置文件，一个用来进行用户权限的限制，一个好像是具体的配置 有两个目录，一个专门装数据，一个装软件，比如命令这些 默认root 访问不了，创建postgres用户和组（源码编译，yum的话自动创建），修改配置文件trust pg_config 这个命令很重要，安装中文搜索引擎，先安装scw库文件，再去安装zhaper这个分词，多个pgsql 一定要指定pg_config（好像指定不起作用,一定要把pg_config 直接运行的这个命令对应的pgsql 对上你想要装扩展的pgsql,要不然在数据库里面创建扩展会不成功 create extension ） 可以通过sql语句查询配置文件的位置（locate 不知道为啥找不到/mnt 下的文件，坑死我了） php编译安装 php.net 上下载源文件 安装额外的包1yum install libxml2-devel bzip2-devel libmcrypt-devel 3.编译安装php7123456789101112131415161718192021222324[root@localhost php-7.1.10]#./configure \&gt; --prefix=/app/php \&gt; --enable-mysqlnd \&gt; --with-mysqli=mysqlnd \&gt; --with-openssl \&gt; --with-pdo-mysql=mysqlnd \&gt; --enable-mbstring \&gt; --with-freetype-dir \&gt; --with-jpeg-dir \&gt; --with-png-dir \&gt; --with-zlib \&gt; --with-libxml-dir=/usr \&gt; --enable-xml \&gt; --enable-sockets \&gt; --with-apxs2=/app/httpd24/bin/apxs \&gt; --with-mcrypt \&gt; --with-config-file-path=/etc \&gt; --with-config-file-scan-dir=/etc/php.d \&gt; --enable-maintainer-zts \&gt; --disable-fileinfo# 进行编译安装[root@localhost php-7.1.10]#make -j 2 &amp;&amp; make install 注意那个with-apxs2 的选项下面那个 make -j 2 指的是用两个cpu进行编译 注意这时候时没有配置文件的，到解压的php文件夹下1[root@localhost php-7.1.10]#cp php.ini-production /etc/php.ini notice 编译php7的时候with-config-file-path 指定了配置文件的位置,这个是很重要的，因为要不然我们没有指定也没有放在默认的php文件存放位置，以后每次运行php 的时候都要指定 配置配置文件的位置很麻烦 测试phpinfo， 看到了local value 还有另一行没，之前看过好像一个是apache 中指定的位置，但是本地可以通过脚本修改，所以local value 是实际的位置 讲道理，上面的编译参数运行不了， –with-config-file-scan-dir=/etc/php.d \，感觉是这个参数在作怪，不太明白这个文件夹中装的啥，反正是开启了一些curl 等的扩展，但实际上好像没有开启，所以需要把屏蔽掉（上面的php 编译参数不太好用，像curl 都没有开启，在项目中用会出错） php 源码包的作用。像pgsql 这些扩展，源码包中都是有的，如果想开启，不用再网上下载，直接去源码包的ext 下面找就好了，然后phpize php -m 查看是否成功。需要注意的是，一个包编译失败之后，再次编译，最好make clean一下。（pgsql 和 pdo_pgsql 是两个扩展···）(知道pgsql 和 pdo_pgsql 的关系嘛， pgsql 只是一个pgsql 的驱动，pdo_pgsql 只有在他之上，才能和php 进行交互，同理联想mysql, php的mysql引擎是 mysqlnd, pdo_mysql 是在这个引擎之上让php和mysql 进行交互的，感觉我要是用了mysqli扩展是不是不用安装mysqlnd扩展了)123456 ![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190711170145.png)5. 关于错误信息的输出。php.ini 有不同的两个版本，development, product， 虽然我没有研究过他们的不同，但目前发现最基本的就是，开发版本会把错误信息输出在页面上，但是生产版本不会，是php.ini 中一个选项的原因，生产版本可以把错误信息输出到日志中保存，好像nginx fpm 那种比较复杂，lamp这种直接在apache 的错误日志中就可以找到。（多熟悉lnmp,最好完全切过来，熟悉swoole）6. 关于php-fpm的配置。这里拿lnmp 来举例，nginx 接受外来请求，转发到php-fpm (php进程管理器，默认监听端口9000) master 进程长，master 进程分别把请求转发给work进程，woker 进程实现了fast-cgi协议 (默认启动几个woker进程，接受请求，请求接受完不断开链接，接着等待，但是可以设置最大请求数量，当达到最大请求数量的时候进程会重启，防止内存泄漏，感觉类似swoole 的进程模型，只是这里面每次还是会重新加载php脚本，所以每次我们修改代码不需要重启)，内嵌php解释器，需要注意的点就是在上面架构中nginx 只是起到转发的作用，我们需要把一些必要的参数携带上转发给我们的php-fpm，这样我们的php才能正常接收到外来请求（php-fpm和 nginx 通信可以通过sock ，常见 tcp 127.0.0.1:9000, 或者unix socket文件，但是unix文件不能让部署在另一台机器上的php-fpm和这台机器上的nginx通信） location ~ \.php { 36 root /home/itbasic/new_datatalk/api/; 37 fastcgi_pass 127.0.0.1:9000; // tcp连接 38 fastcgi_index index.php; 39 access_log logs/access_datatalk_api.log test; 40 error_log logs/error_datatalk_api.log error; 41 fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 这个script_filename 将会被传递给php-fpm,php-fpm 也会传递给php/index.php/api/leave/count, php 能识别这样的连接，并且识别index.php 是脚本,/api/leave/count 是uri 42 include fastcgi_params; 43 44 } 45 46 # 因为前后端分离，后端是在/api下面 # 调试nginx 的几个方法，return &apos;200 ok&apos;; 注意末尾都要有分号，但是这个return 好像只能返回状态码，只能用在nginx 的正则中进行测试，看是否走到这个 location 中，如果想查看nginx 中变量的值的话，可以通过log_fmat test &quot;$request_filename&quot; access_log log/access.log test ,这样记录到日志中，在日志中查看 # 对于虚拟站点的请求最好都写上access_Log 和 error_log ,监控请求是否按照我们的想法走 47 location /api/ { root /home/itbasic/new_datatalk/api/; # 每个匹配都要加上root, 因为各个匹配是平级的关系，后面判断request_filename 的时候是会拼接上这个root的 48 access_log logs/access_datatalk_api.log main; 48 access_log logs/access_datatalk_api.log main; 49 root /home/itbasic/new_datatalk/api/; 50 if (!-e $request_filename) { 51 rewrite ^(.*)$ /index.php$1 last; # 代表在请求前面加上/index.php,last在location 里面代表直接跳出这个location，重走所有的location 52 break; # 感觉可有可无，这个地方是直接终止生命 53 } 54 55 56 } 12345678910111213141516171819202122232425上面我们配置了nginx 的accesslog 和 errorlog,接下来我们需要配置php-fpm 的access_log error log 和 slow_logaccess_log slow_log 在 php-fpm.d 下面的default 配置文件中，对于slow_log ,我们还要设置多长时间才记录，如果是0的话代表不开启error_log 在 php-fpm.conf 中，我是这么理解的，上面两个代表了某个站点的，所以需要单独配置，这个php-fpm 代表整个php-fpm 软件的，所以需要统一配置，他记录的是php-fpm这个软件的错误另外因为默认php-fpm 关闭了work进程的错误输出，我们是获取不到php的错误内容的，我们需要开启catch_work_error 这个配置，然后修改php.ini ,error_log 位置，error_reporting 级别，这样php的错误日志就能在 php.ini 中配置的地址出记录（！！注意不是php-fpm 的error日志），如果没有写权限，默认会输出到nginx 的错误日志上（注意我们的日志文件一定要有w权限，之前一直用的755 没有w权限）如果能写上，那就不会输出到nginx 的错误日志上我们修改了php的配置文件一定要重启php-fpm(nginx 没必要重启)kill -USR2 pid (swoole 的重启USR1 ,并且不会修改pid, 当我们修改一些swoole的配置文件或者php自身的时候，一定要kill -9 再启动，否则上面的重启没有用)![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190711174208.png)上面是慢查询日志，主要看那个sleep ，剩下的函数都是因为那个sleep导致的php 错误级别 error_reporting=E_ALL &amp; ~E_NOTICE // ~代表出资之外，不包含的意思``` 今天在使用composer安装文件的时候提示php版本太低，其实composer 本质上可以打开看一下是一个php的脚本，类似shell脚本，在脚本开始的地方定义了解释器，所以我们直接 composer 就能运行这个脚本，类似我们平时运行 shell 脚本一样，但是那个解释器是在我们没有指定解释器的情况下默认执行的，当我们制定了解释器，那个默认解释器就不起作用了，所以这时候我们只需要 php7.1 composer install xxx 就好了，但是如果composer不兼容以前的话，我们还是得下载最新的composer喽 composer install xxx , 这个install 和 xxx 都会作为参数传进去，通过 $argv可以获取到 redis 的安装需要注意的就是 redis 启动服务要手动指定配置文件， 遇到的问题就是估计之前别人在路径中加入过redis-server 这个命令，导致我用 redis-server /opt/redis/conf/redis.conf 不匹配，出错， 还有有个配置选项是是否展示cli 下 那个命令行redis图像，果断关闭，虽然不知道他为啥报错 改成守护进程模式 之前测试测试数据库总的出错···总结了下原因 不能清楚的认识到mysql怎么连接数据库的。其实换一种思路，php是怎么连接redis的，我们安装好redis服务，然后安装php的redis扩展，就可以了。什么连接函数啊和连接mysql是一样的。关于php连接mysql，现在主推两种方式，mysqli和pdo，分别对应两种扩展，具体的可以参考菜鸟教程里面的这个php连接mysql。 mysqli() 第一个参数’localhost’ 和’127.0.0.1’ 的区别，localhost 连接基于socket，这个文件的位置在php.ini有指定，如果换了位置，则找不到。127.0.0.1基于tcp，就可以啦，不用那个文件，参考链接segmentfaultmysql 这个status挺好用的哈哈]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>环境</tag>
        <tag>lamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lnmp 环境搭建]]></title>
    <url>%2F2018%2F01%2F19%2Flnmp-yum%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[关于lnmp环境的yum安装。作为一个phper，肯定得熟悉。之前写过关于在windows下php环境的搭建··咳咳咳，其实那根本算是搭建，像xampp都是把环境搭配好了，自己只是做了配置虚拟主机，然后运行框架。框架在我的理解中本身除了yaf之类的安装，主流的框架tp，yii，laravel更像是一个文件夹，代码的集合体，这个文件夹中各个子文件夹联系紧密，成为一个整体。当外来请求通过lamp进入到入口文件，路由进入到控制器，模型层，数据库，变成一个有用的数据返回出来，再通过lamp返回给浏览器，上面的流程就很容易发现，简单的像apache,nginx里面的配置文件定义，只是让外来请求找到这个入口文件，进入到入口文件里面之后就靠框架的路由寻找具体的控制器了。lamp环境方便的让外来请求比如对于index.php的请求，如果是直接在linux中，我么需要php (编译器) 可能还需要 -c指定配置文件的位置 文件.php,这样。但是如果是lamp，我们可以通过浏览器直接访问这个php文件。 首先是yum源的安装，更新。 123[root@localhost ~]# rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm[root@localhost ~]# rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm[root@localhost ~]# rpm -Uvh http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 先说这个mysql yum安装，现在要通过这个社区版。 然后剩下两个是为了安装第三方软件用的。这个epel以后可能经常用到，虽然没lamp好像只要这个webtatic就可以了。之前添加源的时候看过一篇文章，好像是说最好不要和官方源里面有内容冲突。这个epel很合适，大家都在用，当然自己也就用咯。 yum安装nginx，mysql，php 123[root@localhost ~]# yum -y install nginx[root@localhost ~]# yum -y install mysql-community-server[root@localhost ~]# yum -y install php70w-devel php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-pdo.x86_64 php70w-mysqlnd php70w-fpm php70w-opcache php70w-pecl-redis php70w-pecl-mongo 其实这里面比如php7安装的那几个我也不懂，据说把70w改成71w就能装7.1版本了。 yum安装的一个好处是通过systemctl enable 能控制软件的开机启动 关闭，通过systemctl status 能看软件的状态，启动，关闭。默认安装的mysql没有密码，可以直接登录进去。据说要配置默认编码，utf8，但我好像没有配置，它自动就是utf8。 12345[root@localhost ~]# vim /etc/my.cnf[mysqld]character_set_server=utf8init_connect=&apos;SET NAMES utf8&apos;[root@localhost ~]# systemctl restart mysqld # 重启 MySQL nginx的配置 1234567891011121314location / &#123; #定义首页索引文件的名称 index index.php index.html index.htm; &#125;# PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.location ~ .php$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 注意这块document root的位置，要卸载location外面，我之前写在上面那个location里面，下面那个location获取不到。 重启nginx，重启php-fpm. 测试是否成功。在nginx根目录下 &lt;?php echo phpinfo();die; 看能不能输出php信息咯。其实还可以检测下和mysql的连接。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>lnmp</tag>
        <tag>环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php安装扩展]]></title>
    <url>%2F2018%2F01%2F18%2Fphp%E5%AE%89%E8%A3%85%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[好久没有写文章了，今天来说一下关于php的扩展，虽然自己理解的不是很深，也没有仔细去研究，只是把平时工作中遇到的情况，解决途径写下来，还有很多不足的地方，以后去补充 php的扩展大部分都是c编写的，php -m 可以列出我们php中安装的扩展 其中swoole就是现在很火的php扩展。以这个为例子Linux下安装 获取tar.gz压缩包（可以去github上直接下载，或者去pecl（php 扩展库里面搜索））。 解压缩 tar xvf 进入解压缩目录（如果进入解压缩目录内部文件是so结尾的，不是.c 之类的结尾的，不用进行后面的操作） phpize (这个命令在php的安装目录下，bin目录下，和php命令在一个目录下) ./configure 生成配置文件，之前安装swoole的时候需要指定php-config,这可不是php的配置文件，也是一个命令，和上面的php，phpize在同一个bin目录下，如果想看更多参数可以 –help, make make install (安装失败make clean，重新再来呗)8.生成的so文件自动放到了/usr/local/php/lib/php/extensions/no-debug-zts-20160303，然后在php.ini 文件里面加上一句extension = swoole.so就可以了 可能需要ldconfig下，http://man.linuxde.net/ldconfig windows下安装 大部分都是xampp的这种集成环境，首先去pecl上下载dll文件，··像swoole我是没找到windows下的扩展文件，需要根据php版本 vc版本 TS Windows版本（windows一般是x86 和64，操作系统位数） 来选择 扩展文件的版本 解压后，把dll文件放到php的扩展目录下ext下面，然后在php.ini里面加上zend_exten```= 这个扩展文件名。就可以了 之前安装redis扩展的时候，···当时用的是xampp，··然后安装好了redis扩展，可是使用不了。坑爹啊，window下我都没安装redis，光安装redis扩展有什么用，····其实这个扩展知识为了让php能操作redis，像apache，在编译安装php7的时候，也要指定apache的apxs之类的位置。 坑： 机器上安装了挺多php的，有5.6，有7，因为7编译安装的时候没有填写配置文件的位置，默认应该是放在/usr/local/lib目录下（php -r “phpinfo();”|grep configure, 注意一定要在phpinfo();后面加引号，查看编译安装参数，像apache，直接去安装目录下的build文件夹里面，查看就可以了），而我的机器上一直还有/etc/php/php.ini 这个配置文件，因为php安装的时候是不存在配置文件，讲道理编译的时候没有写配置文件的位置，应该放在/usr/local/lib目录下，但他还是放在了/etc/php/php.ini,聪明的apache自动去找到了这个配置文件，但当我在默认/usr/local/lib目录下放置了php.ini的时候，他是去这下面寻找的，以前的那个就废弃了。apache可以指定php配置文件，只需要在apache的配置文件里面指定下，地址：[http://www.jb51.net/article/106111.htm] php -m 的好处就在于不用重启服务器，就能看到已经加载的php模块，php -r “phpinfo();” 执行后面的函数返回结果。 php -c 指定配置文件的位置，注意 php -m -c 加载扩展的时候默认使用的是默认配置文件的位置，php -c 文件位置 -m 这里才是新的配置文件位置方式加载扩展。 遗留的问题： php -m显示出扩展swoole ， phpinfo 页面没有这个扩展]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Linux</tag>
        <tag>扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见问题]]></title>
    <url>%2F2018%2F01%2F09%2FLinux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[因为linux平时用的不是很频繁，所以经常会遇见一些问题，然后很容易忘记，然后还经常遇到，所以记录下来。 目录： yum源替换 修改密码 locate 查找文件 添加环境变量 ~ 普通用户和root用户 1.yum源的替换我们每次安装centos的时候，如果不是打包安装，是从新安装的话，为了安装软件速度快点，我们通常会替换yum源，把国外的镜像替换成国内的yum源镜像。常用的有163，阿里云啊。首先我们进入 /etc/yum.repos.d 文件夹下面，查看repo文件，把centos-base 这个yum源文件改名，作为备份文件（mv,剪贴，又能当做重命名来用，注意不是复制哦）。然后wget，国内的yum源地址，yum clean all 清除缓存，yum makecache 在本地生成源的软件信息，方便软件的查找。总结： cd /etc/yum.repos.d 进入目录 mv centos-base.repo centos-base.repo.bak 备份文件 wget -nc http://mirrors.aliyun.com/repo/Centos-7.repo 下载原文 yum clean all 清除缓存 yum makecache 生成缓存 12345* 阿里yum源:[http://mirrors.aliyun.com/repo/](http://mirrors.aliyun.com/repo/)* 163(网易)yum源: [http://mirrors.163.com/.help/](http://mirrors.163.com/.help/)* 中科大的Linux安装镜像源：[http://centos.ustc.edu.cn/](http://centos.ustc.edu.cn/)* 搜狐的Linux安装镜像源：[http://mirrors.sohu.com/](http://mirrors.sohu.com/)* 北京首都在线科技：[http://mirrors.yun-idc.com/](http://mirrors.yun-idc.com/) 2.修改密码passwd 用户名 root用户，非root用户只能修改自己的密码哦，所以passwd后面不能加参数 3.locate查找文件 locate 命令的使用之前一直使用find / -name 文件名，太慢了，使用locate吧。首先yum install mlocate,然后updatedb ,就可以使用locate 文件名称。每次使用前locate 文件名称。（如果是安转好了，每次使用前只用updatedb,然后再locate 寻找就好了） 4.添加环境变量 lamp环境如果通过源码编译安装，安装的位置一般是/usr/local,命令一般在/usr/local/软件/bin/命令，每次使用起来这么一大串，是在麻烦，加入环境变量效果棒棒的 echo $PAHT 查看环境变量 编辑/etc/environment文件，在里面更改PATH环境变量。 例如：向环境变量中添加 /home/YRS/Nim/bin /usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/home/YRS/Nim/bin，保存后记得source /etc/environment 。重新启动后就不用source 。 ​ 5.普通用户的 ~代表家目录，比如/home/vagrant,但是root用户的这个~代表根目录 /home 6.别名 alias 这个还是挺重要的，编辑环境变量可以帮助我们添加一些可以直接执行的命令（类似封装了 /opt/php/bin/php -&gt; php），别名其实和这个作用类似，但是如果我们安装了两个版本的php, 都添加到环境变量里面，容易分不清楚，我们可以取别名，比如 （alias php7.1=’/opt/php7.1/bin/php’ ） 123456// 实际例子alias composer7=&apos;php7.2 /usr/bin/composer&apos;// 我们在使用php 进行composer 安装的时候提示php 版本过低composer install 其实是 php composer.phar install所以我就想到了alias composer7=&apos;/opt/php7.2/bin/php /usr/local/composer.phar&apos; alias -p 查看所有的alias vim ~/.bashrc // 修改alias source ~/.bashrc // 让alias 生效 ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>常见问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn Git 思考]]></title>
    <url>%2F2017%2F12%2F20%2Fsvn-Git-%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[很老的文章了~~总结一下我们的代码发布流程，本地svn commit 到svn 服务器，线上linux 安装一个svn， svn update 代码到线上服务器。 ···今天碰到一个问题，其实这个问题好久之前就没碰到了，只是之前可以通过别的方式化解，然后今天没法通过别的方式解决了，只能通过正确的方式解决。 问题描述：在线上修改了代码，怎么更新到本地。 直接通过小乌龟update，肯定不行。因为小乌龟是直接从svn服务器上更新内容，然而我是线上的代码修改了，而不是svn服务器上的文件修改了。 之前我们这个小项目提交代码到线上是这样的，本地修改后，用小乌龟提交，然后连接到服务器上，切换到网站根目录下，svn up，这样线上就能正常访问了。正是这个过程导致了我一个误区，我以为svn的工作流程是这样。 但其实他应该是这样 其实线上网站根目录下文件夹也是svn客户端服务的内容，他只是svn服务器大脑下的一个分支 之前的错误概念还有就是把线上服务器的内容等同于svn大脑的内容。举个例子，在实际的大项目中，代码整理后，要经过测试环境等等多重步骤才能发布，放到正常的生产环境中，如果我们直接把大脑合并的内容放到生产环境中，这样是太不合理了，这样感觉会导致线上的代码太不稳定了。 所以，正如第二个图中看到的一样，网站根目录也是从线上代码往下拉的，所以我们对线上代码的提交，就应该和我们平时提交代码一样，只是我们平时用小乌龟习惯了，可能已经忘记命令了，还有svn up是svn update的缩写，这个up并不是提交的意思哦（···误导我一年了）。 所以，我们在线上svn commit（svn ci）缩写，必备参数 -m(我原先以为svn不需要，肯定是小乌龟做了处理)。这样就能把代码更新到svn服务器上，然后别的同事svn up就可以了。 svn提交失败，经常需要clean up，可是呢，点击clean up的时候又会显示clean up失败，请clean up，无限死循环。可以进入当前目录的.svn目录下，用Navicat 打开那个wc.db文件（用Navicat打开，如何打开请百度 ），然后清空 work_queue和wc_lock就好了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>svn</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant使用]]></title>
    <url>%2F2017%2F12%2F13%2Fvagrant%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用vagrant的原因？ 其实主要是因为来公司的时候用的这个东西，相比于传统的xampp这种window下的一体化工具，vagrant其实是在vitrual box 之上的一种管理工具，他是基于虚拟机的，所以你可以在虚拟机上干的事他都能干。 首先xampp是window平台下的，他的lamp这个l不具备，所以，你xampp永远都接触不到linux，但是vagrant不同，他是基于虚拟机的，虚拟机可以装linux，所以使用vagrant，你可以使用linux。 使用vagrant首先得加载镜像，这个镜像就相当于最原始的环境，他是个box文件，想象一下，如果这个镜像是你们生产环境的打包，那你是不是就不用做别的处理就可以直接使用了，节省了新人安装环境的成本。 其实vagrant 构建开发环境分为两大部分，第一部分是加载镜像，这主要和box有关， so,先来介绍几个关于vagrant box 的相关命令 vagrant box add (镜像名自定义) 文件路径 （建议下载到本地，vagrant cloud 上面的文件下载很慢） vagrant box add（命名空间/文件名） 其实这样也是可以的，只是很慢 这样下载的文件放在了windows 用户 目录下面的 .vagrant 下面的box文件里面 这个可以修改的 setx VAGRANT_HOME = “” 路径名 /M 就可以了,/M代表整个系统都修改了 set 环境变量名 这样得到环境变量的值 set 环境变量= 这样是删除环境变量 vagrant box remove （box名称） 这样是删除box文件 vagrant box list 展示有哪些box文件 这样把远端或者是本地的box文件加载到系统中，如果是下载的.box文件就可以删除啦 镜像加载完成啦，接下来干嘛呢，就是在这个镜像的基础上构建虚拟环境，我们得用到vagrant的相关命令。 然后呢，新建个文件夹，建议vitrual，代表虚拟环境，再在下面新建单个项目的文件夹，这样的好处是vagrant虚拟环境不容易到处都有 进入对应文件夹（后面的这些vagrant操作命令都是在这个文件夹中进行的） vagrant init （add的box文件名） 初始化，会生成vagrant file 文件，修改其中的 config.vm.box = “new_itbasic” 这个代表box的名称 config.vm.network “private_network”, ip: “192.168.33.10” 私有网络只能自己通讯，相当于虚拟机里面的桥接，不能和局域网中的别的电脑通信（这个ip地址有要求吗） public 相当于net，可以和局域网中其他通信，记得得是局域网中同一个网段哦 config.vm.synced_folder “D:\code\yaf_api”, “/home/itbasic” 设置共享文件夹，配置文件中这上面是两个\\应该是为了转义 config.vm.boot_timeout = 100 config.ssh.username = “root” config.ssh.password = “root” 这个是为了直接可以远程连接虚拟机 配置好后，vagrant up 第一次好像都是用这个，重新加载配置文件了，其实点开vitrual box，会发现自动创建个虚拟机，然后 不用的时候挂起 vagrant suspend，再启动 vagrant resume vagrant halt 是关闭，vagrant reload 重新加载配置文件 vagrant status 查看虚拟机状态 vagrant package - -output itbasic.box 去自己的vitrual环境下，打包自己的环境成box文件，方便以后使用（好像vagrant 打包环境最好把虚拟机关掉，省略后面 - - output itbasic.box 默认生成package.box） vagrant destroy 摧毁虚拟机镜像，这个是保存位置是第三个位置了，这个是由vitrual box决定的，在vitrual box的全局设定里面。 几个坑 vagrant box 可能就2.5g，可是新建的虚拟机可能要10g，这就是我之前环境一直错误，以为是虚拟机的错误之类的，其实报错信息很明显，是我的磁盘空间不足，这里不是指虚拟环境vagrant up的那个文件夹，而是c盘装的virtual box 装的虚拟环境的文件夹。 新导入的虚拟机，可能没有mac地址，需要在网卡配置里面加入对应的mac地址，通过tail -f /var/logs/message 查看启动错误日志，看启动了哪些网卡，把不用的网卡onboot = no就好了，然后再systemctl start network,还可以systemctl stop networkmanger, systemctl disabled networkmanger, 这些不用的东西。 关掉网卡之后可能ssh有问题。config.ssh.host=”192.168.33.10” config.ssh.port=”22” config.ssh.username=”root” config.ssh.password=”root” 把ssh先配置好，要不然改了网卡之后可能连接不上。config.vm.boot_timeout=100 配置好超时时间，这样就不用一直等了。 总结一下：vagrant构建环境其实一共有4个文件夹的位置 vagrant box的文件位置，box add镜像之后，.box文件就可以不要了（如果以后要用，可以直接打包生成） vagrant 的虚拟环境，生成vagrant file 配置文件的目录 基于box生成的供vitrual box 使用的镜像存储目录 共享文件夹目录（用于写代码的目录） 上面的1，3两个大文件默认都是在c盘，坑爹啊，结果我的c盘越来越小 最近遇到的问题： 1.Homestead 需要的vagrant是2.1版本，我那个是1.9，为了升级，我直接卸载了vagrant，然后装了新的vagrant，奇迹就是 vagrant box list 的时候之前的数据还在，zz，看了下文档，vagrant分为程序部分卸载和数据部分卸载，我们单单通过windows卸载的是程序部分， 如果我们删除了用户下.vagrant，那之前的数据才会丢失 2.关于vagrant init 只是通过一个镜像文件生成一个vagrant file 文件，我们在使用homestead的时候，没有使用vagrant init ,直接是vagrant up，这样也是可以的，因为针对这个box的配置文件之前就已经存在了，homestead 中配置文件的名称是homestead.yaml 3.vagrant的那些镜像应该都有个默认用户 vagrant vagrant，虽然这个用户的权利也不是很大，但是我们能通过sudo 完成我们的绝大多数操作 4.之前那些suspend 的项目需要halt，然后up，如果直接resume 会有奇怪的问题]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vagrant</tag>
        <tag>虚拟环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https通信原理]]></title>
    <url>%2F2017%2F12%2F02%2Fhttps%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[参考：https://segmentfault.com/a/1190000012196642作为一个web开发者，对于https和http肯定要有所了解，现在的我对于深层次的https通信看着还不是太懂，但是对于https和http的差别，记得有一次去中科招商的时候面试有问到过。写这篇文章的时候，主要是方便自己看的时候理解。 首先呢 https默认端口号是443，http是80，都知道http相比于http更加安全。但是安全主要在什么方面呢，http通过明文传输，post方式好像看不见，但是get方式可以通过在服务器上监听这个端口，就能看见甚至都不要解密传进来的数据。像之前的talent，远程连接（默认端口23），因为传输过程明文，而且远程连接主要就是用来远程登录，肯定要输入用户名和密码，so，通过对这个端口的监听，就能知道用户通过talent服务的这个端口传进来的用户名和密码，这个安全性的要求不言而喻，所以现在都不用了，现在用ssh。还记得每次连接服务器的时候，让你接受公钥的弹窗嘛，这是为了在传输过程中用服务器的公钥进行加密，然后数据到达服务器端，服务器可以通过私钥进行解密。之前看过一个很形象的比喻。公钥就相当于锁，私钥就相当于钥匙，我这个东西用锁锁起来了，当然就可以用钥匙打开了（这是公钥加密，私钥解密的比喻） https和http都是基于tcp/ip 协议，属于应用层，他们其实是一样的，只是https外层有个ssl包裹起来 其实本质上还是属于http协议。 https在传输过程中使用了加密，有对称加密和非对称加密。 对称加密就是在加密和加密过程中使用同一个密钥，但是这样有个不安全点就是，密钥需要进行传递，传递过程中，如果密钥被捕获了，那加密如同虚设，so，就产生了我们的非对称加密 我所接触的非对称加密有ssh加密，这个因为不管是github上开始代码的提交，还是我们开始远程建立数据库的连接，都要用到。记得我第一次给github提交代码的时候，因为window默认不支持ssh，所以下载了git客户端，在gitbash上进行操作，生成了ssh密钥，把公钥贴在了github的setting里面。（非对称加密算法好像有个叫RSA）。 因为非对称加密有些复杂，https通信过程中,注意是通信过程中，不用非对称加密，用的还是对称加密，因为我们只要保证通信过程中对称加密的密钥不被窃取捕获篡改，就可以了。所以我们在传输密钥的过程用的是非对称加密，这样就得需要服务器的公钥，我们用服务器的公钥加密我们传输数据石宏对称加密的密钥，然后传输到服务器端，服务器用他的私钥进行解密，这样密钥传输成功，我们进行通行的过程中就可以用对称加密了。 那问题来了，服务器怎么传输过来他的公钥呢，怎么保证他传输过来的公钥的安全性呢，用对称加密？不行，无法保证密钥的准确，用非对称加密，也不行，这就陷入无限的死循环中了。 其实非对称加密不仅可以用公钥加密，私钥解密，保证传输数据的数据不被获取（需要私钥解密，可是私钥是私密的东西哦，别人都不知道）到，但不能保证数据不被劫持篡改（但无法保证别人对你这个文件进行修改），还可以使用私钥加密，公钥解密，这样不能保证数据不被获取到，但是可以保证数据不被篡改（因为每个人都可能获取到公钥，然后用公钥解密你这个私钥解密的文件，但无法修改，因为一旦修改了，文件的内容和私钥加密的内容就不一样了，等到客户端接收到服务器端传过来的内容，用公钥解密后，发现内容不一样，就很容易判断到文件被修改，如果一样，则能保证传输过来文件的准确性（我对不能同时修改文件和私钥加密文件的看法是私钥是服务器所特有的，所以不能还原修改文件被私钥加密后的样子）） 首先，CA会向申请者颁发一个证书，这个证书里面的内容有：签发者、证书用途、服务器申请的时候附带的公钥、服务器的加密算法、使用的HASH算法、证书到期的时间等等。 紧接着，把上面所提到的内容，做一次HASH求值，得到一个HASH值。 再接着，用CA的私钥进行加密，这样就完成了数字签名。而用CA的私钥加密后，就生成了类似人体指纹的签名，任何篡改证书的尝试，都会被数字签名发现。 最后，把数字签名，附在数字证书的末尾，传输给服务器 因为这个传输服务器公钥的过程就是为了保证数据的不被篡改，不用管数据是否被窃取到，因为传输的是服务器的公钥，本身就是公开的，所以我们用私钥进行加密，公钥进行解密。 客户端拿到这个数字证书以后，用CA私钥对应的公钥，可以解密数字证书末尾的数字签名，得到证书的内容以及原始的HASH值。 紧接着，客户端按照证书中的HASH算法，对证书的内容求HASH值。如果通过CA公钥解密的HASH和通过计算求得的HASH值相同，那么认证通过，否则失败。 如果认证通过，就可以取得服务器的公开密钥。 所以对服务器公钥的传递本质上还是通过费对称加密算法，只是找了个中间机构ca，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。这样，就方便客户端对于数字证书真实性的验证。 客户端证书HTTPS中不仅可以使用服务器证书，还可以使用客户端证书。以客户端证书进行客户端认证，它的作用与服务器证书是相同的。由于客户端获取证书需要用户自行安装客户端证书，同时也面临着费用的问题。因此，现状是，安全性极高的认证机构可办法客户端证书但是仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入ID和密码，还会要求用户的客户端证书，以确认用户是否从特定的终端访问网银。 总结一下： 首先服务器端让ca用他的私钥对自己的公钥进行加密，然后传给客户端，客户端用ca的公钥进行解密，保证接收到服务器端公钥的准确性。 然后客户端用服务器端公钥对自己传输过程中数据进行对称加密的密钥进行加密，传输给服务器端，因为只有服务器端有私钥，所以只能服务器能解密，保证数据传输过程中密钥的安全性。 最后客户端通过对称加密的密钥给自己传输的数据进行加密，传输给服务器端，服务端用之前客户端传输过来的密钥进行对称结密，完成通信。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具分享]]></title>
    <url>%2F2017%2F11%2F29%2F%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[这篇博客的目的就是把自己平时用的比较顺手，方便能提升效率的工具分享给大家，互相交流，提升工作效率 Evernote 一款记笔记的工具，之所以用这个，是因为刚开始编程的时候，有一次记笔记，当时用的还是word，然后没保存，然后····大家都懂得，记得那时写了挺久的关于php的笔记，不知道你们有没有相同的感觉，即使再看一遍书，很容易把笔记都能写回来，但是心里还是很难受，于是就开始用这款印象笔记了，不知道没网能不能用，···因为我一直在有网的情况下使用，然后他可以最多三个终端上使用（免费版），还有就是会有冲突的，记得冲突的时候及时查看，然后修改就好了，不要像我一样攒着很多（听说有道云也挺不错，但是没有用过） 简书 我用他主要是因为他上面写文章（编辑器可以调整成md）可以一边写，一遍预览 七牛云 主要用来做图床（写md的时候用的啦） phpstorm 真的好好用（下面的terminal，还有新建文件能自动git添加等等） 可以快速打开文件，不用在项目中找（ctrl+alt+n） 本文搜索 ctrl + f 全局搜索 ctrl + shift +f 回退 ctrl + alt + 左方向键 大段注释 ctrl +shift + / alt + 上下键 上下方法切换 alt + 左右键 左右tab页切换 本行注释 不太记得了 应该还有很多，但不太记得了（创建文件自动添加命名空间） 面板上的类的结构 百度云，现在的百度云下载速度受限制了，只有开通会员才会下载速度贼猛，百度干净云帮你解决疑难杂症， 链接: https://pan.baidu.com/s/1dFzqZK1 密码: cjrr，直接下载是个安装好的文件包，点击baiduyunguanjia.exe,，然后就当做普通的百度云用就好了，速度能到4 5m，··当然这和你本身的网速也有关（记得点击召唤大神提速） git bash 命令行，有很多linux命令都可以使用，比如ll这种（直接在git官网下载git.exe,然后安装后就直接会撞上这个）windows有个很有用的命令,explorer .,这是打开当前文件夹，图形化界面的形式（记得xampp也有这个按钮）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令总结]]></title>
    <url>%2F2017%2F11%2F28%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[netstat -an 查看网络连接，-a 表示包括tcp和utp，-n表示不用域名代替ip地址 ps -ef | grep httpd 查看httpd进程是否在 (注意这个筛选是没有端口号的，你想啊，如果一个脚本就监听一个端口还好，要是类似 nginx apache ,listen 那么多端口，你怎么显示呢) ll -a ls-la 展示该目录下所有文件包括隐藏文件 cd 进入目录，~ 普通用户的家目录 /home/vagrant, root用户 /home pwd 展示路径 mkdir 创建目录 chmod -R (文件夹) 755 修改权限 chown root:root 文件名 修改文件所有者和组 chgrp 修改组 useradd 添加用户 passwd 修改密码 （切换到当前用户下就可以修改了哦，不知道怎么修改别的用户的） groupadd 添加组 touch 新建文件 echo 11 &gt;&gt; 文件名 把这个内容输出到文件中 vim i 修改模式 ：wq 保存 ：q 退出不保存 ：q！强制退出 / 查找 ：num 多少行 ：$末尾 cat 查看 echo 输出，比如输出当前进程号 echo $$ (PID的值代表的就是进程号) export 设置环境变量 export FOO = foo ,让当前环境变量立即生效，source ~/.bash_profile 执行这个脚本文件（source在当前进程中直接执行而不是复制子进程执行）感觉直接在命令行这样export FOO = foo 好像就直接生效了，但是如果修改bash_profile 文件的话，要执行source才能生效 env 查看环境变量，比如查看刚刚的环境变量是否生效 env | grep FOO cp 复制文件 cp 源文件 目标文件 ，如果是文件夹 记得带上 -r 参数 mv 剪贴文件 rm -rf 删除文件 lsof -i|grep 3306 查看端口号 tar -xjvf 解压 wc -l 查看行数 awk cat /etc/passwd | awk -F ‘:’ ‘{print %1}’ 筛选内容 cut 切割, cut -d ‘:’ -f 1,2 -d 按照什么进行切割，-f 要获取哪些行数，一般这两个搭配着用 sed sed -n ‘2p’ /etc/passwd 修改内容，类似程序用的vim sort 排序 unique 经常结合sort 使用，因为unique 只能合并连续的两行 find / -name ‘php.ini’ 查找文件 locate 查找文件之前 updatedb ln -s 创造软链接 tail -f top 查看cpu啊内存啊之类的占用情况 df -h 查看服务器硬盘占用，itbasic 服务器就经常磁盘被写满了 wget 下载 curl 下载 常用端口号 ： http 80 https 443 mysql 3306 redis 6379 ssh 22 ~代表家目录，root用户 /root,普通用户/home/用户名]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于tcp连接的一些思考]]></title>
    <url>%2F2017%2F11%2F28%2FLinux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事情是这样的：今天在看一个课程的时候，说redis 是非阻塞的，但redis 是单进程的，而且之前我给redis备份数据的时候，确实客户端的响应会比较慢, 感觉这应该属于阻塞，于是查了一下php 的非阻塞模式 https://www.awaimai.com/660.html 123456$cmh = curl_multi_init();$ch1 = curl_init();curl_setopt($ch1, CURLOPT_URL, &quot;http://localhost:56735/child.php&quot;);curl_multi_add_handle($cmh, $ch1);curl_multi_exec($cmh, $active);echo date(&apos;Y-m-d H:i:s&apos;); 比较有用的就是上面这段代码，说是非阻塞的http请求，我改了请求地址，对应我用swoole写的一个http sever， 故意在服务端sleep， 然后客户端直接打印出了时间，并没有等服务端跑完。此时感觉这和异步的结果很类似，但相比较于异步，我感觉这个区别就是没有回调，脚本直接结束了，进程也结束了，不会管最后返回的内容是啥。试着查询pid, 果然此时已经查询不到了。但是异步的话，进程不会结束，常驻内存，有线程或者进程通知主进程最后的执行结果。 又因为在结果层面上，非阻塞和异步的效果是一致的，都跳过了这段代码的执行，所以导致大家分不清楚。 之前看到swoole文档上说array 函数是非阻塞，但我感觉array_map 这种循环（注意funciton 中不要写阻塞函数，比如sleep, 但在数据量大的时候感觉也会停在那好一会）而且非阻塞或者异步情况，都是返回结果毫无意义的，这些单个函数的话，我们肯定要判断返回值，所以不能说是非阻塞或者异步的吧，只能对那些io请求说是阻塞和非阻塞，同步和异步。 还是回到最上面那段代码，当我netstat -antp|grep 56735, 发现tcp连接是close_wait,这个好久之前在一篇文章中看到过（大愚talk） 我们都知道tcp建立连接需要三次握手4次挥手，这张图片我应该无数次看到了 之前就很好我有时候netstat -antp|grep 56735 ,可以看到一条正向连接， 56735 - 某个端口，某个时候还能看到一条正向一条反向连接，56735-某个端口，某个端口-56735， 为什么 是两条呢，为什么有时候看到一条，有时候看到两条呢，我后面又试了一下 curl 127.0.0.1:56735, 结果发现这时候出现了两条连接，而且两条连接的进程还不一样，一条是curl, 一条是 php ,所以的理解就是两条，之所以平时我只能看到一条是因为另一条的执行进程是浏览器，不在我们服务器上，所以查看不到。（还有什么可以证明是两条tcp连接，我们客户端可以主动断开，服务端也可以，所以我们服务端会出现上图的time_wait状态） 那为什么我们的服务器上会出现大量的time_wait, 不应该只有client 上才会出现吗，因为那张图片上的client 和 server 并不是我们实际工作中的客户端服务端，当我们服务端发送tcp连接的时候，我们服务端就相当于图中的client,之所以会出现close_wait, 是因为我们另一端client发送请求者也就是上面那段代码直接结束了，主动关闭了连接，然后我们服务端还没有跑完，只收到了client的 fin,回复了ack，并没有主动发送fin，断开服务端这边，上述也是模拟tcp close_wait的例子（被连接者也就是foreign address 主动关闭）。当出现大量的close_wait, 会消耗很多服务器资源。有什么办法能销毁这个close_wait 嘛，进程结束，在上面例子上也就是我们服务端进程结束，或者重启，这个tcp连接会主动释放，这也是大愚talk中解决的问题：“mysql 主动关闭连接，我们没有释放连接”。为什么以前php-fpm 模式不会出现，因为以前一个请求结束，所有资源都释放（咋释放的？我记得fast-cgi 可以配置某个进程在接受大量的请求之后自动重启，为了防止内存溢出，可是现在好像每次都会重启。可以在lnmp下测试，mysql主动关闭，看这个tcp连接是否消失，如果直接消失了，说明立刻就重启了吧），现在swoole常驻内存模式，进程不结束，资源得不到释放。 上图中还能发现连接mysql的端口3306确定外，这边端口这么多种多样，明明只是一个脚本的连接呀，其实你可以在php-fpm模式下实验，如果照之前的想法，那php和mysql的连接就应该是端口80 到 3306，可实验结果不是，为啥？因为进程号代表我们这个程序，但是一个程序连接别的端口可以自己生成多个，那个80 和 3306 相当于我们listen 的 socket， 但是我们自己又可以生成多个socket 去连接别人的listen。 还记得swoole中为啥要进程池吗，想想一下，如果一条mysql连接（长连接，我们curl 的连接是短连接，所以李哥经常说的用php维持一个长连接指的应该是这个，长时间不断，可以复用，但这个和websocket不一样哦，websocket 可以服务端主动推送，长连接不可以）长时间没操作，超过wait_timeout (非shell情况下，shell情况下依据 interactive_wait_timeout), mysql主动断开连接，此时即使我们这边tcp 连接还在，mysql给我们的tcp连接不在，那也没法返回数据了（就是那种mysql挂了，我们因为用了单例模式，连接还在，不能重新连接），所以我们需要ping 一下，当能收到反馈，再用。一般连接复用（比如单例模式）都应该这样，但我们很少出现mysql这么主动断开的情况，所以也不用ping, 除此之外，我们还可以利用进程池解决上述问题，从中选择没有被close_wait 的连接（怎么关闭close_wait,我的想法是对于那些ping ，没有返回的连接，我们直接close， 而不能通过异常，除非是那种数据不能传输的异常，我们可以close，否则还可能我们查询有问题导致异常，但是这条连接本身没问题） 还记得itbasic上的连接经常出现这种问题吗，之前是可能是因为一个死循环，导致数据库挂了，所以连接就挂了（我回去试一下，算上上面一共连个测试点）（抓包分析下redis命令） 关于长连接和短连接 现在http1.1 默认长连接，长连接和短连接是啥，长连接指的是tcp连接可以复用，剩下的http请求都走之前建立的tcp连接，怎么证明. netstat 一下，发现线上连接都是establish，然后再次请求，还是一样，过了一会，全部消除（和ws不一样，虽然都是establish，但是ws可以主动推送，而且维持时间更长） 当我们用curl请求的时候，就是短连接，请求完直接time_wait, 2个钟头后直接结束，所以大量的time_wait 并没有啥事（还有fin_wait 2 如果没有收到服务端的fin, 过一段时间也会直接消失） (为什么time_wait 之后2个钟头就结束，这1个钟头是数据包在网络上存活的最长时间, 为的是发过去的确认包对方没有收到，又发新的fin包过来，对方最晚发送的新的fin包是我们这个确认包在网络上的存活时间也就是一个钟头，加上新fin包的存活时间一个钟头，也就是两个钟头，当然在这个第一个fin和最后一个fin包之间，可以发送无数的fin确认包) 上图中的time_wait 就是我用php自身创造的请求，establish 是我们的浏览器http请求，怎么判断的，看ip知道孩子，211.144.144.26是我们当前ip，127.0.0.1 是本机 （之前一直以为因为websocket 导致request请求建立的连接也是establish，然后手动close,现在看来是错误的，它本身就是长连接，可以测试一下过一会他是否主动断开,感觉肯定不需要用户手动close） 1234567swoole版本是4.3.5你好，我用swoole 生成了一个http server， 我在onRequest事件中用mysqli连接了数据库，没有close，然后逻辑执行时间比较长，超过了mysql 的wait_timeout, mysql主动断开了连接，netstat查看的时候发现php连接mysql 是close_wait状态，过了一会这个tcp连接消失了，可是我看处理这个request的work进程id也没变，是因为work进程重启了吗，到这tcp连接消失，类似php-fpm 单个进程接受了某一数量请求（我记得swoole好像也能配置，但我的配置项中没有添加这个参数）当我在回调事件外写mysqli的连接的时候,没有close， 这个tcp连接一直存在也是close_wait状态，符合预期，不知道为什么回调事件中那个tcp连接会主动消失使用swoole时候的疑问，韩大没有理解我的意思，没能解决（我的想法可能就是work进程重启了，导致tcp连接消失） 后面都是以前写的垃圾，没有整理、 首先来介绍下有关网络的相关知识吧，iso，国际标准化组织 制定了 osi七层模型，但这个模型在现实生活中并没有使用，使用的是基于7层模型之上的tcp/ip 4层模型 二者区别 上三层是给用户提供服务的，下四层是数据传输用的（数据不传输的下4层不用了，但上3层还是要用的） 既然是数据传输，那必然就有单位，每一层传输的单位是不一样的，osi7层模型上都有标识，最底层的物理层单位比特，代表的就是0或者1这个单位这些层在水平上的传输，然我们以为他们就是直接想通的，其实他们是从高到低，再从低到高这样传输的。 各个层的作用，感觉了解一些就可以了1.物理层：底层传输2.数据链路层：通过不同的mac地址，通过交换机进行传输，此时还没有ip地址，so交换机肯定是不认识ip地址的啦3.网络层：ip地址，路由器，通过对不同路由器的选择，去寻找不同的主机服务器4.传输层：tcp udp的定义，tcp安全可靠没有udp快，但udp不可靠，还有来确定端口号（端口号的理解，这封信送给你家，只有署名了，才知道给你家的某个人，外来的请求，只有确定了端口号，你才知道这个请求是给哪个服务的）5.会话层：这个文件是直接存储呢，还是要进行网络传输呢6.表示层：数据的表现形式，加密啊，我们window上文件的高级属性也能加密，但是秘钥保存在本机应该是c盘，一旦重装系统，秘钥丢失，那这个文件也可能就打不开了7.应用层：用户接口 线面这张图能表名上面的作用 a: 你在吗？b:我在，你还在吗？a：我还在，我穿输了 其实这个应答应该是没完没了的，但3次之后准确率就比较高了 下面介绍一下ip有关内容ipv4结构如上所示，图中可以看出选项有的有，有的没有，所以结构不唯一，需要检测，没有ipv6固定，速度快 可以看出32次方，一共2的32次方个默认 0.0.0.0 到255.255.255.255其实如下，很多不给用的，就a b c类能用，其中还包括一些私有的，只有局域网内网才能用127这个网段只有一个也就是自己127.0.0.1 上面的ip地址第一个字段代表不同的网段，不同的网段需要通信，要用路由器 a类网段，拥有的主机数是 2的24次方b类：前两个数代表不同网段，后面两个数代表不同的主机c类：前三个数代表不同网段，后面1个数代表不同的主机同一个网段交换只要交换机就可以了这个网段是怎么决定的呢，是有子网掩码决定的，子网掩码的255代表网段，0代表主机，ip地址都是配合子网掩码使用的，没写是因为有默认 最大的主机数（-2 一个是网络地址，一个是广播地址） 私有ip不要钱，有效的保护公网ip不够用 缺点：不能访问公网ip，公网ip也不能访问私网ip（公网ip是互联网上唯一的门牌号） 网络的计算：ip地址和子网掩码和，因为子网掩码前面全是1，所以网络地址网段和ip地址一样，后面子网掩码全是0，所以网络地址主机是0 广播地址怎么算呢，子网掩码有多少位是0，就换算多少位1，前面网段不变，这样就是广播地址 udp 比tcp简单，所以udp比tcp块 常见端口号http 80 https 443mysql 3306ssh 2222redis 忘记了smtp 25(简单邮件传输协议) 不管是window还是linux都禁止了23端口，因为telnet是明文传输，截获了都不用破解 DNS 进行域名解析 虽然我们的端口分tcp和udp，但是系统怕我们弄混淆了，不管tcp的20 21还是udp的20 21都是分配给ftp使用的 DNS（尽然既可以接受tcp协议也可以接受udp协议） listening 表示本机正在监听 establish 表示建立连接 udp的状态为空，因为udp不管你在不在，都会给你发送数据 （我想攻击一个游戏服务器，我把我所有的外部连接都关掉，然后登陆游戏，然后netstat 查看外部连接，就能知道对方的ip地址了） 关于DNS的知识 ip地址太难记，没有域名形象，so 产生了DNS window的host文件是做静态ip和域名对应，优先于DNS匹配，so我们经常本地测试绑定虚拟域名的时候都是这么干的 早期就是通过host文件这么解析的，坏处 dns原理 域名解析原来是从后往前的，··顶级域名在后面 原先有个.me 的国家域名可以申请 这个是全球唯一的（比如www.sina.com 和www.sina.cn就是两个域名，为了防止别人误入错误的地址，大公司会把那些顶级域名都注册了，以免坏人的误导） 三级+二级+顶级+组成完整的域名 根域名管理一级域名，一级域名管理二级域名，二级域名管理三级域名，这种层层管理 dns一般劫持被误导非常难，你只要确保imooc.com 这个二级域名是否是这个网站的，就能确保是否是钓鱼网站（确保二级域和顶级域一致） 域名解析过程主要分为开始的递归查询和后面的迭代查询默认本地域名服务器解析的域名保留3天 （这种分级的更有利管理） 迭代查询允许返回一个最优的值，比如顶级域名不知道，让本地域名服务器去找cn解析 全球所有的域名服务器都知道13台根域名服务器 但是递归查询不可以，递归要么返回一个准确值，要么返回错误 所以，递归查询一般用作客户机和本地域名服务器之间进行查找（注意这个查找虽然图中只是一台，其实会有很多台）而迭代查询一般用在根dns和cn，com这些之间进行查找]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window下运行各种框架总结]]></title>
    <url>%2F2017%2F11%2F25%2Fwindow%E4%B8%8B%E8%BF%90%E8%A1%8C%E5%90%84%E7%A7%8D%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这篇文章主要是对于php运行环境的搭建中运行起来框架的总结，其实运行框架，不管是yii，还是tp，还是laravel，还是我们那个项目框架，与其说是运行起来，不如说是找到框架的入口文件，然后剩下的就直接交给了框架进行处理（route.php的处理，restful api等等，通过解析模块，控制器，方法），绝大部分时候就这这么简单，至少上面三个都不用对apache进行特殊的配置（目前的这篇文章只是单纯的针对Apache）。 so，简化的思考了一下，就是找public下面的index.php 文件（tp laravel都是这个文件 yii是在web目录下，其实找一下就行了，大部分都是reqire项目的核心库这种东西。例如yii 123456789101112&lt;?php// comment out the following two lines when deployed to productiondefined(&apos;YII_DEBUG&apos;) or define(&apos;YII_DEBUG&apos;, true);defined(&apos;YII_ENV&apos;) or define(&apos;YII_ENV&apos;, &apos;dev&apos;);require(__DIR__ . &apos;/../vendor/autoload.php&apos;);require(__DIR__ . &apos;/../vendor/yiisoft/yii2/Yii.php&apos;);$config = require(__DIR__ . &apos;/../config/web.php&apos;);(new yii\web\Application($config))-&gt;run(); ），所以只要配置好了一个环境，剩下的框架的运行基本就一样了。上面已经说了我们这片文章的目的了，运行起来框架，通过的是直接下载代码的这种方式（现在绝大部分框架都是支持composer来安装）。我们先安装好xampp，xampp会帮我们集成安装好apache和mysql，他们和在linux下是一样的，至少我到现在还没有发现什么不同，so，因为太过相似了，导致我从前以为xampp是在window环境下集成安装了lamp这种，其实这个l（linux是没有的），他的环境准确说是wamp（我代表 window这种架构）。他把php，mysql还有apache都放在了他自己也就是xampp的安装目录下，我们找到apache的安装目录，在conf文件夹里面找到（httpd-vhosts.conf）这个配置虚拟域名的文件，我记得以前apache配置虚拟域名是在一块的，都是写在httpd.conf文件里面，现在分开了，其实是包含了conf文件下的所有文件，但这样更清楚。接下来我们就开始配置虚拟主机了（配置虚拟主机的意思就是在一个服务器上配置多域名访问的站点，其实不通过域名通过端口号啊什么的都可以，本质上就是把不同的请求分发到不同的目录下。我们的itbasic就是通过Nginx通过域名的不同把对80端口不同的域名请求分发到不同的端口下，然后通过apache虚拟主机的配置（通过的是端口的不同）来达到发送到不同目录下）。添加1234567891011121314&lt;VirtualHost *:800&gt; ##ServerAdmin webmaster@dummy-host2.example.com ##DocumentRoot &quot;D:/xampp/htdocs/dummy-host2.example.com&quot; ##ServerName dummy-host2.example.com ##ErrorLog &quot;logs/dummy-host2.example.com-error.log&quot; ##CustomLog &quot;logs/dummy-host2.example.com-access.log&quot; common DocumentRoot &quot;D:\code\laravel-v5.1.11\laravel-v5.1.11\public&quot; ServerName laravel.app &lt;Directory &quot;D:\code\laravel-v5.1.11\laravel-v5.1.11\public&quot;&gt; Options Indexes FollowSymLinks Includes ExecCGI AllowOverride All Require all granted &lt;/Directory&gt;&lt;/VirtualHost&gt; 简单的记录下apache的语法 DocumentRoot 代表根目录配置虚拟域名要写在virtualHost标签之间，后面的代表端口号，servername代表域名，directory里面allow代表接受任何的请求，之前安装larave的时候代开index.php嫌弃我权限不够，其实是这个directory标签的内容写错了，注意这个如果说打开文件夹没有权限，在window下你改这个目录的什么所有者权限啊什么都是没用的，我的理解是web请求的时候打开这个文件夹的用户不是我们能预测的，应该是other什么的，因为加了这句话，所以我们在window下安装这些框架不用修改日志文件，要么在linux下安装yii，laravel都要修改log日志文件夹的权限（感觉是因为写日志的操作是来自http的请求，像我们之前安装seaslog第三方的日志的时候，也得修改那个文件夹的权限，道理是一样的）（yii框架的话conf文件夹下web.php cookiekey要随便填一个数，） 当然还要配置个虚拟域名，因为之前apache里面填写的域名如果是假的话，在本地host文件里面配置一下（因为浏览器解析是通过缓存（贼端）host文件，dns解析来找的，配置之后ping一下能不能同，就可以啦） 大功告成。 总结一下,本机运行起来一个框架。 1.安装集成环境（xampp）2.修改apache配置文件，配置虚拟主机3.修改host文件，修改域名到本机127.0.0.1 注意的点：1.配置虚拟主机之后，xampp原先那个localhost直接就访问不了了，所以把那个localhost也配置一个虚拟主机（localhost也属于一个域名）2.如果访问不了，先ping一下域名，看是否能ping通，然后查看apache的access日志和error日志，如果没有，确认http服务是否起起来了，如果有查看日志（linux下tail -f 动态看），window下在文件的最下面，像我现在这个window下环境，就是因为端口号被占了，改成800，所以每次访问域名后面都得加 ： 800，这个Apache的错误日志里面会记录的很清楚 附上三张框架图1.2. (其实在用外链的时候想到了树洞外链，GitHub上一个关于php的开源项目)对了突然想起来yaf框架，其实因为yaf框架是需要扩展模块支持，所以得先安装php扩展（php扩展大部分都是c开发的，），然后原理是一样的（只是yaf框架需要手动生成基本目录） 地址 简单记录下window下安装php扩展（phpinfo能输出php的详细信息，在框架的index.php目录下是唯一所有人都能访问的）然后去pecl下载php扩展，下载dll文件的时候要注意那个什么tc之类的，注意好，下载好放在php的扩展目录下ext，再在php.ini 里面模仿之前的php扩展，加上相应的话就好了，那个扩展还是可以配置一些属性的1zend_extension = D:\xampp\php\ext\php_xdebug-2.5.4-7.0-vc14.dll 像mysql这种，都是可以添加配置信息的12345678[MSSQL]mssql.allow_persistent=Onmssql.max_persistent=-1mssql.max_links=-1mssql.min_error_severity=10mssql.min_message_severity=10mssql.compatability_mode=Offmssql.secure_connection=Off yaf好像不配置，不能再生产环境下用，有个参数，其实安装seaslog的时候那些日志模板啊，日志格式啊都是在这里配置的，就是初始化的感觉。linux下的安装扩展要先下载文件，然后编译成so文件放在对应目录下，然后配置php.ini，有机会再说。window下只要注意好下载对应的dll文件就可以了]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>linux</tag>
        <tag>apache</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用]]></title>
    <url>%2F2017%2F11%2F25%2Fhexo%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[感觉七牛云和我们公司的产品datrix做的东西是一样的，都是用来做存储的，还有树洞外链（GitHub上一个php star很高的项目） hexo server -port 4000 启动服务器，因为我改了端口，导致得换端口 hexo new “文章名称”产生新的文章，注意这个地方一定要是双引号，单引号会出错 hexo g 产生静态文件 hexo c 清理缓存 hexo d 部署到github上 （这个其实就是代码提交，以前很傻比，每次提交代码都用git，其实这个就是把一些静态文件代码git到GitHub上，只是封装了一些操作而已） 注意经常写好了，命名没问题，但是本地测试显示不出来，其实有时候是type那个save快捷键的问题，手动点击保存 还有经常显示不出来都是语法啊什么问题（md语法），不要总怀疑缓存，服务器，注意下md语法和是否保存好了，刷新就可以了]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>datrix</tag>
        <tag>七牛云</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法使用记录]]></title>
    <url>%2F2017%2F11%2F16%2Fmarkdown%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[关于段落，不用使用 &lt;p&gt; 直接使用换行 关于首行缩进中文两字符 &amp;emsp 后面加上 ; 代表缩进一个，因为这个; 如果直接写在&amp;emsp 后面会直接不显示，所以我分开来写 如果是英文字符，肯定就是 &amp;nbsp 啦 *** *** 两个星号之间的内容是加粗, ** ** 代表泄题 `` 两个点好之间代表标记，比如我这上面想显示的md标记都是放在标签里面显示出来 有序列表的话 1. 空格后会自动生成列表，以后想生成下一个列表，自动换行就可以了，不用一个个手敲（这个markdown语法都是空格后好像才能生效） ``` 代表下面的内容是代码块，结束也是 ``` []() 插入超链接，中括号里面是要显示的文本内容， ！[]()插入图片，[]也是文本内容 &lt;!--more--&gt;nexo 产生阅读全文的按钮 *代表无序列表，（小圆点图标）]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>markdown</tag>
        <tag>语法</tag>
        <tag>文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写博客的原因]]></title>
    <url>%2F2017%2F11%2F15%2F%E5%86%99%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[之前学习hexo建站的原因很简单，一个朋友弄过，当第一次见得时候很好奇，好像是被h5那个背景图所吸引，还有一点就是相比于wordpress他更大方，更感觉是现代化的产物。随着进一步的了解，相比于wordpress他不用主机，对于我这种穷人来说就更有好啦，哈哈哈，而且还能在GitHub上混commit。 但当我建出这个小站的时候，我却发现不知道写什么，难道纯粹是为了面试的时候简历上有个博客地址博取好感，感觉仅仅因为这个去经常写些文章花费太大，有些人说生活笔记，关于笔记我用的Evernote，这个随时随地都能同步，没有必要非得用这个。 但不久之后我发现在学习的过程中我虽然记了很多的笔记，但我从来没有去总结，我的总结都是通过第二次第三次第四次去再次碰到这个问题，再去解决，而学会的这个问题，所以我觉得我这种记笔记的方法从根本上说并不是记笔记，而是自我安慰，所以我想通过写博客总结我写过的笔记，进行进一步的加工，还有列出关键的点，这样还能方便平时自己对问题的快速查找，这是我写博客的初衷，当然分享也是其中一点，希望如果有朋友能看见，能指出我的不足，或者我写的东西很方便的帮你找到了答案，这也是我最希望看到的。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>职业</tag>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
