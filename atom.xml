<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-12-17T13:35:06.795Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>es的简单总结</title>
    <link href="http://yoursite.com/2020/12/17/es%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/12/17/es的简单总结/</id>
    <published>2020-12-17T06:07:42.000Z</published>
    <updated>2020-12-17T13:35:06.795Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做商品评论的相关内容，因为数据量比较大，而且后台需要根据内容进行评论匹配的功能，显然用mysql 的 like 不太合适了，我们用的是elasticsearch。</p><a id="more"></a><p>需要注意的几个点:</p><ol><li>es 每条记录都有 id , 这个id 不等同于我们结构体中的id， 需要我们手动指定，如果我们不指定，es 会默认生成一个字符充当id， 当我们用get 请求的时候拼接的id 也是 此id （如果id 重复后插入的会覆盖之前的）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;_index&quot;: &quot;shihuo_other_comment_dgscore_v1&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;other_comment_dgscore&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;25135190&quot;,</span><br><span class="line">        &quot;_score&quot;: null,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;id&quot;: &quot;25135190&quot;,</span><br><span class="line">          &quot;channelType&quot;: 23,</span><br><span class="line">          &quot;createTime&quot;: &quot;2020-12-14 16:38:01&quot;,</span><br><span class="line">          &quot;goodsId&quot;: &quot;50021&quot;,</span><br><span class="line">          &quot;mixId&quot;: &quot;o_39007587&quot;,</span><br><span class="line">          &quot;commentDisplay&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;dgScore&quot;: &quot;0.00&quot;,</span><br><span class="line">          &quot;isPhoto&quot;: 0,</span><br><span class="line">          &quot;mixType&quot;: &quot;o&quot;,</span><br><span class="line">          &quot;praise&quot;: &quot;0&quot;,</span><br><span class="line">          &quot;tagIds&quot;: [],</span><br><span class="line">          &quot;innerScore&quot;: &quot;0.00&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;好看，喜欢。&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot;: [</span><br><span class="line">          25135190</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 比如我们常用的go包（github.com/olivere/elastic）</span><br><span class="line">中通过 Id 去指定这条记录的id</span><br></pre></td></tr></table></figure><p>2.当我们想获取es 的版本号的时候我们可以发送 get  / 请求，能获取到版本号</p><p>3.es 7 好像废弃了 type 的存在，之前我们可以理解 index 数据库，type 表</p><p>4.es 的那些搜索条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">sort 和 query 是同一个级别的 </span><br><span class="line"></span><br><span class="line">sort 也可以传入多个条件</span><br><span class="line">&#123;</span><br><span class="line">    &quot;sort&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;f1&quot;:&#123;</span><br><span class="line">                &quot;order&quot;:&quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;f2&quot;:&#123;</span><br><span class="line">                &quot;order&quot;:&quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go 代码：</span><br><span class="line">res1, err := client.Search(indexName).Query(bo).Sort(&quot;innerScore&quot;, false).Sort(&quot;id&quot;, false).Do(context.TODO())</span><br><span class="line">或者：</span><br><span class="line">sortQuery1 := elastic.NewFieldSort(&quot;name&quot;)</span><br><span class="line">sortQuery2 := elastic.NewFieldSort(&quot;age&quot;).Desc()</span><br><span class="line"></span><br><span class="line">searchService := client.Search().</span><br><span class="line">Index(&quot;students&quot;).</span><br><span class="line">SortBy(sortQuery1, sortQuery2)</span><br><span class="line"></span><br><span class="line">// 几种方法的对应 </span><br><span class="line">/id   -&gt; Get().Index()</span><br><span class="line">/_search -&gt; Search().Index()</span><br><span class="line">/_mapping -&gt; Index().Index() , 这个index方法和后面的index方法 不一样的结构体的方法</span><br><span class="line">/_delete -&gt; Delete().Index()</span><br><span class="line">/_deleteByQuery()  传入query 就可以了</span><br><span class="line">/_updatedByQuery() </span><br><span class="line">这个相比较之前的就是和query 级别多了个参数 script， lang 用的painless。 然后如果我们更新的级别比较频繁，建议用</span><br><span class="line">source 代表更新的field 比如 ctx._source.&#123;$k&#125;=params.&#123;$k&#125;;</span><br><span class="line">我们传入一个map 赋值给一个params ，然后循环params用来构成source 字符串 </span><br><span class="line"></span><br><span class="line">/_update -&gt; id 更新最简单的方式就是</span><br><span class="line">POST /shihuo_other_comment_dgscore/other_comment_dgscore/25117494/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;innerScore&quot;: &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.我们在构造query 参数中需要注意的几个点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query 第一层无可厚非</span><br><span class="line">bool 第二层，我平时就没用用过非bool 的</span><br><span class="line">第三层有两个 filter 和 must，怎么区分呢，filter 一般用来过滤条件，比如 id = ，terms in， term 这种完全匹配 。filter效率比较高，因为他不会根据sort 去排分，must 一般用在 内容匹配上，一般我会搭配match_parse ,感觉这样更精确。然后 must 和 filter 里面装的是数组，剩下的都是 obj， 这点一定要注意。还有个should 是同一级别的，should [] 中是 or 的关系，但是should 自身和must 还是and 关系,</span><br><span class="line">exists 和 missing 匹配 类似sql 中 is_null.</span><br><span class="line"></span><br><span class="line">go 中怎么使用呢，new boolquery， 然后把这些条件都加进去。</span><br></pre></td></tr></table></figure><p>6.我们在用es 更新的时候不一定马上能刷新，比如删除，比如修改，我们可以用refresh = wait_for, 这个就相当于是同步的，默认是false 是异步的，如果用true 所有的都这样会影响性能。</p><p><a href="https://blog.csdn.net/u011228889/article/details/80855431" target="_blank" rel="noopener">关于刷新</a>, 这篇文章讲的挺好的，其实wait_for 也不是马上刷新，只是加了wait for 之后那个接口会在等待刷新完成之后才返回结果。</p><p>7.es 的聚合功能，我们在口碑中有使用到<a href="https://www.cnblogs.com/leeSmall/p/9215909.html" target="_blank" rel="noopener">这篇文章用法讲的很仔细</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;innerTagIds&quot;,</span><br><span class="line">        &quot;size&quot; : 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">go 中 指标聚合的 https://www.tizi365.com/archives/868.html，蛮好用的</span><br></pre></td></tr></table></figure><p>8.es 搜索到的内容json转换成我们需要的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if searchResult.TotalHits() &gt; 0 &#123;</span><br><span class="line">// 查询结果不为空，则遍历结果</span><br><span class="line">var b1 Article</span><br><span class="line">// 通过Each方法，将es结果的json结构转换成struct对象</span><br><span class="line">for _, item := range searchResult.Each(reflect.TypeOf(b1)) &#123;</span><br><span class="line">// 转换成Article对象</span><br><span class="line">if t, ok := item.(Article); ok &#123;</span><br><span class="line">fmt.Println(t.Title)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">之前代码中遇到totalhits &gt; 0 ,拿到数据却是0， 主要就是这个each 方法执行失败的 err我不知道怎么抛出来，需要自己打印下，一般是结构体转换失败。</span><br></pre></td></tr></table></figure><p>9.es 中经常遇到的mapping 问题 <a href="https://www.cnblogs.com/Neeo/articles/10585035.html#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%88dynamic%EF%BC%9Astrict%EF%BC%89" target="_blank" rel="noopener">一般都是字段名字写错了</a>, 而且 es 的mapping 设定好修改包括字段类型，就不方便修改了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做商品评论的相关内容，因为数据量比较大，而且后台需要根据内容进行评论匹配的功能，显然用mysql 的 like 不太合适了，我们用的是elasticsearch。&lt;/p&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>破解</title>
    <link href="http://yoursite.com/2020/12/11/%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/12/11/破解/</id>
    <published>2020-12-11T03:10:47.000Z</published>
    <updated>2020-12-11T03:13:17.262Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些破解有用的文章</p><h3 id="Navicate"><a href="#Navicate" class="headerlink" title="Navicate"></a>Navicate</h3><p><a href="https://www.jianshu.com/p/e43cfe3fe832" target="_blank" rel="noopener">我用的12</a>, 直接打开那个百度云盘，把对应文件copy到对应安装目录下就好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一些破解有用的文章&lt;/p&gt;
&lt;h3 id=&quot;Navicate&quot;&gt;&lt;a href=&quot;#Navicate&quot; class=&quot;headerlink&quot; title=&quot;Navicate&quot;&gt;&lt;/a&gt;Navicate&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.jiansh
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="破解" scheme="http://yoursite.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>速查笔记</title>
    <link href="http://yoursite.com/2020/07/17/%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/17/速查笔记/</id>
    <published>2020-07-17T03:01:39.000Z</published>
    <updated>2020-11-23T09:02:22.392Z</updated>
    
    <content type="html"><![CDATA[<p>工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-X/--request [GET|POST|PUT|DELETE|…]  指定请求的 HTTP 方法</span><br><span class="line">-H/--header                           指定请求的 HTTP Header</span><br><span class="line">-d/--data                             指定请求的 HTTP 消息体（Body）</span><br><span class="line">-v/--verbose                          输出详细的返回信息</span><br><span class="line">-u/--user                             指定账号、密码</span><br><span class="line">-b/--cookie                           读取 cookie  </span><br><span class="line"></span><br><span class="line">例子:curl -v -XPOST -H &quot;Content-Type: application/json&quot; http://127.0.0.1:8080/user -d&apos;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin1234&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>w10 修改环境变量</p><p>set name=cy</p><p>echo %name% (golang 这些编辑器中想生效，就得重启编辑器)</p><p>公司网络最近谷歌不能访问了，只能 用 www.google.com.hk， 修改默认的搜索引擎</p><p><a href="https://www.jianshu.com/p/94a145564254" target="_blank" rel="noopener">https://www.jianshu.com/p/94a145564254</a></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20201123170141.png" alt=""></p><p>我们不能修改默认的搜索引擎，比如谷歌，想修改的话只能新建，然后添加默认，下面那些乱七八糟的都能删除了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>gin 的那点事</title>
    <link href="http://yoursite.com/2020/07/17/gin-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2020/07/17/gin-的那点事/</id>
    <published>2020-07-17T02:45:57.000Z</published>
    <updated>2020-07-17T03:01:16.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事</p><a id="more"></a><p>abort ，next 方法</p><p>gin 的中间件和别的中间件还不一样，gin 的中间件没有next 也能正常执行，next 只是控制自己的代码和中间件的代码执行顺序。中间件中用return 不能停止中间件的执行，只能用abort 方法才能停止后面程序的执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>go 小知识点</title>
    <link href="http://yoursite.com/2020/07/14/go-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2020/07/14/go-小知识点/</id>
    <published>2020-07-14T09:57:32.000Z</published>
    <updated>2020-12-17T07:45:06.689Z</updated>
    
    <content type="html"><![CDATA[<p>读源码学到的新的语法，补充自己对go的更多了解</p><a id="more"></a><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>今天在看别人代码的时候发现了一个 interface.([]int) 新用法，以前不知道，这个其实就是断言 assert， 其实php 中也经常用到</p><p>1.go 中目前我接触到断言,取map值的时候 ，a, ok :=  map[“name”],  虽然没有这个ok 也是能正确运行的，比如 a := map[“name”]</p><p>2.interface 断言， interface.([]int), 转换成[]int类型</p><p>3.断言失败会取断言类型的默认值，如果断言失败还是不知道原因可以用reflect.TypeOf获取断言的真正类型。断言失败的时候经常就是胯类型断言，比如你知道一个类型[]map[string]string, 但你收到这个值的时候不能直接断言interface.([]map[string]string), 而是应该 interface.([]interface{}),  for range 每个值断言map[string]string.<strong> 所以能用结构体就用结构体接受吧，要不然每层断言很辛苦  ，曾经断言60行的代码，用结构体 不到10行 就接受了，还不用处理一堆的断言错误</strong>。</p><p>4.关于类型 interface{} 兼容 string， 但不代表 []interface{} 兼容 []string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Can I convert a []T to an []interface&#123;&#125;? ¶</span><br><span class="line">Not directly. It is disallowed by the language specification because the two types do not have the same representation in memory. It is necessary to copy the elements individually to the destination slice. This example converts a slice of int to a slice of interface&#123;&#125;:</span><br><span class="line"></span><br><span class="line">t := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">s := make([]interface&#123;&#125;, len(t))</span><br><span class="line">for i, v := range t &#123;</span><br><span class="line">    s[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有另一种方式实现转换</span><br><span class="line"></span><br><span class="line">[]interface&#123;&#125;&#123;&quot;11&quot;, &quot;112&quot;&#125;</span><br><span class="line"></span><br><span class="line">notice : []interface&#123;&#125;&#123;v...&#125; , 这样不行的，这样转换的interface slice， 数量总是 1</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>最近用slice 总容易写一个bug， 就是make 的时候给定大小，然后append slice， 这样会导致一直往后面插入slice ，而不是从0 开始修改slice 的值</p><h1 id="channel定义"><a href="#channel定义" class="headerlink" title="channel定义"></a>channel定义</h1><p>之前看过对channel 的定义最好不要在全局，之前不知道为啥原因，当时因为想做缓冲channel， 而以为var 没法做，所以一直没用全局channel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var channel = make([]chan task, 10)</span><br><span class="line">// 10 个的缓冲， 然后是 task 组成的chan 的slice</span><br><span class="line"></span><br><span class="line">slice 用make 和 自身 定义的区别</span><br><span class="line">make([]int, 10)  [0 0 0 ..]</span><br><span class="line">[]int&#123;&#125;  就是nil</span><br></pre></td></tr></table></figure><h1 id="goroutine的意义"><a href="#goroutine的意义" class="headerlink" title="goroutine的意义"></a>goroutine的意义</h1><p>把一个任务分成很多部分，每个任务完成的周期很短。多个任务中我们可以通过channel 进行通信。如果我们通过单个channel ，在进行io的时候会阻塞的， 所以我们需要多个channel 来配合多个goroutine。多个goroutine消耗多个channel, 取数据的时候，可以把channel 传入goroutine当中，来消耗特定的channel。投递数据的时候咋办？当往特定的channel 中投递任务，因为go不像php 那样可以拼变量名，我们可以先把多个channel 放在一个数组中，然后通过数组index 去取特定的channel。</p><p>go  slice 结构， （指向array 的指针，len, cap）</p><p>（go 中slice 的改动会及时没有用 &amp; 也会影响自身）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func handle(a []string)  &#123;</span><br><span class="line">a[0] = &quot;bb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line"></span><br><span class="line">c := make([]string, len(b))</span><br><span class="line">copy(c, b) // copy 的话就不会影响,注意copy 的时候一定要len 一样，否则会copy不全</span><br><span class="line"></span><br><span class="line">// 这种直接赋值的话， c 的改动会直接影响b</span><br><span class="line">// c := b</span><br><span class="line"></span><br><span class="line">handle(c)</span><br><span class="line">fmt.Println(b, c)</span><br><span class="line"></span><br><span class="line">a := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line">sort.Strings(a)</span><br><span class="line"></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(copy 方便数组的拷贝，不影响原始数组的变动)</p><p>（arr := […]int{1,2,3,4}, arr[1:2:3], start 1 end 2  len 3, 索引的位置）</p><p>// go 中的引用类型</p><p>引用类型和原始的基本类型恰恰相反，它的修改可以影响到任何引用到它的变量。在Go语言中，引用类型有切片、map、接口、函数类型以及<code>chan</code>。</p><p>引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。</p><p>//  go 中经常这样，类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Duration int64</span><br></pre></td></tr></table></figure><p>// go 可变参数</p><p>可以变参数，可以是任意多个。我们自己也可以定义可以变参数，可变参数的定义，在类型前加上省略号…即可。</p><p>// 组合类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">name string</span><br><span class="line">email string</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type admin struct &#123;</span><br><span class="line">user</span><br><span class="line">level string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ad:=admin&#123;user&#123;&quot;张三&quot;,&quot;zhangsan@flysnow.org&quot;&#125;,&quot;管理员&quot;&#125;</span><br><span class="line">fmt.Println(&quot;可以直接调用,名字为：&quot;,ad.name) // 能运行</span><br><span class="line">fmt.Println(&quot;也可以通过内部类型调用,名字为：&quot;,ad.user.name) // 能运行</span><br><span class="line">fmt.Println(&quot;但是新增加的属性只能直接调用，级别为：&quot;,ad.level)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 访问权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Admin struct &#123;</span><br><span class="line">user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user 无法被导出，因为 小写，类似严格访问类型</span><br></pre></td></tr></table></figure><p>// race 检测对共享变量的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -race 10.go</span><br><span class="line"></span><br><span class="line">10.exe</span><br></pre></td></tr></table></figure><p>// sync 包真的是解决并发问题的一个优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">count int32</span><br><span class="line">wg    sync.WaitGroup</span><br><span class="line">mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(2) // 计数器</span><br><span class="line">go incCount()</span><br><span class="line">go incCount()</span><br><span class="line">wg.Wait() // 如果信号量不到0 main 进程就一直堵塞</span><br><span class="line">fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func incCount() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">mutex.Lock() // 只能有一个goroutine 进来</span><br><span class="line">value := count</span><br><span class="line">runtime.Gosched()</span><br><span class="line">value++</span><br><span class="line">count = value</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 很经典的一个关于获取三个url 最快速的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func mirroredQuery() string &#123;</span><br><span class="line">    responses := make(chan string, 3)</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;asia.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;europe.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;americas.gopl.io&quot;) &#125;()</span><br><span class="line">    return &lt;-responses // return the quickest response</span><br><span class="line">&#125;</span><br><span class="line">func request(hostname string) (response string) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><h1 id="json-序列化的小问题"><a href="#json-序列化的小问题" class="headerlink" title="json 序列化的小问题"></a>json 序列化的小问题</h1><p>json 协议没有int 类型，只有 number 类型。int 都会被解析成 float64， 注意！！</p><p>上面的描述有bug ，今天一个str  json 反序列化的时候很成功，啥时候会出现上面问题，通过 interface{} 断言的时候。</p><p>json  序列化的时候如果没有这个值，就不给客户端 （比如我们更倾向于返回空对象，而不是一个完整对象，然后值都是空的），可以使用json tag 中的 omitempty </p><p>json 序列化的时候如果不想要这个，可以直接 - （比如密码这类我们不想暴露给客户端，我们只是我们后端struct 使用，并不需要给客户端）</p><p>json 我们也可以用 int 接受 string 类型 （需要注意的是 我们再次 json序列化的时候 还是 string ）</p><p>今天遇到一个很好用json 方法，<a href="https://medium.com/@xfstart07/go-json-%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81-e689522a1f1f" target="_blank" rel="noopener">就当做json 序列化和 反序列化前的操作</a></p><h1 id="url处理"><a href="#url处理" class="headerlink" title="url处理"></a>url处理</h1><p>最近有一个很恶性的需求，就是解析别人填入的url， 再添加一些想要的参数，组成新的url 返回，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">u, err := url.Parse(href)  // 解析成一个url 对象，这个url 对象有个 string() 方法，可以直接输出这个 href</span><br><span class="line">// 获取 query</span><br><span class="line">query := u.RawQuery  </span><br><span class="line">// 解析query</span><br><span class="line">queryMap, err := url.ParseQuery(query) // 返回一个values 对象，是一个 map[string][]string</span><br><span class="line">// go 中一个参数默认对应一个slice， 如果是单个参数，就是slice 的第一位啦</span><br><span class="line">// 这个values 有很多方法，如果想改参数试试 set， 注意参数是[]string, 否则会整体覆盖哦</span><br><span class="line">// 注意map 赋值是不会被修改的，所以还是调用他的方法吧</span><br><span class="line">queryMap.Encode()</span><br><span class="line">u.RawQuery = queryMap.Encode()</span><br><span class="line">// 组成新的query 参数,再赋值下就能得到新的url</span><br></pre></td></tr></table></figure><h1 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>golang 发送http 请求没有 php 那么直接，其实php 也没有那么直接，毕竟curl 那么一大串，只是php 的curl 面向过程，看起来是那么自然，从上而下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">resp, err := http.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line">//</span><br><span class="line">上面的方法编程平时应该用不到，因为我们的请求至少需要一个超时时间吧</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">resp, err := clt.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line">// 不是那么丝滑，需要用客户端发送请求，但又是那么的符合生活，像我们平时请求就应该有个客户端</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 本质</span><br><span class="line">req, err := http.NewRequest(&quot;GET&quot;, &quot;http://www.baidu.com&quot;, nil)</span><br><span class="line"></span><br><span class="line">//然后http.client 结构体的 Do 方法</span><br><span class="line">//http.DefaultClient可以换为另外一个http.client</span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure><p>评论 ：Go的get请求面上有好几种请求方式，实则只有一种：</p><p>1、使用<code>http.NewRequest</code>函数获得<code>request</code>实体</p><p>2、利用<code>http.client</code>结构体的<code>Do</code>方法，将<code>request</code>实体传入<code>Do</code>方法中。</p><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line">resp, err := http.Post(&quot;xxxxxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">注意这个body 是个io.reader. 通过这个strings.NewReader 转变来，显然，这个方法的参数是 strings</span><br><span class="line">// 当我们的content-type 是 application/ json, 我们这块就不能用 data.Encode 了而是应该用 json .Marc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">var r http.Request</span><br><span class="line">r.ParseForm()</span><br><span class="line">r.Form.Add(&quot;xxx&quot;, &quot;xxx&quot;)</span><br><span class="line">body := strings.NewReader(r.Form.Encode())</span><br><span class="line">http.Post(&quot;xxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">// 这种form 请求之前在js 里面用的很经常，简单哇</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">http.PostForm(&quot;xxxx&quot;, data)</span><br><span class="line"></span><br><span class="line">// golang 封装的postForm</span><br></pre></td></tr></table></figure><p>当然上面的方法本质上也是用client 发出来的</p><p>然后client 本质也是依靠 newRequest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">req.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure><p>!!!notice</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">添加request header</span><br><span class="line">net/http包没有封装直接使用请求带header的get或者post方法，所以，要想请求中带header，只能使用NewRequest方法。</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">//此处还可以写req.Header.Set(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line">req.Header.Add(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure><p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。</p><p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。<br>这俩方法是有区别的，Golang底层Header的实现是一个<code>map[string][]string</code>，<code>req.Header.Set</code>方法如果原来Header中没有值，那么是没问题的，如果又值，会将原来的值替换掉。而<code>req.Header.Add</code>的话，是在原来值的基础上，再<code>append</code>一个值，例如，原来header的值是“s”，我后<code>req.Header.Add</code>一个”a”的话，变成了<code>[s a]</code>。但是，获取header值的方法<code>req.Header.Get</code>确只取第一个，所以，如果原来有值，重新<code>req.Header.Add</code>一个新值的话，<code>req.Header.Get</code>得到的值不变。</p><p>其实不止是header 会这样，query 参数也会这样。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">content, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">respBody := string(content)</span><br></pre></td></tr></table></figure><p>获取返回值</p><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>go sort 已经有人封装好包了，相比较自己写快排，冒泡的好处就是，这个包会根据效率自动选择合适的排序方式，我们需要做的就是实现sort 中的接口 （<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）" target="_blank" rel="noopener">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Len()  获取要排序的slice 的len</span><br><span class="line">Less() return s[i] &lt; s[j]  默认倒序</span><br><span class="line">Swap(i, j int) 交换  // s[i], s[j] = s[j],s[i]</span><br><span class="line"></span><br><span class="line">sort.Sort([]object)</span><br></pre></td></tr></table></figure><p>对于倒序，很简单的实践方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse([]object)) // 帮我们少写了好多代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面的用法得写一堆东西，还有简单的方式</span><br><span class="line"></span><br><span class="line">直接调用  sort.Slice() 方法</span><br></pre></td></tr></table></figure><h2 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a>runtime.Caller</h2><p>在调用公司组件的时候，发现log 输出信息有问题，错误行号和文件是上一层函数调用，而不是我想输出的地方的调用。问题就出在，runtime.Caller(skip), 这个参数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">for i:=0; i&lt;=4; i++ &#123;</span><br><span class="line">_, file, line, _ := runtime.Caller(i)</span><br><span class="line">fmt.Println(file,line,&quot;=====&quot;,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 caller(i)  i 是 0 的时候，就是当前文件的输出，因为这个方法被封装了，所以，不管我在项目  // 中哪个地方调用，每次输出内容都是一样的。</span><br><span class="line">//   试试不调用组件，在单独文件中 runtime.Caller(i) 输出试试，就会发现当i = 0 时候这个方法的真  // 正含义。</span><br><span class="line"></span><br><span class="line">// 看看beego 中获取行号和文件名的方法</span><br><span class="line"></span><br><span class="line">func FILE() string &#123;</span><br><span class="line"></span><br><span class="line">    _, file, _, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return file</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// __LINE__ returns the line number at which the function was invoked</span><br><span class="line"></span><br><span class="line">func LINE() int &#123;</span><br><span class="line"></span><br><span class="line">    _, _, line, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return line</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skip 1 ,仅仅跳出当前方法所在的文件，因为他仅仅封装了一层</span><br></pre></td></tr></table></figure><p><a href="https://studygolang.com/articles/3116" target="_blank" rel="noopener">https://studygolang.com/articles/3116</a>, 这篇文章对 call 和 calls 方法讲解的比较细致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pc := make([]uintptr, 1024)</span><br><span class="line">for skip := 0; ; skip++ &#123;</span><br><span class="line">    n := runtime.Callers(skip, pc)</span><br><span class="line">    if n &lt;= 0 &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc[:n])</span><br><span class="line">&#125;</span><br><span class="line">// 当我们调用 callers 方法的时候，pc 这个array 的容量一定要足够大，否则 n 一直不会渠道数据</span><br><span class="line">// runtime.FuncForPC(pc[skip]).FileLine(pc[skip]) , 这个方法比较好玩，从上面calles 获取   //到的指针连获取对应方法的方法名和 函数</span><br></pre></td></tr></table></figure><p><a href="https://colobu.com/2018/11/03/get-function-name-in-go/" target="_blank" rel="noopener">https://colobu.com/2018/11/03/get-function-name-in-go/</a>, 这篇文章也对上面两个方法做了详细的解释</p><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>429  ，限流了</p><p>499 ， 服务端返回的时间超出客户端设置的超时时间，到这客户端提前关闭</p><h2 id="fmt问题"><a href="#fmt问题" class="headerlink" title="fmt问题"></a>fmt问题</h2><p>平时为了打印结构体我们就用 fmt.printf(“%+v”), 但当我们用[]<em>struct 的时候，这个打印就不好使了，会直接打印内存地址（我们为啥要用</em>struct， 因为遍历的时候 struct 不能修改值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type Stu struct &#123;</span><br><span class="line">Name string `json:&quot;name&quot;`</span><br><span class="line">Age string `json:&quot;age&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*func (t *Stu)String()  string&#123;</span><br><span class="line">return &quot;11&quot;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">str := `</span><br><span class="line">[&#123;&quot;name&quot;:&quot;12&quot;&#125;]</span><br><span class="line">`</span><br><span class="line">var students []Stu</span><br><span class="line"></span><br><span class="line">err := json.Unmarshal([]byte(str), &amp;students)</span><br><span class="line"></span><br><span class="line">for _, v := range students &#123;</span><br><span class="line">v.Name = &quot;xiugia111&quot;</span><br><span class="line">v.Age = &quot;1111&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%+v &quot;, students[0], err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为了让修改生效，我们必须让 students []*Stu</span><br><span class="line">// 但这样之后我们打印 []*Stud 就是内存地址，我们需要哥 *Stu 定义 string() 方法，这样就能 fmt // 直接打印了</span><br></pre></td></tr></table></figure><h3 id="Kafka使用"><a href="#Kafka使用" class="headerlink" title="Kafka使用"></a>Kafka使用</h3><h3 id="Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）"><a href="#Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）" class="headerlink" title="Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）"></a>Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）</h3><p>今天在使用es 的时候，想起了之前使用redis 的时候有not found 的判定，找了下 果然这个es 包中也有。只是这个es 包判定not found 用的是方法，原理是 http 请求的code，相比较redis， 感觉这个更靠谱些。</p><h3 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h3><p>time 很实用的一个方法， time.Since 可以获取时间差</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读源码学到的新的语法，补充自己对go的更多了解&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go 包的学习</title>
    <link href="http://yoursite.com/2020/07/03/go-%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/03/go-包的学习/</id>
    <published>2020-07-03T06:41:03.000Z</published>
    <updated>2020-07-03T06:47:03.682Z</updated>
    
    <content type="html"><![CDATA[<p>go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们</p><a id="more"></a><p>math/rand</p><p>随机数我们经常用到，php 中rand(), 就能生成一个随机数，但是go中不行，详见 <a href="https://blog.sqrtthree.com/articles/random-number-in-golang/" target="_blank" rel="noopener">https://blog.sqrtthree.com/articles/random-number-in-golang/</a></p><p>这篇文章的解释。php 中也有seed 的概念，不太清楚php中默认seed 是什么，因为一直改变，导致rand() 产生的随机数一直在变，我们可以通过函数设置seed 固定，这样rand 产生的随机数就不变了</p><p>ps: seed 并不是 rand 产生随机数从上限的概念，应该是随机数算法中用到的。还有go rand产生的随机数好像都是从1 开始的，比如我们想从5 开始，可以给产生的随机数都 + 5， 就能满足需求了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-并发</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/07/02/go-并发/</id>
    <published>2020-07-02T13:56:22.000Z</published>
    <updated>2020-10-14T13:24:10.529Z</updated>
    
    <content type="html"><![CDATA[<p>这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较go 的多进程 （process）和 java的多线程（thread）更轻量。</p><a id="more"></a><p>我们在我们项目代码中可以随意的通过 go func（）{} （） 生成一个goroutine， 不同的goroutine 可以执行不同的逻辑，我们的主进程也可以看成一个goroutine，他会不等待 其他的goroutine, 如果main 执行完了，其他的goroutine 会自动结束，不管有没有执行完， 所以我们经常在代码的尾部，sleep ，等待其他goroutine执行完。但这只是demo，真正工作中无法知道一个goroutine 要执行的时间，比如 curl的返回，多种方法可以解决上述的问题，等待goroutine 执行完。</p><p>1.我们可以通过go 的sync 包，同步阻塞，等待所有的goroutine 执行完。</p><p>sync.waitGroup 只是让goroutine 在没有channel 的执行下也阻塞住了，等待goroutine的执行，但并没有解决线程安全的问题。</p><p>2.通过channel ，我们在channel 的使用过程中经常会发生死锁问题，这恰恰是我们可以通过channel 等待goroutine 执行的关键所在。</p><p><a href="https://studygolang.com/articles/18800" target="_blank" rel="noopener">https://studygolang.com/articles/18800</a></p><p>这篇文章很好的解释了channel 造成死锁的几个原因。</p><p><a href="https://juejin.im/post/5d216f07e51d4550bf1ae8e0" target="_blank" rel="noopener">https://juejin.im/post/5d216f07e51d4550bf1ae8e0</a></p><p>掘金的这篇文章比较简单，但也说明了channel的几个使用场景。</p><p>关于并发：</p><p>首先想说一下关于并发的场景，其实并发在生活中很常见，只要用户量足够多，同一时刻很可能有两个人在做同样的事情，但这不是高并发，高并发常见的场景就是秒杀的时候，很多用户在某一个时刻被召集起来争抢有限的资源。总结：就是某一时刻某个api 被大量请求，这就是我们压测的原因， 在高并发的情况下我们的服务是否稳定。</p><p>其实很多时候我们的接口在高并发下其实没啥影响，比如幂等的接口（获取某个后台配置），只要我们的服务器撑得住，多少的并发量不是问题，这不是目前我想表达的并发，想说的是非幂等性接口在高并发下的危险性，比如秒杀情况下的超卖。为什么会出现超卖，就是我们在获取数据的同时并不是立马就能处理逻辑，比如在我们减少库存的途中，另一个请求先完成了，导致库存数已经为0了，这时候虽然我们之前的库存1 ，减少为0 合情合理，但其实我们在减少库存1的时候库存数量已经是0了，我们并不知道，所以实际库存已经是 -1了，这就是超卖。</p><p>这个库存可以类比到我们代码中就是公共变量，在lnmp的架构中，因为我们的webserver其实是 fpm提供的，fpm 会有多个进程，每个进程中有php，我们的业务代码存在于每个进程中，每当请求结束，这个进程中的变量生命周期就结束了，这种同步模式不存在公共变量读写不一致问题，唯一可能的就是我们从第三方中间件比如redis 比如 mysql中数据读写不一致问题，一般是redis ，所以就有了 redis + lua 的 原子性操作。</p><p>而在go 中，当我们用go 的 net/http 包做webserver 的时候，对于全局变量，不同的goroutine会存在读写不一致问题， 这时候我们就会引入sync 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决goroutine 一起完成我们引入了</span><br><span class="line">w sync.WaitGroup</span><br><span class="line"></span><br><span class="line">// 添加4个goroutine</span><br><span class="line">w.add(4)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">  defer w.Done()</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">// 完成</span><br><span class="line">w.Wait()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决读写不一致问题</span><br><span class="line">// 互斥锁</span><br><span class="line">r sync.Mutex</span><br><span class="line"></span><br><span class="line">r.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.Unlock()</span><br><span class="line"></span><br><span class="line">// 注意这个锁是针对代码的，而不是针对资源的，同一时刻只能有一个goroutine能执行</span><br><span class="line">// 我们不能随便用 defer r.Unlock() , 当锁不存在的时候会报错</span><br><span class="line">// 互斥锁有时候太严格，比如两个读操作，并不需要等待</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决上述问题，出现了读写锁</span><br><span class="line">r Sync.RWMutex</span><br><span class="line"></span><br><span class="line">// 读锁</span><br><span class="line">r.Rlock()</span><br><span class="line">r.RUnlock()</span><br><span class="line"></span><br><span class="line">// 写锁</span><br><span class="line">r.Lock()</span><br><span class="line">r.Unlock()</span><br><span class="line"></span><br><span class="line">// 相比于普通锁 (读写锁性能更高，因为两个读锁之间不会互斥)</span><br><span class="line">r Sync.Mutex </span><br><span class="line"></span><br><span class="line">r.Lock()</span><br><span class="line">r.Unlock()</span><br></pre></td></tr></table></figure><p>模拟并发的出现也是个技术活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样正常情况下不会发生超卖，因为间隔时间太短</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">     time.Sleep(5 * time.Second)  // 睡个5s ，必然出现</span><br><span class="line">     </span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除了锁之外，还可以通过原子性操作解决并发问题</span><br><span class="line">// data++ 这种操作原来也会出现线程不安全问题</span><br></pre></td></tr></table></figure><p>go 对于并发问题的解决，经常用到goroutine,我们用goroutine 经常会造成 死锁，我们来分析一下这些原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">result:=make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">sum:=0</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">sum=sum+i</span><br><span class="line">&#125;</span><br><span class="line">result&lt;-sum</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Print(&lt;-result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不会造成死锁，以上示例使用一个单独的goroutine求和，当得到结果时，存放在result这个chan里，然后供main goroutine读取出来。当result没有被存储值的时候，读取result是阻塞的，所以会等到结果返回，协同工作，通过chan通信。</span><br><span class="line"></span><br><span class="line">// 如果这个 &lt;- result 是写在go func 上面，就会造成，因为一直阻塞在读取 chan 处，并不会执行到协程处，就会造成死锁</span><br></pre></td></tr></table></figure><p>多进程下面读写安全的map(其实很简单，读取的时候加读锁，写的时候加写锁)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package common</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line">//安全的Map</span><br><span class="line">type SynchronizedMap struct &#123;</span><br><span class="line">rw *sync.RWMutex</span><br><span class="line">data map[interface&#123;&#125;]interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//存储操作</span><br><span class="line">func (sm *SynchronizedMap) Put(k,v interface&#123;&#125;)&#123;</span><br><span class="line">sm.rw.Lock()</span><br><span class="line">defer sm.rw.Unlock()</span><br><span class="line"></span><br><span class="line">sm.data[k]=v</span><br><span class="line">&#125;</span><br><span class="line">//获取操作</span><br><span class="line">func (sm *SynchronizedMap) Get(k interface&#123;&#125;) interface&#123;&#125;&#123;</span><br><span class="line">sm.rw.RLock()</span><br><span class="line">defer sm.rw.RUnlock()</span><br><span class="line"></span><br><span class="line">return sm.data[k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除操作</span><br><span class="line">func (sm *SynchronizedMap) Delete(k interface&#123;&#125;) &#123;</span><br><span class="line">sm.rw.Lock()</span><br><span class="line">defer sm.rw.Unlock()</span><br><span class="line"></span><br><span class="line">delete(sm.data,k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历Map，并且把遍历的值给回调函数，可以让调用者控制做任何事情</span><br><span class="line">func (sm *SynchronizedMap) Each(cb func (interface&#123;&#125;,interface&#123;&#125;))&#123;</span><br><span class="line">sm.rw.RLock()</span><br><span class="line">defer sm.rw.RUnlock()</span><br><span class="line"></span><br><span class="line">for k, v := range sm.data &#123;</span><br><span class="line">cb(k,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成初始化一个SynchronizedMap</span><br><span class="line">func NewSynchronizedMap() *SynchronizedMap&#123;</span><br><span class="line">return &amp;SynchronizedMap&#123;</span><br><span class="line">rw:new(sync.RWMutex),</span><br><span class="line">data:make(map[interface&#123;&#125;]interface&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 之前模拟过一个例子</span><br><span class="line">// 利用500 个goroutine 对 普通map 进行增加，会发现运行结束，count 的值不是500</span><br><span class="line">// 对上面的 安全map 修改，count 的值也不正确</span><br><span class="line">// 因为上面的值只有get ， get完 +1 put， 这不是原子性，所以只有 incr 方法才能让最终的值是500</span><br></pre></td></tr></table></figure><p>关于 context ,很重要的一个知识点，对于并发，我们之前一直通过 waitgroup . add 去添加信号量，但是对于 树状的goroutine， 这样会越来越复杂，完美的方式还是通过 context 上下文的传递。 我们设置一个可以随时取消的上下文，当上下文被cancel 的时候，这个请求自然就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 本质上这些 控制并发用的都是 channel</span><br><span class="line">// channel 也经常用于 代码的阻塞</span><br><span class="line">// 下面的代码中如果 一直select 不到数据，会一直default， 但我不知道select 这个频率是多少</span><br><span class="line">func main() &#123;</span><br><span class="line">stop := make(chan bool)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-stop:</span><br><span class="line">fmt.Println(&quot;监控退出，停止了...&quot;)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;goroutine监控中...&quot;)</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">fmt.Println(&quot;可以了，通知监控停止&quot;)</span><br><span class="line">stop&lt;- true</span><br><span class="line">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span><br><span class="line">time.Sleep(5 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 关于 context 需要认知的几个东西</span><br><span class="line"></span><br><span class="line">// 首先是context 的 struct</span><br><span class="line">type Context interface &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok bool) // 方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</span><br><span class="line"></span><br><span class="line">Done() &lt;-chan struct&#123;&#125; // 这个done 方法我们经常用，就是select 获取到值就说明超时了</span><br><span class="line"></span><br><span class="line">Err() error  //方法返回取消的错误原因，因为什么Context被取消。</span><br><span class="line"></span><br><span class="line">Value(key interface&#123;&#125;) interface&#123;&#125; // 这个value 方法在我们项目中用到的就是中间件解析内容，让后放到context里面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 经典用法</span><br><span class="line">func Stream(ctx context.Context, out chan&lt;- Value) error &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">  v, err := DoSomething(ctx)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">  return err</span><br><span class="line">  &#125;</span><br><span class="line">  select &#123;</span><br><span class="line">  case &lt;-ctx.Done():</span><br><span class="line">  return ctx.Err()</span><br><span class="line">  case out &lt;- v:</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 平时经常用的两个context </span><br><span class="line">var (</span><br><span class="line">background = new(emptyCtx)</span><br><span class="line">todo       = new(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Background() Context &#123;</span><br><span class="line">return background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TODO() Context &#123;</span><br><span class="line">return todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context 的衍生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br><span class="line"></span><br><span class="line">这四个With函数，接收的都有一个partent参数，就是父Context，我们要基于这个父Context创建出子Context的意思，这种方式可以理解为子Context对父Context的继承，也可以理解为基于父Context的衍生。</span><br><span class="line"></span><br><span class="line">通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。</span><br><span class="line"></span><br><span class="line">WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。 WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。</span><br><span class="line"></span><br><span class="line">WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。</span><br><span class="line"></span><br><span class="line">WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">withxxx  返回的 cancel 我们可以主动调用， 完了就可以取消这个context ， 这时候 done() 方法就能获取到内容了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于 withValue 赋值</span><br><span class="line">//</span><br><span class="line">我们可以使用context.WithValue方法附加一对K-V的键值对，这里Key必须是等价性的，也就是具有可比性；Value值要是线程安全的。</span><br><span class="line"></span><br><span class="line">这样我们就生成了一个新的Context，这个新的Context带有这个键值对，在使用的时候，可以通过Value方法读取ctx.Value(key)。</span><br><span class="line"></span><br><span class="line">记住，使用WithValue传值，一般是必须的值，不要什么值都传递。</span><br><span class="line">// 就是 k v 形式</span><br></pre></td></tr></table></figure><p>上下文真是个好东西, 方便我们 协程隔离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前写代码的过程中，发现大佬们在中间件解析用户uid 的时候都通过 constant.withValue 存储到上下文中，当时很不理解，为啥不直接 全局变量存储，后来想通了，go 中 包内变量多goroutine共享，很容易相互污染。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">分析一下这个源码包</span><br><span class="line"></span><br><span class="line">思路就是 以 http.request 地址为key， 存储在一个全局的map 中（感觉这个map 还挺大的）</span><br><span class="line"></span><br><span class="line">value 是个map[interface&#123;&#125;]interface&#123;&#125; 存储我们需要 set 的 key value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">get set 方法就是 对map 的 获取写入，然后注意读写锁</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">获取整个map 我们类似 copy slice， 因为 map 是地址类型，我们直接给出去了，万一修改了，会污染之前的src map</span><br></pre></td></tr></table></figure><p>番外：gin 的context 竟然没有 WithContext 方法太奇怪了吧， 害的hms 直接封装了 一个属性代表 空的 context</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较go 的多进程 （process）和 java的多线程（thread）更轻量。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>go-反射</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/07/02/go-反射/</id>
    <published>2020-07-02T08:13:01.000Z</published>
    <updated>2020-07-02T08:38:33.837Z</updated>
    
    <content type="html"><![CDATA[<p>反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。</p><a id="more"></a><p>go中反射的使用当然包含上述依赖注入的场景，目前我接触到的场景就是struct 中tag 的使用，比如struct 在json string 中 对于json属性名的自动转小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Name struct&#123;</span><br><span class="line">   name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := Name&#123;&quot;111&quot;&#125;</span><br><span class="line"></span><br><span class="line">r := reflect.TypeOf(a)  // 返回一个type 类型</span><br><span class="line">r.NumField()  // 返回属性的个数</span><br><span class="line">r.Field(i) // 返回第i 个属性</span><br><span class="line">r.Name() // 获取属性的名称</span><br><span class="line">r.Kind() // 获取属性的类别 ，比如自定义结构体叫myStruct, kind 返回 struct, name 返回myStruct</span><br><span class="line"></span><br><span class="line">// 对于地址类型</span><br><span class="line">r := reflect.TypeOf(a).Elem() // 返回一个type类型，我们就能愉快的使用接下来的那些方法了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(a)  // 返回一个value 类型 ，（把类型和值分开了，虽然感觉很奇怪）</span><br><span class="line">v.Field(i) 这个返回的类型和上面type 的类型还不一样，上面的那个可以获取tag等属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 还有个很重要的就是函数的反射</span><br><span class="line"></span><br><span class="line">func Sum(a int, b int) int &#123;</span><br><span class="line">   return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := reflect.ValueOf(Sum)</span><br><span class="line"></span><br><span class="line">// 注意call 调用的时候必须是[]value, 然后单个value 可以用ValueOf 来返回</span><br><span class="line">p.Call(reflect.Value&#123;reflect.ValueOf(10), reflect.ValueOf(20)&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>go-加密</title>
    <link href="http://yoursite.com/2020/06/17/go-%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2020/06/17/go-加密/</id>
    <published>2020-06-17T07:23:40.000Z</published>
    <updated>2020-06-17T07:27:06.817Z</updated>
    
    <content type="html"><![CDATA[<p>加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>go 数据库原生操作</title>
    <link href="http://yoursite.com/2020/06/09/go-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%94%9F%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/06/09/go-数据库原生操作/</id>
    <published>2020-06-09T12:28:16.000Z</published>
    <updated>2020-06-09T12:52:51.286Z</updated>
    
    <content type="html"><![CDATA[<p>go web 开发，操作mysql 是基础啦</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;database/sql&quot;</span><br><span class="line">   _ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line">首先是包的引入，很常见吧，下面那个驱动引入，却未使用可能是只希望使用这个包的 init()方法</span><br></pre></td></tr></table></figure><blockquote><p>通常来说, 不应该直接使用驱动所提供的方法, 而是应该使用 sql.DB, 因此在导入 mysql 驱动时, 这里使用了匿名导入的方式(在包路径前添加 _), 当导入了一个数据库驱动后, 此驱动会自行初始化并注册自己到Golang的database/sql上下文中, 因此我们就可以通过 database/sql 包提供的方法访问数据库了.</p><p>可能这就是interface 的作用吧</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type DbWorker struct &#123;</span><br><span class="line">    //mysql data source name</span><br><span class="line">    Dsn string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    dbw := DbWorker&#123;</span><br><span class="line">        Dsn: &quot;user:password@tcp(127.0.0.1:3306)/test&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    db, err := sql.Open(&quot;mysql&quot;,</span><br><span class="line">        dbw.Dsn) // 返回一个sql.DB 的指针</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>sql.Open并不会立即建立一个数据库的网络连接, 也不会对数据库链接参数的合法性做检验, 它仅仅是初始化一个sql.DB对象. 当真正进行第一次数据库查询操作时, 此时才会真正建立网络连接;</li><li>sql.DB表示操作数据库的抽象接口的对象，但不是所谓的数据库连接对象，sql.DB对象只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法;</li><li>sql.Open返回的sql.DB对象是协程并发安全的.</li><li>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</li></ol><p>所以我们平时用的都是长连接，在池子里面可以复用的啦。平时我们在 prepare ，query(查询)， exec(插入，修改) 之后都要及时 close</p><p>MySQL 5.5 之前， UTF8 编码只支持1-3个字节,从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，utf8mb4兼容utf8，所以能支持更多的字符集;关于emoji表情的话mysql的utf8是不支持，需要修改设置为utf8mb4，才能支持。</p><p>(4 字节的utf8 我们应该一直在用啦)</p></blockquote><p>插入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;insert tasks (content, user, create_at, update_at, deleted) values (?, ?, ?, ?, ?)&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">now, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2016-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">update := time.Now().Format(&quot;2006-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">result, err := stmt.Exec(&quot;测试&quot;, &quot;cy&quot;, now, update, 0)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(result.LastInsertId())</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;update tasks set content = ? where id = ?&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">stmt.Exec(&quot;ceshi11111&quot;, 2)</span><br></pre></td></tr></table></figure><p>查询代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:wyqnkxk2012_CY@tcp(118.184.219.156)/cy&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">err = db.Ping()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//update(db)</span><br><span class="line">//return</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(&quot;select * from tasks where id = ?&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(stmt)</span><br><span class="line">&#125;</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">rows, err := stmt.Query(3)</span><br><span class="line"></span><br><span class="line">defer rows.Close()</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := []*task&#123;&#125;</span><br><span class="line"></span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">tmp := &amp;task&#123;&#125;</span><br><span class="line">rows.Scan(&amp;tmp.id, &amp;tmp.content, &amp;tmp.user, &amp;tmp.create_at, &amp;tmp.update_at, &amp;tmp.deleted)</span><br><span class="line">arr = append(arr, tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go web 开发，操作mysql 是基础啦&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go time</title>
    <link href="http://yoursite.com/2020/06/09/go-time/"/>
    <id>http://yoursite.com/2020/06/09/go-time/</id>
    <published>2020-06-09T11:47:50.000Z</published>
    <updated>2020-07-03T08:50:54.958Z</updated>
    
    <content type="html"><![CDATA[<p>go 中时间包的使用</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">time.Now() // time 包的 Time 类型</span><br><span class="line"></span><br><span class="line">// Time</span><br><span class="line">// 2018-05-31 09:22:19 +0800 CST Time 类型打印出来长这样</span><br><span class="line">time.Now() // 获取当前时间的Time 类型</span><br><span class="line">time.Now().Unix()  Time 类型装 int64</span><br><span class="line">time.Now().Unix()Formate(&quot;2006-01-02 15:04:05&quot;) // 格式化</span><br><span class="line">time.Now().in(a)  // 使用某个时区，返回的是Time 类型，所以可以用</span><br><span class="line"></span><br><span class="line">// location</span><br><span class="line">time.Location() // 返回时区信息</span><br><span class="line">a,_ := time.LoadLocation(&quot;UTC&quot;)  // time 包的 location,如果想用时区，就得用这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数字转Time</span><br><span class="line">time.Unix(11111)</span><br><span class="line"></span><br><span class="line">// 字符串转Time</span><br><span class="line">time.Parse() 和 Time.Format() 是互逆的两个函数</span><br><span class="line">time.Parse() 解析字符串成Time 的时候需要时区信息，我们可以用Loadlocation获取时区信息，然后作为第三个参数传进去</span><br><span class="line"></span><br><span class="line">// Duration </span><br><span class="line">这个在sleep 的时候经常用到</span><br><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond          = 1000 * Nanosecond</span><br><span class="line">    Millisecond          = 1000 * Microsecond</span><br><span class="line">    Second               = 1000 * Millisecond</span><br><span class="line">    Minute               = 60 * Second</span><br><span class="line">    Hour                 = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>今天遇到一个问题，比如sleep() ,这个参数需要是 time.duration, 但是我需要可控的 整数， 6 <em> time.Second， 这样执行不了，需要把 6转换成 time.Duration(6) </em> time.Second, 这样就能运算了。</p><p>这个其实并不是包的特殊性，还是golang语法自身问题自己了解的不足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type c int</span><br><span class="line"></span><br><span class="line">var cparam int</span><br><span class="line">cparam = 1</span><br><span class="line"></span><br><span class="line">o := 1</span><br><span class="line"></span><br><span class="line">fmt.Println(cparam == o)  // 必然报错，虽然是别名，但还是不同类型</span><br><span class="line"></span><br><span class="line">time.Sleep(6 * time.Second) // 这是因为 6可以当做 time.Duration 类型</span><br><span class="line"></span><br><span class="line">可是</span><br><span class="line">r := rand.Int() // int</span><br><span class="line"></span><br><span class="line">time.Sleep(r * time.Second) // 不同的数据类型不能相乘</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天还发现 time 包的一个很牛逼的方法，涉及channl， 所以只有 goroutine 的时候用得到。 time.After() 是一个channl 在规定时间后可以读取一个数据，利用select 机制，可以控制超时问题。</span><br></pre></td></tr></table></figure><p>今天 发现go 去修改时间也很方便，比如</p><p>time.Add() 比如 + 1天， -1 天，</p><p>Sub() 计算两天的差值（不是用来算负数天的哦）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 中时间包的使用&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>go 环境搭建</title>
    <link href="http://yoursite.com/2020/06/06/go-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/06/go-环境搭建/</id>
    <published>2020-06-06T08:24:09.000Z</published>
    <updated>2020-07-01T13:02:18.471Z</updated>
    
    <content type="html"><![CDATA[<p>go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了</p><a id="more"></a><p>学习任何一门语言，刚开始面对的第一个问题就是环境的搭建吧，相较于php的编译安装，go的环境搭建更加简单。</p><p>首先要明确的一点是go 是交叉编译，所以我们无论在win 还是 mac 还是 linux 下开发都是一样的。php 有很多扩展比如redis ，在win下版本比较少，所以我们不得不需要一个linux 环境， 我们平时开发php ，是把远程服务器的代码sftp 到本地，然后本地代码的修改实时上传到服务器上，在服务器上跑。go不需要 （goland 甚至连着个功能都没有，需要装插件）。</p><ol><li><p>下载go的安装包，因为墙的原因，我们可以去 studygolang 上面下载，win和 mac 都是那种点击下一步傻瓜般的安装，linux 下安装也很简单，下载解压完之后就是一个编译好的二进制包（就像php 编译完成那样）。我们只需要把 我们环境变量的 path ，添加上 go下载包中的bin，就能直接使用go的命令了。linux 下可以直接编译 /etc/profile, source /etc/profile 生效。保存好后 echo  $PATH，查看path 。</p></li><li><p>go 安装需要注意的几个路基</p><p>goroot  就是我们（linux 下解压完go 安装包的地址，win 和 mac 下是我们自己制定的go 安装路基）</p><p>gopath 是我们自己制定的一个文件夹，需要在这下面手动建立 bin， pkg， src 三个目录，其中bin 是我们日后编译生成二进制文件的地方，pkg 很重要，里面的mod 文件就是我们安装的第三方库所在的目录，src 就是在 go mod 没出现前，我们存放我们项目代码的地方(之前就觉得我们的代码只能存放在一个地方，很不方便，go mod 的出现就不需要管这个文件夹了）</p><p>go env 我们可以查看和 go 相关的 环境变量，必要重要的有  GO111MODULE, 怎么设置  go env -w </p><p> GO111MODULE=”on”,  还有 GOPROXY=<a href="https://goproxy.cn,direct，" target="_blank" rel="noopener">https://goproxy.cn,direct，</a> goproxy.cn 就是 七牛云搞的golang 下载包中国镜像，后面的direct 代表如果找不到，就直接按照网址下载。go 的第三方包的命名很好玩，基本就是这个仓库所在的可以访问的url 路径，比如 code.chenye2017.cn/xxx/xxx, 不需要像composer 那样中间走一层代理，那层代理还要给你开访问权限，才能下载。</p></li></ol><p>3.在用goland 编辑的时候，会遇到包找不到的请款，我们需要手动 seting 去配置 goroot  gopath ，还要开启vgo（就是gomod）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200606164735.png" alt=""></p><p>这个地方要选空，否则还是会出现包找不到的问题。</p><p>4.go mod 的使用，go mod init xxx 初始化项目，生成 go mod 文件，类似composer init 生成 composer.json，go run main.go 开始跑项目啦。会自动下载需要的安装包，这个相比于composer install 更加的方便。</p><p>今天在初始化别人项目的时候发现goland 的 go vgo 已经设置好了，但是还是找不到go module 的位置，仔细一看发现是自定义的package name 找不到。当我们想用go module 的时候，我们一定要 go init 起一个默认的命名空间，然后当我们使用自己定义的包名的时候，都会用到这个这个命名空间做前缀。</p><p>以上就是总结的 go 环境安装，完结~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq记录</title>
    <link href="http://yoursite.com/2020/05/26/rabbitmq%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/05/26/rabbitmq记录/</id>
    <published>2020-05-26T03:45:16.000Z</published>
    <updated>2020-10-10T07:21:06.465Z</updated>
    
    <content type="html"><![CDATA[<p>rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 <a href="http://docs.php.net/manual/da/book.amqp.php" target="_blank" rel="noopener">http://docs.php.net/manual/da/book.amqp.php</a>，一种是市面上比较流行的库<a href="https://github.com/php-amqplib/php-amqplib" target="_blank" rel="noopener">https://github.com/php-amqplib/php-amqplib</a>， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。</p><a id="more"></a><h3 id="不同的角色"><a href="#不同的角色" class="headerlink" title="不同的角色"></a>不同的角色</h3><p>关于rabbitmq 的理论知识，<a href="https://www.cnblogs.com/wutianqi/p/10043011.html" target="_blank" rel="noopener">https://www.cnblogs.com/wutianqi/p/10043011.html</a>， 这篇文章讲解的很清楚。</p><p>生产者 : 也是通过channel， 去 declare 一个 队列 ，然后发送消息（为什么要使用channel， 因为tcp 连接断开重建很浪费资源）。如果中间没走exchange 的 话，就不需要 routing key 了 。很多人经常把routing key 和  队列名称写一样，因为可能这个消息当初考虑的时候就是专门给这个队列queue 使用的。但其实 routing key  和 queue 可以不一样的，消费者在定义自己的队列便于接受 exchange 投递过来的消息，routing key 就相当于一把钥匙，可以打开这个队列的门。</p><p>上面关于生产者的描述并不准确，上面的过程大概就是单个脚本发送消息的过程，是一种翻译。准确的生产者只做一件事，就是发送消息。首先获取connection， 再通过connection 去获取channel (如果是消费者的channel ，我们在rabbitmq的管理界面还能获取到这个消费者的详细信息)。然后通过channel 去 publish 消息，就结束了。其中关于exchange 的 declare ，是重复的操作，我们可以提取出来，而不分给生产者发送消息这个行为 ，因为publish 的时候我们是不需要exchange 的declare 的，我们完全可以手动在web 上新建exchange， 然后publish的时候填入 exchange 的名称。同理 queue的declare 也是如此。所以我们在生产者消费者的同时，我们可以一方去declare 就好了。</p><p>channel 的publish 方法第二个参数是key ，当我们是 简单或者工作或者 fanout 模式的时候，这个key 就是 queue的名称。一定要注意如果这个key 是空的，或者不存在，我们的消息就会丢弃，因为没地方存储。</p><p>说到这里，就需要注意一下我之前的一个误区，开了生产者，然后启动消费者，消费者拿不到消息，消息为啥丢失了吗？我的理解中，不应该消息积存了，后来消费者启动了，开始消费吗？其实主要是exchange 不能存消息的，当我们启动消费者的时候，经常会启动一个队列，如果这个队列以前不存在，exchange拿着routing key 匹配不到 队列，就会把这个消息丢失。</p><p>消费者：和上面的生产者对应</p><p>同理，消息者其实也是获取到一个connection， connection 获取到channel ，我们就可以去消费消息了 （go 消费消息好像只能用协程的方式）。channel consume 的时候需要一个 queue 的名称，其他什么都不需要。但我们需要把这个queue 绑定到对应的exchange 上，注意了！！！因为识货一直用的routing key 都是字符串，所以不涉及匹配模式，所以我们很容易把生产者的routing key 和 消费者的routing key 当做一个，其实在topic 模式下  queue的 routingkey 需要是正则表达式，比如 #.coupon.#, 生产者 1.coupon.2 就能被这个消费者消费到，不要搞反了。 #可以接收到所有的消息。</p><p>总结：</p><p>所以我觉得，对于生产者，可以定义exchange ，但是queue 这些没必要，因为我们发送消息的时候只要exchange ，和 routing key 。</p><p>对于消费者，可以定义exchange （如果生产者没定义）。需要定义queue，因为consume 的时候需要，需要queue bind exchange 利用 binding key。</p><p>消息代理： broker ，kafka 也有这个玩意，但kafka 的broker 上面有分区，可以存储消息 （rabbitmq 就是一种消息代理）</p><p>虚拟主机：vhost,  识货到现在都没用 （可以利用不同域名区分生产和开发环境，识货直接用的不同的ip）</p><p>交换机：exchange，识货到现在只用一个exchange 就是 amp.topic</p><p>绑定： binding， 把队列queue 和 exchange 绑定起来</p><p>路由键： routing key， 生产者把消息推送到 exchange 上</p><p>队列：queue</p><p>连接： connection</p><p>通道： channel</p><p>消费者： consumer</p><h3 id="不同的工作模式"><a href="#不同的工作模式" class="headerlink" title="不同的工作模式"></a>不同的工作模式</h3><p>一共有5中</p><p>没有exchange 的有simple 和 work 模式，simple  p -&gt; queue-&gt;c,  这样</p><p>work  p-&gt; queue -&gt;(c1, c2)</p><p>exchange 又分多种工作模式，比如topic, direct, fanout. (这三种相较于上面的 work 模式就是不同的队列消费的是同样的消息)。工作中其实我们无意的都在使用work 模式，因为会启动多个消费者。之所以多个消费者消费不同的消息，是因为我们的生产者的routingkey 是不一样的，即使我们消费者的binding key 是一样的。</p><p>识货用的都是direct  （虽然 amq.topic 这个交换机的类型是topic ），但是绑定 exchange 的queue 的 bindingkey 一直类似 a.b.c 这样，所以其实就是direct。这种有个坏处就是某个queue 需要另一个routing key的数据，我们不得不在这个queue上绑定一个新的bindingkey 对应这个新的routing key， topic 模式就是为了解决这个问题出现的 ， bindingkey 对于 routing key 的模糊匹配。那什么是fanout呢，fanout就是不要routing key 的 direct， 直接推所有绑定到 exchange的 queue。</p><h3 id="写代码的时候应该注意的几个属性"><a href="#写代码的时候应该注意的几个属性" class="headerlink" title="写代码的时候应该注意的几个属性"></a>写代码的时候应该注意的几个属性</h3><p>交换机的属性：（识货就用一个交换机 amp.topic 所以这些都没用用过）</p><p>name:</p><p>durable: 持久化，消息代理重启后，交换机是否还存在。交换机有两个状态，持久（durable）、暂存（transient）。持久化的交换机会在消息代理重启后依旧存在，而暂存的交换机则不会。</p><p>auto-delete: 当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它。</p><p>arguments: 依赖代理本身</p><p>队列属性：</p><p>name:</p><p>durable: 消息代理重启后，队列是否还在。</p><p>exclusive:  只被一个连接使用，连接关闭后，将立即删除队列。（这个排他性也很坑爹，如果设置了，经常别的连接不能用）</p><p>auto-delete: 当所有的消费者都退订队列后将自动删除该队列 .(如果设置false， 经常就是消费者没了，队列也就没了)</p><p>消息属性：(识货这边从来没设置过，照样跑)</p><ul><li><p>Content type（内容类型）</p></li><li><p>Content encoding（内容编码）</p></li><li><p>Routing key（路由键）</p></li><li><p>Delivery mode (persistent or not)</p><p>Delivery mode (persistent or not)<br>投递模式（持久化 或 非持久化）</p></li><li><p>Message priority（消息优先权）</p></li><li><p>Message publishing timestamp（消息发布的时间戳）</p></li><li><p>Expiration period（消息有效期）</p></li><li><p>Publisher application id（发布应用的ID）</p></li></ul><p>消息确认：</p><p>消息确认开启后，如果我们没有确认消息，消息会是 unack 状态，当消费者挂掉后，几秒中unack的消息会重置成total 未消费状态 (一定要注意)</p><p>未确认的东西。识货的消息从来没有设置持久化状态，但是mq 挂掉了之后消息还能找回来。</p><p>(消息能够以持久化的方式发布，AMQP代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162641.png" alt=""></p><p>要善于利用rabbitmq 的管理界面，注意detail 那块，这是我们使用死信队列造成延迟队列。</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162949.png" alt=""></p><p>下面的consumer 可以知道绑定的消费者</p><p>下面的binding 就是通过routingkey 绑定的信息</p><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列的应用场景：比如订单三十分钟内付款有效。</p><p>实现方式：<a href="https://www.cnblogs.com/-mrl/p/11113989.html" target="_blank" rel="noopener">https://www.cnblogs.com/-mrl/p/11113989.html</a></p><p>rabbitmq 延迟队列的实现方式：通过消息过期，转发到死信交换机中。消息过期有两种方式，一种是消息自己的存活时间到达还没有消费，一种是队列的时间到达但其中的消息没有被消费，这两种情况消息都会被投递到死信队列中。</p><p>区别：第一种我们可以单独对每个消息设置存活时间，不需要为了每个不同的时间建立不同的队列，比如a消息三十分钟过期，b消息40分钟过期，我们都投递到一个没有消费者的队列中，消息到期了自动转发到死信队列中。</p><p>补充：</p><p><a href="https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/" target="_blank" rel="noopener">https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/</a></p><p>上面的做法好像缺点更大，容易造成队列堵塞，所以还是弄成不同时间级别的队列吧。</p><p>​</p><p>识货从来没有nack 这种操作，只有ack。</p><p>nack 不等同于超时，超时是还没有应答，属于 unack，nack 是应答错误 ，是程序执行完了。（nack 如果需要重回队列，需要设置 repeat  true，消息回到队列头部重新开始消费，我们需要注意消费消息的幂等性， 还要小心造成死循环。如果没有设置repeat true ，消息会被丢弃）</p><p>unack 的消息在这个消费者挂掉重启的时候会重新被消费 （或者可以被自己的兄弟消费者消费掉）</p><p>好久没用rabbitmq ，认知又有点生疏，以识货代码为例</p><p>produce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$routingKey = $queName = &apos;apps_kb_other&apos;;</span><br><span class="line">$connection = sfContext::getInstance()-&gt;getDatabaseConnection(&apos;rabbitmqHeartbeat&apos;);</span><br><span class="line">            $arguments = array(</span><br><span class="line">                &quot;x-dead-letter-exchange&quot; =&gt; array(&quot;S&quot;, &quot;amq.topic&quot;),</span><br><span class="line">                &quot;x-message-ttl&quot; =&gt; array(&quot;I&quot;, 2000),</span><br><span class="line">                &quot;x-dead-letter-routing-key&quot; =&gt; array(&quot;S&quot;, $routingKey)</span><br><span class="line">            );</span><br><span class="line">            $channel = $connection-&gt;channel();</span><br><span class="line"></span><br><span class="line">            //var_dump(get_class($channel));exit;</span><br><span class="line">            $channel-&gt;queue_declare($queName, false, true, false, false, false, $arguments);</span><br><span class="line">      </span><br><span class="line">     // 声明了一个队列，但在识货这个队列是没啥用的，一般就是等待这个队列的message ttl 到期，然后给到交换机 amq.topic, 利用routing key 绑定一个新的队列，消费者消费这个队列。</span><br></pre></td></tr></table></figure><p>consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$routingKey = &apos;apps_kb_other&apos;;</span><br><span class="line">           $quename = &apos;apps_kb_other_queue&apos;;</span><br><span class="line"></span><br><span class="line">       //    $this-&gt;callback(&apos;&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           // mq consume</span><br><span class="line">           $channel = $connection-&gt;channel();</span><br><span class="line">           $channel-&gt;queue_declare($quename, false, true, false, false, false);</span><br><span class="line">// 这个地方声明的是一个新的queue，跟着routingkey 绑定</span><br><span class="line"></span><br><span class="line">           $channel-&gt;basic_qos(null, 10, null);</span><br><span class="line">         // 一次性不要取出来过多，导致unack 过多  </span><br><span class="line">           $channel-&gt;queue_bind($quename, &quot;amq.topic&quot;, $routingKey);</span><br><span class="line">// 这个新的队列和routingkey 绑定，一定不要和之前那个ttl message 的队列名称一样，虽然不会报错</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">           $channel-&gt;basic_consume($quename, &apos;&apos;, false, false, false, false, [$this, &apos;callback&apos;]);</span><br><span class="line">          // 这个地方quename 也不要写成routingkey 虽然也不会报错吧</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 &lt;a href=&quot;http://docs.php.net/manual/da/book.amqp.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.php.net/manual/da/book.amqp.php&lt;/a&gt;，一种是市面上比较流行的库&lt;a href=&quot;https://github.com/php-amqplib/php-amqplib&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/php-amqplib/php-amqplib&lt;/a&gt;， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>golang-类型转换</title>
    <link href="http://yoursite.com/2020/05/07/golang-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/07/golang-类型转换/</id>
    <published>2020-05-07T13:08:47.000Z</published>
    <updated>2020-05-07T13:15:16.446Z</updated>
    
    <content type="html"><![CDATA[<p>类型转换经常用来</p><a id="more"></a><p>golang是强类型语言, 就算int64 和 int 都要相互转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.Atoi   字符串转int</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型转换经常用来&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://yoursite.com/categories/golang/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>外接广告</title>
    <link href="http://yoursite.com/2020/04/21/%E5%A4%96%E6%8E%A5%E5%B9%BF%E5%91%8A/"/>
    <id>http://yoursite.com/2020/04/21/外接广告/</id>
    <published>2020-04-21T03:36:04.000Z</published>
    <updated>2020-04-21T07:58:39.475Z</updated>
    
    <content type="html"><![CDATA[<p>最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。</p><a id="more"></a><p>首先介绍一下前置知识吧，对于ios 和 android 手机的标识。ios手机现在一般用idfa， 但是用户可以关闭广告追踪，那我们获取到的就是一堆 0000-000··这样乱七八糟的东西，毫无价值，为了实验效果，我们一定要开启ios手机的广告追踪。（怎么快速获取当前手机的idfa，可以在appstore中下载一个myidfa,可以快速获取到，注意字母都是大写）。所以要是苹果手机用户关闭了广告跟踪，那么我们就完全追踪不到点击广告的用户信息了，广告的转化率我们必然</p><p>android 手机五花八门，之前一般都是用的imei ，然后有的手机可能还有多个，目前没有考虑很多的情况，都是取的默认的第一个。但现在imei好像逐渐开始也获取不到了，国内的手机一般用的都建议用oaid，据说覆盖量已经 80%以上（但是oaid是国内手机联盟定的东西，像海外的安卓机器是没有的，而且现在识货android客户端也是不支持回传oaid的）</p><p>主要流程：当我们app（识货）在头条（或者朋友圈）上面投放广告的时候，当用户点击我们投放的广告，会给我们的web server发送一条请求，这个请求包括用户的基本信息，比如ios 的idfa 或者android 的imei,还有个call_back,类似标识这个用户信息是头条回传给我们的，我们拿到这个信息存储下来，当用户启动我们app的时候，我们可以把这个用户的信息（imei 或者 idfa）和 头条回传给我们的信息作比对，如果对应上，然后时间间隔在我们希望之内（比如两天），就可以当做这个用户是头条带来的。</p><h1 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h1><p>头条应该是接入的几个广告主中最简单的。头条是没有账号区分的（接口中让我们传入sign，但其实可以不用传），所以当我门投放部使用多账户进行广告投放，在我们代码中是没有影响的，我门只需要调用头条的上传用户行为的接口，传入设备信息和call_back 就好了。</p><p>坑点：</p><p>1.首先我们要区分开发者和广告主两个角色，开发者角色在这次广告对接中基本没啥用处，就是用来看开发者文档的。广告主角色很重要，因为我们配置好监控链接，联调上传行为的时候需要用广告主角色登陆后台管理界面，进行联调（填写头条用户id，然后刷新头条信息流，出现联调广告，点击，观察头条发起调用我们的url，我们可以直接拿这条url测试我们的监控接口是否正常，然后取出callback 和 idfa或者imei，作为参数调用头条的上传用户行为,这就是整个步骤啦，注意imei属于隐私数据，所以会用md5加密）</p><p>2.在我们联调的时候需要填写很多信息，比如下载链接，ios就是App Store我们应用的连接，android 需要我们上传apk到头条或者自己上传一个到七牛云，说白了，用户点击广告需要下载，我们给他们提供一个下载地址（好像不能用应用宝地址，因为腾讯？）</p><p>3.主要就是上面两个，剩下的就是代码设计方面，首先是对于表的设计，因为头条那边我们回传用户行为不需要去重，所以我们之前的代码中自己检测到属于头条带来的新用户直接就上报了，自己没做任何处理，比如记录日志，比如存表。这样带来一个坏处就是万一逻辑哪里出错了，不好排查，比如我们和bi那边做数据差异对比，完全拿不出证据证明这个用户在我们逻辑中属于新用户，为什么bi那边不算新用户，所以可以把用户的上报行为时间也存下来。</p><h1 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h1><p>快手和头条内容基本一致，就是快手不支持去重，只能我们这边自己去重，所以我们终究要保存下我们上传的用户信息，再次触发上报条件的时候，需要检测之前是否上报过。</p><p>（为什么我们会触发多次激活的上报条件？按理说不正常，但历史原因是识货这边在获取用户启动信息的list里面可能第一次没有获取到imei 或者idfa，这样用户虽然激活了，但是没法匹配到头条那边的点击广告信息，只能在第二次用户启动app的时候去激活）</p><p>快手比价坑的就是他的callback往往很长，··长的你不能想象，所以我们要注意数据库是否会自动截断。</p><h1 id="广点通"><a href="#广点通" class="headerlink" title="广点通"></a>广点通</h1><p>广点通相比较上面二者更加复杂，首先就是多账户系统和开发者。</p><p>1.开发者需要把多账户（多个广告主）接通流程，首先开发者需要自己建立一个应用（这个应用不用区分ios 和 android ，目的就是获取一个appkey 和 appsecret, 这个信息在我们上传用户行为的时候需要，头条那边之前以为也需要，但是他那个sign 可以不传，所以这个应用可以不建立）</p><p>2.建立好应用之后就需要我们通过腾讯系老一套的oauth2.0 ，把广告主账户挂载在这个应用下面，因为应用需要获取我们的广告主信息，所以需要通过模拟第三方登陆，让我们应用获取到广告主的信息（比如accesstoken）,这个accesstoken 很重要，上传用户行为就靠他了。ps:这个accesstoken 有时间限制的，为了让他一直有效，我们需要通过refreshtoken 一直刷新accesstoken 的时间（感觉上就是类似redis 的set， 不断的刷新有效期，可以写个定时任务）</p><p>3.获取到accesstoken ，我们再建立用户行为，（但是激活和次留可以用一个行为id），然后把accesstoken ，行为id，事件回传就可以了</p><p>综上，其实各家广告厂商套路其实都差不多，我们提供给他们的广告连接都是可以加上我们自己的参数的，类似微信登陆我们在回调的时候对于scene字段传入我们自定义的值。我们可以利用这个值作为不同的投放计划名称，方便我们不同计划的统计，虽然头条他们本身也能传给我们计划名称。</p><p>各家公司对于ios 和 android 需要建立不同的计划，但是我们的检测链接可不需要，因为我们可以从他们回传的内容中获取到os,判断是android 还是 ios，而且毕竟是mysql，关系型数据库，我们只需要把它们返回的内容都保存就好了，有个例外就是快手不行，因为他们的回传内容中获取不到os，我们无法判断是android还是ios，（android 和 ios 匹配头条用户信息的逻辑不一样，所以要区分）难道通过idfa或者imei去判断，显然不保险，不如填写两条不同的检测链接，标识哪个是ios ，哪个是android。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="广告" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-validate验证器</title>
    <link href="http://yoursite.com/2019/12/16/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-validate%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/16/tp源码分析-validate验证器/</id>
    <published>2019-12-15T16:12:26.000Z</published>
    <updated>2019-12-15T17:06:37.418Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。</p><p>曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。</p><a id="more"></a><p>首先说下php 的验证库可以做哪些事吧，还是蛮丰富的。</p><ol><li>首先是验证器，在我看来验证器就是单独抽象了一个层出来，我们在controller里面只需要调用，让controller更加简洁，而且也能复用，验证器类都继承于think\validate。</li><li>其次controller 里面的validate 方法可以直接调用，本质上和前面一样都是调用tp的验证器库。</li><li>最后我们如果想单独使用验证器，就当做普通方法那样也是可以的，毕竟有时候我们除了对于传入参数的验证，业务代码中也有一些内容需要验证的。</li></ol><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>属性：</p><p>static type : 这个主要是我们第三种方法独立验证器用到的。rule 规则都存在这里面，当我们使用独立验证器的时候，想扩展验证规则，extend 方法修改的就是这个属性，因为是static， 所以在本次请求的下次使用中，也能调用上次extend 的验证规则</p><p>alias： 就是我们rule 中可以用  &gt;: 5, 当做 gt: 5 来使用</p><p>rule: 验证规则，我们在写验证器的时候，重写的就是这个属性</p><p>message: 提示信息的重写。包含5个占位符，:attribute, :rule, :1, :2, :3</p><p>field: 字段的描述，主要作用用在message中message 中的占位符 :attribute 会被这个内容替代</p><p>typeMsg: 提示信息呗，这块是英文的，最终会通过 lang\zh-cn.php 转换成中文</p><p>currentScene: 当前验证的场景，这个感觉就是为了验证器准备的（场景），其实也蛮实用的，方便验证器中规则的自由组合。</p><p>filter: 主要是利用php filter_var函数的验证</p><p>regex: 主要是用到正则的验证, ctype 也是php 很好用的一个扩展，方便一些特殊字符的验证</p><p>scene: 场景</p><p>error: 错误信息，只有控制器中错误才能抛出异常</p><p>batch: 当前参数验证错误，还能轮到下一个参数</p><p>only: 场景中哪些参数被验证</p><p>remove: 场景中移除</p><p>append: 场景中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">看源码写的一点总结</span><br><span class="line">// remove 不可能移除所有，除非append 中是空</span><br><span class="line">// remove 连续移除是通过 |</span><br><span class="line">// remove append 的最佳实践是二者不要存在顺序关系，因为程序不会鉴别</span><br></pre></td></tr></table></figure><p>方法：</p><p>__construct:  </p><p>rule 验证规则， message 提醒， field 字段描述 :attribute 占位符实际内容</p><p>make:</p><p>new self 生成一个验证器</p><p>rule:</p><p>独立验证修改rule 和 field 属性，供后面check 使用。方便直接传入 rule 和 message </p><p>extend:</p><p>独立验证器中的方法扩展</p><p>setTypeMsg:</p><p>独立验证器中使用</p><p>message:</p><p>提示信息</p><p>scene:</p><p>修改当前验证场景</p><p>hasScene:</p><p>scene 优先考虑 sceneEdit 方法，再考虑 scene -&gt; [‘edit’ =&gt; []] 属性</p><p>batch:</p><p>批量验证</p><p>only:</p><p>场景的使用验证哪些字段</p><p>remove:</p><p>场景移除验证规则</p><p>append:</p><p>场景添加沿正规则: 上线 remove 和 append的调用的时候没有先后顺序 ！！！</p><p>check:</p><p>验证器核心，这时候传入的内容会覆盖掉初始化的内容。</p><p>getScene:</p><p>根据传入的scene 和 current scene 修改 only  remove add 内容</p><p>getDataValue: </p><p>根据传入的data 数组和 可以， 获取对应的内容</p><p>checkItem:</p><p>实际的验证，通过 call_user_func 去调用对应的验证内容</p><p>checkRule:</p><p>官网上这么说，</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191216005751.png" alt=""></p><p>感觉意义不大，毕竟静态方法make 创造的更好用点</p><p>getRuleMsg: </p><p>获取错误信息，可以好好看看，挺好的，调用了lang 类。因为自定义的closure ，如果 不是 === true， 就当做error， 结果就当做errorMsg，和调用类方法还是有点区别的。</p><p>getValidateType:</p><p>像一些 is，比如 isEmail, isIp 都走的is 方法</p><p>后面就是一些验证方法了，以后写代码都可以借鉴下</p><h3 id="ValidateRule"><a href="#ValidateRule" class="headerlink" title="ValidateRule"></a>ValidateRule</h3><p>这个类的主要用途就是通过rule 类的形式去调用对应的验证规则</p><p>属性：</p><p>title  :attribute</p><p>rule 规则</p><p>message 提示信息</p><p>方法：</p><p>addItem ：</p><p>为 is 方法统一添加rule，message 属性</p><p>getRule  getTile  getMesage 获取对应属性</p><p>title 设定title</p><p>——call  </p><p>——callStatic </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。&lt;/p&gt;
&lt;p&gt;曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPhP" scheme="http://yoursite.com/tags/ThinkPhP/"/>
    
      <category term="validate" scheme="http://yoursite.com/tags/validate/"/>
    
  </entry>
  
  <entry>
    <title>持久化</title>
    <link href="http://yoursite.com/2019/12/03/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/12/03/持久化/</id>
    <published>2019-12-03T11:59:55.000Z</published>
    <updated>2020-05-28T13:59:32.128Z</updated>
    
    <content type="html"><![CDATA[<p>我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。</p><a id="more"></a><p>举个例子吧，之前接手的一个任务毒和nike关联出价，当前台下发撤单任务的时候，因为牵扯到很多curl 请求，不能同步实现，1.感觉可以通过把请求内容放到mq当中，然后利用daemon 化的task始终监听这个mq，如果有内容，则触发任务，往后执行，否则停歇1min 继续监听。2.那个前作者是通过把内容放到redis中，通过daemon化的task监听这个redis，如果检测到这个redis这个key，就执行相应任务。</p><p>总结一下吧，其实上面两个方式php的daemon话都是通过while true，那么supervisor 的作用是啥呢，当php的这个脚本挂掉了，supervisor可以重新拉起这个脚本。同理pm2也可以，而且不一定是脚本挂掉，脚本执行完了，也可以重新拉起，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo date(&apos;Y-m-d H:i:s&apos;)</span><br><span class="line">echo &apos;end&apos;;</span><br><span class="line">// 利用上面两个进程管理工具之后，可以一直输出</span><br></pre></td></tr></table></figure><p>上面的例子还有个很重要的技术点就是定时触发。相比较crontab 的task，上面的task 触发任务时间不一致，触发时间靠前台控制，所以我们这时候就通过始终运行一个后台任务，然后靠前台触发一个开关，后端始终运行的task始终监测这个开关，如果是开就运行，虽然可能存在一定时间的误差，但大体上还是能完成任务的。</p><p>再比如之前接手的一个安卓灰度更新的任务，当某个渠道开启灰度之后，我们需要每隔30min发送一条钉钉消息，我们同样可以检测表中渠道是否有开启灰度的状态，如果有，则发一条消息，并记录通知时间，下次的循环任务检测是否灰度还在开启，如果还在开启，检测时间通知是否超过30min，如果超过了，再发送消息，并更新通知时间。</p><p>上面的任务看似已经解决，但还是会涉及一个多进程问题，再举个例子，比如erp系统，需要爬取商户的店铺信息，这个task 要一直执行，如果我们有100个商户，就得运行100个task，启动100个脚本。我们上面灰度通知的好解决，一种办法就是检测运行的渠道，循环运行的渠道列表，然后发送消息通知，另一种就是一次性检测，把渠道更新信息包含在一条短消息中发出去，之所以这么做是因为后续的任务（发送钉钉通知）可以在很短时间内完成，如果像erp的那种爬虫任务，只能通过启动多个脚本了。</p><p>关于php的多进程扩展pnctl 这里暂时不做讨论，说一下pm2 和 supervisor 的简单使用。</p><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p><a href="https://juejin.im/post/5b823506e51d4538d517662f" target="_blank" rel="noopener">这篇文章关于pm2讲解的很好</a></p><p>我比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br><span class="line">pm2 app.js --name wx_spider --watch   // name 名称，方便理解， watch 文件变动，方便重启，类似nodemon</span><br><span class="line">pm2 delete all</span><br><span class="line">pm2 delete (:id)</span><br><span class="line">pm2 restart app</span><br><span class="line">pm2 logs (:name)</span><br></pre></td></tr></table></figure><p>pm2 配置简单，非常好用，echo 的内容之间在log中能看到，除了node， php也是能管理的</p><p>（PM2 的安装需要通过node 和 npm， node 的安装很简单，但我们一定要注意npm 安装的module 位置，如果是linux 下，一定要配置好node_path ,否则 npm -g 安装的内容可能不能使用， npm config  get prefix  可以查看node -g 包安装的位置 。同理node的安装位置最好也是/usr/local/ 下面，方便直接访问）</p><p>今天在使用pm2 管理我的一个task的时候遇到一个问题，就是普通的脚本pm2 start app.js 或者 pm2 start test.php, 但是我现在的命令是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php symfony trade:UpdateCommentDgTags updateUserPublishment  --split=4</span><br></pre></td></tr></table></figure><p>之前的那个命令是肯定不可以的，需要使用配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; //统计报表更新</span><br><span class="line">  &quot;name&quot;: &quot;up4&quot;, // 随便取</span><br><span class="line">  &quot;args&quot;: &quot;trade:UpdateCommentDgTags updateUserPublishment  --split=4&quot;, // 这些都属于参数</span><br><span class="line">  &quot;script&quot;: &quot;symfony&quot;, // 这个地方一定要注意，symfony 其实是脚本，只是没有 .php 的后缀</span><br><span class="line">  &quot;exec_interpreter&quot;: &quot;php&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;Cluster&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;fork&quot;,</span><br><span class="line">  &quot;max_memory_restart&quot;: &quot;100M&quot;,</span><br><span class="line">  &quot;cwd&quot;： &quot;../&quot;  // 上一级目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要注意，这个地方symonfy 是脚本，怪不得之前我在执行task 命令的时候忘记输入symfony ,他说找不到脚本。 后面的那一长串都会统一看成参数，只是参数解析的形式不一样，比如 trade:UpdateCommentDgTags, 解析成方法名称，–split = 4 解析成参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps:   php test.php --goods_id=12 uo22</span><br><span class="line"></span><br><span class="line">test.php</span><br><span class="line">&lt;?php</span><br><span class="line">var_dump($argv)</span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; test.php</span><br><span class="line">    [1] =&gt; uo22</span><br><span class="line">    [2] =&gt; --goods_id=12</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>pm2 log日志的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error log path    │ /home/username/.pm2/logs/app-error-0.log</span><br><span class="line">out log path      │ /home/username/.pm2/logs/app-out-0.log</span><br></pre></td></tr></table></figure><p>需要注意的是这个error 应该是pm2 自身的error, 一般我们程序抛出的都是在out 日志里面</p><p>！！~notice: pm2 虽然香，但也不能乱用，比如之前我在预发布机器上跑的一个task 脚本，因为跑完了，脚本 die， 不断的被pm2重启，导致cpu 很快被耗尽，所以很多脚本停止的时候 都会有个sleep 操作，过一段时间再重启。当然如果你是那种常驻内存，比如node 做的webserver 肯定不用，因为一般不会崩溃，唯一一种就是你的代码有问题，不断的报错，导致服务不断的被唤醒。</p><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p><a href="https://learnku.com/laravel/t/2126/supervisor-installation-configuration-use" target="_blank" rel="noopener">使用和安装可以大致看看这个文章，但这篇文章的配置文件有问题</a></p><p>配置文件里面一定要有[supervisord]和[supervisorctl] 部分，否则会报错。<a href="https://juejin.im/post/5c66be44f265da2de52d784d" target="_blank" rel="noopener">这篇文章应该还可以</a> 需要注意的就是监听端口从 127.0.0.1:9001 改成 0.0.0.0:9001 ,方便外网访问，贴个图</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191203210626.png" alt=""></p><p>基本就能用啦 （比如我那几百万的任务task就能通过这两个处理，不用我一直看着了，跑完了看看 log就好了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="daemon" scheme="http://yoursite.com/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>复盘一下代码的提交流程</title>
    <link href="http://yoursite.com/2019/11/28/%E5%A4%8D%E7%9B%98%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/28/复盘一下代码的提交流程/</id>
    <published>2019-11-28T06:20:02.000Z</published>
    <updated>2019-11-28T10:36:20.370Z</updated>
    
    <content type="html"><![CDATA[<p>昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。</p><a id="more"></a><p>首先我们开发一个功能需要从master上面下拉代码</p><ol><li><p>注意是远程的master，本地的master没啥屌用，因为一般为了提交方便和方便记忆，本地分支和远程分支保持同名，如果你用master 的话，总不能推送到远程master上吧，似乎没人有这个权限。</p></li><li><p>提交代码前是否要合并master ？ 血的例子，别吧。如果你往master上面提交代码没冲突，那就别合并了，对吧，为啥要合并呢 ？只要你的代码正常上线，dont care anything ，因为要是你真的在这个时候合并了远程master，然后远程master 0.01%的可能是个脏master，这时候你的开发分支也就脏了，意味着你合并master 之后改的东西，在领导发现master 脏了之后，都是要被回滚的，回滚的终结点不一定，凭他们的感觉吧，其实感觉就是那个人把release 合并到master 上的点。那问题来了，如果，万一你真的合并了脏master，咋办，其实也好办，你git reset 到合并master之前的那个commit，重新提交给master，看是否能合并，不能合并，再去解决冲突（后面会介绍冲突解决办法），所以感觉在merge 别的分支的时候一定要做好commit message （最好不要改merge 的info，比如当时我修改改成conflict resolve 我都不知道我要回退到哪个版本，其实只要回退到merge 之前的版本就好了）， 有时候真的会帮大忙，方便你的开发分支剔除掉别的合并的内容</p></li><li><p>开发feature中是否要合并master ？ 还是血的例子，别吧。万一你开发分支合并了错误的master，万一你不知道，接着在错误分支上开发，当开发很多的时候，当master 需要回滚的时候会很艰难，毕竟开发了那么多。这时候只能继续相信master， 不断的合并master，其实没啥屌用，你的开发分支已经领先master了，如果你没回滚，你合并的时候只会在人家前面，你会多提交很多内容，这些内容在你给领导要求pr merge 的时候被看到肯定会打回来，~~~不知道咋解决</p></li><li><p>我的流程总结。开发的时候下拉master成为一个开发分支，比如chenye/feature/gray_test, 开发完了，提交dev。万一和dev冲突，下来dev到本地，merge gray_test,看冲突是啥，万一是自己的文件，直接解决。解决完了，推送到远程，给dev提交pr，合并之后，自己的gray_test 就能合并到dev了。注意，在解决冲突的时候一定不要修改自己的开发分支，也就是gray_test, 万一在release 或者 master合并的时候修改了自己的开发分支，一定要dev， release ，master 按顺序重新提交一遍！！！！！否则，别人拉代码的时候一定会冲突。</p></li><li><p>当发现别人的代码冲突的时候咋办，最好的办法就是告诉别人，因为你不知道以哪个为标准。</p><p>你觉得是以master为标准，毕竟线上跑着呢，万一人家当初并不想把代码提交到master上，被另一个同学误操作了，也就是你clone的master是错误代码，这时候以master会覆盖调用dev的正确代码。</p><p>你说以dev标准，毕竟dev是最新的代码 ？还是不对，可能别人着急，直接提交了master，也就是说master代码比dev新，这样dev就会覆盖掉master上的新代码。</p><p>所以遇到这种情况，直接告知吧，任何一种自己修改别人冲突的方法都是不负责任的行为。</p></li></ol><p>顺带提一下最近遇到的win 和 linux 下空格遇到的问题，我们都知道代码是跑在linux下的，所以我们的换行一定要</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160209.png" alt=""></p><p>用这个LF, win下是</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160245.png" alt=""></p><p>我们既然改变不了win，可以通过phpstorm自带的功能，去编辑文件，模拟在linux下的编辑。</p><p>（ps:我是怎么发现这个问题的，在用php的heredoc 换行的时候就能发现）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="虎扑" scheme="http://yoursite.com/tags/%E8%99%8E%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-数据库操作</title>
    <link href="http://yoursite.com/2019/11/17/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/11/17/tp源码分析-数据库操作/</id>
    <published>2019-11-17T07:45:09.000Z</published>
    <updated>2019-11-17T07:53:51.947Z</updated>
    
    <content type="html"><![CDATA[<p>tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo</p><p>的api 去操作数据就好了。</p><a id="more"></a><p>我们先来看看常用的pdo api</p><p>首先是关于pdo的安装部分，我们要安装统一的pdo扩展，然后在这个扩展的基础上安装 pdo mysql ,或者 pdo postgresql，类似针对不同的数据库的驱动的感觉。</p><p>预定义常量：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo&lt;/p&gt;
&lt;p&gt;的api 去操作数据就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go 基础变量</title>
    <link href="http://yoursite.com/2019/11/17/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/go-学习笔记/</id>
    <published>2019-11-17T07:44:14.000Z</published>
    <updated>2020-07-02T08:12:30.665Z</updated>
    
    <content type="html"><![CDATA[<p>php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能</p><a id="more"></a><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>slice 切片的申明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice  底层是指向数组的指针,所以如果我们用 var 去声明的话，默认得到的是一个nil</span><br><span class="line">相比较map 的nil， slice 的 nil 我们是可以append，map的nil 之后我们是没法属性或者给属性赋值的。</span><br><span class="line"></span><br><span class="line">一般 arr := make(a, 0, 10)</span><br><span class="line">arr := []int&#123;1,2&#125;  // 这种方式也用的多，容易被忽略</span><br><span class="line"></span><br><span class="line">ps: 在go中经常有 type cy int, 这种别名</span><br><span class="line">[]cy&#123;&#125;, 这样给切片值其实很正常，类似 []int&#123;&#125;</span><br></pre></td></tr></table></figure><p>map 的申明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map</span><br><span class="line">map[string]string&#123;&quot;namme&quot;: &quot;ccc&quot;&#125;</span><br></pre></td></tr></table></figure><p>变量申明多种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var num int  // 没给初始值，默认 0</span><br><span class="line">num := 1  // 这样更简洁更方便， 函数外不给使用</span><br><span class="line"></span><br><span class="line">int, float64, bool 这都是和别的语言一样的，array , slice, map</span><br><span class="line"></span><br><span class="line">arr1 := [...]int&#123;1,2&#125;  // 因为不能扩展，用的比较少</span><br><span class="line">slice1 := []int&#123;1,2&#125;  // 关联数组</span><br><span class="line">map1 := map1[string]string&#123;&#125; // 索引数组</span><br><span class="line"></span><br><span class="line">// 换一种看法看go， 下面两种都代表数组，只是填充的对象是byte 或者是rune</span><br><span class="line">[]byte&#123;&#125;</span><br><span class="line">[]rune&#123;&#125;</span><br><span class="line">(不管是byte 还是 rune，对应的字符序列都是 十进制，要想转换成 十六进制需要通过 hex.encodetostring ,或者 printf , 第一个只能对 slice 处理，第二个可以对数组)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结构体，类似</span><br><span class="line">type cy struct &#123;</span><br><span class="line">name string `json:Name` // json 的时候生成key 的名称</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cy1 := new(cy)</span><br><span class="line">cy1.name = &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(cy1.name)</span><br><span class="line">//cy 类似类名，所以我们还需要变量名</span><br><span class="line"></span><br><span class="line">// 别名</span><br><span class="line">type</span><br><span class="line"></span><br><span class="line">// map value 定义成某个字段太局限了，可以 map[string]interface&#123;&#125; 这样，更灵活</span><br><span class="line">// :=  map[string]interface&#123;&#125;&#123;&#125; ,一定要给初始值</span><br><span class="line"></span><br><span class="line">// go 中 printf %v  struct 这种不够，因为 名称打印不出来，需要 %+v 打印</span><br></pre></td></tr></table></figure><p>一次性给多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1, arr2 := []int&#123;1,2&#125;, []int&#123;2,3&#125;</span><br></pre></td></tr></table></figure><p>因为go 中的异常机制和php还是有点区别的，很多函数在使用之后会有error 的返回，我们根据 error != nil ,就能知道是否错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if _,error := test(x , y ); error != nil &#123;</span><br><span class="line">  错误处理</span><br><span class="line">&#125; </span><br><span class="line">:=  ,只有多个变量中有一个是新的，:= 不会报错</span><br><span class="line"></span><br><span class="line">真实因为go 的这种语言机制，导致 if 才能这样用，最多有两个表达式，第二个 值的内容是布尔 （上面 _ 属于匿名）</span><br><span class="line"></span><br><span class="line">还有go 中和 js let 一样，都有块状作用域，比如那个 if 里面赋值的变量，只能在 &#123;&#125; 中使用</span><br></pre></td></tr></table></figure><p>var 和 const 一次性声明多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">test1 int</span><br><span class="line">test2 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 枚举，内部可以用iota</span><br><span class="line">const (</span><br><span class="line">test2 iota</span><br><span class="line">test3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>go 中 if 和 for 都是不用括号包裹的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
</feed>
