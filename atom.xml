<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-06T07:24:52.598Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>新的起点</title>
    <link href="http://yoursite.com/2021/02/06/%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9/"/>
    <id>http://yoursite.com/2021/02/06/新的起点/</id>
    <published>2021-02-06T02:41:06.000Z</published>
    <updated>2021-02-06T07:24:52.598Z</updated>
    
    <content type="html"><![CDATA[<p>不知道还能在虎扑呆多久, 又要开始漂泊的生活</p><a id="more"></a><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>常用的数据结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string : 配置项，json 之后的存储</span><br><span class="line"></span><br><span class="line">hash  :对于对象的存储，比如设备，不需要一次性取出所有的字段内容</span><br><span class="line"></span><br><span class="line">set : 去重</span><br><span class="line"></span><br><span class="line">sortSet :  排行榜</span><br><span class="line"></span><br><span class="line">list  : 队列任务</span><br></pre></td></tr></table></figure><ul><li>lua 的使用</li></ul><ul><li>分布式锁</li></ul><ul><li><p>数据持久化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">RDB 和 aof</span><br><span class="line"></span><br><span class="line">简单说rdb 就是备份数据，aof 是备份指令。</span><br><span class="line"></span><br><span class="line">RDB（Redis DataBase）详解：</span><br><span class="line">RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个 dump.rdb 文件。Redis 重启会通过加载 dump.rdb 文件恢复数据。</span><br><span class="line"></span><br><span class="line">Redis 提供了 SAVE 和 BGSAVE 两个命令来生成 RDB 文件，区别是前者是阻塞的，后者是后台 fork 子进程进行，不会阻塞主进程处理命令请求。载入 RDB 文件不需要手工运行，而是 server 端自动进行，只要启动时检测到 RDB 文件存在 server 端便会载入 RDB 文件重建数据集。当然上面简介中已经提到，如果同时存在 AOF 的话会优先使用 AOF 重建数据集，因为其保存的数据更完整。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">适合大规模的数据恢复，如果业务对数据完整性和一致性要求不高，RDB 的启动速度更快，是很好的选择。</span><br><span class="line">RDB 文件简洁，它保存了某个时间点的 Redis 数据集，适合用于做备份。你可以设定一个时间点对 RDB 文件进行归档，如果 1s 间隔保存一次快照，这样就能在需要的时候很轻易地把数据恢复到不同的版本。</span><br><span class="line">考虑到磁盘硬件故障问题，RDB 文件很适合用于灾备，因为单文件可以很方便地传输到另外的数据中心。</span><br><span class="line">RDB 的性能很好，需要进行持久化时，主进程会 fork 一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的 I/O 操作。</span><br><span class="line">缺点：</span><br><span class="line">1、数据的完整性和一致性不高，因为 SAVE 命令执行是有时间间隔的，比如 5min 备份一次，RDB 可能在最后一次备份时宕机，这 5min 的时间窗数据可能丢失。</span><br><span class="line"></span><br><span class="line">2、备份时占用内存，因为 Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件。所以 Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AOF（Append Only File），Redis 默认不开启。它的出现是为了弥补 RDB 的不足（RDB 可能丢失一个时间窗口的数据），所以它采用日志的形式来记录每个写操作，生成一个 appendonly.aof 文件，并将日志追加到文件末尾。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。有点类似 Mysql 的 binlog。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">AOF 策略最大限度地保证数据不丢失，数据的完整性和一致性更高。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">AOF 备份产生的 appendonly.aof 文件较大，数据恢复的时候，也会比较慢，Redis 针对 AOF 文件大的问题，提供重写的瘦身机制。</span><br><span class="line"></span><br><span class="line">面试官：OK（这不是简单概括了，至于具体配置参数就不问了，这一块用的不多。）</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>redis 为什么快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.单线程不代表一定就慢，单线程有一个最大好处就是节省线程切换的开销，更不用考虑并发读写带来的复杂操作场景，这就大大节省了线程间切换的时间了。</span><br><span class="line"></span><br><span class="line">2.Reids 是基于内存的读写操作，内存肯定比传统磁盘IO数据库快</span><br><span class="line"></span><br><span class="line">3.Reids 核心是基于非阻塞的IO多路复用机制</span><br></pre></td></tr></table></figure></li><li><p>redis 底层数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">string 还是蛮简单的</span><br><span class="line">/*  </span><br><span class="line"> * 保存字符串对象的结构  </span><br><span class="line"> */  </span><br><span class="line">struct sdshdr &#123;  </span><br><span class="line">      </span><br><span class="line">    // buf 中已占用空间的长度  </span><br><span class="line">    int len;  </span><br><span class="line">  </span><br><span class="line">    // buf 中剩余可用空间的长度  </span><br><span class="line">    int free;  </span><br><span class="line">  </span><br><span class="line">    // 数据空间  </span><br><span class="line">    char buf[];  </span><br><span class="line">&#125;;</span><br><span class="line">len 变量，用于记录buf 中已经使用的空间长度。</span><br><span class="line">free 变量，用于记录buf 中还空余的空间，初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现，这样做是为了杜绝C语言中缓冲区溢出的可能性，当我们需要对一个SDS进行修改的时候，Redis 会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS的空间，然后再执行拼接操作。</span><br><span class="line">buf 字符数组，用于记录我们的字符串（记录Redis）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list 双端链表</span><br><span class="line"></span><br><span class="line">链表还是常规的普通双端链表，可以支持反向查找和遍历，更方便操作，通过增删节点来灵活地调整链表的长度，双端链表在Redis内部也是被多次使用：</span><br><span class="line"></span><br><span class="line">事务模块使用双端链表依序保存输入的命令。</span><br><span class="line"></span><br><span class="line">服务器模块使用双端链表来保存多个客户端。</span><br><span class="line"></span><br><span class="line">订阅/发送模块使用双端链表来保存订阅模式的多个客户端。</span><br><span class="line"></span><br><span class="line">事件模块使用双端链表来保存时间事件（time event）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sortSet</span><br><span class="line"></span><br><span class="line">链表还是常规的普通双端链表，可以支持反向查找和遍历，更方便操作，通过增删节点来灵活地调整链表的长度，双端链表在Redis内部也是被多次使用：</span><br><span class="line"></span><br><span class="line">事务模块使用双端链表依序保存输入的命令。</span><br><span class="line"></span><br><span class="line">服务器模块使用双端链表来保存多个客户端。</span><br><span class="line"></span><br><span class="line">订阅/发送模块使用双端链表来保存订阅模式的多个客户端。</span><br><span class="line"></span><br><span class="line">事件模块使用双端链表来保存时间事件（time event）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(红黑树和跳跃表分别是什么)</span><br><span class="line">红黑树：红黑树的查找效率很高，但是在进行重新平衡时，会涉及到大量节点的变化，因此实现和操作起来都比较复杂。</span><br><span class="line"></span><br><span class="line">跳跃表：通过简单的多层索引结构，实现简单，且能达到近似于红黑树的查找效率，插入节点（多层插入）不需要像红黑树那样有额外操作。而且跳跃表还能实现范围查找及输出，而红黑树只支持单个元素查找，对于范围查找效率低。</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>缓存策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FIFO（First In First Out）： 先进先出算法，即先放入缓存的先被移除。</span><br><span class="line">LRU（Least Recently Used）： 最近最少使用算法，使用时间距离现在最久的那个被移除。</span><br><span class="line">LFU（Least Frequently Used）： 最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。</span><br></pre></td></tr></table></figure></li><li><p>redis 集群</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210206122055.png" alt=""></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">master 读  slave 写</span><br><span class="line"></span><br><span class="line">利用raft 算法进行选举</span><br><span class="line">利用一致性hash 算法进行数据分片</span><br><span class="line"></span><br><span class="line">三机房部署，每个机房有一主一从，即一个 Master 对应一个 Slave ，但是你会发现，机房 1 中的 Master 1 连接的 Slave 在机房 2，机房 2 中的 Master 2 连接的 Slave 在机房 3，机房 3 中的 Master 3 连接的 Slave 在机房 1，这样构成一个环，为什么要这样设计？</span><br><span class="line"></span><br><span class="line">三机房部署（其中一主一从构成一个分片，之间通过异步复制同步数据，一旦某个机房掉线，则分片上位于另一个机房的 slave 会被提升为 master 从而可以继续提供服务） ；每个 master 负责一部分 slot，数目尽量均摊；客户端对于某个 Key 操作先通过公式计算（计算方法见下文）出所映射到的 slot，然后直连某个分片，写请求一律走 master，读请求根据路由规则选择连接的分片节点，</span><br><span class="line"></span><br><span class="line">假设机房 1 的全部机器断电了，1 机房数据都不能访问了吗？这显然是我们不希望的。前面已经说了 Master 负责写，Master 会自动同步到 Slava，如果 Master 写服务宕机，Slave 读服务会被提升为 master ，也就是说机房 1 的数据在机房 2 的 Slava2 上还有备份，数据还在，在宕机的 master 没有恢复前 Slave 要同时承担读写服务，虽然累一点，但是系统仍然能提供服务。</span><br><span class="line"></span><br><span class="line">但是你会发现，单个机房如果距离很远， Master 1 的数据同步到 Slave2 上是跨机房，跨机房同步肯定不如同机房块，这样一来 Slave2 负责的读就会有延迟，Master1 要更新的数据还没有同步到他在另一个机房的备份前，读操作就是不一致的，这样设计牺牲掉一致性（C）。</span><br></pre></td></tr></table></figure><ul><li><p>redis 雪崩，穿透，击穿</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">雪崩就是指缓存中大批量热点数据过期后系统涌入大量查询请求，因为大部分数据在Redis层已经失效，请求渗透到数据库层，大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</span><br><span class="line"></span><br><span class="line">resolve:</span><br><span class="line">1.将缓存失效时间分散开，比如每个key的过期时间是随机，防止同一时间大量数据过期现象发生，这样不会出现同一时间全部请求都落在数据库层，如果缓存数据库是分布式部署，将热点数据均匀分布在不同Redis和数据库中，有效分担压力，别一个人扛。</span><br><span class="line">2. 简单粗暴，让Redis数据永不过期（如果业务准许，比如不用更新的名单类）。当然，如果业务数据准许的情况下可以，比如中奖名单用户，每期用户开奖后，名单不可能会变了，无需更新。</span><br><span class="line"></span><br><span class="line">穿透是指绕过Reids，调用者发起的请求参数（key）在缓存和数据库中都不存在，通过不存在的key，成功穿透到系统底层，大规模不断发起不存在的key检索请求导致系统压力过大最后故障。</span><br><span class="line">(这个遇到还是蛮常见的，比如我们详情页回去这个商品的口碑数据，因为有的商品就是没有符合规则的口碑，会一直击穿redis 调用es， 压测的时候es扛不住)</span><br><span class="line">resolve:</span><br><span class="line">1.分布式布隆过滤器：布隆是BloomFilter音译过来的，Redis 自身支持BloomFilter。</span><br><span class="line">2.返回空值：遇到数据库和Redis都查询不到的值，在Redis里set一个null value，过期时间很短，目的在于同一个key再次请求时直接返回null，避免穿透。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">击穿 (就是一个key 大量的访问，golang 的 sync包可以解决这个问题，单个请求没返回，剩下的请求都会被阻塞，而不是直接查询db)</span><br><span class="line">击穿和穿透概念类似，一般是指一个key被穿透，这个key是热点key，同一个key会被有成千上万次请求，比如微博热点排行榜，key是小时时间戳，value是个list的榜单。每个小时产生一个key，这个key会有百万QPS，如果这个key失效了，就像保险丝熔断，百万QPS直接压垮数据库。</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>布隆过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter：即布隆过滤器。可以用于检索一个元素是否在一个集合中。</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">BloomFilter检索一个元素是否在一个集合中有一定的错误率（很低），但不会漏判。</span><br><span class="line"></span><br><span class="line">如果判断一个key不在集合中，那一定不在。</span><br><span class="line">如果判断一个key存在，那不一定真的在。</span><br><span class="line">本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</span><br><span class="line"></span><br><span class="line">相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1.布隆过滤器的特点就是不能删除</span><br><span class="line">2.某个内容返回存在不一定存在（hash 碰撞），但是返回不存在就一定不存在。</span><br><span class="line">（识货的使用场景，双十一两个广告红包，用户点击之后红包变灰，如果这个小功能对所有用户，比如每天200w的用户，太浪费了，以天为单位做布隆过滤器，用户点击之后把对应位数置为1，用户下次请求，如果返回是0必然没点过，都是白图，如果是1，有概率没点过（hash碰撞，别人点的），但概率不大）</span><br></pre></td></tr></table></figure></li><li><p>redis 热点数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">关于热点数据问题我有话要说，这个问题我早在刚刚学习使用 Redis 时就从已经意识到了，所以在使用时会刻意避免，坚决不会给自己挖坑，热点数据最大的问题会造成 Reids 集群负载不均衡（也就是数据倾斜）导致的故障，这些问题对于 Redis 集群都是致命打击</span><br><span class="line"></span><br><span class="line">识货的热点数据：信息流里面标签的展示依赖一个配置项，信息流本身的qps 就比较高，而且信息流在app中的场景也比较多。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">resolve:</span><br><span class="line"></span><br><span class="line">1.识货的场景就是多生成几个一样的配置，每次过来随机读取</span><br><span class="line">2.对于数据一致性不是那么高的业务，可以将热点 key 缓存到业务机器的本地缓存中，因为是业务端的本地内存中，省去了一次远程的 IO 调用。但是当数据更新时，可能会造成业务和 Redis 数据不一致。(本地缓存也是很好用的)。</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>redis 大key 问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">大的标准</span><br><span class="line">1. 大：string 类型 value &gt; 10K，set、list、hash、zset 等集合数据类型中的元素个数 &gt; 1000。</span><br><span class="line">2. 超大： string 类型 value &gt; 100K，set、list、hash、zset 等集合数据类型中的元素个数 &gt; 10000。</span><br><span class="line"></span><br><span class="line">识货的金刚位配置，很大。</span><br><span class="line">拆分，比如20个金刚位，按照顺序拆分成2个配置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">先说说造成 Reids 集群负载不均衡故障的主要原因：</span><br><span class="line">1. 高访问量的 Key，也就是热 key，根据过去的维护经验一个 key 访问的 QPS 超过 1000 就要高度关注了，比如热门商品，热门话题等。</span><br><span class="line">2. 大 Value，有些 key 访问 QPS 虽然不高，但是由于 value 很大，造成网卡负载较大，网卡流量被打满，单台机器可能出现千兆 / 秒，IO 故障。</span><br><span class="line">3. 热点 Key + 大 Value 同时存在，服务器杀手。</span><br><span class="line"></span><br><span class="line">那么热点 key 或大 Value 会造成哪些故障呢：</span><br><span class="line">1. 数据倾斜问题：大 Value 会导致集群不同节点数据分布不均匀，造成数据倾斜问题，大量读写比例非常高的请求都会落到同一个 redis server 上，该 redis 的负载就会严重升高，容易打挂。</span><br><span class="line">2. QPS 倾斜：分片上的 QPS 不均。</span><br><span class="line">3. 大 Value 会导致 Redis 服务器缓冲区不足，造成 get 超时。</span><br><span class="line">4. 由于 Value 过大，导致机房网卡流量不足。</span><br><span class="line">5. Redis 缓存失效导致数据库层被击穿的连锁反应。</span><br></pre></td></tr></table></figure></li><li><p>redis 热点数据怎么定位（说实话，这个都是dba 在搞的）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 提前获知法：</span><br><span class="line">根据业务，人肉统计 or 系统统计可能会成为热点的数据，如，促销活动商品，热门话题，节假日话题，纪念日活动等。</span><br><span class="line"></span><br><span class="line">2.Redis 客户端收集法：</span><br><span class="line">调用端通过计数的方式统计 key 的请求次数，但是无法预知 key 的个数，代码侵入性强。</span><br><span class="line"></span><br><span class="line">3.Redis 集群代理层统计：</span><br><span class="line">像 Twemproxy，codis 这些基于代理的 Redis 分布式架构，统一的入口，可以在 Proxy 层做收集上报，但是缺点很明显，并非所有的 Redis 集群架构都有 proxy。</span><br><span class="line"></span><br><span class="line">4.Redis 服务端收集：</span><br><span class="line">监控 Redis 单个分片的 QPS，发现 QPS 倾斜到一定程度的节点进行 monitor，获取热点 key， Redis 提供了 monitor 命令，可以统计出一段时间内的某 Redis 节点上的所有命令，分析热点 key，在高并发条件下，会存在内存暴涨和 Redis 性能的隐患，所以此种方法适合在短时间内使用；同样只能统计一个 Redis 节点的热点 key，对于集群需要汇总统计，业务角度讲稍微麻烦一点。</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道还能在虎扑呆多久, 又要开始漂泊的生活&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>es的简单总结</title>
    <link href="http://yoursite.com/2020/12/17/es%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/12/17/es的简单总结/</id>
    <published>2020-12-17T06:07:42.000Z</published>
    <updated>2020-12-17T13:35:06.795Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做商品评论的相关内容，因为数据量比较大，而且后台需要根据内容进行评论匹配的功能，显然用mysql 的 like 不太合适了，我们用的是elasticsearch。</p><a id="more"></a><p>需要注意的几个点:</p><ol><li>es 每条记录都有 id , 这个id 不等同于我们结构体中的id， 需要我们手动指定，如果我们不指定，es 会默认生成一个字符充当id， 当我们用get 请求的时候拼接的id 也是 此id （如果id 重复后插入的会覆盖之前的）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;_index&quot;: &quot;shihuo_other_comment_dgscore_v1&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;other_comment_dgscore&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;25135190&quot;,</span><br><span class="line">        &quot;_score&quot;: null,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;id&quot;: &quot;25135190&quot;,</span><br><span class="line">          &quot;channelType&quot;: 23,</span><br><span class="line">          &quot;createTime&quot;: &quot;2020-12-14 16:38:01&quot;,</span><br><span class="line">          &quot;goodsId&quot;: &quot;50021&quot;,</span><br><span class="line">          &quot;mixId&quot;: &quot;o_39007587&quot;,</span><br><span class="line">          &quot;commentDisplay&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;dgScore&quot;: &quot;0.00&quot;,</span><br><span class="line">          &quot;isPhoto&quot;: 0,</span><br><span class="line">          &quot;mixType&quot;: &quot;o&quot;,</span><br><span class="line">          &quot;praise&quot;: &quot;0&quot;,</span><br><span class="line">          &quot;tagIds&quot;: [],</span><br><span class="line">          &quot;innerScore&quot;: &quot;0.00&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;好看，喜欢。&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot;: [</span><br><span class="line">          25135190</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 比如我们常用的go包（github.com/olivere/elastic）</span><br><span class="line">中通过 Id 去指定这条记录的id</span><br></pre></td></tr></table></figure><p>2.当我们想获取es 的版本号的时候我们可以发送 get  / 请求，能获取到版本号</p><p>3.es 7 好像废弃了 type 的存在，之前我们可以理解 index 数据库，type 表</p><p>4.es 的那些搜索条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">sort 和 query 是同一个级别的 </span><br><span class="line"></span><br><span class="line">sort 也可以传入多个条件</span><br><span class="line">&#123;</span><br><span class="line">    &quot;sort&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;f1&quot;:&#123;</span><br><span class="line">                &quot;order&quot;:&quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;f2&quot;:&#123;</span><br><span class="line">                &quot;order&quot;:&quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go 代码：</span><br><span class="line">res1, err := client.Search(indexName).Query(bo).Sort(&quot;innerScore&quot;, false).Sort(&quot;id&quot;, false).Do(context.TODO())</span><br><span class="line">或者：</span><br><span class="line">sortQuery1 := elastic.NewFieldSort(&quot;name&quot;)</span><br><span class="line">sortQuery2 := elastic.NewFieldSort(&quot;age&quot;).Desc()</span><br><span class="line"></span><br><span class="line">searchService := client.Search().</span><br><span class="line">Index(&quot;students&quot;).</span><br><span class="line">SortBy(sortQuery1, sortQuery2)</span><br><span class="line"></span><br><span class="line">// 几种方法的对应 </span><br><span class="line">/id   -&gt; Get().Index()</span><br><span class="line">/_search -&gt; Search().Index()</span><br><span class="line">/_mapping -&gt; Index().Index() , 这个index方法和后面的index方法 不一样的结构体的方法</span><br><span class="line">/_delete -&gt; Delete().Index()</span><br><span class="line">/_deleteByQuery()  传入query 就可以了</span><br><span class="line">/_updatedByQuery() </span><br><span class="line">这个相比较之前的就是和query 级别多了个参数 script， lang 用的painless。 然后如果我们更新的级别比较频繁，建议用</span><br><span class="line">source 代表更新的field 比如 ctx._source.&#123;$k&#125;=params.&#123;$k&#125;;</span><br><span class="line">我们传入一个map 赋值给一个params ，然后循环params用来构成source 字符串 </span><br><span class="line"></span><br><span class="line">/_update -&gt; id 更新最简单的方式就是</span><br><span class="line">POST /shihuo_other_comment_dgscore/other_comment_dgscore/25117494/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;innerScore&quot;: &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.我们在构造query 参数中需要注意的几个点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query 第一层无可厚非</span><br><span class="line">bool 第二层，我平时就没用用过非bool 的</span><br><span class="line">第三层有两个 filter 和 must，怎么区分呢，filter 一般用来过滤条件，比如 id = ，terms in， term 这种完全匹配 。filter效率比较高，因为他不会根据sort 去排分，must 一般用在 内容匹配上，一般我会搭配match_parse ,感觉这样更精确。然后 must 和 filter 里面装的是数组，剩下的都是 obj， 这点一定要注意。还有个should 是同一级别的，should [] 中是 or 的关系，但是should 自身和must 还是and 关系,</span><br><span class="line">exists 和 missing 匹配 类似sql 中 is_null.</span><br><span class="line"></span><br><span class="line">go 中怎么使用呢，new boolquery， 然后把这些条件都加进去。</span><br></pre></td></tr></table></figure><p>6.我们在用es 更新的时候不一定马上能刷新，比如删除，比如修改，我们可以用refresh = wait_for, 这个就相当于是同步的，默认是false 是异步的，如果用true 所有的都这样会影响性能。</p><p><a href="https://blog.csdn.net/u011228889/article/details/80855431" target="_blank" rel="noopener">关于刷新</a>, 这篇文章讲的挺好的，其实wait_for 也不是马上刷新，只是加了wait for 之后那个接口会在等待刷新完成之后才返回结果。</p><p>7.es 的聚合功能，我们在口碑中有使用到<a href="https://www.cnblogs.com/leeSmall/p/9215909.html" target="_blank" rel="noopener">这篇文章用法讲的很仔细</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;innerTagIds&quot;,</span><br><span class="line">        &quot;size&quot; : 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">go 中 指标聚合的 https://www.tizi365.com/archives/868.html，蛮好用的</span><br></pre></td></tr></table></figure><p>8.es 搜索到的内容json转换成我们需要的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if searchResult.TotalHits() &gt; 0 &#123;</span><br><span class="line">// 查询结果不为空，则遍历结果</span><br><span class="line">var b1 Article</span><br><span class="line">// 通过Each方法，将es结果的json结构转换成struct对象</span><br><span class="line">for _, item := range searchResult.Each(reflect.TypeOf(b1)) &#123;</span><br><span class="line">// 转换成Article对象</span><br><span class="line">if t, ok := item.(Article); ok &#123;</span><br><span class="line">fmt.Println(t.Title)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">之前代码中遇到totalhits &gt; 0 ,拿到数据却是0， 主要就是这个each 方法执行失败的 err我不知道怎么抛出来，需要自己打印下，一般是结构体转换失败。</span><br></pre></td></tr></table></figure><p>9.es 中经常遇到的mapping 问题 <a href="https://www.cnblogs.com/Neeo/articles/10585035.html#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%88dynamic%EF%BC%9Astrict%EF%BC%89" target="_blank" rel="noopener">一般都是字段名字写错了</a>, 而且 es 的mapping 设定好修改包括字段类型，就不方便修改了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做商品评论的相关内容，因为数据量比较大，而且后台需要根据内容进行评论匹配的功能，显然用mysql 的 like 不太合适了，我们用的是elasticsearch。&lt;/p&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>破解</title>
    <link href="http://yoursite.com/2020/12/11/%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/12/11/破解/</id>
    <published>2020-12-11T03:10:47.000Z</published>
    <updated>2020-12-11T03:13:17.262Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些破解有用的文章</p><h3 id="Navicate"><a href="#Navicate" class="headerlink" title="Navicate"></a>Navicate</h3><p><a href="https://www.jianshu.com/p/e43cfe3fe832" target="_blank" rel="noopener">我用的12</a>, 直接打开那个百度云盘，把对应文件copy到对应安装目录下就好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一些破解有用的文章&lt;/p&gt;
&lt;h3 id=&quot;Navicate&quot;&gt;&lt;a href=&quot;#Navicate&quot; class=&quot;headerlink&quot; title=&quot;Navicate&quot;&gt;&lt;/a&gt;Navicate&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.jiansh
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="破解" scheme="http://yoursite.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>速查笔记</title>
    <link href="http://yoursite.com/2020/07/17/%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/17/速查笔记/</id>
    <published>2020-07-17T03:01:39.000Z</published>
    <updated>2021-01-05T02:57:32.160Z</updated>
    
    <content type="html"><![CDATA[<p>工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-X/--request [GET|POST|PUT|DELETE|…]  指定请求的 HTTP 方法</span><br><span class="line">-H/--header                           指定请求的 HTTP Header</span><br><span class="line">-d/--data                             指定请求的 HTTP 消息体（Body）</span><br><span class="line">-v/--verbose                          输出详细的返回信息</span><br><span class="line">-u/--user                             指定账号、密码</span><br><span class="line">-b/--cookie                           读取 cookie  </span><br><span class="line"></span><br><span class="line">例子:curl -v -XPOST -H &quot;Content-Type: application/json&quot; http://127.0.0.1:8080/user -d&apos;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin1234&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>w10 修改环境变量</p><p>set name=cy</p><p>echo %name% (golang 这些编辑器中想生效，就得重启编辑器)</p><p>公司网络最近谷歌不能访问了，只能 用 www.google.com.hk， 修改默认的搜索引擎</p><p><a href="https://www.jianshu.com/p/94a145564254" target="_blank" rel="noopener">https://www.jianshu.com/p/94a145564254</a></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20201123170141.png" alt=""></p><p>我们不能修改默认的搜索引擎，比如谷歌，想修改的话只能新建，然后添加默认，下面那些乱七八糟的都能删除了</p><h1 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h1><p>其实一直有个痛点，我们用charles 抓的包之前我不知道咋修改参数，导致我每次想改变请求的时候，我都是copy 到 postman上修改成我想要的请求，这样又有一个痛点就是返回的结果没有直接在手机上展示，不够直观，···可是还能忍</p><p>直到我们现在go 本地开发，客户端的请求是 <a href="http://sh-gateway.xxx.xxx/xxxxx" target="_blank" rel="noopener">http://sh-gateway.xxx.xxx/xxxxx</a>, 而我本地接口是 <a href="http://127.0.0.1:4040/xxxx" target="_blank" rel="noopener">http://127.0.0.1:4040/xxxx</a>, 这个其实前端经常遇到，他们的解决办法是用proxy， 之前我做vue 的时候还不知道这个插件的作用，猜测一下，其实就是类似这个proxy 接收到以后该上线的请求，构造一个新的curl ，发送到新的地址（所以这个proxy 是node 写的~~）</p><p>其实charles 也自带这个功能，我们可以用他的rewrite功能</p><p>tools —&gt; rewrite </p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210105104642.png" alt=""></p><p>上面那个是要匹配的原始url， 如下</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210105104714.png" alt=""></p><p>下面那个是要修改的请求</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210105104854.png" alt=""></p><p>可以修改 path url， body 等，</p><p>服务端对于客户端请求的ip怎么获取 ？ 还记得以前 看tp源码时候吗，通过x-word-for 之类的header 参数，所以这里我们只要添加对应header 参数就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>gin 的那点事</title>
    <link href="http://yoursite.com/2020/07/17/gin-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2020/07/17/gin-的那点事/</id>
    <published>2020-07-17T02:45:57.000Z</published>
    <updated>2020-07-17T03:01:16.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事</p><a id="more"></a><p>abort ，next 方法</p><p>gin 的中间件和别的中间件还不一样，gin 的中间件没有next 也能正常执行，next 只是控制自己的代码和中间件的代码执行顺序。中间件中用return 不能停止中间件的执行，只能用abort 方法才能停止后面程序的执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>go 小知识点</title>
    <link href="http://yoursite.com/2020/07/14/go-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2020/07/14/go-小知识点/</id>
    <published>2020-07-14T09:57:32.000Z</published>
    <updated>2021-01-08T08:46:11.660Z</updated>
    
    <content type="html"><![CDATA[<p>读源码学到的新的语法，补充自己对go的更多了解</p><a id="more"></a><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>今天在看别人代码的时候发现了一个 interface.([]int) 新用法，以前不知道，这个其实就是断言 assert， 其实php 中也经常用到</p><p>1.go 中目前我接触到断言,取map值的时候 ，a, ok :=  map[“name”],  虽然没有这个ok 也是能正确运行的，比如 a := map[“name”]</p><p>2.interface 断言， interface.([]int), 转换成[]int类型</p><p>3.断言失败会取断言类型的默认值，如果断言失败还是不知道原因可以用reflect.TypeOf获取断言的真正类型。断言失败的时候经常就是胯类型断言，比如你知道一个类型[]map[string]string, 但你收到这个值的时候不能直接断言interface.([]map[string]string), 而是应该 interface.([]interface{}),  for range 每个值断言map[string]string.<strong> 所以能用结构体就用结构体接受吧，要不然每层断言很辛苦  ，曾经断言60行的代码，用结构体 不到10行 就接受了，还不用处理一堆的断言错误</strong>。</p><p>4.关于类型 interface{} 兼容 string， 但不代表 []interface{} 兼容 []string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Can I convert a []T to an []interface&#123;&#125;? ¶</span><br><span class="line">Not directly. It is disallowed by the language specification because the two types do not have the same representation in memory. It is necessary to copy the elements individually to the destination slice. This example converts a slice of int to a slice of interface&#123;&#125;:</span><br><span class="line"></span><br><span class="line">t := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">s := make([]interface&#123;&#125;, len(t))</span><br><span class="line">for i, v := range t &#123;</span><br><span class="line">    s[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有另一种方式实现转换</span><br><span class="line"></span><br><span class="line">[]interface&#123;&#125;&#123;&quot;11&quot;, &quot;112&quot;&#125;</span><br><span class="line"></span><br><span class="line">notice : []interface&#123;&#125;&#123;v...&#125; , 这样不行的，这样转换的interface slice， 数量总是 1</span><br></pre></td></tr></table></figure><p>5.今个写代码遇到件事， 对于  int 1, 我用 string(int 1) —–&gt; 想直接得到结果，这样是不行的，还是老老实的用 strconv.Itoa,  string 应该直接用在字符类型，比如 rune  []byte 这类 </p><h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><p>奇怪的现象</p><p>1.最近用slice 总容易写一个bug， 就是make 的时候给定大小，然后append slice， 这样会导致一直往后面插入slice ，而不是从0 开始修改slice 的值。原因就是 make 的时候 len 和 cap 都是 给定的值，每个位置都有自己的默认值，append 的元素已经没地方放了，只会动态扩容 slice 来容纳给更多的内容。</p><p>2.slice 和 map 虽然是地址类型，但是我们 for range 的时候改变值并不会修改自身，原因就是因为for range 的时候是copy 。copy 之后dst 和src 指向的底层 array 不一样，导致指向 dst 和  src 的slice 随意修改都不影响对方。</p><p>3.copy 也有需要注意的地方，就是 src 的len &gt; dst 的len ，并不会copy 全，也就是copy的时候并不会动态扩容</p><p>4.切片的传递属于引用传递，我们日常使用切片也是引用。所以我们在用切片相互赋值的时候，修改某一个可能会影响两一个。原因就是slice 底层指向了同一个数组</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/Image.png" alt=""></p><p>5.我们在什么情况下使用切片不会影响到之前赋值的切片呢，就是在切片动态扩容，改变切片地址指向的时候，比如 append 的时候。因为我们一般切片创建用的 make，make slice  len == cap ，当我们append 的时候必然扩容。</p><p>6.切片是由3个属性决定， 指针 ，len， cap 一般情况下我们 len 和 cap 都一样， 所以会导致我们觉得 指针改变，切片就变化，指针不变，切片就不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func m(modify[]int) []int&#123;</span><br><span class="line">fmt.Printf(&quot;\n %p&quot;, modify)</span><br><span class="line">modify = append(modify, 13)</span><br><span class="line">fmt.Printf(&quot;\n %p \n&quot;, modify)</span><br><span class="line">fmt.Println(len(modify), cap(modify), modify)</span><br><span class="line">return  modify</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">a4 := make([]int, 2,10)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%p \n&quot;, a4)</span><br><span class="line">m(a4)</span><br><span class="line">fmt.Printf(&quot;%p&quot;, a4)</span><br><span class="line">fmt.Println(a4, len(a4), cap(a4))</span><br><span class="line">&#125;</span><br><span class="line">// 这个例子a4 没有变化，虽然 没有扩容 ，指针没变，一般情况下如果m 方法中我们 m[0] = 12, 这样a4 必然改变、</span><br><span class="line">// 这个例子中 ，虽然没有扩容，但是 cap 和 len 没有通过函数返回，导致即使 a4在 m 方法中没有扩容，指针没改变，m 方法中 append 13 也没有影响 a4 。 仅在m 方法中a4 被影响了一小会,因为受影响的 len 没有返回，所以退出m方法， a4又还原了。这也是 append 必须有接受值的原因才能改变slice</span><br></pre></td></tr></table></figure><p>6.我们var 定义 []int 的时候，[]int 是nil， 所以我们不能给他赋值。但是我们make 的时候，虽然此时没有开辟内存空间，但是point 是有值的。！！！所以如果用var 定义的变量赋值会报address 不存在错误，如果用make 就不会。</p><p>7.for range 的时候只循环len 的内容，不循环cap 的内容</p><h1 id="channel定义"><a href="#channel定义" class="headerlink" title="channel定义"></a>channel定义</h1><p>之前看过对channel 的定义最好不要在全局，之前不知道为啥原因，当时因为想做缓冲channel， 而以为var 没法做，所以一直没用全局channel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var channel = make([]chan task, 10)</span><br><span class="line">// 10 个的缓冲， 然后是 task 组成的chan 的slice</span><br><span class="line"></span><br><span class="line">slice 用make 和 自身 定义的区别</span><br><span class="line">make([]int, 10)  [0 0 0 ..]</span><br><span class="line">[]int&#123;&#125;  就是nil</span><br></pre></td></tr></table></figure><h1 id="goroutine的意义"><a href="#goroutine的意义" class="headerlink" title="goroutine的意义"></a>goroutine的意义</h1><p>把一个任务分成很多部分，每个任务完成的周期很短。多个任务中我们可以通过channel 进行通信。如果我们通过单个channel ，在进行io的时候会阻塞的， 所以我们需要多个channel 来配合多个goroutine。多个goroutine消耗多个channel, 取数据的时候，可以把channel 传入goroutine当中，来消耗特定的channel。投递数据的时候咋办？当往特定的channel 中投递任务，因为go不像php 那样可以拼变量名，我们可以先把多个channel 放在一个数组中，然后通过数组index 去取特定的channel。</p><p>go  slice 结构， （指向array 的指针，len, cap）</p><p>（go 中slice 的改动会及时没有用 &amp; 也会影响自身）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func handle(a []string)  &#123;</span><br><span class="line">a[0] = &quot;bb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line"></span><br><span class="line">c := make([]string, len(b))</span><br><span class="line">copy(c, b) // copy 的话就不会影响,注意copy 的时候一定要len 一样，否则会copy不全</span><br><span class="line"></span><br><span class="line">// 这种直接赋值的话， c 的改动会直接影响b</span><br><span class="line">// c := b</span><br><span class="line"></span><br><span class="line">handle(c)</span><br><span class="line">fmt.Println(b, c)</span><br><span class="line"></span><br><span class="line">a := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line">sort.Strings(a)</span><br><span class="line"></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(copy 方便数组的拷贝，不影响原始数组的变动)</p><p>（arr := […]int{1,2,3,4}, arr[1:2:3], start 1 end 2  len 3, 索引的位置）</p><p>// go 中的引用类型</p><p>引用类型和原始的基本类型恰恰相反，它的修改可以影响到任何引用到它的变量。在Go语言中，引用类型有切片、map、接口、函数类型以及<code>chan</code>。</p><p>引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。</p><p>//  go 中经常这样，类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Duration int64</span><br></pre></td></tr></table></figure><p>// go 可变参数</p><p>可以变参数，可以是任意多个。我们自己也可以定义可以变参数，可变参数的定义，在类型前加上省略号…即可。</p><p>// 组合类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">name string</span><br><span class="line">email string</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type admin struct &#123;</span><br><span class="line">user</span><br><span class="line">level string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ad:=admin&#123;user&#123;&quot;张三&quot;,&quot;zhangsan@flysnow.org&quot;&#125;,&quot;管理员&quot;&#125;</span><br><span class="line">fmt.Println(&quot;可以直接调用,名字为：&quot;,ad.name) // 能运行</span><br><span class="line">fmt.Println(&quot;也可以通过内部类型调用,名字为：&quot;,ad.user.name) // 能运行</span><br><span class="line">fmt.Println(&quot;但是新增加的属性只能直接调用，级别为：&quot;,ad.level)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 访问权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Admin struct &#123;</span><br><span class="line">user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user 无法被导出，因为 小写，类似严格访问类型</span><br></pre></td></tr></table></figure><p>// race 检测对共享变量的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -race 10.go</span><br><span class="line"></span><br><span class="line">10.exe</span><br></pre></td></tr></table></figure><p>// sync 包真的是解决并发问题的一个优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">count int32</span><br><span class="line">wg    sync.WaitGroup</span><br><span class="line">mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(2) // 计数器</span><br><span class="line">go incCount()</span><br><span class="line">go incCount()</span><br><span class="line">wg.Wait() // 如果信号量不到0 main 进程就一直堵塞</span><br><span class="line">fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func incCount() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">mutex.Lock() // 只能有一个goroutine 进来</span><br><span class="line">value := count</span><br><span class="line">runtime.Gosched()</span><br><span class="line">value++</span><br><span class="line">count = value</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 很经典的一个关于获取三个url 最快速的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func mirroredQuery() string &#123;</span><br><span class="line">    responses := make(chan string, 3)</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;asia.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;europe.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;americas.gopl.io&quot;) &#125;()</span><br><span class="line">    return &lt;-responses // return the quickest response</span><br><span class="line">&#125;</span><br><span class="line">func request(hostname string) (response string) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><h1 id="json-序列化的小问题"><a href="#json-序列化的小问题" class="headerlink" title="json 序列化的小问题"></a>json 序列化的小问题</h1><p>json 协议没有int 类型，只有 number 类型。int 都会被解析成 float64， 注意！！</p><p>上面的描述有bug ，今天一个str  json 反序列化的时候很成功，啥时候会出现上面问题，通过 interface{} 断言的时候。</p><p>json  序列化的时候如果没有这个值，就不给客户端 （比如我们更倾向于返回空对象，而不是一个完整对象，然后值都是空的），可以使用json tag 中的 omitempty </p><p>json 序列化的时候如果不想要这个，可以直接 - （比如密码这类我们不想暴露给客户端，我们只是我们后端struct 使用，并不需要给客户端）</p><p>json 我们也可以用 int 接受 string 类型 （需要注意的是 我们再次 json序列化的时候 还是 string ）</p><p>今天遇到一个很好用json 方法，<a href="https://medium.com/@xfstart07/go-json-%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81-e689522a1f1f" target="_blank" rel="noopener">就当做json 序列化和 反序列化前的操作</a></p><h1 id="url处理"><a href="#url处理" class="headerlink" title="url处理"></a>url处理</h1><p>最近有一个很恶性的需求，就是解析别人填入的url， 再添加一些想要的参数，组成新的url 返回，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">u, err := url.Parse(href)  // 解析成一个url 对象，这个url 对象有个 string() 方法，可以直接输出这个 href</span><br><span class="line">// 获取 query</span><br><span class="line">query := u.RawQuery  </span><br><span class="line">// 解析query</span><br><span class="line">queryMap, err := url.ParseQuery(query) // 返回一个values 对象，是一个 map[string][]string</span><br><span class="line">// go 中一个参数默认对应一个slice， 如果是单个参数，就是slice 的第一位啦</span><br><span class="line">// 这个values 有很多方法，如果想改参数试试 set， 注意参数是[]string, 否则会整体覆盖哦</span><br><span class="line">// 注意map 赋值是不会被修改的，所以还是调用他的方法吧</span><br><span class="line">queryMap.Encode()</span><br><span class="line">u.RawQuery = queryMap.Encode()</span><br><span class="line">// 组成新的query 参数,再赋值下就能得到新的url</span><br></pre></td></tr></table></figure><h1 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>golang 发送http 请求没有 php 那么直接，其实php 也没有那么直接，毕竟curl 那么一大串，只是php 的curl 面向过程，看起来是那么自然，从上而下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">resp, err := http.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line">//</span><br><span class="line">上面的方法编程平时应该用不到，因为我们的请求至少需要一个超时时间吧</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">resp, err := clt.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line">// 不是那么丝滑，需要用客户端发送请求，但又是那么的符合生活，像我们平时请求就应该有个客户端</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 本质</span><br><span class="line">req, err := http.NewRequest(&quot;GET&quot;, &quot;http://www.baidu.com&quot;, nil)</span><br><span class="line"></span><br><span class="line">//然后http.client 结构体的 Do 方法</span><br><span class="line">//http.DefaultClient可以换为另外一个http.client</span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure><p>评论 ：Go的get请求面上有好几种请求方式，实则只有一种：</p><p>1、使用<code>http.NewRequest</code>函数获得<code>request</code>实体</p><p>2、利用<code>http.client</code>结构体的<code>Do</code>方法，将<code>request</code>实体传入<code>Do</code>方法中。</p><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line">resp, err := http.Post(&quot;xxxxxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">注意这个body 是个io.reader. 通过这个strings.NewReader 转变来，显然，这个方法的参数是 strings</span><br><span class="line">// 当我们的content-type 是 application/ json, 我们这块就不能用 data.Encode 了而是应该用 json .Marc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">var r http.Request</span><br><span class="line">r.ParseForm()</span><br><span class="line">r.Form.Add(&quot;xxx&quot;, &quot;xxx&quot;)</span><br><span class="line">body := strings.NewReader(r.Form.Encode())</span><br><span class="line">http.Post(&quot;xxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">// 这种form 请求之前在js 里面用的很经常，简单哇</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">http.PostForm(&quot;xxxx&quot;, data)</span><br><span class="line"></span><br><span class="line">// golang 封装的postForm</span><br></pre></td></tr></table></figure><p>当然上面的方法本质上也是用client 发出来的</p><p>然后client 本质也是依靠 newRequest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">req.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure><p>!!!notice</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">添加request header</span><br><span class="line">net/http包没有封装直接使用请求带header的get或者post方法，所以，要想请求中带header，只能使用NewRequest方法。</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">//此处还可以写req.Header.Set(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line">req.Header.Add(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure><p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。</p><p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。<br>这俩方法是有区别的，Golang底层Header的实现是一个<code>map[string][]string</code>，<code>req.Header.Set</code>方法如果原来Header中没有值，那么是没问题的，如果又值，会将原来的值替换掉。而<code>req.Header.Add</code>的话，是在原来值的基础上，再<code>append</code>一个值，例如，原来header的值是“s”，我后<code>req.Header.Add</code>一个”a”的话，变成了<code>[s a]</code>。但是，获取header值的方法<code>req.Header.Get</code>确只取第一个，所以，如果原来有值，重新<code>req.Header.Add</code>一个新值的话，<code>req.Header.Get</code>得到的值不变。</p><p>其实不止是header 会这样，query 参数也会这样。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">content, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">respBody := string(content)</span><br></pre></td></tr></table></figure><p>获取返回值</p><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>go sort 已经有人封装好包了，相比较自己写快排，冒泡的好处就是，这个包会根据效率自动选择合适的排序方式，我们需要做的就是实现sort 中的接口 （<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）" target="_blank" rel="noopener">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Len()  获取要排序的slice 的len</span><br><span class="line">Less() return s[i] &lt; s[j]  默认倒序</span><br><span class="line">Swap(i, j int) 交换  // s[i], s[j] = s[j],s[i]</span><br><span class="line"></span><br><span class="line">sort.Sort([]object)</span><br></pre></td></tr></table></figure><p>对于倒序，很简单的实践方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse([]object)) // 帮我们少写了好多代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面的用法得写一堆东西，还有简单的方式</span><br><span class="line"></span><br><span class="line">直接调用  sort.Slice() 方法</span><br></pre></td></tr></table></figure><h2 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a>runtime.Caller</h2><p>在调用公司组件的时候，发现log 输出信息有问题，错误行号和文件是上一层函数调用，而不是我想输出的地方的调用。问题就出在，runtime.Caller(skip), 这个参数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">for i:=0; i&lt;=4; i++ &#123;</span><br><span class="line">_, file, line, _ := runtime.Caller(i)</span><br><span class="line">fmt.Println(file,line,&quot;=====&quot;,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 caller(i)  i 是 0 的时候，就是当前文件的输出，因为这个方法被封装了，所以，不管我在项目  // 中哪个地方调用，每次输出内容都是一样的。</span><br><span class="line">//   试试不调用组件，在单独文件中 runtime.Caller(i) 输出试试，就会发现当i = 0 时候这个方法的真  // 正含义。</span><br><span class="line"></span><br><span class="line">// 看看beego 中获取行号和文件名的方法</span><br><span class="line"></span><br><span class="line">func FILE() string &#123;</span><br><span class="line"></span><br><span class="line">    _, file, _, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return file</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// __LINE__ returns the line number at which the function was invoked</span><br><span class="line"></span><br><span class="line">func LINE() int &#123;</span><br><span class="line"></span><br><span class="line">    _, _, line, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return line</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skip 1 ,仅仅跳出当前方法所在的文件，因为他仅仅封装了一层</span><br></pre></td></tr></table></figure><p><a href="https://studygolang.com/articles/3116" target="_blank" rel="noopener">https://studygolang.com/articles/3116</a>, 这篇文章对 call 和 calls 方法讲解的比较细致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pc := make([]uintptr, 1024)</span><br><span class="line">for skip := 0; ; skip++ &#123;</span><br><span class="line">    n := runtime.Callers(skip, pc)</span><br><span class="line">    if n &lt;= 0 &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc[:n])</span><br><span class="line">&#125;</span><br><span class="line">// 当我们调用 callers 方法的时候，pc 这个array 的容量一定要足够大，否则 n 一直不会渠道数据</span><br><span class="line">// runtime.FuncForPC(pc[skip]).FileLine(pc[skip]) , 这个方法比较好玩，从上面calles 获取   //到的指针连获取对应方法的方法名和 函数</span><br></pre></td></tr></table></figure><p><a href="https://colobu.com/2018/11/03/get-function-name-in-go/" target="_blank" rel="noopener">https://colobu.com/2018/11/03/get-function-name-in-go/</a>, 这篇文章也对上面两个方法做了详细的解释</p><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>429  ，限流了</p><p>499 ， 服务端返回的时间超出客户端设置的超时时间，到这客户端提前关闭</p><h2 id="fmt问题"><a href="#fmt问题" class="headerlink" title="fmt问题"></a>fmt问题</h2><p>平时为了打印结构体我们就用 fmt.printf(“%+v”), 但当我们用[]<em>struct 的时候，这个打印就不好使了，会直接打印内存地址（我们为啥要用</em>struct， 因为遍历的时候 struct 不能修改值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type Stu struct &#123;</span><br><span class="line">Name string `json:&quot;name&quot;`</span><br><span class="line">Age string `json:&quot;age&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*func (t *Stu)String()  string&#123;</span><br><span class="line">return &quot;11&quot;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">str := `</span><br><span class="line">[&#123;&quot;name&quot;:&quot;12&quot;&#125;]</span><br><span class="line">`</span><br><span class="line">var students []Stu</span><br><span class="line"></span><br><span class="line">err := json.Unmarshal([]byte(str), &amp;students)</span><br><span class="line"></span><br><span class="line">for _, v := range students &#123;</span><br><span class="line">v.Name = &quot;xiugia111&quot;</span><br><span class="line">v.Age = &quot;1111&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%+v &quot;, students[0], err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为了让修改生效，我们必须让 students []*Stu</span><br><span class="line">// 但这样之后我们打印 []*Stud 就是内存地址，我们需要哥 *Stu 定义 string() 方法，这样就能 fmt // 直接打印了</span><br></pre></td></tr></table></figure><h1 id="Kafka使用"><a href="#Kafka使用" class="headerlink" title="Kafka使用"></a>Kafka使用</h1><h1 id="Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）"><a href="#Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）" class="headerlink" title="Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）"></a>Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）</h1><p>今天在使用es 的时候，想起了之前使用redis 的时候有not found 的判定，找了下 果然这个es 包中也有。只是这个es 包判定not found 用的是方法，原理是 http 请求的code，相比较redis， 感觉这个更靠谱些。</p><h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><p>time 很实用的一个方法， time.Since 可以获取时间差</p><p><a href="https://www.jianshu.com/p/f809b06144f7" target="_blank" rel="noopener">https://www.jianshu.com/p/f809b06144f7</a>, 时间的很好的一个文章</p><p>timer :  延迟触发，只触发一次。 可以重置</p><p>ticker : 多次执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// timer</span><br><span class="line">        d := time.Duration(time.Second*2)</span><br><span class="line"></span><br><span class="line">        t := time.NewTimer(d)</span><br><span class="line">        defer t.Stop()</span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line">                &lt;- t.C</span><br><span class="line"></span><br><span class="line">                fmt.Println(&quot;timeout...&quot;)</span><br><span class="line">// need reset</span><br><span class="line">t.Reset(time.Second*2), // 如果没有这个reset 就deadlock了</span><br><span class="line">        &#125;</span><br><span class="line"> // ticker , 这个随便获取</span><br><span class="line">  t := time.NewTicker(3*time.Second)</span><br><span class="line">        defer t.Stop()</span><br><span class="line"></span><br><span class="line">        fmt.Println(time.Now())</span><br><span class="line">        time.Sleep(4*time.Second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line"></span><br><span class="line">                select &#123;</span><br><span class="line"></span><br><span class="line">                case &lt;-t.C:</span><br><span class="line"></span><br><span class="line">                        fmt.Println(time.Now())</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>go 中 error 的处理还是没有总结出什么好的办法，目前想到的就是公用的方法，统一内部自己处理异常，当然也会抛出去，外层就可以不用处理了。</p><p>几种error 可以不处理的场景:</p><p>1.断言失败，有默认值的</p><p>2.调用方法，失败了error有返回，对于int float 这些都有默认的返回值。但对于一些结构体，还是要给默认值的，否则可能会是nil</p><p>3.思考一下我在项目中error 的处理方式。一般有问题，都在最底层的服务统一处理，因为一层层的往上抛，感觉日志记录可能重复，详见我的third 包调用 第三方的处理方式。但是我的service中， error 一般都没处理，一般是抛给了 controller 处理，因为我的service 虽然按道理也是公共的，但是调用方其实很少，当时考虑的也不太周到，所以都是交给controller 处理。</p><p>error 几种常见需要解决的问题</p><p>1.wrap ，我经常要 对错误信息添加，比如对发生错误时候的参数进行记录。</p><p>2.判断两个error 是否相等。我们需要注意的是 error 是地址类型 （可以通过 reflect 获取 ），所以两个error 完全相等必须是同一个变量，而不只是 new 里面的内容相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var UserSexNil = errors.New(&quot;未查到该用户信息！&quot;)</span><br><span class="line"></span><br><span class="line">// 然后我们通过 err == UserSexNil 判断</span><br></pre></td></tr></table></figure><p>go 1.13 之后又很完美的方式解决我上面的蛋疼问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Error(&quot;%w xxx&quot;, errors.New(&quot;old error&quot;)) // 这个新生成的error 就是old error + 自定义的xx信息， 但此时我们要判断是否是old error 生成，需要调用特殊的方法</span><br><span class="line"></span><br><span class="line">errors.Is(newError, oldError)</span><br><span class="line"></span><br><span class="line">当我们要断言某种错误的时候， 这个我其实用的很少，可以通过 errors.As() 来断言获取到对应的内容，因为要赋值</span><br></pre></td></tr></table></figure><p><a href="https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html" target="_blank" rel="noopener">这篇文章讲的很好</a></p><p>引申: 看了这个想到了怎么对interface 类型执行，可以</p><h1 id="静态文件引入"><a href="#静态文件引入" class="headerlink" title="静态文件引入"></a>静态文件引入</h1><p>php 中对于静态文件引入很容易，定义个相对路径就好了，但是我们go 微服务不可以（不是所有的都不可以）， 我们go 的执行方式是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec /app/&quot;$@&quot; -conf /app/config.yaml</span><br><span class="line"></span><br><span class="line">// 这个 @是个二进制文件（也就是build之后生成的文件），我们在go 中获取到的执行路径就是 当前路径，所以一旦修改了这个二进制文件地址，这个相对路径就不生效了， 所以这块有两种方式</span><br><span class="line">1. 相对路径改成绝对路径，我们把我们的文件也copy到文件中某个位置，然后用绝对路径</span><br><span class="line">2. go build 只会对go 结尾文件生效，我们利用第三方包把我们的静态文件也打包成go 文件，这样我们就能取到这个文件了</span><br><span class="line"></span><br><span class="line">// 对于静态文件打包成go 文件可以试一下这个包</span><br><span class="line">go-bindata， 我其实就用到他的压缩，然后获取内容用的 Asset方法， 可以看一下生成的</span><br></pre></td></tr></table></figure><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><p>1.一些公共变量在框架init 的时候初始化，但这个变量应该放在哪？我开始是放在main 文件中，但有个很坑爹的时候，service 对于main 中变量引入不了，一来是因为循环依赖（比如 a 依赖b， b反过来也引入a），我们可以开一个单独的包，定义这个公共变量，并且 包含 自身init 函数</p><p>2.今天听大佬分享 公共pool 中对象被耗尽的问题，如何解决？ （最近接的案例就是我们的redis pool 被耗尽了）。1.池子里面对象尽可能给多，2.池子里面对象取出来尽快还回去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读源码学到的新的语法，补充自己对go的更多了解&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go 包的学习</title>
    <link href="http://yoursite.com/2020/07/03/go-%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/03/go-包的学习/</id>
    <published>2020-07-03T06:41:03.000Z</published>
    <updated>2020-07-03T06:47:03.682Z</updated>
    
    <content type="html"><![CDATA[<p>go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们</p><a id="more"></a><p>math/rand</p><p>随机数我们经常用到，php 中rand(), 就能生成一个随机数，但是go中不行，详见 <a href="https://blog.sqrtthree.com/articles/random-number-in-golang/" target="_blank" rel="noopener">https://blog.sqrtthree.com/articles/random-number-in-golang/</a></p><p>这篇文章的解释。php 中也有seed 的概念，不太清楚php中默认seed 是什么，因为一直改变，导致rand() 产生的随机数一直在变，我们可以通过函数设置seed 固定，这样rand 产生的随机数就不变了</p><p>ps: seed 并不是 rand 产生随机数从上限的概念，应该是随机数算法中用到的。还有go rand产生的随机数好像都是从1 开始的，比如我们想从5 开始，可以给产生的随机数都 + 5， 就能满足需求了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-并发</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/07/02/go-并发/</id>
    <published>2020-07-02T13:56:22.000Z</published>
    <updated>2021-01-11T09:10:04.013Z</updated>
    
    <content type="html"><![CDATA[<p>这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较php 的多进程 （process）和 java的多线程（thread）更轻量。</p><a id="more"></a><p>我们在我们项目代码中可以随意的通过 go func（）{} （） 生成一个goroutine， 不同的goroutine 可以执行不同的逻辑，我们的主进程也可以看成一个goroutine，他会不等待 其他的goroutine, 如果main 执行完了，其他的goroutine 会自动结束，不管有没有执行完， 所以我们经常在代码的尾部，sleep ，等待其他goroutine执行完。但这只是demo，真正工作中无法知道一个goroutine 要执行的时间，比如 curl的返回，多种方法可以解决上述的问题，等待goroutine 执行完。</p><ul><li>我们可以通过go 的sync 包，同步阻塞，等待所有的goroutine 执行完。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决goroutine 一起完成我们引入了</span><br><span class="line">w sync.WaitGroup</span><br><span class="line"></span><br><span class="line">// 添加4个goroutine</span><br><span class="line">w.add(4)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">  defer w.Done()</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">// 完成</span><br><span class="line">w.Wait()</span><br></pre></td></tr></table></figure><p>sync.waitGroup 只是让goroutine 在没有channel 的执行下也阻塞住了，等待goroutine的执行，但并没有解决线程安全的问题。线程安全解决方式</p><p>1.互斥锁。但比如 web， 读多写少，互斥锁并不是很友好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决读写不一致问题</span><br><span class="line">// 互斥锁</span><br><span class="line">r sync.Mutex</span><br><span class="line"></span><br><span class="line">r.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.Unlock()</span><br><span class="line"></span><br><span class="line">// 注意这个锁是针对代码的，而不是针对资源的，同一时刻只能有一个goroutine能执行</span><br><span class="line">// 我们不能随便用 defer r.Unlock() , 当锁不存在的时候会报错</span><br><span class="line">// 互斥锁有时候太严格，比如两个读操作，并不需要等待</span><br></pre></td></tr></table></figure><p>2.读写锁。相比较互斥锁，只是读写互斥，读读不互斥，更友好点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决上述问题，出现了读写锁</span><br><span class="line">r Sync.RWMutex</span><br><span class="line"></span><br><span class="line">// 读锁</span><br><span class="line">r.Rlock()</span><br><span class="line">r.RUnlock()</span><br><span class="line"></span><br><span class="line">// 写锁</span><br><span class="line">r.Lock()</span><br><span class="line">r.Unlock()</span><br><span class="line"></span><br><span class="line">// 相比于普通锁 (读写锁性能更高，因为两个读锁之间不会互斥)</span><br><span class="line">r Sync.Mutex </span><br><span class="line"></span><br><span class="line">r.Lock()</span><br><span class="line">r.Unlock()</span><br></pre></td></tr></table></figure><p>3.并发安全的map。</p><p>4.data++ 这种操作原来也会出现线程不安全问题 。除了锁之外，还可以通过原子性操作解决并发问题</p><ul><li>通过channel ，我们在channel 的使用过程中经常会发生死锁问题，这恰恰是我们可以通过channel 等待goroutine 执行的关键所在。</li></ul><p><a href="https://studygolang.com/articles/18800" target="_blank" rel="noopener">https://studygolang.com/articles/18800</a></p><p>这篇文章很好的解释了channel 造成死锁的几个原因。</p><p><a href="https://juejin.im/post/5d216f07e51d4550bf1ae8e0" target="_blank" rel="noopener">https://juejin.im/post/5d216f07e51d4550bf1ae8e0</a></p><p>掘金的这篇文章比较简单，但也说明了channel的几个使用场景。</p><p>关于并发：</p><p>首先想说一下关于并发的场景，其实并发在生活中很常见，只要用户量足够多，同一时刻很可能有两个人在做同样的事情，但这不是高并发，高并发常见的场景就是秒杀的时候，很多用户在某一个时刻被召集起来争抢有限的资源。总结：就是某一时刻某个api 被大量请求，这就是我们压测的原因， 在高并发的情况下我们的服务是否稳定。</p><p>其实很多时候我们的接口在高并发下其实没啥影响，比如幂等的接口（获取某个后台配置），只要我们的服务器撑得住，多少的并发量不是问题，这不是目前我想表达的并发，想说的是非幂等性接口在高并发下的危险性，比如秒杀情况下的超卖。为什么会出现超卖，就是我们在获取数据的同时并不是立马就能处理逻辑，比如在我们减少库存的途中，另一个请求先完成了，导致库存数已经为0了，这时候虽然我们之前的库存1 ，减少为0 合情合理，但其实我们在减少库存1的时候库存数量已经是0了，我们并不知道，所以实际库存已经是 -1了，这就是超卖。</p><p>这个库存可以类比到我们代码中就是公共变量，在lnmp的架构中，因为我们的webserver其实是 fpm提供的，fpm 会有多个进程，每个进程中有php，我们的业务代码存在于每个进程中，每当请求结束，这个进程中的变量生命周期就结束了，这种同步模式不存在公共变量读写不一致问题，唯一可能的就是我们从第三方中间件比如redis 比如 mysql中数据读写不一致问题，一般是redis ，所以就有了 redis + lua 的 原子性操作。</p><p>而在go 中，当我们用go 的 net/http 包做webserver 的时候，对于全局变量，不同的goroutine会存在读写不一致问题， 这时候我们就会引入sync 包</p><p>模拟并发的出现也是个技术活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样正常情况下不会发生超卖，因为间隔时间太短</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">     time.Sleep(5 * time.Second)  // 睡个5s ，必然出现</span><br><span class="line">     </span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 对于并发问题的解决，经常用到goroutine,我们用goroutine 经常会造成 死锁，我们来分析一下这些原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">result:=make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">sum:=0</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">sum=sum+i</span><br><span class="line">&#125;</span><br><span class="line">result&lt;-sum</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Print(&lt;-result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不会造成死锁，以上示例使用一个单独的goroutine求和，当得到结果时，存放在result这个chan里，然后供main goroutine读取出来。当result没有被存储值的时候，读取result是阻塞的，所以会等到结果返回，协同工作，通过chan通信。</span><br><span class="line"></span><br><span class="line">// 如果这个 &lt;- result 是写在go func 上面，就会造成，因为一直阻塞在读取 chan 处，并不会执行到协程处，就会造成死锁</span><br><span class="line"></span><br><span class="line">// 死锁发生的原因就是 主协程被阻塞住，然后也没有办法解决这种状态</span><br><span class="line">// 不管是主协程还是从协程，但凡从channel 读取数据，读取不到都会被阻塞住，之所以 从协程堵塞住不会死锁是因为不会影响主协程的执行。当主协程塞数据进去的时候从协程就能执行了。</span><br><span class="line">// 上面的特性又引入了另一个不通过 sync包而让主协程等待其他协程全都执行完了再往下执行的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logicCount := 5</span><br><span class="line">finishChannel = make(chan bool, logicCount)</span><br><span class="line"></span><br><span class="line">for i:=0;i&lt;logicCount; i++ &#123;</span><br><span class="line">  go func() &#123;</span><br><span class="line">    finishChannel &lt;- true</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i:=0; i&lt; logicCount; i++ &#123;</span><br><span class="line">  &lt;-finishChannel</span><br><span class="line">&#125;</span><br><span class="line">读取logicCount 之后就不堵塞了</span><br></pre></td></tr></table></figure><ul><li><p>我们平时工作中用到 协程的场景 (这篇文章的核心！！！！)</p><p>1.一个api接口中聚合了不同的逻辑，相互不干扰。比如我们的home/info, 我会启动5个goroutine，去处理不同的业务。我会启动两个channel， 一个代表finishChannel  (chan bool),主要用来阻塞主协程的执行，一个resChannel, 用来读取数据。之所以不用resChannel 来阻塞主协程，是因为我在判断所有业务是否都执行完的时候并不想把这些数据都取出来（现在想想也可）。resChannel 中的消息体一般长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Message struct &#123;</span><br><span class="line">  Flag string</span><br><span class="line">  Msg interface&#123;&#125;</span><br><span class="line">  Err err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag 代表不同的逻辑，下面一个switch 接入，进行不同的逻辑处理。msg 因为不同逻辑返回内容不一样，我们取出来之后要断言一次。err 就是错误信息。</p><p>2.同一个接口循环去做通样的事。比如没有群发消息，我们不能bulk，只能单个循环。我们可以利用goroutine。</p></li></ul><p>多进程下面读写安全的map(其实很简单，读取的时候加读锁，写的时候加写锁) (可以读一下cache2go 来了解一下本地缓存， 核心也是一个安全的map， 本地缓存相比较分布式缓存有一个缺点是如果容器重启了，缓存就消失了，如果没有redis 这种落地数据的操作)</p><p>上面我的home/Info 还可以有个方式去解决 并发等待问题就是 errGroup， 类似于waitgroup，把常用的几个功能进行了分装 （add  wait done）, 主要作用如下</p><ul><li>errgroup 可以捕获和记录子协程的错误(只能记录最先出错的协程的错误)</li><li>errgroup 可以控制协程并发顺序。确保子协程执行完成后再执行主协程 （waitgroup 的wait）</li><li>errgroup 可以使用 context 实现协程撤销。或者超时撤销。子协程中使用 ctx.Done()来获取撤销信号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// demo</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line"></span><br><span class="line">    &quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    group, ctx := errgroup.WithContext(context.Background())</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        index := i</span><br><span class="line">        group.Go(func() error &#123;</span><br><span class="line">            fmt.Printf(&quot;start to execute the %d gorouting\n&quot;, index)</span><br><span class="line">            time.Sleep(time.Duration(index) * time.Second)</span><br><span class="line">            if index%2 == 0 &#123;</span><br><span class="line">                return fmt.Errorf(&quot;something has failed on grouting:%d&quot;, index)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;gorouting:%d end\n&quot;, index)</span><br><span class="line">            </span><br><span class="line">            select &#123;</span><br><span class="line">            case: err &lt;- ctx.Done():</span><br><span class="line">   // 获取其他协程或者主协程的终止信号，来进行相对应的处理</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return nil</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if err := group.Wait(); err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下errGroup 的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Group struct &#123;</span><br><span class="line">  cancel  func()             //context cancel()</span><br><span class="line">    wg      sync.WaitGroup         </span><br><span class="line">    errOnce sync.Once          //只会传递第一个出现错的协程的 error</span><br><span class="line">    err     error              //传递子协程错误</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 虽然我们没法主动调用cancel， 但是我们可以通过返回的ctx 接收到 cancel 信号</span><br><span class="line">func WithContext(ctx context.Context) (*Group, context.Context) &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    return &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 就是go 方法挺蛋疼，不能传参数进去</span><br><span class="line">func (g *Group) Go(f func() error) &#123;</span><br><span class="line">    g.wg.Add(1)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer g.wg.Done()</span><br><span class="line">        if err := f(); err != nil &#123;</span><br><span class="line">            g.errOnce.Do(func() &#123;       </span><br><span class="line">                g.err = err             //记录子协程中的错误</span><br><span class="line">                if g.cancel != nil &#123;</span><br><span class="line">                    g.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>errGroup 虽然好，但是仅仅解决了我们 waitgroup 的工作 和 goroutine 中 err传递的工作，对于结果集的传递，感觉还是得造一个channel 用来传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package common</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line">//安全的Map</span><br><span class="line">type SynchronizedMap struct &#123;</span><br><span class="line">rw *sync.RWMutex</span><br><span class="line">data map[interface&#123;&#125;]interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//存储操作</span><br><span class="line">func (sm *SynchronizedMap) Put(k,v interface&#123;&#125;)&#123;</span><br><span class="line">sm.rw.Lock()</span><br><span class="line">defer sm.rw.Unlock()</span><br><span class="line"></span><br><span class="line">sm.data[k]=v</span><br><span class="line">&#125;</span><br><span class="line">//获取操作</span><br><span class="line">func (sm *SynchronizedMap) Get(k interface&#123;&#125;) interface&#123;&#125;&#123;</span><br><span class="line">sm.rw.RLock()</span><br><span class="line">defer sm.rw.RUnlock()</span><br><span class="line"></span><br><span class="line">return sm.data[k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除操作</span><br><span class="line">func (sm *SynchronizedMap) Delete(k interface&#123;&#125;) &#123;</span><br><span class="line">sm.rw.Lock()</span><br><span class="line">defer sm.rw.Unlock()</span><br><span class="line"></span><br><span class="line">delete(sm.data,k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历Map，并且把遍历的值给回调函数，可以让调用者控制做任何事情</span><br><span class="line">func (sm *SynchronizedMap) Each(cb func (interface&#123;&#125;,interface&#123;&#125;))&#123;</span><br><span class="line">sm.rw.RLock()</span><br><span class="line">defer sm.rw.RUnlock()</span><br><span class="line"></span><br><span class="line">for k, v := range sm.data &#123;</span><br><span class="line">cb(k,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成初始化一个SynchronizedMap</span><br><span class="line">func NewSynchronizedMap() *SynchronizedMap&#123;</span><br><span class="line">return &amp;SynchronizedMap&#123;</span><br><span class="line">rw:new(sync.RWMutex),</span><br><span class="line">data:make(map[interface&#123;&#125;]interface&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 之前模拟过一个例子</span><br><span class="line">// 利用500 个goroutine 对 普通map 进行增加，会发现运行结束，count 的值不是500</span><br><span class="line">// 对上面的 安全map 修改，count 的值也不正确</span><br><span class="line">// 因为上面的值只有get ， get完 +1 put， 这不是原子性，所以只有 incr 方法才能让最终的值是500</span><br></pre></td></tr></table></figure><p>关于 context ,很重要的一个知识点，对于并发，我们之前一直通过 waitgroup . add 去添加信号量，但是对于 树状的goroutine， 这样会越来越复杂，完美的方式还是通过 context 上下文的传递。 我们设置一个可以随时取消的上下文，当上下文被cancel 的时候，这个请求自然就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 本质上这些 控制并发用的都是 channel</span><br><span class="line">// channel 也经常用于 代码的阻塞</span><br><span class="line">// 下面的代码中如果 一直select 不到数据，会一直default， 但我不知道select 这个频率是多少</span><br><span class="line">// select 只会被调用一次，这是我们需要知道的</span><br><span class="line">// select 下面的case 都满足，会随机公平的选择一个</span><br><span class="line">// 当default 和 case 都满足的时候 ，会优先case</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">stop := make(chan bool)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-stop:</span><br><span class="line">fmt.Println(&quot;监控退出，停止了...&quot;)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;goroutine监控中...&quot;)</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">fmt.Println(&quot;可以了，通知监控停止&quot;)</span><br><span class="line">stop&lt;- true</span><br><span class="line">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span><br><span class="line">time.Sleep(5 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 关于 context 需要认知的几个东西</span><br><span class="line"></span><br><span class="line">// 首先是context 的 struct</span><br><span class="line">type Context interface &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok bool) // 方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</span><br><span class="line"></span><br><span class="line">Done() &lt;-chan struct&#123;&#125; // 这个done 方法我们经常用，就是select 获取到值就说明超时了</span><br><span class="line"></span><br><span class="line">Err() error  //方法返回取消的错误原因，因为什么Context被取消。</span><br><span class="line"></span><br><span class="line">Value(key interface&#123;&#125;) interface&#123;&#125; // 这个value 方法在我们项目中用到的就是中间件解析内容，让后放到context里面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 经典用法</span><br><span class="line">func Stream(ctx context.Context, out chan&lt;- Value) error &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">  v, err := DoSomething(ctx)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">  return err</span><br><span class="line">  &#125;</span><br><span class="line">  select &#123;</span><br><span class="line">  case &lt;-ctx.Done():</span><br><span class="line">  return ctx.Err()</span><br><span class="line">  case out &lt;- v:</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">// 平时经常用的两个context </span><br><span class="line">var (</span><br><span class="line">background = new(emptyCtx)</span><br><span class="line">todo       = new(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Background() Context &#123;</span><br><span class="line">return background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TODO() Context &#123;</span><br><span class="line">return todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context 的衍生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br><span class="line"></span><br><span class="line">这四个With函数，接收的都有一个partent参数，就是父Context，我们要基于这个父Context创建出子Context的意思，这种方式可以理解为子Context对父Context的继承，也可以理解为基于父Context的衍生。</span><br><span class="line"></span><br><span class="line">通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。</span><br><span class="line"></span><br><span class="line">WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。</span><br><span class="line">// 通过主动调用这个cancel 方法，可以结束当前函数的执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。</span><br><span class="line">// 理解 成截止日期。当然我们也可以手动调用，结束函数的执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。</span><br><span class="line">// 这个是duration，上面的是time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">withxxx  返回的 cancel 我们可以主动调用， 完了就可以取消这个context ， 这时候 done() 方法就能获取到内容了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于 withValue 赋值</span><br><span class="line">//</span><br><span class="line">我们可以使用context.WithValue方法附加一对K-V的键值对，这里Key必须是等价性的，也就是具有可比性；Value值要是线程安全的。</span><br><span class="line"></span><br><span class="line">这样我们就生成了一个新的Context，这个新的Context带有这个键值对，在使用的时候，可以通过Value方法读取ctx.Value(key)。</span><br><span class="line"></span><br><span class="line">记住，使用WithValue传值，一般是必须的值，不要什么值都传递。</span><br><span class="line">// 就是 k v 形式</span><br></pre></td></tr></table></figure><p>上下文真是个好东西, 方便我们 协程隔离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前写代码的过程中，发现大佬们在中间件解析用户uid 的时候都通过 constant.withValue 存储到上下文中，当时很不理解，为啥不直接 全局变量存储，后来想通了，go 中 包内变量多goroutine共享，很容易相互污染。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较php 的多进程 （process）和 java的多线程（thread）更轻量。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>go-反射</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/07/02/go-反射/</id>
    <published>2020-07-02T08:13:01.000Z</published>
    <updated>2020-07-02T08:38:33.837Z</updated>
    
    <content type="html"><![CDATA[<p>反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。</p><a id="more"></a><p>go中反射的使用当然包含上述依赖注入的场景，目前我接触到的场景就是struct 中tag 的使用，比如struct 在json string 中 对于json属性名的自动转小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Name struct&#123;</span><br><span class="line">   name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := Name&#123;&quot;111&quot;&#125;</span><br><span class="line"></span><br><span class="line">r := reflect.TypeOf(a)  // 返回一个type 类型</span><br><span class="line">r.NumField()  // 返回属性的个数</span><br><span class="line">r.Field(i) // 返回第i 个属性</span><br><span class="line">r.Name() // 获取属性的名称</span><br><span class="line">r.Kind() // 获取属性的类别 ，比如自定义结构体叫myStruct, kind 返回 struct, name 返回myStruct</span><br><span class="line"></span><br><span class="line">// 对于地址类型</span><br><span class="line">r := reflect.TypeOf(a).Elem() // 返回一个type类型，我们就能愉快的使用接下来的那些方法了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(a)  // 返回一个value 类型 ，（把类型和值分开了，虽然感觉很奇怪）</span><br><span class="line">v.Field(i) 这个返回的类型和上面type 的类型还不一样，上面的那个可以获取tag等属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 还有个很重要的就是函数的反射</span><br><span class="line"></span><br><span class="line">func Sum(a int, b int) int &#123;</span><br><span class="line">   return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := reflect.ValueOf(Sum)</span><br><span class="line"></span><br><span class="line">// 注意call 调用的时候必须是[]value, 然后单个value 可以用ValueOf 来返回</span><br><span class="line">p.Call(reflect.Value&#123;reflect.ValueOf(10), reflect.ValueOf(20)&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>go-加密</title>
    <link href="http://yoursite.com/2020/06/17/go-%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2020/06/17/go-加密/</id>
    <published>2020-06-17T07:23:40.000Z</published>
    <updated>2020-06-17T07:27:06.817Z</updated>
    
    <content type="html"><![CDATA[<p>加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>go 数据库原生操作</title>
    <link href="http://yoursite.com/2020/06/09/go-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%94%9F%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/06/09/go-数据库原生操作/</id>
    <published>2020-06-09T12:28:16.000Z</published>
    <updated>2020-06-09T12:52:51.286Z</updated>
    
    <content type="html"><![CDATA[<p>go web 开发，操作mysql 是基础啦</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;database/sql&quot;</span><br><span class="line">   _ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line">首先是包的引入，很常见吧，下面那个驱动引入，却未使用可能是只希望使用这个包的 init()方法</span><br></pre></td></tr></table></figure><blockquote><p>通常来说, 不应该直接使用驱动所提供的方法, 而是应该使用 sql.DB, 因此在导入 mysql 驱动时, 这里使用了匿名导入的方式(在包路径前添加 _), 当导入了一个数据库驱动后, 此驱动会自行初始化并注册自己到Golang的database/sql上下文中, 因此我们就可以通过 database/sql 包提供的方法访问数据库了.</p><p>可能这就是interface 的作用吧</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type DbWorker struct &#123;</span><br><span class="line">    //mysql data source name</span><br><span class="line">    Dsn string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    dbw := DbWorker&#123;</span><br><span class="line">        Dsn: &quot;user:password@tcp(127.0.0.1:3306)/test&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    db, err := sql.Open(&quot;mysql&quot;,</span><br><span class="line">        dbw.Dsn) // 返回一个sql.DB 的指针</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>sql.Open并不会立即建立一个数据库的网络连接, 也不会对数据库链接参数的合法性做检验, 它仅仅是初始化一个sql.DB对象. 当真正进行第一次数据库查询操作时, 此时才会真正建立网络连接;</li><li>sql.DB表示操作数据库的抽象接口的对象，但不是所谓的数据库连接对象，sql.DB对象只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法;</li><li>sql.Open返回的sql.DB对象是协程并发安全的.</li><li>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</li></ol><p>所以我们平时用的都是长连接，在池子里面可以复用的啦。平时我们在 prepare ，query(查询)， exec(插入，修改) 之后都要及时 close</p><p>MySQL 5.5 之前， UTF8 编码只支持1-3个字节,从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，utf8mb4兼容utf8，所以能支持更多的字符集;关于emoji表情的话mysql的utf8是不支持，需要修改设置为utf8mb4，才能支持。</p><p>(4 字节的utf8 我们应该一直在用啦)</p></blockquote><p>插入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;insert tasks (content, user, create_at, update_at, deleted) values (?, ?, ?, ?, ?)&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">now, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2016-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">update := time.Now().Format(&quot;2006-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">result, err := stmt.Exec(&quot;测试&quot;, &quot;cy&quot;, now, update, 0)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(result.LastInsertId())</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;update tasks set content = ? where id = ?&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">stmt.Exec(&quot;ceshi11111&quot;, 2)</span><br></pre></td></tr></table></figure><p>查询代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:wyqnkxk2012_CY@tcp(118.184.219.156)/cy&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">err = db.Ping()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//update(db)</span><br><span class="line">//return</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(&quot;select * from tasks where id = ?&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(stmt)</span><br><span class="line">&#125;</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">rows, err := stmt.Query(3)</span><br><span class="line"></span><br><span class="line">defer rows.Close()</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := []*task&#123;&#125;</span><br><span class="line"></span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">tmp := &amp;task&#123;&#125;</span><br><span class="line">rows.Scan(&amp;tmp.id, &amp;tmp.content, &amp;tmp.user, &amp;tmp.create_at, &amp;tmp.update_at, &amp;tmp.deleted)</span><br><span class="line">arr = append(arr, tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go web 开发，操作mysql 是基础啦&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go time</title>
    <link href="http://yoursite.com/2020/06/09/go-time/"/>
    <id>http://yoursite.com/2020/06/09/go-time/</id>
    <published>2020-06-09T11:47:50.000Z</published>
    <updated>2020-07-03T08:50:54.958Z</updated>
    
    <content type="html"><![CDATA[<p>go 中时间包的使用</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">time.Now() // time 包的 Time 类型</span><br><span class="line"></span><br><span class="line">// Time</span><br><span class="line">// 2018-05-31 09:22:19 +0800 CST Time 类型打印出来长这样</span><br><span class="line">time.Now() // 获取当前时间的Time 类型</span><br><span class="line">time.Now().Unix()  Time 类型装 int64</span><br><span class="line">time.Now().Unix()Formate(&quot;2006-01-02 15:04:05&quot;) // 格式化</span><br><span class="line">time.Now().in(a)  // 使用某个时区，返回的是Time 类型，所以可以用</span><br><span class="line"></span><br><span class="line">// location</span><br><span class="line">time.Location() // 返回时区信息</span><br><span class="line">a,_ := time.LoadLocation(&quot;UTC&quot;)  // time 包的 location,如果想用时区，就得用这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数字转Time</span><br><span class="line">time.Unix(11111)</span><br><span class="line"></span><br><span class="line">// 字符串转Time</span><br><span class="line">time.Parse() 和 Time.Format() 是互逆的两个函数</span><br><span class="line">time.Parse() 解析字符串成Time 的时候需要时区信息，我们可以用Loadlocation获取时区信息，然后作为第三个参数传进去</span><br><span class="line"></span><br><span class="line">// Duration </span><br><span class="line">这个在sleep 的时候经常用到</span><br><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond          = 1000 * Nanosecond</span><br><span class="line">    Millisecond          = 1000 * Microsecond</span><br><span class="line">    Second               = 1000 * Millisecond</span><br><span class="line">    Minute               = 60 * Second</span><br><span class="line">    Hour                 = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>今天遇到一个问题，比如sleep() ,这个参数需要是 time.duration, 但是我需要可控的 整数， 6 <em> time.Second， 这样执行不了，需要把 6转换成 time.Duration(6) </em> time.Second, 这样就能运算了。</p><p>这个其实并不是包的特殊性，还是golang语法自身问题自己了解的不足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type c int</span><br><span class="line"></span><br><span class="line">var cparam int</span><br><span class="line">cparam = 1</span><br><span class="line"></span><br><span class="line">o := 1</span><br><span class="line"></span><br><span class="line">fmt.Println(cparam == o)  // 必然报错，虽然是别名，但还是不同类型</span><br><span class="line"></span><br><span class="line">time.Sleep(6 * time.Second) // 这是因为 6可以当做 time.Duration 类型</span><br><span class="line"></span><br><span class="line">可是</span><br><span class="line">r := rand.Int() // int</span><br><span class="line"></span><br><span class="line">time.Sleep(r * time.Second) // 不同的数据类型不能相乘</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天还发现 time 包的一个很牛逼的方法，涉及channl， 所以只有 goroutine 的时候用得到。 time.After() 是一个channl 在规定时间后可以读取一个数据，利用select 机制，可以控制超时问题。</span><br></pre></td></tr></table></figure><p>今天 发现go 去修改时间也很方便，比如</p><p>time.Add() 比如 + 1天， -1 天，</p><p>Sub() 计算两天的差值（不是用来算负数天的哦）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 中时间包的使用&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>go 环境搭建</title>
    <link href="http://yoursite.com/2020/06/06/go-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/06/go-环境搭建/</id>
    <published>2020-06-06T08:24:09.000Z</published>
    <updated>2020-07-01T13:02:18.471Z</updated>
    
    <content type="html"><![CDATA[<p>go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了</p><a id="more"></a><p>学习任何一门语言，刚开始面对的第一个问题就是环境的搭建吧，相较于php的编译安装，go的环境搭建更加简单。</p><p>首先要明确的一点是go 是交叉编译，所以我们无论在win 还是 mac 还是 linux 下开发都是一样的。php 有很多扩展比如redis ，在win下版本比较少，所以我们不得不需要一个linux 环境， 我们平时开发php ，是把远程服务器的代码sftp 到本地，然后本地代码的修改实时上传到服务器上，在服务器上跑。go不需要 （goland 甚至连着个功能都没有，需要装插件）。</p><ol><li><p>下载go的安装包，因为墙的原因，我们可以去 studygolang 上面下载，win和 mac 都是那种点击下一步傻瓜般的安装，linux 下安装也很简单，下载解压完之后就是一个编译好的二进制包（就像php 编译完成那样）。我们只需要把 我们环境变量的 path ，添加上 go下载包中的bin，就能直接使用go的命令了。linux 下可以直接编译 /etc/profile, source /etc/profile 生效。保存好后 echo  $PATH，查看path 。</p></li><li><p>go 安装需要注意的几个路基</p><p>goroot  就是我们（linux 下解压完go 安装包的地址，win 和 mac 下是我们自己制定的go 安装路基）</p><p>gopath 是我们自己制定的一个文件夹，需要在这下面手动建立 bin， pkg， src 三个目录，其中bin 是我们日后编译生成二进制文件的地方，pkg 很重要，里面的mod 文件就是我们安装的第三方库所在的目录，src 就是在 go mod 没出现前，我们存放我们项目代码的地方(之前就觉得我们的代码只能存放在一个地方，很不方便，go mod 的出现就不需要管这个文件夹了）</p><p>go env 我们可以查看和 go 相关的 环境变量，必要重要的有  GO111MODULE, 怎么设置  go env -w </p><p> GO111MODULE=”on”,  还有 GOPROXY=<a href="https://goproxy.cn,direct，" target="_blank" rel="noopener">https://goproxy.cn,direct，</a> goproxy.cn 就是 七牛云搞的golang 下载包中国镜像，后面的direct 代表如果找不到，就直接按照网址下载。go 的第三方包的命名很好玩，基本就是这个仓库所在的可以访问的url 路径，比如 code.chenye2017.cn/xxx/xxx, 不需要像composer 那样中间走一层代理，那层代理还要给你开访问权限，才能下载。</p></li></ol><p>3.在用goland 编辑的时候，会遇到包找不到的请款，我们需要手动 seting 去配置 goroot  gopath ，还要开启vgo（就是gomod）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200606164735.png" alt=""></p><p>这个地方要选空，否则还是会出现包找不到的问题。</p><p>4.go mod 的使用，go mod init xxx 初始化项目，生成 go mod 文件，类似composer init 生成 composer.json，go run main.go 开始跑项目啦。会自动下载需要的安装包，这个相比于composer install 更加的方便。</p><p>今天在初始化别人项目的时候发现goland 的 go vgo 已经设置好了，但是还是找不到go module 的位置，仔细一看发现是自定义的package name 找不到。当我们想用go module 的时候，我们一定要 go init 起一个默认的命名空间，然后当我们使用自己定义的包名的时候，都会用到这个这个命名空间做前缀。</p><p>以上就是总结的 go 环境安装，完结~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq记录</title>
    <link href="http://yoursite.com/2020/05/26/rabbitmq%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/05/26/rabbitmq记录/</id>
    <published>2020-05-26T03:45:16.000Z</published>
    <updated>2020-12-29T08:04:18.736Z</updated>
    
    <content type="html"><![CDATA[<p>rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 <a href="http://docs.php.net/manual/da/book.amqp.php" target="_blank" rel="noopener">http://docs.php.net/manual/da/book.amqp.php</a>，一种是市面上比较流行的库<a href="https://github.com/php-amqplib/php-amqplib" target="_blank" rel="noopener">https://github.com/php-amqplib/php-amqplib</a>， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。</p><a id="more"></a><h3 id="不同的角色"><a href="#不同的角色" class="headerlink" title="不同的角色"></a>不同的角色</h3><p>关于rabbitmq 的理论知识，<a href="https://www.cnblogs.com/wutianqi/p/10043011.html" target="_blank" rel="noopener">https://www.cnblogs.com/wutianqi/p/10043011.html</a>， 这篇文章讲解的很清楚。</p><p>生产者 : 也是通过channel， 去 declare 一个 队列 ，然后发送消息（为什么要使用channel， 因为tcp 连接断开重建很浪费资源）。如果中间没走exchange 的 话，就不需要 routing key 了 。很多人经常把routing key 和  队列名称写一样，因为可能这个消息当初考虑的时候就是专门给这个队列queue 使用的。但其实 routing key  和 queue 可以不一样的，消费者在定义自己的队列便于接受 exchange 投递过来的消息，routing key 就相当于一把钥匙，可以打开这个队列的门。</p><p>上面关于生产者的描述并不准确，上面的过程大概就是单个脚本发送消息的过程，是一种翻译。准确的生产者只做一件事，就是发送消息。首先获取connection， 再通过connection 去获取channel (如果是消费者的channel ，我们在rabbitmq的管理界面还能获取到这个消费者的详细信息)。然后通过channel 去 publish 消息，就结束了。其中关于exchange 的 declare ，是重复的操作，我们可以提取出来，而不分给生产者发送消息这个行为 ，因为publish 的时候我们是不需要exchange 的declare 的，我们完全可以手动在web 上新建exchange， 然后publish的时候填入 exchange 的名称。同理 queue的declare 也是如此。所以我们在生产者消费者的同时，我们可以一方去declare 就好了。</p><p>channel 的publish 方法第二个参数是key ，当我们是 简单或者工作或者 fanout 模式的时候，这个key 就是 queue的名称。一定要注意如果这个key 是空的，或者不存在，我们的消息就会丢弃，因为没地方存储。</p><p>说到这里，就需要注意一下我之前的一个误区，开了生产者，然后启动消费者，消费者拿不到消息，消息为啥丢失了吗？我的理解中，不应该消息积存了，后来消费者启动了，开始消费吗？其实主要是exchange 不能存消息的，当我们启动消费者的时候，经常会启动一个队列，如果这个队列以前不存在，exchange拿着routing key 匹配不到 队列，就会把这个消息丢失。</p><p>消费者：和上面的生产者对应</p><p>同理，消息者其实也是获取到一个connection， connection 获取到channel ，我们就可以去消费消息了 （go 消费消息好像只能用协程的方式）。channel consume 的时候需要一个 queue 的名称，其他什么都不需要。但我们需要把这个queue 绑定到对应的exchange 上，注意了！！！因为识货一直用的routing key 都是字符串，所以不涉及匹配模式，所以我们很容易把生产者的routing key 和 消费者的routing key 当做一个，其实在topic 模式下  queue的 routingkey 需要是正则表达式，比如 #.coupon.#, 生产者 1.coupon.2 就能被这个消费者消费到，不要搞反了。 #可以接收到所有的消息。</p><p>总结：</p><p>所以我觉得，对于生产者，可以定义exchange ，但是queue 这些没必要，因为我们发送消息的时候只要exchange ，和 routing key 。</p><p>对于消费者，可以定义exchange （如果生产者没定义）。需要定义queue，因为consume 的时候需要，需要queue bind exchange 利用 binding key。</p><p>消息代理： broker ，kafka 也有这个玩意，但kafka 的broker 上面有分区，可以存储消息 （rabbitmq 就是一种消息代理）</p><p>虚拟主机：vhost,  识货到现在都没用 （可以利用不同域名区分生产和开发环境，识货直接用的不同的ip）</p><p>交换机：exchange，识货到现在只用一个exchange 就是 amp.topic</p><p>绑定： binding， 把队列queue 和 exchange 绑定起来</p><p>路由键： routing key， 生产者把消息推送到 exchange 上</p><p>队列：queue</p><p>连接： connection</p><p>通道： channel</p><p>消费者： consumer</p><h3 id="不同的工作模式"><a href="#不同的工作模式" class="headerlink" title="不同的工作模式"></a>不同的工作模式</h3><p>一共有5中</p><p>没有exchange 的有simple 和 work 模式，simple  p -&gt; queue-&gt;c,  这样</p><p>work  p-&gt; queue -&gt;(c1, c2)</p><p>exchange 又分多种工作模式，比如topic, direct, fanout. (这三种相较于上面的 work 模式就是不同的队列消费的是同样的消息)。工作中其实我们无意的都在使用work 模式，因为会启动多个消费者。之所以多个消费者消费不同的消息，是因为我们的生产者的routingkey 是不一样的，即使我们消费者的binding key 是一样的。</p><p>识货用的都是direct  （虽然 amq.topic 这个交换机的类型是topic ），但是绑定 exchange 的queue 的 bindingkey 一直类似 a.b.c 这样，所以其实就是direct。这种有个坏处就是某个queue 需要另一个routing key的数据，我们不得不在这个queue上绑定一个新的bindingkey 对应这个新的routing key， topic 模式就是为了解决这个问题出现的 ， bindingkey 对于 routing key 的模糊匹配。那什么是fanout呢，fanout就是不要routing key 的 direct， 直接推所有绑定到 exchange的 queue。</p><h3 id="写代码的时候应该注意的几个属性"><a href="#写代码的时候应该注意的几个属性" class="headerlink" title="写代码的时候应该注意的几个属性"></a>写代码的时候应该注意的几个属性</h3><p>交换机的属性：（识货就用一个交换机 amp.topic 所以这些都没用用过）</p><p>name:</p><p>durable: 持久化，消息代理重启后，交换机是否还存在。交换机有两个状态，持久（durable）、暂存（transient）。持久化的交换机会在消息代理重启后依旧存在，而暂存的交换机则不会。</p><p>auto-delete: 当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它。</p><p>arguments: 依赖代理本身</p><p>队列属性：</p><p>name:</p><p>durable: 消息代理重启后，队列是否还在。</p><p>exclusive:  只被一个连接使用，连接关闭后，将立即删除队列。（这个排他性也很坑爹，如果设置了，经常别的连接不能用）</p><p>auto-delete: 当所有的消费者都退订队列后将自动删除该队列 .(如果设置false， 经常就是消费者没了，队列也就没了)</p><p>消息属性：(识货这边从来没设置过，照样跑)</p><ul><li><p>Content type（内容类型）</p></li><li><p>Content encoding（内容编码）</p></li><li><p>Routing key（路由键）</p></li><li><p>Delivery mode (persistent or not)</p><p>Delivery mode (persistent or not)<br>投递模式（持久化 或 非持久化）</p></li><li><p>Message priority（消息优先权）</p></li><li><p>Message publishing timestamp（消息发布的时间戳）</p></li><li><p>Expiration period（消息有效期）</p></li><li><p>Publisher application id（发布应用的ID）</p></li></ul><p>消息确认：</p><p>消息确认开启后，如果我们没有确认消息，消息会是 unack 状态，当消费者挂掉后，几秒中unack的消息会重置成total 未消费状态 (一定要注意)</p><p>未确认的东西。识货的消息从来没有设置持久化状态，但是mq 挂掉了之后消息还能找回来。</p><p>(消息能够以持久化的方式发布，AMQP代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162641.png" alt=""></p><p>要善于利用rabbitmq 的管理界面，注意detail 那块，这是我们使用死信队列造成延迟队列。</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162949.png" alt=""></p><p>下面的consumer 可以知道绑定的消费者</p><p>下面的binding 就是通过routingkey 绑定的信息</p><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列的应用场景：比如订单三十分钟内付款有效。</p><p>实现方式：<a href="https://www.cnblogs.com/-mrl/p/11113989.html" target="_blank" rel="noopener">https://www.cnblogs.com/-mrl/p/11113989.html</a></p><p>rabbitmq 延迟队列的实现方式：通过消息过期，转发到死信交换机中。消息过期有两种方式，一种是消息自己的存活时间到达还没有消费，一种是队列的时间到达但其中的消息没有被消费，这两种情况消息都会被投递到死信队列中。</p><p>区别：第一种我们可以单独对每个消息设置存活时间，不需要为了每个不同的时间建立不同的队列，比如a消息三十分钟过期，b消息40分钟过期，我们都投递到一个没有消费者的队列中，消息到期了自动转发到死信队列中。</p><p>补充：</p><p><a href="https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/" target="_blank" rel="noopener">https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/</a></p><p>上面的做法好像缺点更大，容易造成队列堵塞，所以还是弄成不同时间级别的队列吧。</p><p>​</p><p>识货从来没有nack 这种操作，只有ack。</p><p>nack 不等同于超时，超时是还没有应答，属于 unack，nack 是应答错误 ，是程序执行完了。（nack 如果需要重回队列，需要设置 repeat  true，消息回到队列头部重新开始消费，我们需要注意消费消息的幂等性， 还要小心造成死循环。如果没有设置repeat true ，消息会被丢弃）</p><p>unack 的消息在这个消费者挂掉重启的时候会重新被消费 （或者可以被自己的兄弟消费者消费掉）</p><p>好久没用rabbitmq ，认知又有点生疏，以识货代码为例</p><p>produce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$routingKey = $queName = &apos;apps_kb_other&apos;;</span><br><span class="line">$connection = sfContext::getInstance()-&gt;getDatabaseConnection(&apos;rabbitmqHeartbeat&apos;);</span><br><span class="line">            $arguments = array(</span><br><span class="line">                &quot;x-dead-letter-exchange&quot; =&gt; array(&quot;S&quot;, &quot;amq.topic&quot;),</span><br><span class="line">                &quot;x-message-ttl&quot; =&gt; array(&quot;I&quot;, 2000),</span><br><span class="line">                &quot;x-dead-letter-routing-key&quot; =&gt; array(&quot;S&quot;, $routingKey)</span><br><span class="line">            );</span><br><span class="line">            $channel = $connection-&gt;channel();</span><br><span class="line"></span><br><span class="line">            //var_dump(get_class($channel));exit;</span><br><span class="line">            $channel-&gt;queue_declare($queName, false, true, false, false, false, $arguments);</span><br><span class="line">      </span><br><span class="line">     // 声明了一个队列，但在识货这个队列是没啥用的，一般就是等待这个队列的message ttl 到期，然后给到交换机 amq.topic, 利用routing key 绑定一个新的队列，消费者消费这个队列。</span><br></pre></td></tr></table></figure><p>consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$routingKey = &apos;apps_kb_other&apos;;</span><br><span class="line">           $quename = &apos;apps_kb_other_queue&apos;;</span><br><span class="line"></span><br><span class="line">       //    $this-&gt;callback(&apos;&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           // mq consume</span><br><span class="line">           $channel = $connection-&gt;channel();</span><br><span class="line">           $channel-&gt;queue_declare($quename, false, true, false, false, false);</span><br><span class="line">// 这个地方声明的是一个新的queue，跟着routingkey 绑定</span><br><span class="line"></span><br><span class="line">           $channel-&gt;basic_qos(null, 10, null);</span><br><span class="line">         // 一次性不要取出来过多，导致unack 过多  </span><br><span class="line">           $channel-&gt;queue_bind($quename, &quot;amq.topic&quot;, $routingKey);</span><br><span class="line">// 这个新的队列和routingkey 绑定，一定不要和之前那个ttl message 的队列名称一样，虽然不会报错</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">           $channel-&gt;basic_consume($quename, &apos;&apos;, false, false, false, false, [$this, &apos;callback&apos;]);</span><br><span class="line">          // 这个地方quename 也不要写成routingkey 虽然也不会报错吧</span><br></pre></td></tr></table></figure><p>我们日常发送消息，在网上抄的代码，都是</p><p>1.get conn</p><p>2.conn open channel</p><p>3.channel declare queue (注意这一步是可以省略的，当queue 已经存在的时候 。我们重复定义queue 不会报错，但是我们定义了重复queue ，给的属性，比如 queue 中消息的ttl 不一样，会报错的。)</p><p>4.channel 发送消息，此时只需要传入一个 queue 的名称即可，notice !!! 如果我们没有用到exchange， 我们千万不要传，否则 会出现奇怪的现象。</p><p>5.发送消息时候的两个属性，mandatory  immediate, 概括来说，mandatory标志告诉服务器至少将该消息route到一个队列中，否则将消息返还给生产者；immediate标志告诉服务器如果该消息关联的queue上有消费者，则马上将消息投递给它，如果所有queue都没有消费者，直接把消息返还给生产者，不用将消息入队列等待消费者了 <a href="https://blog.csdn.net/u013256816/article/details/54914525" target="_blank" rel="noopener">来源</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// go 发送mq 的代码</span><br><span class="line">conn, err := amqp.Dial(&quot;amqp://shihuomq:0VXUPJZYlYz9rRfm@10.180.18.92:5672/&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err, &quot;----&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch, err := conn.Channel()</span><br><span class="line">failOnError(err, &quot;channel 关闭&quot;)</span><br><span class="line">defer ch.Close()</span><br><span class="line"></span><br><span class="line">///args := amqp.Table&#123;&quot;x-dead-letter-exchange&quot;: &quot;amq.topic&quot;, &quot;x-message-ttl&quot;: 3000, &quot;x-dead-letter-routing-key&quot;: &quot;shihuo.supplier.comment&quot;&#125;</span><br><span class="line">//q, err := ch.QueueDeclare(&quot;trd_supplier_comment_deferred&quot;, true, false, false, false, args) // 声明一个test队列，并设置队列的死信交换机为&quot;dlx&quot;</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err, &quot;----&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body,_ := json.Marshal(map[string]interface&#123;&#125;&#123;</span><br><span class="line">&quot;channelType&quot;: &quot;other_comment&quot;,</span><br><span class="line">&quot;id&quot;: 11,</span><br><span class="line">&quot;goods_id&quot;: 12333,</span><br><span class="line">&#125;)</span><br><span class="line">err = ch.Publish(&quot;&quot;, &quot;trd_supplier_comment_deferred&quot;, false, false, amqp.Publishing&#123;</span><br><span class="line">Body:       []byte(body),</span><br><span class="line">//Expiration: &quot;5000&quot;, // 设置TTL为5秒</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ch.Publish(&quot;&quot;, &quot;trd_supplier_comment_deferred&quot;, false, false, amqp.Publishing&#123;</span><br><span class="line">Body:       []byte(body),</span><br><span class="line">//Expiration: &quot;5000&quot;, // 设置TTL为5秒</span><br><span class="line">&#125;)</span><br><span class="line">ch.Publish(&quot;&quot;, &quot;trd_supplier_comment_deferred&quot;, false, false, amqp.Publishing&#123;</span><br><span class="line">Body:       []byte(body),</span><br><span class="line">//Expiration: &quot;5000&quot;, // 设置TTL为5秒</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">failOnError(err, &quot;发下先拍下哦&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 &lt;a href=&quot;http://docs.php.net/manual/da/book.amqp.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.php.net/manual/da/book.amqp.php&lt;/a&gt;，一种是市面上比较流行的库&lt;a href=&quot;https://github.com/php-amqplib/php-amqplib&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/php-amqplib/php-amqplib&lt;/a&gt;， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>golang-类型转换</title>
    <link href="http://yoursite.com/2020/05/07/golang-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/07/golang-类型转换/</id>
    <published>2020-05-07T13:08:47.000Z</published>
    <updated>2020-05-07T13:15:16.446Z</updated>
    
    <content type="html"><![CDATA[<p>类型转换经常用来</p><a id="more"></a><p>golang是强类型语言, 就算int64 和 int 都要相互转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.Atoi   字符串转int</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型转换经常用来&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://yoursite.com/categories/golang/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>外接广告</title>
    <link href="http://yoursite.com/2020/04/21/%E5%A4%96%E6%8E%A5%E5%B9%BF%E5%91%8A/"/>
    <id>http://yoursite.com/2020/04/21/外接广告/</id>
    <published>2020-04-21T03:36:04.000Z</published>
    <updated>2020-04-21T07:58:39.475Z</updated>
    
    <content type="html"><![CDATA[<p>最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。</p><a id="more"></a><p>首先介绍一下前置知识吧，对于ios 和 android 手机的标识。ios手机现在一般用idfa， 但是用户可以关闭广告追踪，那我们获取到的就是一堆 0000-000··这样乱七八糟的东西，毫无价值，为了实验效果，我们一定要开启ios手机的广告追踪。（怎么快速获取当前手机的idfa，可以在appstore中下载一个myidfa,可以快速获取到，注意字母都是大写）。所以要是苹果手机用户关闭了广告跟踪，那么我们就完全追踪不到点击广告的用户信息了，广告的转化率我们必然</p><p>android 手机五花八门，之前一般都是用的imei ，然后有的手机可能还有多个，目前没有考虑很多的情况，都是取的默认的第一个。但现在imei好像逐渐开始也获取不到了，国内的手机一般用的都建议用oaid，据说覆盖量已经 80%以上（但是oaid是国内手机联盟定的东西，像海外的安卓机器是没有的，而且现在识货android客户端也是不支持回传oaid的）</p><p>主要流程：当我们app（识货）在头条（或者朋友圈）上面投放广告的时候，当用户点击我们投放的广告，会给我们的web server发送一条请求，这个请求包括用户的基本信息，比如ios 的idfa 或者android 的imei,还有个call_back,类似标识这个用户信息是头条回传给我们的，我们拿到这个信息存储下来，当用户启动我们app的时候，我们可以把这个用户的信息（imei 或者 idfa）和 头条回传给我们的信息作比对，如果对应上，然后时间间隔在我们希望之内（比如两天），就可以当做这个用户是头条带来的。</p><h1 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h1><p>头条应该是接入的几个广告主中最简单的。头条是没有账号区分的（接口中让我们传入sign，但其实可以不用传），所以当我门投放部使用多账户进行广告投放，在我们代码中是没有影响的，我门只需要调用头条的上传用户行为的接口，传入设备信息和call_back 就好了。</p><p>坑点：</p><p>1.首先我们要区分开发者和广告主两个角色，开发者角色在这次广告对接中基本没啥用处，就是用来看开发者文档的。广告主角色很重要，因为我们配置好监控链接，联调上传行为的时候需要用广告主角色登陆后台管理界面，进行联调（填写头条用户id，然后刷新头条信息流，出现联调广告，点击，观察头条发起调用我们的url，我们可以直接拿这条url测试我们的监控接口是否正常，然后取出callback 和 idfa或者imei，作为参数调用头条的上传用户行为,这就是整个步骤啦，注意imei属于隐私数据，所以会用md5加密）</p><p>2.在我们联调的时候需要填写很多信息，比如下载链接，ios就是App Store我们应用的连接，android 需要我们上传apk到头条或者自己上传一个到七牛云，说白了，用户点击广告需要下载，我们给他们提供一个下载地址（好像不能用应用宝地址，因为腾讯？）</p><p>3.主要就是上面两个，剩下的就是代码设计方面，首先是对于表的设计，因为头条那边我们回传用户行为不需要去重，所以我们之前的代码中自己检测到属于头条带来的新用户直接就上报了，自己没做任何处理，比如记录日志，比如存表。这样带来一个坏处就是万一逻辑哪里出错了，不好排查，比如我们和bi那边做数据差异对比，完全拿不出证据证明这个用户在我们逻辑中属于新用户，为什么bi那边不算新用户，所以可以把用户的上报行为时间也存下来。</p><h1 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h1><p>快手和头条内容基本一致，就是快手不支持去重，只能我们这边自己去重，所以我们终究要保存下我们上传的用户信息，再次触发上报条件的时候，需要检测之前是否上报过。</p><p>（为什么我们会触发多次激活的上报条件？按理说不正常，但历史原因是识货这边在获取用户启动信息的list里面可能第一次没有获取到imei 或者idfa，这样用户虽然激活了，但是没法匹配到头条那边的点击广告信息，只能在第二次用户启动app的时候去激活）</p><p>快手比价坑的就是他的callback往往很长，··长的你不能想象，所以我们要注意数据库是否会自动截断。</p><h1 id="广点通"><a href="#广点通" class="headerlink" title="广点通"></a>广点通</h1><p>广点通相比较上面二者更加复杂，首先就是多账户系统和开发者。</p><p>1.开发者需要把多账户（多个广告主）接通流程，首先开发者需要自己建立一个应用（这个应用不用区分ios 和 android ，目的就是获取一个appkey 和 appsecret, 这个信息在我们上传用户行为的时候需要，头条那边之前以为也需要，但是他那个sign 可以不传，所以这个应用可以不建立）</p><p>2.建立好应用之后就需要我们通过腾讯系老一套的oauth2.0 ，把广告主账户挂载在这个应用下面，因为应用需要获取我们的广告主信息，所以需要通过模拟第三方登陆，让我们应用获取到广告主的信息（比如accesstoken）,这个accesstoken 很重要，上传用户行为就靠他了。ps:这个accesstoken 有时间限制的，为了让他一直有效，我们需要通过refreshtoken 一直刷新accesstoken 的时间（感觉上就是类似redis 的set， 不断的刷新有效期，可以写个定时任务）</p><p>3.获取到accesstoken ，我们再建立用户行为，（但是激活和次留可以用一个行为id），然后把accesstoken ，行为id，事件回传就可以了</p><p>综上，其实各家广告厂商套路其实都差不多，我们提供给他们的广告连接都是可以加上我们自己的参数的，类似微信登陆我们在回调的时候对于scene字段传入我们自定义的值。我们可以利用这个值作为不同的投放计划名称，方便我们不同计划的统计，虽然头条他们本身也能传给我们计划名称。</p><p>各家公司对于ios 和 android 需要建立不同的计划，但是我们的检测链接可不需要，因为我们可以从他们回传的内容中获取到os,判断是android 还是 ios，而且毕竟是mysql，关系型数据库，我们只需要把它们返回的内容都保存就好了，有个例外就是快手不行，因为他们的回传内容中获取不到os，我们无法判断是android还是ios，（android 和 ios 匹配头条用户信息的逻辑不一样，所以要区分）难道通过idfa或者imei去判断，显然不保险，不如填写两条不同的检测链接，标识哪个是ios ，哪个是android。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="广告" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-validate验证器</title>
    <link href="http://yoursite.com/2019/12/16/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-validate%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/16/tp源码分析-validate验证器/</id>
    <published>2019-12-15T16:12:26.000Z</published>
    <updated>2019-12-15T17:06:37.418Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。</p><p>曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。</p><a id="more"></a><p>首先说下php 的验证库可以做哪些事吧，还是蛮丰富的。</p><ol><li>首先是验证器，在我看来验证器就是单独抽象了一个层出来，我们在controller里面只需要调用，让controller更加简洁，而且也能复用，验证器类都继承于think\validate。</li><li>其次controller 里面的validate 方法可以直接调用，本质上和前面一样都是调用tp的验证器库。</li><li>最后我们如果想单独使用验证器，就当做普通方法那样也是可以的，毕竟有时候我们除了对于传入参数的验证，业务代码中也有一些内容需要验证的。</li></ol><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>属性：</p><p>static type : 这个主要是我们第三种方法独立验证器用到的。rule 规则都存在这里面，当我们使用独立验证器的时候，想扩展验证规则，extend 方法修改的就是这个属性，因为是static， 所以在本次请求的下次使用中，也能调用上次extend 的验证规则</p><p>alias： 就是我们rule 中可以用  &gt;: 5, 当做 gt: 5 来使用</p><p>rule: 验证规则，我们在写验证器的时候，重写的就是这个属性</p><p>message: 提示信息的重写。包含5个占位符，:attribute, :rule, :1, :2, :3</p><p>field: 字段的描述，主要作用用在message中message 中的占位符 :attribute 会被这个内容替代</p><p>typeMsg: 提示信息呗，这块是英文的，最终会通过 lang\zh-cn.php 转换成中文</p><p>currentScene: 当前验证的场景，这个感觉就是为了验证器准备的（场景），其实也蛮实用的，方便验证器中规则的自由组合。</p><p>filter: 主要是利用php filter_var函数的验证</p><p>regex: 主要是用到正则的验证, ctype 也是php 很好用的一个扩展，方便一些特殊字符的验证</p><p>scene: 场景</p><p>error: 错误信息，只有控制器中错误才能抛出异常</p><p>batch: 当前参数验证错误，还能轮到下一个参数</p><p>only: 场景中哪些参数被验证</p><p>remove: 场景中移除</p><p>append: 场景中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">看源码写的一点总结</span><br><span class="line">// remove 不可能移除所有，除非append 中是空</span><br><span class="line">// remove 连续移除是通过 |</span><br><span class="line">// remove append 的最佳实践是二者不要存在顺序关系，因为程序不会鉴别</span><br></pre></td></tr></table></figure><p>方法：</p><p>__construct:  </p><p>rule 验证规则， message 提醒， field 字段描述 :attribute 占位符实际内容</p><p>make:</p><p>new self 生成一个验证器</p><p>rule:</p><p>独立验证修改rule 和 field 属性，供后面check 使用。方便直接传入 rule 和 message </p><p>extend:</p><p>独立验证器中的方法扩展</p><p>setTypeMsg:</p><p>独立验证器中使用</p><p>message:</p><p>提示信息</p><p>scene:</p><p>修改当前验证场景</p><p>hasScene:</p><p>scene 优先考虑 sceneEdit 方法，再考虑 scene -&gt; [‘edit’ =&gt; []] 属性</p><p>batch:</p><p>批量验证</p><p>only:</p><p>场景的使用验证哪些字段</p><p>remove:</p><p>场景移除验证规则</p><p>append:</p><p>场景添加沿正规则: 上线 remove 和 append的调用的时候没有先后顺序 ！！！</p><p>check:</p><p>验证器核心，这时候传入的内容会覆盖掉初始化的内容。</p><p>getScene:</p><p>根据传入的scene 和 current scene 修改 only  remove add 内容</p><p>getDataValue: </p><p>根据传入的data 数组和 可以， 获取对应的内容</p><p>checkItem:</p><p>实际的验证，通过 call_user_func 去调用对应的验证内容</p><p>checkRule:</p><p>官网上这么说，</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191216005751.png" alt=""></p><p>感觉意义不大，毕竟静态方法make 创造的更好用点</p><p>getRuleMsg: </p><p>获取错误信息，可以好好看看，挺好的，调用了lang 类。因为自定义的closure ，如果 不是 === true， 就当做error， 结果就当做errorMsg，和调用类方法还是有点区别的。</p><p>getValidateType:</p><p>像一些 is，比如 isEmail, isIp 都走的is 方法</p><p>后面就是一些验证方法了，以后写代码都可以借鉴下</p><h3 id="ValidateRule"><a href="#ValidateRule" class="headerlink" title="ValidateRule"></a>ValidateRule</h3><p>这个类的主要用途就是通过rule 类的形式去调用对应的验证规则</p><p>属性：</p><p>title  :attribute</p><p>rule 规则</p><p>message 提示信息</p><p>方法：</p><p>addItem ：</p><p>为 is 方法统一添加rule，message 属性</p><p>getRule  getTile  getMesage 获取对应属性</p><p>title 设定title</p><p>——call  </p><p>——callStatic </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。&lt;/p&gt;
&lt;p&gt;曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPhP" scheme="http://yoursite.com/tags/ThinkPhP/"/>
    
      <category term="validate" scheme="http://yoursite.com/tags/validate/"/>
    
  </entry>
  
  <entry>
    <title>持久化</title>
    <link href="http://yoursite.com/2019/12/03/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/12/03/持久化/</id>
    <published>2019-12-03T11:59:55.000Z</published>
    <updated>2020-05-28T13:59:32.128Z</updated>
    
    <content type="html"><![CDATA[<p>我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。</p><a id="more"></a><p>举个例子吧，之前接手的一个任务毒和nike关联出价，当前台下发撤单任务的时候，因为牵扯到很多curl 请求，不能同步实现，1.感觉可以通过把请求内容放到mq当中，然后利用daemon 化的task始终监听这个mq，如果有内容，则触发任务，往后执行，否则停歇1min 继续监听。2.那个前作者是通过把内容放到redis中，通过daemon化的task监听这个redis，如果检测到这个redis这个key，就执行相应任务。</p><p>总结一下吧，其实上面两个方式php的daemon话都是通过while true，那么supervisor 的作用是啥呢，当php的这个脚本挂掉了，supervisor可以重新拉起这个脚本。同理pm2也可以，而且不一定是脚本挂掉，脚本执行完了，也可以重新拉起，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo date(&apos;Y-m-d H:i:s&apos;)</span><br><span class="line">echo &apos;end&apos;;</span><br><span class="line">// 利用上面两个进程管理工具之后，可以一直输出</span><br></pre></td></tr></table></figure><p>上面的例子还有个很重要的技术点就是定时触发。相比较crontab 的task，上面的task 触发任务时间不一致，触发时间靠前台控制，所以我们这时候就通过始终运行一个后台任务，然后靠前台触发一个开关，后端始终运行的task始终监测这个开关，如果是开就运行，虽然可能存在一定时间的误差，但大体上还是能完成任务的。</p><p>再比如之前接手的一个安卓灰度更新的任务，当某个渠道开启灰度之后，我们需要每隔30min发送一条钉钉消息，我们同样可以检测表中渠道是否有开启灰度的状态，如果有，则发一条消息，并记录通知时间，下次的循环任务检测是否灰度还在开启，如果还在开启，检测时间通知是否超过30min，如果超过了，再发送消息，并更新通知时间。</p><p>上面的任务看似已经解决，但还是会涉及一个多进程问题，再举个例子，比如erp系统，需要爬取商户的店铺信息，这个task 要一直执行，如果我们有100个商户，就得运行100个task，启动100个脚本。我们上面灰度通知的好解决，一种办法就是检测运行的渠道，循环运行的渠道列表，然后发送消息通知，另一种就是一次性检测，把渠道更新信息包含在一条短消息中发出去，之所以这么做是因为后续的任务（发送钉钉通知）可以在很短时间内完成，如果像erp的那种爬虫任务，只能通过启动多个脚本了。</p><p>关于php的多进程扩展pnctl 这里暂时不做讨论，说一下pm2 和 supervisor 的简单使用。</p><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p><a href="https://juejin.im/post/5b823506e51d4538d517662f" target="_blank" rel="noopener">这篇文章关于pm2讲解的很好</a></p><p>我比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br><span class="line">pm2 app.js --name wx_spider --watch   // name 名称，方便理解， watch 文件变动，方便重启，类似nodemon</span><br><span class="line">pm2 delete all</span><br><span class="line">pm2 delete (:id)</span><br><span class="line">pm2 restart app</span><br><span class="line">pm2 logs (:name)</span><br></pre></td></tr></table></figure><p>pm2 配置简单，非常好用，echo 的内容之间在log中能看到，除了node， php也是能管理的</p><p>（PM2 的安装需要通过node 和 npm， node 的安装很简单，但我们一定要注意npm 安装的module 位置，如果是linux 下，一定要配置好node_path ,否则 npm -g 安装的内容可能不能使用， npm config  get prefix  可以查看node -g 包安装的位置 。同理node的安装位置最好也是/usr/local/ 下面，方便直接访问）</p><p>今天在使用pm2 管理我的一个task的时候遇到一个问题，就是普通的脚本pm2 start app.js 或者 pm2 start test.php, 但是我现在的命令是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php symfony trade:UpdateCommentDgTags updateUserPublishment  --split=4</span><br></pre></td></tr></table></figure><p>之前的那个命令是肯定不可以的，需要使用配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; //统计报表更新</span><br><span class="line">  &quot;name&quot;: &quot;up4&quot;, // 随便取</span><br><span class="line">  &quot;args&quot;: &quot;trade:UpdateCommentDgTags updateUserPublishment  --split=4&quot;, // 这些都属于参数</span><br><span class="line">  &quot;script&quot;: &quot;symfony&quot;, // 这个地方一定要注意，symfony 其实是脚本，只是没有 .php 的后缀</span><br><span class="line">  &quot;exec_interpreter&quot;: &quot;php&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;Cluster&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;fork&quot;,</span><br><span class="line">  &quot;max_memory_restart&quot;: &quot;100M&quot;,</span><br><span class="line">  &quot;cwd&quot;： &quot;../&quot;  // 上一级目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要注意，这个地方symonfy 是脚本，怪不得之前我在执行task 命令的时候忘记输入symfony ,他说找不到脚本。 后面的那一长串都会统一看成参数，只是参数解析的形式不一样，比如 trade:UpdateCommentDgTags, 解析成方法名称，–split = 4 解析成参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps:   php test.php --goods_id=12 uo22</span><br><span class="line"></span><br><span class="line">test.php</span><br><span class="line">&lt;?php</span><br><span class="line">var_dump($argv)</span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; test.php</span><br><span class="line">    [1] =&gt; uo22</span><br><span class="line">    [2] =&gt; --goods_id=12</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>pm2 log日志的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error log path    │ /home/username/.pm2/logs/app-error-0.log</span><br><span class="line">out log path      │ /home/username/.pm2/logs/app-out-0.log</span><br></pre></td></tr></table></figure><p>需要注意的是这个error 应该是pm2 自身的error, 一般我们程序抛出的都是在out 日志里面</p><p>！！~notice: pm2 虽然香，但也不能乱用，比如之前我在预发布机器上跑的一个task 脚本，因为跑完了，脚本 die， 不断的被pm2重启，导致cpu 很快被耗尽，所以很多脚本停止的时候 都会有个sleep 操作，过一段时间再重启。当然如果你是那种常驻内存，比如node 做的webserver 肯定不用，因为一般不会崩溃，唯一一种就是你的代码有问题，不断的报错，导致服务不断的被唤醒。</p><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p><a href="https://learnku.com/laravel/t/2126/supervisor-installation-configuration-use" target="_blank" rel="noopener">使用和安装可以大致看看这个文章，但这篇文章的配置文件有问题</a></p><p>配置文件里面一定要有[supervisord]和[supervisorctl] 部分，否则会报错。<a href="https://juejin.im/post/5c66be44f265da2de52d784d" target="_blank" rel="noopener">这篇文章应该还可以</a> 需要注意的就是监听端口从 127.0.0.1:9001 改成 0.0.0.0:9001 ,方便外网访问，贴个图</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191203210626.png" alt=""></p><p>基本就能用啦 （比如我那几百万的任务task就能通过这两个处理，不用我一直看着了，跑完了看看 log就好了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="daemon" scheme="http://yoursite.com/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>复盘一下代码的提交流程</title>
    <link href="http://yoursite.com/2019/11/28/%E5%A4%8D%E7%9B%98%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/28/复盘一下代码的提交流程/</id>
    <published>2019-11-28T06:20:02.000Z</published>
    <updated>2019-11-28T10:36:20.370Z</updated>
    
    <content type="html"><![CDATA[<p>昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。</p><a id="more"></a><p>首先我们开发一个功能需要从master上面下拉代码</p><ol><li><p>注意是远程的master，本地的master没啥屌用，因为一般为了提交方便和方便记忆，本地分支和远程分支保持同名，如果你用master 的话，总不能推送到远程master上吧，似乎没人有这个权限。</p></li><li><p>提交代码前是否要合并master ？ 血的例子，别吧。如果你往master上面提交代码没冲突，那就别合并了，对吧，为啥要合并呢 ？只要你的代码正常上线，dont care anything ，因为要是你真的在这个时候合并了远程master，然后远程master 0.01%的可能是个脏master，这时候你的开发分支也就脏了，意味着你合并master 之后改的东西，在领导发现master 脏了之后，都是要被回滚的，回滚的终结点不一定，凭他们的感觉吧，其实感觉就是那个人把release 合并到master 上的点。那问题来了，如果，万一你真的合并了脏master，咋办，其实也好办，你git reset 到合并master之前的那个commit，重新提交给master，看是否能合并，不能合并，再去解决冲突（后面会介绍冲突解决办法），所以感觉在merge 别的分支的时候一定要做好commit message （最好不要改merge 的info，比如当时我修改改成conflict resolve 我都不知道我要回退到哪个版本，其实只要回退到merge 之前的版本就好了）， 有时候真的会帮大忙，方便你的开发分支剔除掉别的合并的内容</p></li><li><p>开发feature中是否要合并master ？ 还是血的例子，别吧。万一你开发分支合并了错误的master，万一你不知道，接着在错误分支上开发，当开发很多的时候，当master 需要回滚的时候会很艰难，毕竟开发了那么多。这时候只能继续相信master， 不断的合并master，其实没啥屌用，你的开发分支已经领先master了，如果你没回滚，你合并的时候只会在人家前面，你会多提交很多内容，这些内容在你给领导要求pr merge 的时候被看到肯定会打回来，~~~不知道咋解决</p></li><li><p>我的流程总结。开发的时候下拉master成为一个开发分支，比如chenye/feature/gray_test, 开发完了，提交dev。万一和dev冲突，下来dev到本地，merge gray_test,看冲突是啥，万一是自己的文件，直接解决。解决完了，推送到远程，给dev提交pr，合并之后，自己的gray_test 就能合并到dev了。注意，在解决冲突的时候一定不要修改自己的开发分支，也就是gray_test, 万一在release 或者 master合并的时候修改了自己的开发分支，一定要dev， release ，master 按顺序重新提交一遍！！！！！否则，别人拉代码的时候一定会冲突。</p></li><li><p>当发现别人的代码冲突的时候咋办，最好的办法就是告诉别人，因为你不知道以哪个为标准。</p><p>你觉得是以master为标准，毕竟线上跑着呢，万一人家当初并不想把代码提交到master上，被另一个同学误操作了，也就是你clone的master是错误代码，这时候以master会覆盖调用dev的正确代码。</p><p>你说以dev标准，毕竟dev是最新的代码 ？还是不对，可能别人着急，直接提交了master，也就是说master代码比dev新，这样dev就会覆盖掉master上的新代码。</p><p>所以遇到这种情况，直接告知吧，任何一种自己修改别人冲突的方法都是不负责任的行为。</p></li></ol><p>顺带提一下最近遇到的win 和 linux 下空格遇到的问题，我们都知道代码是跑在linux下的，所以我们的换行一定要</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160209.png" alt=""></p><p>用这个LF, win下是</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160245.png" alt=""></p><p>我们既然改变不了win，可以通过phpstorm自带的功能，去编辑文件，模拟在linux下的编辑。</p><p>（ps:我是怎么发现这个问题的，在用php的heredoc 换行的时候就能发现）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="虎扑" scheme="http://yoursite.com/tags/%E8%99%8E%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-数据库操作</title>
    <link href="http://yoursite.com/2019/11/17/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/11/17/tp源码分析-数据库操作/</id>
    <published>2019-11-17T07:45:09.000Z</published>
    <updated>2019-11-17T07:53:51.947Z</updated>
    
    <content type="html"><![CDATA[<p>tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo</p><p>的api 去操作数据就好了。</p><a id="more"></a><p>我们先来看看常用的pdo api</p><p>首先是关于pdo的安装部分，我们要安装统一的pdo扩展，然后在这个扩展的基础上安装 pdo mysql ,或者 pdo postgresql，类似针对不同的数据库的驱动的感觉。</p><p>预定义常量：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo&lt;/p&gt;
&lt;p&gt;的api 去操作数据就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
