<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-11T04:49:32.807Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>持续交付</title>
    <link href="http://yoursite.com/2019/03/20/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    <id>http://yoursite.com/2019/03/20/持续交付/</id>
    <published>2019-03-20T06:28:18.000Z</published>
    <updated>2019-04-11T04:49:32.807Z</updated>
    
    <content type="html"><![CDATA[<p>上面要求代码从svn改成git,需要一个私有化的代码管理工具，于是想到了gitlab, 其实我们人这么少，一般一个前端，一个后端，流程简单，svn和git 用起来没啥区别，可是呢上面说了，那就改吧<br><a id="more"></a></p><ul><li>gitlab 搭建<br><a href="https://blog.csdn.net/Abysscarry/article/details/79402695" target="_blank" rel="noopener">https://blog.csdn.net/Abysscarry/article/details/79402695</a><br>慕课网教程上那么复杂是因为配置了本地https<br>唯一一点没有提到的就是自定义域名的文件位置，如果用yum安装的话<br>在 /etc/gitlab/gitlab.rb下面。</li><li>gitlab使用<br>默认有个root账户，自己设置密码，<br><img src="https://upload-images.jianshu.io/upload_images/5525740-9b6fda318458402b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><ol><li><p>可以创建用户和项目<br>创建项目类似github 上创建项目，后面项目的提交就是git 的使用<br><img src="https://upload-images.jianshu.io/upload_images/5525740-1313d8fff713f69a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>创建用户的话如上，主要是那个reqular和admin, 这块不是项目权限，应该是类似整个gitlab 的权限， 新建的用户可以给个初始密码，然后用户登陆的时候可以修改，用户提交代码需要把ssh 公钥粘贴到gitlab 上，一切和github类似</p></li><li><p>配置项目权限 （管理员才有这些权限，比如root）<br><img src="https://upload-images.jianshu.io/upload_images/5525740-de997e9e384c70cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><p>点击项目，给项目配置人员信息</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-7989fc4b0855b256.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-c828d921114d9f37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>目前只配置了develop和 master ,develop 是开发者，开发者不能向master 分支提交代码。只能自己开个feature分支，提交之后再gitlab 上面提交merge 申请，这个项目的master 可以merge , 这个项目的master 可以直接向master 分支提交代码</p><p>上面的administrator / test , administrator  是用户名， test 是项目名</p><ol><li>监控系统信息(感觉这个可以放在一般的管理系统中，掌握服务器情况)</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5525740-20282f376d80872b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>今天新建一个项目的时候总是显示密码错误，主要原因可能是项目建成了private ， 没有解决问题，但发现了另一个问题，我下载项目的时候总是显示password ,那他是怎么识别我的name呢，答案是gitlab 上贴的ssh key，我们的每一个gitlab 用户或者 github 用户都要至少绑定一个ssh key,就是通过这个ssh key 识别我们用户名称的,我们在用gitlab 提交代码时候总是显示要配置用户名和密码，可以全局配置也可以在单个项目中配置，所以这个并不是我们登陆github 或者gitlab 的用户名，这个只是我们提交时候日志上面显示的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上面要求代码从svn改成git,需要一个私有化的代码管理工具，于是想到了gitlab, 其实我们人这么少，一般一个前端，一个后端，流程简单，svn和git 用起来没啥区别，可是呢上面说了，那就改吧&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PHP 反射</title>
    <link href="http://yoursite.com/2019/03/06/PHP-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/03/06/PHP-反射/</id>
    <published>2019-03-06T02:43:51.000Z</published>
    <updated>2019-04-09T08:41:58.077Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>故事背景：在做文件上传的时候，对图片的上传和视频的上传走的是相同的接口，可是视频和图片有些参数是不同的，于是通过一个基类base,扩展出多个子类，image,video ···上传类，根绝参数的不同调用不同类的upload方法。</p><blockquote><p>简单点说反射的就是让你拥有剖析类、函数的能力。</p><p>有的同学可能会问我剖析类有什么用，我为什么要学反射，我只能说不学反射并不会对你实现业务有任何影响，但是如果你想写出结构优雅的程序，想写出维护性和扩展性都很高的程序，学习反射是必不可少的。</p></blockquote><p>Laravel 中依赖注入用的就是反射。<a href="http://www.dahouduan.com/2017/08/21/php-refleciton-1/" target="_blank" rel="noopener">参考文章</a></p><a id="more"></a><p>base类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;&apos;;</span><br><span class="line">  public function upload()</span><br><span class="line">  &#123;</span><br><span class="line">  var_dump($this-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>video 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Video extends Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;video&apos;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Image extends Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;image&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Upload</span><br><span class="line">&#123;</span><br><span class="line">  public static alias()</span><br><span class="line">  &#123;</span><br><span class="line">  return [</span><br><span class="line">  &apos;video&apos; =&gt; \App\Video,</span><br><span class="line">  &apos;image&apos; =&gt; \App\Image</span><br><span class="line">]</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  public fileUpload($type)</span><br><span class="line">  &#123;</span><br><span class="line">  $classArr = self::alias();</span><br><span class="line">  $className = $classArr[$type];</span><br><span class="line">  $reflection = new ReflectionClass($className); // 获取反射对象</span><br><span class="line">  return $ref-&gt;newInstance() // 获取类实例化对象</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是一段很简单的使用反射实现的代码，其中对实例化参数的判断，类是否能实例化等诸多反射的方法都未使用到。</p><p>总结一下我在使用easyswoole 写代码过程中的感觉：</p><ul><li><p>首先想熟练的使用easyswoole,必须得熟悉swoole,比如对swoole http server 的配置，举个例子，当上传文件大于easyswoole 默认上传文件总的大小的时候，easyswoole(包括swoole)的tcp 链接会主动断掉，但是swoole的服务器端会打印一个warning ,显示传输文件过大，但是easyswoole 不会，服务器端不报异常，只是客户端建立不了链接，这就很尴尬了，之前还以为是端口号或者自己代码哪里出了问题。（ps:php文件上传和两个参数有关，一个是php.ini 里面的upload size, 一个是post size, 如果是swoole 上传的话，还和swoole 的配置项有关，在easyswoole 中对http server 的配置和swoole 中对http server 配置一样，只是参数修改的位置不一样罢了）</p></li><li><p>再者是对easy swoole 的使用，之前习惯于查看文档或者手册去学习（比如laravel 和 php 手册），对其中的所有的方法都有详细的解释，我们应该学会通过查看源码去学习其中方法的使用，比如easy swoole 中对获取参数这些都没有doc 文档，我们可以在request 类下面查看有哪些可以调用的方法，或者是通过编辑器补全</p></li><li><p>说到编辑器补全，之前发现的一个问题就是比如上传类，当可能返回上传类或者null 的时候，通过链式调用，上传类的方法得不到补全，可是我们通过php7的返回结果限制，就能让编辑器自动补全了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Request</span><br><span class="line">&#123;</span><br><span class="line">   public function uploadFile($name) :?UploadFile</span><br><span class="line">    &#123;</span><br><span class="line">  if ($file[$name]) &#123;</span><br><span class="line">          return $file[$name]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         return null</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">// ?代表可能是Null</span><br></pre></td></tr></table></figure></li><li><p>当我们想知道这个结果有哪些可以调用的方法的时候，我们可以直接打印这个结果，查看属于哪个类，然后我们到这个类下面查找，比如我之前想知道反射的 getParamtes  方法返回结果的foreach 中的value 有哪些可以调用的方法的时候，查看这个value 的类，然后查看这个类有哪些方法，比如getClass()-&gt;name, 就是获取参数提示符（这个参数提示符还是蛮奇怪的，Bag 这种自定义的类可以提示， 但是 string int 这种类却不提示）</p></li><li><p>今天在查看easyswoole源码的时候,发现自己对public protected private 都忘记了,首先public 是最简单的，protected 本类和继承类中可以使用，private只有本类中可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"> class A &#123;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function test1()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected function test2()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function test3()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public function test4()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$b = new B();</span><br><span class="line"></span><br><span class="line">$b-&gt;test1();</span><br><span class="line"></span><br><span class="line">$b-&gt;test4();</span><br><span class="line"></span><br><span class="line">$b-&gt;test2();</span><br><span class="line"></span><br><span class="line">//$b-&gt;test3();</span><br></pre></td></tr></table></figure><p>​</p></li></ul><p>下面<a href="http://www.dahouduan.com" target="_blank" rel="noopener">文章来源</a></p><p>PHP 内置了一组反射类来实现类的反射，常用的有：</p><ul><li>ReflectionClass 解析类</li><li>ReflectionProperty 类的属性的相关信息</li><li>ReflectionMethod 类方法的有关信息</li><li>ReflectionParameter 取回了函数或方法参数的相关信息</li></ul><p>想看全的就翻手册去。</p><p>今天先通过一段演示代码简单看下php的反射到底是个什么东西。</p><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Hero &#123;</span><br><span class="line"></span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    protected $skills = [];</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $skills = []) &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;skills = $skills;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function attack($hero) &#123;</span><br><span class="line">        echo &quot;Attack &#123;$hero-&gt;name&#125;&quot; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function execute($index) &#123;</span><br><span class="line">        echo &quot;Axecute &#123;$index&#125; skill&quot; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ref = new ReflectionClass(&apos;Hero&apos;); // 参数类名</span><br><span class="line"></span><br><span class="line">if ($ref-&gt;isInstantiable()) &#123;</span><br><span class="line">    echo &apos;可以实例化&apos; . PHP_EOL; // 判断是否可以实例化，比如单例或者静态类的存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取类的构造函数</span><br><span class="line">$constructor = $ref-&gt;getConstructor();</span><br><span class="line">print_r($constructor); //ReflectionMethod  E对象</span><br><span class="line"></span><br><span class="line">//获取属性</span><br><span class="line">if ($ref-&gt;hasProperty(&apos;name&apos;)) &#123;</span><br><span class="line">    $attr = $ref-&gt;getProperty(&apos;name&apos;);</span><br><span class="line">    print_r($attr); //ReflectionProperty  对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取属性列表</span><br><span class="line">$attributes = $ref-&gt;getProperties();</span><br><span class="line">foreach ($attributes as $row) &#123;</span><br><span class="line">    //row 为 ReflectionProperty 的实例</span><br><span class="line">    echo $row-&gt;getName() . &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法</span><br><span class="line">if ($ref-&gt;hasMethod(&apos;attack&apos;)) &#123;</span><br><span class="line">    $method = $ref-&gt;getMethod(&apos;attack&apos;);</span><br><span class="line">    //$method 为 ReflectionMethod 的实例</span><br><span class="line">    print_r($method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法列表</span><br><span class="line">$methods = $ref-&gt;getMethods();</span><br><span class="line">foreach ($methods as $row) &#123;</span><br><span class="line">    //这的row 是 ReflectionMethod 的实例</span><br><span class="line">    echo $row-&gt;getName() . PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想知道上面代码的用途，最好的办法就是执行一下，自己打印一遍(如果用xdebug 对这种脚本式的执行是再方便不过了)</p><p>上面例子想表达的效果就是：仅仅通过类名，就能了解类的内部结构，进而去实例化类</p><p>例子2：</p><p>student</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Bag&#123;</span><br><span class="line"></span><br><span class="line">    public function name()&#123;</span><br><span class="line">        return  &quot;学生包&quot;.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">    public $id;</span><br><span class="line"></span><br><span class="line">    public $name;</span><br><span class="line">    public function __construct($id,$name,Bag $bag)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;id = $id;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line">    public function study()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;name.&apos; is learning.....&apos;.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showBag()&#123;</span><br><span class="line">        echo &quot;My bag have &quot;.$this-&gt;bag-&gt;all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">require &apos;student.php&apos;;</span><br><span class="line">function make($class, $vars = []) &#123;</span><br><span class="line">    $ref = new ReflectionClass($class);</span><br><span class="line"></span><br><span class="line">    if(!$ref-&gt;isInstantiable()) &#123;</span><br><span class="line">        throw new Exception(&quot;类&#123;$class&#125; 不存在&quot;); // 感觉这块应该是累不可以实例化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $constructor = $ref-&gt;getConstructor();</span><br><span class="line">    if(is_null($constructor)) &#123;</span><br><span class="line">        return new $class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $params = $constructor-&gt;getParameters();</span><br><span class="line">    $resolveParams = [];</span><br><span class="line">    foreach ($params as $key=&gt;$value) &#123;</span><br><span class="line">        $name = $value-&gt;getName();</span><br><span class="line">        if(isset($vars[$name])) &#123;</span><br><span class="line">            $resolveParams[] = $vars[$name];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $default = $value-&gt;isDefaultValueAvailable() ? $value-&gt;getDefaultValue() : null;</span><br><span class="line">            if(is_null($default)) &#123;</span><br><span class="line">           </span><br><span class="line">                if($value-&gt;getClass()) &#123;</span><br><span class="line">                // 依赖注入的实现，以这个为例子</span><br><span class="line">                // 需要Bag $bag ，却没有传入 bag，自动实例化</span><br><span class="line">                // 如果需要参数，直接在vars 里面加，但感觉参数名称不能和原本的冲突</span><br><span class="line">                    $resolveParams[] = make($value-&gt;getClass()-&gt;getName(), $vars);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new Exception(&quot;&#123;$name&#125; 没有传值且没有默认值。&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $resolveParams[] = $default;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $ref-&gt;newInstanceArgs($resolveParams);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有提供name 值</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提供name 值</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要 Bag ，却没有传入</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">    $stu-&gt;showBag();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到构造函数的第三个参数 <code>$bag</code> ,被自动实例化了，然后传递给了 <code>Student</code> 类的构造函数，这个部分很关键，这个地方可以用来实现依赖注入，我们不必在手动实例化对象了，我们可以根据参数的对应的类来自动实例化对象，从而实现类之间的解耦。</p><p>// 感觉这个解耦就是不用手动去传参数，避免类修改的时候自己大片代码需要修改</p></blockquote><p>例子3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// 这个不能算是容器，容器是反射的一种高级应用，下面的只是反射的一种基础应用</span><br><span class="line">if (PHP_SAPI != &apos;cli&apos;) &#123;</span><br><span class="line">    exit(&apos;Please run it in terminal!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">if ($argc &lt; 3) &#123;</span><br><span class="line">    exit(&apos;At least 2 arguments needed!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">$controller = ucfirst($argv[1]) . &apos;Controller&apos;;</span><br><span class="line">$action = &apos;action&apos; . ucfirst($argv[2]);</span><br><span class="line">// 检查类是否存在</span><br><span class="line">if (!class_exists($controller)) &#123;</span><br><span class="line">    exit(&quot;Class $controller does not existed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 获取类的反射</span><br><span class="line">$reflector = new ReflectionClass($controller);</span><br><span class="line">// 检查方法是否存在</span><br><span class="line">if (!$reflector-&gt;hasMethod($action)) &#123;</span><br><span class="line">    exit(&quot;Method $action does not existed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 取类的构造函数</span><br><span class="line">$constructor = $reflector-&gt;getConstructor();</span><br><span class="line">// 取构造函数的参数</span><br><span class="line">$parameters = $constructor-&gt;getParameters();</span><br><span class="line">// 遍历参数</span><br><span class="line">foreach ($parameters as $key =&gt; $parameter) &#123;</span><br><span class="line">    // 获取参数声明的类</span><br><span class="line">    $injector = new ReflectionClass($parameter-&gt;getClass()-&gt;name);</span><br><span class="line">    // 实例化参数声明类并填入参数列表</span><br><span class="line">    $parameters[$key] = $injector-&gt;newInstance();</span><br><span class="line">&#125;</span><br><span class="line">// 使用参数列表实例 controller 类</span><br><span class="line">$instance = $reflector-&gt;newInstanceArgs($parameters);</span><br><span class="line">// 执行</span><br><span class="line">$instance-&gt;$action();</span><br><span class="line">class HelloController</span><br><span class="line">&#123;</span><br><span class="line">    private $model;</span><br><span class="line">    public function __construct(TestModel $model)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;model = $model;</span><br><span class="line">    &#125;</span><br><span class="line">    public function actionWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;model-&gt;property, PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TestModel</span><br><span class="line">&#123;</span><br><span class="line">    public $property = &apos;property&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（以上代码非原创）将以上代码保存为 <code>run.php</code></p><p>（以上代码非原创）将以上代码保存为 <code>run.php</code><br>运行方式，在终端下执行<code>php run.php Hello World</code></p><p>可以看到，我们要执行 <code>HelloController</code> 下的 <code>WorldAction</code>,</p><p>可以看到，我们要执行 <code>HelloController</code> 下的 <code>WorldAction</code>,<br><code>HelloController</code> 的构造函数需要一个 <code>TestModel</code>类型的对象,</p><p>通过php 反射，我们实现了, <code>TestModel</code> 对象的自动注入，</p><p>上面的例子类似于一个请求分发的过程,是路由请求的分发的一部分，假如我们要接收一个请求 地址例如： <code>/Hello/World</code></p><p>意思是要执行 <code>HelloController</code> 下的 <code>WorldAction</code> 方法。</p></blockquote><p>上面的例子有个最大的缺陷就是所有类写在一个文件中，导致没有使用bind 也不会出错 （注意container 中没有自动加载）</p><p>发现：感觉依赖注入的类的参数都是空的，都是直接就能实例化的那种</p><p>感觉上面那个发现并不多</p><p>控制反转：就是通过一个container 容器去解决依赖关系，把类的实例化从类的内部改成从外部传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public function buy($obj)</span><br><span class="line">    &#123;</span><br><span class="line">       // $obj = new Car(); 改成依赖注入的模式</span><br><span class="line">        $obj-&gt;pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个obj 我们不希望手动传入，希望可以帮我们自动生成，于是就出现了依赖注入（通过类的反射实例化类，但这个类我们要提前绑定到容器中，要不然可能找不到，我们的容器可没有自动加载机制，容器一般有两个方法bind 和 make, bind 一般是 一个类的标识 和一个匿名函数，make 实例化这个类的标识，执行之前绑定的匿名函数，这就是最简单的container）</p><p>能解决的问题：</p><p>当我们把依赖类通过注入的方式传入的时候，我们可以只是传入这个类的类型（接口），当我们使用的时候可以在这个容器中为这个类型不同的实体类，达到switch 切换的效果</p>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;故事背景：在做文件上传的时候，对图片的上传和视频的上传走的是相同的接口，可是视频和图片有些参数是不同的，于是通过一个基类base,扩展出多个子类，image,video ···上传类，根绝参数的不同调用不同类的upload方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单点说反射的就是让你拥有剖析类、函数的能力。&lt;/p&gt;
&lt;p&gt;有的同学可能会问我剖析类有什么用，我为什么要学反射，我只能说不学反射并不会对你实现业务有任何影响，但是如果你想写出结构优雅的程序，想写出维护性和扩展性都很高的程序，学习反射是必不可少的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Laravel 中依赖注入用的就是反射。&lt;a href=&quot;http://www.dahouduan.com/2017/08/21/php-refleciton-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>小程序</title>
    <link href="http://yoursite.com/2019/02/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/25/小程序/</id>
    <published>2019-02-25T10:15:03.000Z</published>
    <updated>2019-02-27T13:06:47.839Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了下小程序的编写，理由：</p><ol><li>vue 还有 react 没学会，小程序是真的简单 ，类似后台模板引擎</li><li>微信不会弹广告，vue或者react 编写的webapp 在一些安卓手机浏览器上，比如魅族自带的浏览器，访问的时候会有很多广告的出现</li><li>不用记域名，之前在做itbasic的时候，就发现大家都记不住域名，导致pc端还好，大家可以收藏域名，手机端完全不会去使用</li><li>练习js, 熟悉es6<br>这篇文章的目的不是介绍小程序的简单使用，只是想记录下容易忽略的知识点（包括es6中），完成了项目的时候才发现，<strong>代码是练出来的，而不是看出来的</strong><a id="more"></a></li></ol><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://upload-images.jianshu.io/upload_images/5525740-f3ba6c063e063b59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h6 id="app-wxss"><a href="#app-wxss" class="headerlink" title="app.wxss"></a>app.wxss</h6><p> 是全局样式文件，比如我们想让每个page页面的背景色从白色变成灰色，可以在这里面定义，又比如我们对iconfont 的使用。</p><h6 id="iconfont-的使用"><a href="#iconfont-的使用" class="headerlink" title="iconfont 的使用"></a>iconfont 的使用</h6><p>我们在编写前端页面的时候经常会需要小图标，现在比较流行iconfont, 我们在阿里的那个官网上选择好图标<img src="https://upload-images.jianshu.io/upload_images/5525740-2226a06bb4bb7aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>然后选择添加至项目<br><img src="https://upload-images.jianshu.io/upload_images/5525740-1fc62e0aee7a00af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>选择项目名称<br><img src="https://upload-images.jianshu.io/upload_images/5525740-d78190d6a7276f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>选择font class ,在线链接，查看线上地址，复制所有css ,保存到本地，然后在这个全局css 中引入，就可以全局使用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;styles/iconfont.wxss&apos;;</span><br></pre></td></tr></table></figure></p><p>我们通过修改font-size 和 color 可以修改图标的大小和颜色（毕竟实际上这些图标都是字体）</p><h6 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h6><p>主要是页面pages 路径的配置，一些基础配置，tabBar (注意tabBar 没有对应的pages ，pages页面上是不会显示tabBar的)， 引入的组件如果想全局使用，也可以在这个页面上配置</p><h5 id="components"><a href="#components" class="headerlink" title="components"></a>components</h5><p>编写的组件位置，其实和pages文件夹差不多，感觉就是组件里面文件一般用index 命名，而pages 里面一般用文件夹名称命名</p><p>其他的文件夹都是可以自己定义的，其实小程序只是给了一个标准的最简单的项目目录，很多时候都可以自己定义文件夹，然后引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">引入 js</span><br><span class="line">import &#123;config&#125; from &apos;../config.js&apos;</span><br><span class="line"></span><br><span class="line">这个config.js 中被引入的内容需要在文件中导出</span><br><span class="line">const config = 4;</span><br><span class="line">export &#123;config&#125;</span><br><span class="line"></span><br><span class="line">感觉和PHP 不一样的地方就是php 一般都是include 文件，而不是对具体变量的引入和导出，当然现在很多时候php 一个文件就是一个class,也是类似一个变量的存在</span><br></pre></td></tr></table></figure></p><h2 id="小程序知识"><a href="#小程序知识" class="headerlink" title="小程序知识"></a>小程序知识</h2><h6 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h6><p>页面，<br>wx:if , wx:for  去判断，循环页面元素，<br>rpx 是小程序上的计量单位，没听懂，反正知道通过使用它，可以实现页面的自适应<br>flex 页面布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">flex-direction: row;</span><br><span class="line">just-content: (主轴) row 横着排列（横 主 纵 副）column (纵 主 横 副) space-between 等（todo: flex 均分怎么实现）</span><br><span class="line">align-item: （副轴）</span><br></pre></td></tr></table></figure></p><p>positon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position:relative (相较于自身)</span><br><span class="line">position:absolute(因为一般只有固定在底部或者首部用到，所以一般这样定位的话就是相对于页面)</span><br></pre></td></tr></table></figure></p><p>目前用到的元素：view ,image(类似view)<br>绑定点击事件 bind:tap, bind:like<br>引入组件：在该pages json 文件中引入，或者全局json 中引入，（父组件给子组件传值通过属性）然后用组件名称使用，在父组件上定义属性，传入子组件定义的data中（子组件给父组件传值通过事件，子组件抛出事件，触发父组件绑定的事件）</p><h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><p>let 新的定义变量方式，if 或者 for 中定义的，外面获取不到<br>const 不能改变的量<br>onLoad 方法中一般写入初始化的时候对后台接口的请求（蛋疼的就是经常页面加载的时候出现抖动，当返回数据比较慢的时候）<br>自定义的方法就写在最外层就好了<br>data : 定义页面中的值，初始化<br>setData :改变页面中的值<br>wx.getStorage()  感觉这些就是类似调用系统接口，应该安卓和ios 中用的比较多，这是微信封装的，注意其中的同步和异步之分</p><h3 id="推荐组件"><a href="#推荐组件" class="headerlink" title="推荐组件"></a>推荐组件</h3><p>vant 有赞出的小程序组件，只有用过小程序原生组件才会知道vant 用起来有多么方便，npm 安装</p><p>值的注意的是：事件 event.detail 能获取到这个组件本身，之前我们经常用event.detail.value 获取组件传递的值，通过event.detail去调用组件自身的一些方法，比如日期picker 上显示的日期大小</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了下小程序的编写，理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vue 还有 react 没学会，小程序是真的简单 ，类似后台模板引擎&lt;/li&gt;
&lt;li&gt;微信不会弹广告，vue或者react 编写的webapp 在一些安卓手机浏览器上，比如魅族自带的浏览器，访问的时候会有很多广告的出现&lt;/li&gt;
&lt;li&gt;不用记域名，之前在做itbasic的时候，就发现大家都记不住域名，导致pc端还好，大家可以收藏域名，手机端完全不会去使用&lt;/li&gt;
&lt;li&gt;练习js, 熟悉es6&lt;br&gt;这篇文章的目的不是介绍小程序的简单使用，只是想记录下容易忽略的知识点（包括es6中），完成了项目的时候才发现，&lt;strong&gt;代码是练出来的，而不是看出来的&lt;/strong&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>框架学习-获取请求参数</title>
    <link href="http://yoursite.com/2019/02/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2019/02/25/框架学习-获取请求参数/</id>
    <published>2019-02-25T06:51:45.000Z</published>
    <updated>2019-02-25T10:37:36.490Z</updated>
    
    <content type="html"><![CDATA[<p>PHP属于一门高级语言，感觉就是那种语言里面偏向于应用层的语言，再加上lnmp架构还有框架的存在，对于http请求过程中的细节封装了太多层，导致我们实际在使用过程中得到的参数已经是面目全非的样子，记录下对其探索的历程</p><a id="more"></a><p>问题出现在很久之前，有一次我用json数据去请求我们itbasic的接口，可惜没法解析，我原本以为是框架的原因，于是我开始打印$_POST中数据(post 方式提交)，可是其中也是毫无结果，算了，不处理了，搞不定，反正用不到~昨天，前端小朋友再次发现这个问题，感觉很简单，为了维护自己的高大形象，就处理下吧。</p><p>首先是关于content-type 的理解：</p><blockquote><p>一般是指网页中存在的Content-Type，Content-Type属性指定请求和响应的HTTP内容类型。如果未指定 ContentType，默认为text/html。</p></blockquote><p>上述问题中为什么会出现指定请求和响应的HTTP内容类型，因为content-type 在request中可以设置，在response中也可以设置，在request 中设置代表我发送的请求，在response中的设置代表从服务器返回的内容。</p><p>常见的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.text/html</span><br><span class="line">2.text/plain</span><br><span class="line">3.text/css</span><br><span class="line">4.text/javascript</span><br><span class="line">5.application/x-www-form-urlencoded</span><br><span class="line">6.multipart/form-data</span><br><span class="line">7.application/json</span><br><span class="line">8.application/xml</span><br></pre></td></tr></table></figure><p>我们在接口调用的时候常用的是后面4个</p><h3 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h3><blockquote><p>会将表单内的数据转换拼接成 key-value 对（非 ASCII 码进行编码）</p><p>编码方式应该是urlencode</p></blockquote><p>还记得自己刚写php代码时候吗，那时候最基础的功能是实现一个表单提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form enctype=&quot;application/x-www-form-urlencoded&quot; action=&quot;http://homeway.me/post.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;homeway&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;key&quot; value=&quot;nokey&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后服务器端就可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$name = $_POST[&apos;name&apos;];</span><br><span class="line">$key = $_POST[&apos;key&apos;]</span><br></pre></td></tr></table></figure><p>实际接收到的内容（通过swoole rowContent 打印出来，获取原始的<code>POST</code>包体，用于非<code>application/x-www-form-urlencoded</code>格式的<code>Http POST</code>请求，返回原始<code>POST</code>数据，此函数等同于PHP的<code>fopen(&#39;php://input&#39;)</code>）</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-b025bdb118cfc2f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>所以其实$_POST 就是对上述dept_name 进行 &amp; explode, 然后urldecode 一下</p><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>最先接触这个东西的时候是文件上传的时候</p><blockquote><p><form> 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。</form></p></blockquote><p>postman 中发送请求</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-c0fe828812283de0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>平时我测试接口的时候经常用的是form-data, 服务端实际接受到的数据如下(swoole)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件</span><br><span class="line">这种方式不会对中文进行编码</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5525740-2c03c3ce87ca18ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>既可以上传文件等二进制数据，也可以上传表单键值对，</p></blockquote><p>所以本该用来进行上传文件的请求方式，我平时用它来进行普通接口的测试，通过这种方式提交数据也可以通过PHP 的 $_POST 来获取到    ，上述中的boundary用来分割数据</p><p>看到了postman 上面的raw吗</p><blockquote><p>raw 原始类型，可以上传任意格式的文本，比如 text、json、xml、html（中文不进行编码）</p></blockquote><p>其中 json,text,html 都是通过这种方式，然后添加content-type</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-49bf8044ad6f94ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>微信中经常用这种方式，之前在开发企业号的时候经常遇到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.homeway.me HTTP/1.1 </span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">    &lt;id&gt;123&lt;/id&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;name&gt;</span><br><span class="line">            &lt;value&gt;homeway&lt;/value&gt;</span><br><span class="line">        &lt;/name&gt;</span><br><span class="line">        &lt;age&gt;</span><br><span class="line">            &lt;value&gt;22&lt;/value&gt;</span><br><span class="line">        &lt;/age&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure><blockquote><p>php中<code>$_POST</code>只能读取<code>application/x-www-form-urlencoded</code>数据，<code>$_FILES</code>只能读取<code>multipart/form-data</code>类型数据，(感觉$_POST 也能读取multipart/form-data 中的数据)</p></blockquote><p>要读取那里面的数据只能用最原始的方法(同理json)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = file_get_contents(‘php://input’);</span><br><span class="line">$request-&gt;rawContent() // swoole</span><br></pre></td></tr></table></figure><p>notice:</p><blockquote><p>一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。(我根据这个新增框架中json 数据的解析)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$getArr = static::$request-&gt;get;</span><br><span class="line">        $getArr = count($getArr) &gt; 0 ? $getArr : [];</span><br><span class="line"></span><br><span class="line">        $postArr = static::$request-&gt;post;</span><br><span class="line">        $postArr = count($postArr) &gt; 0 ? $postArr : []; //后面的覆盖前面的，所有post写在后面</span><br><span class="line"></span><br><span class="line">        if (isset(static::$request-&gt;header[&apos;content-type&apos;])) &#123;</span><br><span class="line">            if (static::$request-&gt;header[&apos;content-type&apos;] == &apos;application/json&apos;) &#123;</span><br><span class="line">                $rawContent = static::$request-&gt;rawContent() ?: &apos;&apos;;</span><br><span class="line">                $rawContent = json_decode($rawContent, true);</span><br><span class="line">                $postArr    = array_merge($postArr, $rawContent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return array_merge($getArr, $postArr);</span><br></pre></td></tr></table></figure><p>notice:</p><p>千万要注意：不能上来没有判断是json 就对rawContent 取到的内容进行切割，因为只有json 的时候切割才会符合我们预期，别的时候不会</p><p>上面就是post方式提交数据的几种情况，接下来我们说get方式（现在的restful api 还有delete put 等方式，我在各个文章上都没找到关于上面内容的解释，猜测一下，是不是delete put 本质上还是属于put 方式）</p><p>起因：之所以注意到get请求的这种方式，是因为再一次偶然的过程中发现get 请求的content-type 不存在，想了下确实合乎道理，get的参数都是拼接在url 上面 （file_get_contents(‘php://input’) 只能获取post请求中的输入）</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-f2d12e0a9ff47633.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>注意就算是urlencode 加密，他们都是有字符编码的限制的，如果字符编码不一致，那么加密出来的结果将会不一样</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-aaef0e7ec0c6f314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>同理可以联想之前做的aes-128-ecb 加密，为什么有那么多可选项，也是这个原因</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-b67717f86e0a6514.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><a href="https://blog.csdn.net/andyzhaojianhui/article/details/5181902" target="_blank" rel="noopener">这篇文章对于编码的解释很透彻</a></p><p><a href="https://segmentfault.com/a/1190000015800019" target="_blank" rel="noopener">这篇文章和上面那篇文章都有简单描述urlencode是怎么实现的</a></p><p>(这篇文章中的很多坑我们写的时候没有碰到是因为很多默认配置的原因，比如php 字符集默认配置utf8,页面配置字符集 utf-8)</p><p>所以呢在通过get 方式传递参数的时候，我们一定要注意那些中文字符 urlencode 的时候（或者别的编码方式的时候设置的字符集是什么，是gbk 还是utf8,我们忽略这个问题是因为我们经常就默认都设置成utf8 导致很多时候这些细节会被忽略）</p><p>同理联想php中也有urlencode 函数，他的字符集是怎么设置的</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-a4c102a9049ca8d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>所以呢，当我们出现乱码的时候我们还可以这样考虑下：</p><ol><li>客户端传递过来的数据进行了怎么样的加密（字符集），get方式，post方式中的www-formedate-urlencode</li><li>服务端传递过来的数据进行了怎么样的解密（字符集）</li></ol><blockquote><p>在post方法里所要传送的数据也要URL encode，那么他是用什么编码方式的呢？<br>   在form所在的html文件里如果有段<meta http-equiv="Content-Type" content="text/html; charset=字符集（GBK，utf-8等）">，那么post就会用此处指定的编码方式编码。一般大家都认为这段代码是为了让浏览器知道用什么字符集来对网页解释，所以网站都会把它放在html代码的最前端，尽量不出现乱码，其实它还有个作用就是指定form表单的post方法提交数据的 URL encode编码方式。从这里可以看出对于get方法来说，浏览器对数据的URL encode的编码方式是有浏览器设置来决定(或者在请求之前，我们提前对非asii码进行编码设置，这样决定权就从浏览器变成我们开发者)，（可以用js做统一指定），而post方法，开发人员可以指定。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP属于一门高级语言，感觉就是那种语言里面偏向于应用层的语言，再加上lnmp架构还有框架的存在，对于http请求过程中的细节封装了太多层，导致我们实际在使用过程中得到的参数已经是面目全非的样子，记录下对其探索的历程&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="框架，HTTP" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6%EF%BC%8CHTTP/"/>
    
  </entry>
  
  <entry>
    <title>加密解密</title>
    <link href="http://yoursite.com/2019/02/21/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>http://yoursite.com/2019/02/21/加密解密/</id>
    <published>2019-02-21T03:50:59.000Z</published>
    <updated>2019-02-25T09:29:46.636Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个底层码农，其实加密解密平时是用不到的，毕竟平时写的就是cms 的curd, 但随着API的流行以及老大对代码质量的重视，还有和别的部门的交互，于是需要加解密啦。<a href="https://t.ti-node.com/thread/6497068236977209344" target="_blank" rel="noopener">原文</a></p><a id="more"></a><p>首先的区分下加解密和hash 的不同，对于md5() 这样加密之后理论上就不能解密的方式，我们一般称之为hash,在我们以往的网站编程中，对于用户的密码保存一般都是通过hash这种方式，通过把用户的密码拼接一个字符串，然后md5下生成的值保存到数据库中，下次用户登陆的时候，再次把用户输入的密码做上次同样的操作，对比和数据库中值是否一致，如果一致说明密码正确，否则密码错误。</p><p>加密我们平时生活中遇到最多的应该就是https 解析过程，因为非对称加密太消耗性能，所以我们传输过程需要对称加密（对称加密就是加密密钥和解密密钥一致，非对称反之），而对于密钥的传输我们用的是非对称（非对称因为密钥的不同又有公钥和私钥之分：公钥加密，私钥解密，数据不会被获取；私钥加密，公钥解密，数据不会被篡改）。</p><p>对称加密算法一般有AES(itbasic 请求datrix 那边用的就是这种),DES,3DES，非对称有RSA</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-b0ca983394ce8b5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="加解密的原理图"></p><p>上图中，123456 就是对称加密过程中的密钥</p><blockquote><p>最一开始的时候，我朝人民一般都是倾向于使用“天王盖地虎”，“宝塔镇河妖”这种加解密技术；然而，美帝用了一种叫做DES的技术进行对称加解密，这玩意一度成为业界通用的对称加解密技术，银行、五角大楼都爱用这玩意，可惜好景不长、世风日下、世态炎凉，这玩意的破解成本越来越低越来越低～～ 于是，为了续命，就又有一些白胡子老头给DES打补丁，缝缝补补搞出来一个玩意叫做3DES，继续用，又不是不能用…这个顾名思义就行了，别打我，真的：3DES就是用DES处理（注意是处理，我没说是加密）了三次的意思。就目前看来，3DES实际上用的可能也并不是十分广泛了，所以如果大家在选择对称加解密技术的时候，尽量避开DES和3DES就可以了。</p><p>呵呵，喜新厌旧的沙雕人类…虽然DES已经没人用了，但毕竟也是辉煌过，我觉得还是得动手表演一波儿。我们知道，<strong>在php7里，原来的mcrypt系列加解密已经被放弃掉了，官方建议我们使用openssl系列来进行加解密</strong>，所以确保你的PHP环境里安装了openssl标准扩展。</p></blockquote><p>上面是原文中对于DES 和 3DES 的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 这个函数打印出来openssl支持的所有加密方法以及模式的组合</span><br><span class="line">$arr_ava_methods = openssl_get_cipher_methods(true);</span><br><span class="line">print_r( $arr_ava_methods );</span><br><span class="line">exit;</span><br><span class="line">// 返回值</span><br><span class="line">    [123] =&gt; aes-192-cfb8</span><br><span class="line">    [124] =&gt; aes-192-ctr</span><br><span class="line">    [125] =&gt; aes-192-ecb</span><br><span class="line">    [126] =&gt; aes-192-gcm</span><br><span class="line">    [127] =&gt; aes-192-ocb</span><br><span class="line">    [128] =&gt; aes-192-ofb</span><br><span class="line">    [129] =&gt; aes-256-cbc</span><br><span class="line">    [130] =&gt; aes-256-ccm</span><br><span class="line">    [131] =&gt; aes-256-cfb</span><br><span class="line">    [132] =&gt; aes-256-cfb1</span><br><span class="line">    [133] =&gt; aes-256-cfb8</span><br><span class="line">    [134] =&gt; aes-256-ctr</span><br></pre></td></tr></table></figure><blockquote><p>其中带有ede的，比如des-ede*这样的就表示是3DES</p></blockquote><p>其中des 有如下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">des-cbc</span><br><span class="line">des-cfb*（注意后面的通配符星号）</span><br><span class="line">des-ecb</span><br><span class="line">des-ofb</span><br></pre></td></tr></table></figure><p>下面是如何通过des-ecb 的方式加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 我们就选用des-ecb方法进行一次des加密</span><br><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">$my_method   = &apos;des-ecb&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123;</span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">$key  = &quot;123456&quot;;</span><br><span class="line">$data = &quot;helloMOTO&quot;;</span><br><span class="line">echo &quot;明文：&quot;.$data.PHP_EOL;</span><br><span class="line">$enc_data  = openssl_encrypt( $data, $my_method, $key );</span><br><span class="line">echo &quot;密文：&quot;.$enc_data.PHP_EOL;</span><br><span class="line">$dec_data  = openssl_decrypt( $enc_data, $my_method, $key );</span><br><span class="line">echo &quot;明文：&quot;.$dec_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">明文：helloMOTO</span><br><span class="line">密文：IbpWiZbAoNMiknX3jdeqmQ==</span><br><span class="line">明文：helloMOTO</span><br></pre></td></tr></table></figure><p>接下来我们说说aes 的加密方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">// 选用aes-128-ecb</span><br><span class="line">$my_method   = &apos;aes-128-ecb&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123; </span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">// 加密用的密码</span><br><span class="line">$key  = &quot;1234567812345678&quot;;</span><br><span class="line">// 加密的内容</span><br><span class="line">$data = &quot;12345678abcdxxoo12345678abcdxxoo&quot;;</span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA );</span><br><span class="line">$hex = bin2hex( $enc_data );</span><br><span class="line">echo $hex.&apos; : &apos;.strlen( $hex ).PHP_EOL;</span><br></pre></td></tr></table></figure><p>aes-128-ecb, 其中128代表密钥的长度，多余的长度会被直接街去掉(这个可以通过代码验证下，比如12345 用密钥1234567812345678和12345678123456789分别加密，看结果是否一样，最后再用不满128bit来加密123456781234567 )，128bit</p><p>128/8=16 位，aes-192-ecb, aes-256-ecb, 这其中的192 ，256，都是同样的意思。</p><blockquote><p>最后一个参数是OPENSSL_RAW_DATA，如果选用这个option的话，经过加密后的数据会是奇怪的二进制数据，无法直接通过文本方式查看，所以要看的话必须先使用bin2hex函数处理一下。</p></blockquote><p>上面这段话一定要注意理解，反正我第一次没有理解，导致第一次加密数据失败，网上的很多aes-128-ecb 这种加密代码的封装中都携带着自己的逻辑，所以会误导视野。上述opensssl_encrypt(),如果没有用最后一个参数，直接返回的结果是加密结果base64 的结果，如果有了，返回的是一段奇怪的二进制数据数据，这里我们可以理解成原始数据（加密数据最原始的样子），我们可以通过base64或者 bin2hex 转换城对应的base64格式或者16进制格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">明文：</span><br><span class="line">12345678abcdxxoo12345678abcdxxoo</span><br><span class="line">密文：c1391e34caf38f8c2a477cbda3772533c1391e34caf38f8c2a477cbda3772533d96aa42b59151a9e9b5925fc9d95adaf</span><br><span class="line">// 上面密文切分的结果</span><br><span class="line">c1391e34caf38f8c2a477cbda3772533 | c1391e34caf38f8c2a477cbda3772533 | d96aa42b59151a9e9b5925fc9d95adaf</span><br><span class="line"></span><br><span class="line">难道说明文“12345678abcdxxoo”被密钥“1234567812345678”加密后后的密文就是“c1391e34caf38f8c2a477cbda3772533”？</span><br><span class="line"></span><br><span class="line">DES和3DES会将明文以64bit（8字节）作为一个单元进行分组；</span><br><span class="line">AES则会将明文以128bit（16字节）作为一个单元进行分组；</span><br><span class="line">无论是AES还是DES，当最后一个分组的数据长度不满足分组标准长度的时候，会用某种填充方式进行填充；</span><br><span class="line">AES对一个16字节分组加密完毕后，分组大小依然为16字节；DES也一样</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5525740-f9d3aff215a407a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>上面就是aes ecb 的处理过程</p><p>如果我们把加密的内容分组之后稍微修改下分组顺序再解密，可以得到原文分组顺序的不同</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-83bd4bcca97d0aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>ecb太不靠谱了，竟然能修改，出现了cbc 模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">$my_method   = &apos;aes-128-cbc&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123;</span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">// 密钥 和 明文</span><br><span class="line">$key  = &quot;1234567812345678&quot;;</span><br><span class="line">$data = &quot;12345678abcdxxooxxooabcd12345678i&quot;;</span><br><span class="line">// 每种方法都有自己需要的iv向量的长度</span><br><span class="line">$iv_length = openssl_cipher_iv_length( $my_method );</span><br><span class="line">// 根据长度生成相应iv</span><br><span class="line">$iv        = openssl_random_pseudo_bytes( $iv_length, $cstrong ); // 我就是一直把这玩意当成一个随机的字符串看待的</span><br><span class="line">echo &quot;明文：&quot;.$data.PHP_EOL;</span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA, $iv );</span><br><span class="line">$dec_data = openssl_decrypt( $enc_data, $my_method, $key, OPENSSL_RAW_DATA, $iv );</span><br><span class="line">echo &quot;解密：&quot;.$dec_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line">// 神器的代码</span><br><span class="line">test2(1,$c); // 这样竟让不会报错</span><br><span class="line">function test2 ($a, &amp;$b) &#123;</span><br><span class="line">        var_dump($a+$b, $b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><blockquote><p>这个传说中的iv向量终于他妈出现了！相对于ECB模式，CBC在加密之前多了一个XOR异或运算的环节，但是第一个明文分组和谁做异或呢？所以这个iv向量就是初始化后给第一个明文分组做XOR异或运算用的，第二个明文分组就与第一个密文分组做XOR异或运算，然后再加密得到第二个密文分组…依次重复下去。</p><p>xor 就是异或，相同的取0，不同的取1</p></blockquote><p>总结：</p><blockquote><p>AES和DES以及3DES这种加密方式被称为分组密码，分组密码每次只能加密固定长度的明文，所以如果明文很长的话，就需要轮流为每个分组明文进行加密，AES的分组长度是128bit，而DES的分组长度为64bit；如果一旦需要对多个分组进行轮流加密，加入明文被分成了三个明文分组，那么就需要对三个明文进行迭代加密（粗暴理解就是轮流加密），然而会有很多种不同的迭代方式，这种不同的迭代方式专业名词就叫“模式”，这些模式有：ECB、CBC、OFB、CFB、CTR… …</p><p>对明文进行分组的方式是固定的，唯一不同的就是分组长度不一样而已；模式是指对多个明文从第一个开始轮流加密到最后一个的这个过程，是怎么轮流执行的。</p></blockquote><p>非对称加解密就不copy了，以后用到的时候再看吧</p><p>自己的总结：</p><p>其实上面用到的也就怎么用php 进行aes-128-ecb加密，加密出来的数据让别的语言可以解析出来</p><p>这其中会遇到很多问题，比如之前曾经遇到过但是没有记录的和java通信过程中的padding 填充问题，以后遇到了再补充吧。</p><p>顺带补充一下：</p><p><a href="https://www.devglan.com/online-tools/aes-encryption-decryption" target="_blank" rel="noopener">https://www.devglan.com/online-tools/aes-encryption-decryption</a></p><p>这个网站以及下面的php代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$data = &apos;陈野&apos;;</span><br><span class="line">$key = &apos;1234567812345678&apos;;</span><br><span class="line"></span><br><span class="line">echo $key.PHP_EOL;</span><br><span class="line"></span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA);</span><br><span class="line">echo $enc_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo base64_encode($enc_data).PHP_EOL;</span><br><span class="line"></span><br><span class="line">echo bin2hex( $enc_data );</span><br></pre></td></tr></table></figure><p>默认的填充方式</p><p>pkcs5padding or pkcs7padding (不确定)</p><p>字符集（utf8）</p><p><a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="noopener">http://tool.chacuo.net/cryptaes</a></p><p>上面这个网站才是真正意义上详细的加密，参数可以选择</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个底层码农，其实加密解密平时是用不到的，毕竟平时写的就是cms 的curd, 但随着API的流行以及老大对代码质量的重视，还有和别的部门的交互，于是需要加解密啦。&lt;a href=&quot;https://t.ti-node.com/thread/6497068236977209344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试题</title>
    <link href="http://yoursite.com/2019/02/21/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/21/PHP面试题/</id>
    <published>2019-02-21T02:50:35.000Z</published>
    <updated>2019-02-21T02:51:48.293Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些有意义常用的面试题</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集一些有意义常用的面试题&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="interview" scheme="http://yoursite.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>laravel 核心技术读书笔记</title>
    <link href="http://yoursite.com/2019/01/03/laravel-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/03/laravel-核心技术读书笔记/</id>
    <published>2019-01-03T15:31:06.000Z</published>
    <updated>2019-01-03T16:10:40.018Z</updated>
    
    <content type="html"><![CDATA[<p>关于laravel 框架核心技术一书的阅读感受<br><a id="more"></a></p><p>###1.关于命名空间<br>我理解的命名空间是文件中的namespace 可以定义成任意的值，但是composer 的自动加载因为符合psr4 ，所以要求命名空间和文件路径一致，文件名和类名保持一样。当我们不适用composer的自动加载的时候，就可以随便指定文件中的namespace是多少了，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace test;</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以保存在任意位置任意名称的文件中，但是不能写在composer autoload 驱动的框架中，除非改成别的方式加载，比如map<br>还记得我们在控制器中引用别的类吗，通过use,然后就能直接使用new classname()了，但是我们在脚本中使用的时候，我们一定要用到include 先去包含这个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace test;</span><br><span class="line"></span><br><span class="line">include &apos;test2.php&apos;;</span><br><span class="line"></span><br><span class="line">use test2\test5;</span><br><span class="line"></span><br><span class="line">class test </span><br><span class="line">&#123;</span><br><span class="line">  public function test2()</span><br><span class="line">  &#123;</span><br><span class="line">      test1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$a = new test();</span><br><span class="line">$a-&gt;test2();</span><br><span class="line"></span><br><span class="line">$b = new test5();</span><br><span class="line">$b-&gt;test3();</span><br></pre></td></tr></table></figure></p><p>可能你在想，既然我们都include 了，那为啥还要使用use，use在这个地方的作用是什么，当你使用 use test2\test5的时候，你在使用 new test5(), 它实际new 的是 test2\test5(), 如果没有 new test5(), 当前命名空间下的test5类，所以你明白了use 并不是导入包含文件，只是引入一个类的前缀，想不适用前缀，那就 new \test5() ，绝对路径吧，如果想使用当前命名空间下的 test5(),那就把外来引入的换个名称吧，比如 as。现在想想，其实我们平时同一个文件夹下面命名空间一样，本质上是写在一个文件中的，只是我们为了方便好看，才把分到多个文件中，但是我们互相引用的时候，同一个命名空间下面，不用use，因为默认就在当前文件夹下面找。</p><p>当我接触use 的时候，书中还有一句话，use只能引用类，并不能引用常量，函数··！！难道还可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace test;</span><br><span class="line"></span><br><span class="line">//include &apos;test2.php&apos;;</span><br><span class="line"></span><br><span class="line">use test2\test5;</span><br><span class="line"></span><br><span class="line">class test </span><br><span class="line">&#123;</span><br><span class="line">  public function test2()</span><br><span class="line">  &#123;</span><br><span class="line">      test1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* class test5</span><br><span class="line">&#123;</span><br><span class="line">    public function test3()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function autoload($class) &#123;</span><br><span class="line">    echo $class;</span><br><span class="line">    include &apos;./test2.php&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(&apos;test\autoload&apos;);</span><br><span class="line"></span><br><span class="line">$a = new test();</span><br><span class="line">$a-&gt;test2();</span><br><span class="line"></span><br><span class="line">$b = new test5();</span><br><span class="line">$b-&gt;test3();</span><br></pre></td></tr></table></figure></p><p>对，你没看错，class 的外面还能定义function, 然后我们当前命名空间中可以直接使用，如果是不同的命名空间，需要加前缀</p><p>###2.spl_autoload<em>register 和 __autoload<br>\</em>_autoload已经被废弃了，在7.2 中。__autoload 如果在一个库中出现多次，会出错的，虽然是魔术方法，但可以不在类中定义，spl_autolad_register ，可以绑定多个自动加载，还可以删除，composer的自动加载机制中就用到了删除。他是类似一种方法的执行，可以写在任意地方，可以直接是方法名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register(&apos;test\autoload&apos;);</span><br></pre></td></tr></table></figure></p><p>可以是面向对象的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register([$this, &apos;autoload&apos;], true, true);</span><br></pre></td></tr></table></figure></p><p>第二个参数true 代表异常可以捕获，__autoload 就不行，第三个参数说实话不知道咋用，队列头部和队列尾部，就是先加载哪个自动加载函数的意思呗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于laravel 框架核心技术一书的阅读感受&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>LBS 和 redis mongodb</title>
    <link href="http://yoursite.com/2018/12/24/LBS-%E5%92%8C-redis-mongodb/"/>
    <id>http://yoursite.com/2018/12/24/LBS-和-redis-mongodb/</id>
    <published>2018-12-24T14:00:01.000Z</published>
    <updated>2018-12-25T03:49:08.051Z</updated>
    
    <content type="html"><![CDATA[<p>LBS,刚听起来挺高大上的，其实简单理解就是附近的人。其实这个需求蛮常见的，比如大众点评中搜索摸某一个店铺按照离我当前位置距离进行排序，又或者某些社交软件中的附近的人，实现的方式有很多，php + mysql ， php + redis ， php+ mongodb， 其中mysql 的话，就是把所有的点的坐标保存下来，然后通过编写sql语句，直接通过sql去查询每个点离我们的距离，然后排序返回，但数据量大的时候，可能不太好，所以就有了后面的nosql ， redis 和 mongodb 的相关应用，其中 mongodb 在这方面应该是我听得最多的，当初想试这个功能也是因为想教一下前端朋友mongodb的相关功能，方便他面试，但后来发现其实还是redis 实现比较方便，因为php的mongodb扩展 mongo(php5） 和 mongodb(php7) 接口一点都不一样，而且中文文档比较少啦。其实通过es 也是可以实现的，方法很多.<br><a href="https://zhuanlan.zhihu.com/p/31380780" target="_blank" rel="noopener">详细见这篇文章</a><br><a id="more"></a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>(<a href="https://yq.aliyun.com/articles/62844" target="_blank" rel="noopener">参考</a>)redis 自从3.2就有了对于经纬度的处理，但注意并不是新增了一个一个数据结构，这个经纬度是在 有序集合zset 的基础上发展而来的，所以我们对于zset 的操作都能对经纬度使用，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrange key 0 10 #  把key 中所有的member 都取出来 zrange cy1 0 10</span><br><span class="line">zcard key   # key 中有多少个member, zcard cy1</span><br><span class="line">zsore  key member #  key 中具体的member 的score，对于经纬度这个取出来看不懂</span><br></pre></td></tr></table></figure></p><p>穿插一句：刚开始使用redis 的时候，虽然他的api很简单，便于理解，但是和sql编程还是不同的，为什么我们一个对象有了member 这个名称还需要key 呢，你想啊，我么需要从一个集合中获取离这个点比较近的点，这个集合的名称就是 key,这个是事先我们往集合中塞就定好的，后面我们可能变化的是member 的名称，需要我们从外边传入。<br>关于php使用redis, 大致分成两种方法，有通过编译c扩展，还有就是通过composer 安装predis,这是两种方法，我们不要混淆了，平时我们大部分用的是c扩展额，然后自己封装其中基本的方法和连接方式，需要注意的是关于重连啊，或者单例模式是的使用啊之类的，还有就是其中__call方法的使用，如果有那些我们没有封装的方法，但是自己还使用了，默认就会调用这个方法。一般很多时候调用方法正确的放回是0和1，所以我们不能根据0和1来判定方法是否执行成功，很多时候他代表着影响的行数，比如新增返回1，修改返回0。还有c扩展方式安装的，比如 geoRadiusByMember, 不知道这个方法的参数都是啥，也不知道在哪能找到，只能凭着redis的使用去猜测，比如最后一个option 应该传数组，但其实如果传错的话，也有提示，感谢扩展报错信息的详细<br><img src="https://upload-images.jianshu.io/upload_images/5525740-b62f23df1e40a292.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>geoadd: 增加地理位置的坐标。<br>geodist: 获取两个地理位置的距离。<br>geohash: 获取地理位置的GeoHash值。<br>geopos: 获取地理位置的坐标。<br>georadius: 根据给定经纬度坐标获取指定范围内的地理位置集合。<br>georadiusbymember: 根据给定地理位置获取指定范围内的地理位置集合。</p><p>georadius 和 georadiusbymember 的参数</p><p>WITHDIST: 同时返回地理位置与给定位置的距离<br>WITHCOORD: 同时返回地理位置的经纬度坐标<br>WITHHASH: 同时返回Redis内部的GeoHash值（非标准算法值），一般用于debug<br>ASC|DESC：结果按距离升降序排序<br>STORE|STOREDIST: 结果存到新的有序集合中，前者以GeoHash值做score，后者以与指定位置的距离作score，该选项与WITH[DIST|COORD|HASH]选项冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public function addLocation()</span><br><span class="line">    &#123;</span><br><span class="line">        $redis = new Redis();</span><br><span class="line"></span><br><span class="line">        //var_dump($redis-&gt;geodist(&apos;cy1&apos;, &apos;a&apos;, &apos;b&apos;));exit;</span><br><span class="line"></span><br><span class="line">        $lnt = Request::instance()-&gt;post(&apos;lnt&apos;);</span><br><span class="line">        $lat = Request::instance()-&gt;post(&apos;lat&apos;);</span><br><span class="line">        $name = Request::instance()-&gt;post(&apos;name&apos;);</span><br><span class="line">      // 1 成功 新增</span><br><span class="line">        // 0 也可能是成功  修改</span><br><span class="line"></span><br><span class="line">        $res = $redis-&gt;geoadd(&apos;cy1&apos;, $lnt ,$lat, $name); // 相同的名称就直接替换了</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function dist()</span><br><span class="line">    &#123;</span><br><span class="line">        $member1 = Request::instance()-&gt;post(&apos;member1&apos;);</span><br><span class="line">        $member2 = Request::instance()-&gt;post(&apos;member2&apos;);</span><br><span class="line"></span><br><span class="line">        $redis = new Redis();</span><br><span class="line">        var_dump($redis-&gt;geodist(&apos;cy1&apos;, $member1, $member2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function fujin()</span><br><span class="line">    &#123;</span><br><span class="line">        $radius = Request::instance()-&gt;post(&apos;radius&apos;); // 多少半径</span><br><span class="line">        $member = Request::instance()-&gt;post(&apos;member&apos;); // 点的名称</span><br><span class="line">        $unit = Request::instance()-&gt;post(&apos;unit&apos;); // 单位</span><br><span class="line"></span><br><span class="line">        $option = [&apos;withdist&apos;, &apos;withcoord&apos;];</span><br><span class="line"></span><br><span class="line">        $redis = new Redis();</span><br><span class="line">        var_dump($redis-&gt;georadiusbymember(&apos;cy1&apos;, $member, $radius, $unit, $option</span><br><span class="line"></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证方法，通过求得两个点的距离之后按照多少米之内半径调整圆的大小，来观察另一点是否在圆圈内来验证.</p><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><p>关于mongodb的安装就看菜鸟教程吧，也是解压完就能用，类似redis,然后服务端启动是 mongod, 客户端shell是 mongo(然后据说是js shell，不知道需不需要node的支持，反正我的服务器上node 是必须的，因为vue 啊 或者 hexo 啊 都需要node), 启动的时候要设置 dbpath 和 log path,直接写到配置文件中就可以 mongod启动了。</p><p>小插曲：因为这个mongo启动的时候输了一堆的信息，然后又看不懂，所以就像通过检查端口号来看是否启动成功，这又到了用ps 和 netstat 的时候了。先通过ps -ef|grep 27017 没有，是不是这个命令本来就不输出端口号呢？ps -ef |grep nginx,果然没有端口号，于是netstat -antp|grep 27017,看到了，害怕这个应用层服务不是基于tcp (也许是多虑吧)，我把t 去掉了，查到了。完事之后自己思考了下，ps 主要是用来检查进程的，netstat 是用来检查网络连接的，拿nginx 来举例，他可能有一个manage 进程，然后有个master 子进程，然后每个master还有worker进程，然后他监听了 80 ，443 等端口，所以ps 查出来的只能是进程相关，netstat 查出来的才是各种提供的服务和端口号。</p><p>mongodb 和 redis 同属于nosql，拿现在比较流行的话说，他也是对标mysql的产品，很多教程拿他和mysql做对比，确实也更容易理解<br><img src="https://upload-images.jianshu.io/upload_images/5525740-b1708965ed613950.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>我们刚开始进入shell :<br>show dbs   显示有哪些数据库，默认 local 和 admin<br>可是默认我们在test 下面，为什么test 没有显示，因为test 中没有内容呀，但凡我们插入数据，就可以有了</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>use test 切换数据库，如果没有就新建</p><p>db 显示当前数据库</p><p>db.dropdatabase  删除当前数据库</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>db.runoob.drop 删除当前表/collection</p><p>show tables   显示当前数据库中有哪些表 </p><p>show collections  同上</p><p>db.createCollection(‘test’)   创建表</p><p>db.createCollection(“mycol”, { capped : true, autoIndexId : true, size :<br>   6142800, max : 10000 } ) 创建表</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>db.runoob.insert({“name”:”菜鸟教程”})  插入数据 ，这个runoob 是表的名字，在mongodb 中是文档的意思，然后mongo 中table 中 field 不需要统一</p><p>db.col.insert({title: ‘MongoDB 教程’,<br>    description: ‘MongoDB 是一个 Nosql 数据库’,<br>    by: ‘菜鸟教程’,<br>    url: ‘<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>‘,<br>    tags: [‘mongodb’, ‘database’, ‘NoSQL’],<br>    likes: 100<br>})   // 往col 表里面插入数据</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>db.col.find({title:’cy’, sex:’boy’})   //查找col 表里面数据,and 条件<br>db.col.find().pretty() 更好的显示出来</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-cb07bdb5491c4ba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}})</p><blockquote><p>db.col.save({<br>    “_id” : ObjectId(“56064f89ade2f21f36b03136”),<br>    “title” : “MongoDB”,<br>    “description” : “MongoDB 是一个 Nosql 数据库”,<br>    “by” : “Runoob”,<br>    “url” : “<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“,<br>    “tags” : [<br>            “mongodb”,<br>            “NoSQL”<br>    ],<br>    “likes” : 110<br>})</p></blockquote><p>save 的话，保存id 就是更新，没有id 的话就是新增</p><p>默认的话只能更新一条，如下可以更新多条，因为第二个布尔值代表多条的意思</p><p>db.col.update( { “count” : { $gt : 3 } } , { $set : { “test2” : “OK”} },false,true );</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>db.col.remove({‘title’:’MongoDB 教程’})<br>db.col.remove({‘title’:’MongoDB 教程’}， 1)  // 只想删除一个，just one 参数设置为1</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>db.col.find({likes : {$lt :200, $gt : 100}})</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>db.col.find({“title” : {$type : 2}})</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>db.COLLECTION_NAME.find().sort({KEY:1})</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>db.col.createIndex({“title”:1})<br>db.values.createIndex({open: 1, close: 1}, {background: true})，第二个是参数，前面的1是升序，-1是降序</p><p>未完待续····（坑爹的php 的 mongodb扩展，感觉不知道咋用呀）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LBS,刚听起来挺高大上的，其实简单理解就是附近的人。其实这个需求蛮常见的，比如大众点评中搜索摸某一个店铺按照离我当前位置距离进行排序，又或者某些社交软件中的附近的人，实现的方式有很多，php + mysql ， php + redis ， php+ mongodb， 其中mysql 的话，就是把所有的点的坐标保存下来，然后通过编写sql语句，直接通过sql去查询每个点离我们的距离，然后排序返回，但数据量大的时候，可能不太好，所以就有了后面的nosql ， redis 和 mongodb 的相关应用，其中 mongodb 在这方面应该是我听得最多的，当初想试这个功能也是因为想教一下前端朋友mongodb的相关功能，方便他面试，但后来发现其实还是redis 实现比较方便，因为php的mongodb扩展 mongo(php5） 和 mongodb(php7) 接口一点都不一样，而且中文文档比较少啦。其实通过es 也是可以实现的，方法很多.&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31380780&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详细见这篇文章&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>常用的接口(-)</title>
    <link href="http://yoursite.com/2018/12/07/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/07/常用的接口/</id>
    <published>2018-12-06T16:34:57.000Z</published>
    <updated>2018-12-07T16:32:34.037Z</updated>
    
    <content type="html"><![CDATA[<p>关于登陆，现在的网站有第三方登陆（qq,微信，微博）， 手机号登陆，用户名密码登陆，sso登陆，找回密码，注销 感觉其实都差不多<br><a id="more"></a></p><p><strong>第三方登陆</strong><br>其实国内的大多数第三方登陆都是基于oauth 2.0的变种，同理还有微信上消息more按钮点击能跳转到公司网站同样实现登陆都是基于这个，那什么是oauth2.0呢，阮老师这篇文章讲解的很清楚<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">oauth2.0</a>，而我们用的更多的又是其中的授权码模式，大致逻辑如下</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-517ca8a069faf690.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>其中比较重要的两点就是用户授权code和access_token, code作用代表用户同意登陆了，access_token 代表这个用户资源（有时候像之前的小程序，是拿着用户同意之后返回的code 去换回openid, 这个openid 类似这个access_token, 他在每个应用中是唯一的，代表了一个用户，如果我们想把不同app上同一个微信用户绑在一起，需要我们去微信联合平台绑定需要处理的app，然后下次请求的时候会返回一个unit id ，这个对于同一个微信用户在不同的app内部是唯一的）</p><p>for example 微信消息跳转itbasic网站<br>1.引导用户点击授权链接，微信给的授权链接上会有参数绑定回调地址和state参数，当用户点击的时候，微信会重定向（注意不是回调）填写的会掉地址，并携带参数state,还有code ,也就是用户授权码，下面是我们的重定向地址代码<br>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public function dologin($req)</span><br><span class="line">    &#123;</span><br><span class="line">        $code = $req-&gt;param(&apos;code&apos;);  # 用户授权码</span><br><span class="line">        $state = $req-&gt;param(&apos;state&apos;);  # 自己定义的参数，比如这次登陆来自微信，或者登陆之后需要跳转的地址</span><br><span class="line">        $accesstoken = $this-&gt;getAccessToken(); # 微信这块的access_token不需要用户的授权即可获取，但后面获取用户信息还是需要授权码，所以原理和上面是一样的</span><br><span class="line">         </span><br><span class="line">        $url = &apos;https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=&apos;.$accesstoken.&apos;&amp;code=&apos;.$code;  </span><br><span class="line"></span><br><span class="line">        $res =$this-&gt;http($url); #获取用户信息</span><br><span class="line"></span><br><span class="line">        if (!array_key_exists(&apos;UserId&apos;, $res[&apos;result&apos;])) &#123;</span><br><span class="line">             // 记录错误信息（微信）到日志,获取用户信息出错</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">           // 根据实际业务处理，我这块是登陆</span><br><span class="line">          // 你可以根据返回的用户名称，判断是新用户，还是老用户，新用户的话会往数据库插入数据</span><br><span class="line">            $user_model = Box::getObject(&apos;user&apos;, model);</span><br><span class="line">            $res = $user_model-&gt;search($res[&apos;name&apos;]);</span><br><span class="line"></span><br><span class="line">            if (!$res) &#123;</span><br><span class="line">                // 记录错误信息（itbaisc） 到日志，查找用户失败</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            $userinfo = $res;</span><br><span class="line">            $userinfo = [&apos;userid&apos; =&gt; $userinfo[&apos;id&apos;], &apos;username&apos; =&gt; $userinfo[&apos;username&apos;], &apos;status&apos; =&gt; $userinfo[&apos;status&apos;], &apos;deptsid&apos; =&gt; $userinfo[&apos;deptsid&apos;], &apos;postsid&apos; =&gt; $userinfo[&apos;postsid&apos;], &apos;role&apos; =&gt; $userinfo[&apos;role&apos;], &apos;long&apos; =&gt; true];</span><br><span class="line">            Session::set(&apos;userinfo&apos;, $userinfo);  //实现登陆</span><br><span class="line">        </span><br><span class="line">        $state = urldecode($state);  // 之前我们自己绑定的参数，因为url在http参数中需要加密，防止多余的http这些参数</span><br><span class="line">        header( &quot;Location: $state&quot; );exit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>手机号登陆</strong><br>首先生成验证码,存入缓存中，手机号=》验证码（过期时间，离开当前页面让其失效，只能使用一次），然后调用第三方接口发送给手机上这个验证码，用户收到验证码之后调用新的接口进行验证，我们在缓存中寻找手机号验证码是否匹配，如果匹配代表成功，后面是登陆啊，还是绑定啊看自己的业务需求</p><p><strong>sso登陆</strong><br>一处登陆处处登陆，一处注销，处处注销<br>(itbasic的原理类似oauth2。首先用户验证是否在的登陆中心登陆，如果没有，先登录，登陆中心成功后返回一个access_token,重定向到你来时候那个地址，相当于帮你发出请求，你拿着这个access_token获取用户信息，干啥都是你自己的事情。下次用户再来的时候，验证中心已经登陆上了，直接返回access_token然后重定向)<br>（注销，我们在每次去验证中心验证的时候，都记住有哪些来的网站，注销的时候都请求他们注销的地址就好了，这个时候可以直接请求，不用重定向，因为不用种cookie,直接销毁服务端数据就好了）</p><p><strong>找回密码</strong><br>通过邮箱。首先填写用户名和邮箱（为了防止别人恶意找回用户），确保用户名和邮箱和登陆的时候绑定一致，才发送修改密码的邮件，邮件内容是</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-804e1f534d3a4917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这样其实就足够了，这个token 是我们之前发送邮件时候生成的，我们只需要保证 用户名 =&gt;token,当用户请求这个接口的时候（注意一定是get请求，因为是点击），我们通过这个token,知道是哪个用户就好了，然后返回一个界面让用户修改密码就可以了.</p><p>熟悉了几个函数的使用</p><p>http_query_build ,拼接http请求参数（这个对url 好像还会进行urlencode加密）</p><p>parse_str, 把上面的拼接内容分开</p><p>当然上面各个案例的解决方案很多，比如找回密码用手机而不是用邮箱，只是简单记录下常用的方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于登陆，现在的网站有第三方登陆（qq,微信，微博）， 手机号登陆，用户名密码登陆，sso登陆，找回密码，注销 感觉其实都差不多&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>日志 awk sed</title>
    <link href="http://yoursite.com/2018/11/28/%E6%97%A5%E5%BF%97-awd-sed/"/>
    <id>http://yoursite.com/2018/11/28/日志-awd-sed/</id>
    <published>2018-11-28T10:32:20.000Z</published>
    <updated>2019-02-26T10:30:20.312Z</updated>
    
    <content type="html"><![CDATA[<p>日志很重要</p><blockquote><p>日志可以进行数据挖掘，分析用户的喜好，比如什么资源被用户频繁访问（对应面试题：取出访问量前20的网址）  –来自百度某朋友</p><p>你线上要是有错误怎么办，你们平时是不是都不看日志，只有错误了才解决，··balabal （一顿嘲讽）  –来自平安好房某专家表哥</p><p>为啥本地开发的时候，错误信息能输出在页面，线上环境直接就是个500页面，好奇怪，好奇怪     –来自17年的me</p></blockquote><a id="more"></a><p>###了解日志<br>我们itbasic用的其实是lamp, 通过apache的模块处理php, php的错误日志可以在虚拟域名里面进行配置<br>lnmp,nginx 起到静态文件处理的作用，php 转给php-fpm 进行处理，虽然网上说nginx 记录不了错误日志，但其实当我在虚拟站点里面配置error-log的时候，也是有记录的，和php-fpm中是一样的。<br>php-fpm 中开启日志需要修改php.fpm 的配置文件（还可以添加慢查询日志，<a href="https://juejin.im/post/5b9394a0e51d450e686747e3" target="_blank" rel="noopener">据说很重要</a>，有空的话可以把itbasic改成lnmp,有空的话看看php-fpm 中各个参数的作用，）</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-689499213d1911e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>特别是这块，php_flag和php_value 的作用是一致的，不知道为什么要搞两个一样的，还有就是他们的使用是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_flag[error_reporting] = 0</span><br></pre></td></tr></table></figure></p><p>来覆盖代码中的error_reporting ,····原先以为还有什么作用呢</p><p>###分析日志</p><p>我不会告诉你最开始接触sed和awk 是因为面试题，很多时候，当我们分析一个大日志文件的时候，我们甚至都打不开这个文件，因为太大了， 但是我们可以通过这些文本处理工具对数据加以筛选。</p><p>awk（参照<a href="http://www.ruanyifeng.com/blog/2018/11/awk.html" target="_blank" rel="noopener">阮一峰</a>老师，很可惜，没有出sed 入门）</p><p><strong>基本用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">$ awk 动作 文件名</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">$ awk &apos;&#123;print $0&#125;&apos; demo.txt</span><br><span class="line"></span><br><span class="line">$ echo &apos;this is a test&apos; | awk &apos;&#123;print $0&#125;&apos;</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure></p><p>print 和 echo 都是标准输出，stdin ,这个东西最近经常看到，感觉就是输出在控制台上，比如php cli 模式下，普通php 脚本中 echo,  print,  var_dump都可以打印在控制台上（但好像记得之前子进程中输出好像只有父进程中才能看到，不记得是return 还是 输出了），这种标准输出好像都可以通过管道进行连接然后进行处理<br>上面的分割， \$1 代表第一个元素，$0 代表整体元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 练习（test.log）：</span><br><span class="line">root:x:0:0:root:/root:/usr/bin/zsh</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line"></span><br><span class="line"># 想输出第一个字符的话</span><br><span class="line">cat test.log|awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos;</span><br></pre></td></tr></table></figure></p><p> 想一下，我们通过cat ,是不是能把文件默认输出在页面上，然后我们通过awk去处理，设置分隔符号 ‘:’,默认的分隔符符号是 ‘ ‘.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 练习：提取nginx 500 日志，并统计总数</span><br><span class="line"># 78.181.37.209 - - [28/Nov/2018:15:01:56 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&quot;</span><br><span class="line">cat access.log|awk -F &apos; &apos; &apos;if ($9 == 500) print $0&apos; | wc -l</span><br></pre></td></tr></table></figure><p>注意这个分隔符号是空格，即使双引号里面有空格，也会把切割开， wc -l 可以统计行数</p><p><strong>变量</strong><br>内置一些变量，比如行数NR，这一行有多少个字段NF(这两个应该是最常用)，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILENAME：当前文件名</span><br><span class="line">FS：字段分隔符，默认是空格和制表符。</span><br><span class="line">RS：行分隔符，用于分割每一行，默认是换行符。</span><br><span class="line">OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。</span><br><span class="line">ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</span><br><span class="line">OFMT：数字输出的格式，默认为％.6g。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">练习：</span><br><span class="line">      2 345</span><br><span class="line">      2 123</span><br><span class="line">      1 789</span><br><span class="line">      1 1234</span><br><span class="line"></span><br><span class="line">awk &apos;&#123;print NR&quot; &quot; $2&#125;&apos; log  # 行数  第二个字段中间用空格连接</span><br><span class="line">awk &apos;&#123;print NR&quot; &quot; $(NF)&#125;&apos; # 行数 最后一个字段中间用空格连接，运行的时候中间的值会被替换</span><br></pre></td></tr></table></figure><p><strong>函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tolower()：字符转为小写。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">substr()：返回子字符串。</span><br><span class="line">sin()：正弦。</span><br><span class="line">cos()：余弦。</span><br><span class="line">sqrt()：平方根。</span><br><span class="line">rand()：随机数。</span><br></pre></td></tr></table></figure></p><p><strong>条件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;条件 动作&apos; 文件名</span><br><span class="line">awk &apos;条件 动作&apos; 文件名awk -F &apos;:&apos; &apos;/usr/ &#123;print $1&#125;&apos; demo.txt</span><br><span class="line">awk -F &apos;:&apos; &apos;NR % 2 == 0 &#123;print $0&#125;&apos; demo.text #输出偶数行</span><br><span class="line">awk -F &apos;:&apos; &apos;&#123;if (NR % 2 == 0) print $0; else print &quot;error&quot; &apos;&#125;&apos; demo.text</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">练习</span><br><span class="line">[例]：有如下文件test,请统计每个网址出现次数，用一句shell实现。</span><br><span class="line">a [www.baidu.com]  20:00</span><br><span class="line">b [www.qq.com]  14:00</span><br><span class="line">d [www.baidu.com] 23:00</span><br><span class="line">e [www.qq.com]  20:30</span><br><span class="line">f [www.360.com] 20:30</span><br><span class="line"></span><br><span class="line"> cat url.txt|awk &apos;&#123;print $2&#125;&apos;|sort|uniq -c|sort -rn</span><br><span class="line"># cat 查看文件内容， 输出第二行的内容，排序，因为 uniq 只能把连接在一起的文件重复文件合并，然后再倒序</span><br></pre></td></tr></table></figure><p>uniq -c  把重复的行数显示在前，但是只能合并连续的<br>sort 排序， -rn   r是倒序，n是按照数字处理<br>head -n 5  取出前五行，这也是查询的时候经常要用到的</p><p>补充一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 取出cpu 或者内存占用前五，top 查看占用</span><br><span class="line">ps -aux|sort -k3rn|head -n 5</span><br><span class="line"># sort 自带切割，</span><br><span class="line"># ps -aux 可以查看所有进程， 比如之前我想查看我的一个脚本 server.php,可以通过 ps -aux|grep server.php, 相比较netstat -antp|grep 9000,查看端口占用情况， ps -aux 查看更加清楚，比如swoole 的进程，1个 master ,1个manage,剩下的work ，所有的进程都能查看到，但是netstat 只能查看到一个</span><br></pre></td></tr></table></figure></p><p>统计某接口的调用次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log| grep &apos;GET /app/kevinContent&apos; | wc -l</span><br></pre></td></tr></table></figure><p>统计报错接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log| awk &apos;&#123;if ($9 == 500) print $0&#125;&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志很重要&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日志可以进行数据挖掘，分析用户的喜好，比如什么资源被用户频繁访问（对应面试题：取出访问量前20的网址）  –来自百度某朋友&lt;/p&gt;
&lt;p&gt;你线上要是有错误怎么办，你们平时是不是都不看日志，只有错误了才解决，··balabal （一顿嘲讽）  –来自平安好房某专家表哥&lt;/p&gt;
&lt;p&gt;为啥本地开发的时候，错误信息能输出在页面，线上环境直接就是个500页面，好奇怪，好奇怪     –来自17年的me&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP常用工具</title>
    <link href="http://yoursite.com/2018/11/23/PHP%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/23/PHP常用工具/</id>
    <published>2018-11-23T15:26:05.000Z</published>
    <updated>2018-11-23T15:26:05.422Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThinkPHP的感觉</title>
    <link href="http://yoursite.com/2018/11/12/ThinkPHP%E7%9A%84%E6%84%9F%E8%A7%89/"/>
    <id>http://yoursite.com/2018/11/12/ThinkPHP的感觉/</id>
    <published>2018-11-12T10:12:27.000Z</published>
    <updated>2018-11-23T14:49:20.988Z</updated>
    
    <content type="html"><![CDATA[<p>学习，为了更好地适应未来的工作。简单的解除了下tp和laravel，总体来说tp比laravel简单多了，封装的也没有那么深，所以用起来还是很方便的，用的是5.0，5.1和5.0区别就挺大了，不如有了门脸，又是一个使用类不知道到底用哪个命名空间下类比较好的时候了，还有获取参数的方式，5.1已经没有getInstance()这种东西了，记录一下这几天的感觉,方便交流</p><a id="more"></a><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/5525740-1711c1f695c442d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>首先是模块的创建，主要是为了方便后台模块和 api 模块的分开</p><p>后台模块， 这个项目中主要是通过接口能返回html 模板</p><p>但是 api 模块，单单只用返回json 数据</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>关于api 模块的json 返回，我们只要调用json() 方法就可以了，不需要做进一步的配置，  我们还可以通过json 方法的进一步封装，让调用起来更加方便</p><p>[图片上传失败…(image-14c2c0-1542018168779)]</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-3f4891bc6eed7db0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这种方法其实就是在返回头上加上个别的信息</p><p>这种公共的方法我们可以写在 common.php 文件中</p><p>控制器中获取传过来的参数</p><p>有个坑就是5.0 和 5.1 通过request 获取参数的方式竟然就不一样了，</p><p>5.0 中 其中一种 Request::instance()-&gt;get()</p><p>5.1 Request::get() (5.1中已经开始出现faceade这种看不懂的东西了)</p><p>其实用助手函数就没有上述问题了，···但无奈我不喜欢用，但感觉助手函数的话对不同版本的tp代码都是通用的</p><p>对于put 参数，我们在用postman 提交代码的时候需要通过第二种方式提交，第一种方式是获取不到的，可能是因为表单默认屏蔽了put delete 提交方式</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-2a8c7fec8f0290ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-ae6d9385c9e24a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这个header 头信息是真的坑，解决这个办法就是先把$header 信息保留成数组，然后再通过数组去寻找这个变量</p><p>讲道理，还是有点不明白_initialize 和 __construct(） 的区别</p><p>关于文件的定义，基本上除了配置文件，剩下的都是class 文件，按照psr4 ,类名要和文件名一样，我之前有过类名和文件名不一样，导致文件加载失败</p><p>异常处理那块，当调用父的 异常处理函数，需要return ,否则会报错，感觉和调用模板也需要return 是一个道理</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>关于 tp 的路由，好久之前就知道被吐槽pathinfo 模式，虽然我不知道是因为什么被吐槽，除了pathinfo 还有别的模式吗？</p><p>除了默认的pathinfo, 我们对于api 接口（admin 那种返回html 的可以不用管），可以使用路由注册的形式，就是在route.php 中进行路由注册，他会首先匹配,没找到的会使用pathinfo 模式，这块需要我们在配置文件中进行配置</p><p>（可以完全关闭pathinfo 或者 路由注册的形式）</p><p>（关于路由注册这块，tp 的路由注册和laravel 的还不一样，他不是使用命名空间的形式，用的是感觉自己定义的形式， 但感觉因为这个方面，路tp的路由方面应该不能单独拆出来给别的项目使用），但其实也挺好理解， 注意</p><p>完全路由匹配，还有路由参数的限制</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-916eb13b10cccba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>参照： <a href="https://www.jianshu.com/p/73ed6e42d389" target="_blank" rel="noopener">https://www.jianshu.com/p/73ed6e42d389</a></p><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>今天因为不太知道config() 助手函数都是从哪里获取的数据，查了一下，这篇文章写得还是蛮好的</p><p><a href="https://www.jianshu.com/p/cd8b68143fde" target="_blank" rel="noopener">https://www.jianshu.com/p/cd8b68143fde</a></p><p>比如我们那个api模块的接口需要很多额外的参数，我们只需要在application 最外层定义一个extra 的目录，然后会自动引入里面的文件</p><p>我们配置文件的数据返回大致如下</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-e2abedcb35db3400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过 config() 可以看到全局的配置参数</p><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p>model 最近用的都是orm,不管是后台admin 还是api接口，都可以公用，所以新建了一个common模块，在里面写入了model,通过model() 或者命名空间的方式都能使用（我比较喜欢用命名空间的方式去使用，tp的orm可以分离出来去别的项目中使用，当然model()方法引入model类就不可以了，只能通过命名空间的方式）</p><p>题外话 ：关于为什么用model() 就能引入common 模块下的model，我们可以理解成约定俗成，甚至可以理解成1 + 1  = 2， 之前我纠结这些问题很久，但其实他就像我们使用别的约定俗成的概念是一样的，只是这个可能是由于框架的封装，在我们的印象中很难站住脚 ，或者没有看到官方给的白纸黑字的文档，能做的就是看源码，model 是怎么执行加载的，表哥说过，你可以画上 1年半载去弄懂框架的源码，但如果你弄不懂的话，你也可以通过专注业务区提升自己的能力，有些东西能用就好了。</p><p>基本的方法:</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-7f4cbfcd522b2d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过在数据库配置文件中设置表前缀，默认类名称是  ‘表前缀_类名’ ， laravel 是表名单数</p><p><strong>查询</strong></p><p>select   获取集合  ，这个直接json 返回外面就是array ,在项目里面打印是 是object ,这个项目里面转换成 array 需要 collection($arr)-&gt;toArray()， 这个Db::  用select , 查出来竟让也是 object ,想变成 array,可以通过toArray()</p><p>find   只能获取一条 ,这个直接 就是数组</p><p>column, 查询单列</p><p>value  查询单个值（那种集合的查询调用 value 也是只返回一个值）</p><p>field  获取哪些对应字段,还可以给字段取别名（感觉很强大，还能用函数 sum(score)）</p><p>order   同上</p><p>limit  5 size</p><p>page  1  页码  (感觉这个page 还是和limit 分开来使用比较方便)</p><p><strong>查询方法</strong></p><p>where  =&gt;   [‘id’=&gt; 1, ‘status’=&gt; 1],  多条件等于情况， [‘id’, ‘status’]  代表两个column</p><p>where =&gt; [‘id’ =&gt; [‘&gt;’, 3]]   id 大于3的情况</p><p>whereOr</p><p><strong>插入</strong></p><p>insert</p><p>insertAll  批量插入</p><p>insertGetId  插入成功之后返回id</p><p>getLastInsID  返回最新插入的id</p><p><strong>更新</strong></p><p>update</p><p>setField 更新某个字段</p><p>setInc   自增</p><p>setDec 自减</p><p><strong>删除</strong></p><p>delete </p><p>关于链式操作，注意select() ，table 这些不属于链式操作，所以需要放在最后面，剩下的那些链式操作没有顺序要求</p><p>alias  给表取别名</p><p>groupby  分组</p><p>having  （最好在group by 中使用count这种的聚合函数）</p><p>子查询和 union 基本不用</p><p>distinct 唯一不同的值，不同的值，比如这个返回admin和chunice</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-e8cdd9dd8a20254d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>count  这个好像需要放在 where 条件后面，要不然也会报错</p><p>orm 之所以能调用这些db的方法是因为orm 的基础是db</p><p>自动写入时间戳都是针对orm 这种操作可以的，db 操作是不可以的， 上面的操作都是db 的操作</p><p>注意用Db 进行操作的时候，命名前缀已经失效了，记住要用表的全名</p><p>关于join 表，老师和表哥说都不要join ,因为数据多的时候join会出问题，对于用户和用户名的对应的时候，利用先找出所有数据，再把userid 取出来进行in 的查询，再通过遍历之前需要处理的数据，把username 链接进去，这样是可以的，但是对于zan这种，可能不存在这条数据</p><p>这几种join是当初面试的时候经常问的</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-70d997091c479147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>comment  给sql语句增加注释（··感觉好没用啊）</p><p>fetchSql 返回sql 语句 （ 感觉挺好，可以知道执行了什么，但用with 那种关联关系，只能返回第一条语句···，太废物了）</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>其实，感觉：查询出来的是object 对象，还是纯种的array ,就是看调用者，如果是 Db::table 调用，就是 数组</p><p>如果是 User::  这种方式调用，就是 object， object 又有 user  和 collection 之分</p><p><strong>新增</strong></p><p>save   插入 这个不能用静态方法，只能实例化调用</p><p>saveAll 批量</p><p>返回值是受影响的行数，我们想获取到自增id ,可以通过 </p><p>$user = new User()</p><p>$user-&gt;save([])</p><p>echo $user-&gt;id ,这种方式获取到，因为save 不能非静态化的调用， save() 返回值是受影响的行数</p><p>批量新增 saveAll()</p><p>create  静态调用</p><p>User::create() , 返回值是自增id</p><p><strong>修改</strong></p><p>save ,需要传入主键</p><p>saveAll  批量</p><p>update 静态调用 ,这个方法也可以直接调用，Db和模型都有这个方法</p><p>据说通过 -&gt;where-&gt;update() 这种就不能使用tp模型的事件功能（什么是事件功能？就是那种更新表前会有什么操作，类似钩子）</p><p>感觉这个方法除了静态调用，就不知道有什么比较方便的地方了，感觉那种直接通过模型只使用update() 方法不太好，不太直观，感觉很多时候应该是不止是就是用一个update 方法这么简单</p><p><strong>删除</strong></p><p>delete 删除，也是模型和Db 都能使用的</p><p>destroy 删除</p><p><strong>查询</strong></p><p>get （条件） </p><p>，find</p><p>感觉查询的功能真的是各种强大，慢慢学习吧</p><p>获取器的重要作用：</p><p>其实我们在平时的开发中总会遇到类似的问题，就是数据库中对于status 存储着各种数字，然后给前端展示的时候，循环结果，把结果中的每条数据的status 对应的中文取出来，然后再加上，读取器就是为了这个产生的，我们在读取一个</p><p>attr 的时候，类似定义一个钩子，他会自动帮我们把取到的数据进行修改（其实有两个参数的，第一个是这个值，第二个是整条数据的值）</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-2ea087a1d37bc10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>all (条件) select ()</p><p><strong>软删除</strong></p><p>这种事很常用的，我们平时使用的时候通过加入一个标志位，然后tp中也是使用标志位，delete_time ,但筛选数据的时候不用我们处理，仿佛真的就删除一样，可是在管理工具中还是能看见</p><p>关于orm 的执行日志，或者是说sql日志，统一的开启数据库调试模式，然后直接在log中查看就好了</p><p>notice : 就是很灵活，因为orm 也是基于数据库的，所以数据库中的很多方法在orm 中也可以用，甚至同名，比如update,但返回的内容不一样，orm 的update 返回的是更新的实例，数据库的update 返回的是兽影响的行数</p><p>感觉就是模型的话要是不用with 这些关联属性，意义会小很多，可是后来发现，那些处理orm 查出来的的数据，确实会方便很多</p><p>关联：</p><p>1对 1 ： </p><p>虽然感觉有时候反着写也是对的，但最好还是遵从 （虽然七月老师说是二者是不对等的，比如 user 和 userinfo  ,userinfo 有 userid ,但user 找不到 userinfo ,但如果是 1对 1 ，是真的都能通过定义 hasOne 和 belongsTo 去获取对方）</p><p>（按照编辑器的推荐，确实 hasOne 更准确点）</p><p>（user  hasOne  userinfo   这个也更符合我们的习惯）</p><p>感觉上反正很怪，如果编辑器能提醒就好了，但只能提醒是主键还是外键，并不是提醒是哪种表的主键，那张表的外键</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-bd87f301d2501d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>user  -&gt; info</p><p>user 中定义 hasOne</p><p>$this-&gt;hasOne(‘info’, ‘user_id’,’id’），这个提示比较符合大众的想法</p><p>info 中定义 belongsTo</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-da97683778092efd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>$this-&gt;belongsTo(‘user’, ‘user_id,’id’)</p><p>单个模型还能通过</p><p>$banner-&gt;hidden([‘update_time’, ‘delete_time’]); 来隐藏对应的字段</p><p><em>感觉最好还是在model 的定义的时候隐藏</em></p><p><em>注意select () 这种查找出来的都是数据集合 collection</em></p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-3b17ab3543bd69a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>看一下这个例子，通过嵌套关系，可以实现images 内部数据的排序，所以关联关系也是可以嵌套的</p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>自己新建的缓存文件不要和 thinkphp里面的字段名称一样，否则回报错误</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a><strong>Exception</strong></h3><p>配置文件中开启debug 模式，要不然总是 ‘tp 专为api而生，十年磨一剑’的错误信息</p><p>开启之后还需要处理，因为我们前台只需要json数据，我们需要考虑程序上线之后如果发生错误了我们该怎么处理，其实没法处理，因为我们不知道什么时候会发生，想象一下如果我们知道他会发生，那我们为什么不去阻止而让他发生呢，此时我们需要一个监听全局异常事件的东西，当php抛出异常的时候我们只要去捕获他，然后处理就好了，类似前端的钩子 。 </p><p>知道吗 ？在我们原生的php当中，其实有个专门对全局异常进行处理的函数，可以自己定义，可是呢··我没有自己去试过，首先是异常自己理解的比较浅，再者对于框架的使用比较少，</p><p>tp的全局异常处理应该也是这个原理，本质上应该还是修改这个函数，当我们在tp中想改变全局异常处理函数只需要修改配置文件中的异常处理函数名称，改成自己需要配置的就好了</p><p>接下来我们重写下全局异常处理函数，让他更符合我们的要求</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-747c9b0c36acb611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>首先需要继承tp自带的异常处理，然后重写他的render 方法，，为什么？因为我们在bug模式的时候需要tp给我们提示错误信息，总比我们自己看 $e-&gt;getMessage() 方便详细的多</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-5fc354627abfef17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>接下来， Basci Exception 是自己默认定义的exception， 既然是自己定义的错误，自然不用tp的异常处理，直接返回前台json 数据就好了，因为自己定义的错误，一般是手动抛出，自己了解错误的原因</p><p>然后是非自己定义，首先要是判断是否开启了debug 模式，如果开启了，说明在调试，直接使用tp自带的就好了，千万注意要加上return ,要不然会报错，毕竟是html 页面的返回（类似可以想象一下tp中模板的返回）</p><p>再者是如果是上线环境，只需要告知前台服务器错误就好了，定义个固定的数组，返回给前端，然后记日志</p><p>（记录日志也是很简单的，log::error(), 写在runtime的log下面）</p><p>异常处理定义完毕，就要开始定义异常类了。使用异常类的原因就是告别传统的遇到错误的返回方式，还记得之前我们在嵌套函数中执行错误后怎么返回的吗，只能层层往上抛出，到了最外层的controller 返回，可是异常就不一样了，当异常处理检测到这个地方抛出的异常，就能直接进入异常处理函数中，多方便。</p><p>（还有一点我觉得定义异常的好处，就是之前我们对错误信息的输出总是 code =&gt; message =&gt; ,有时候为了规范我们通过写一个方法，通过code 去获取message ，但你想象一下，当你写完接口之后，满屏的 code ，你也不知道这个code 代表的啥意思，当然我们可以约定code的规范，如果我们通过throw new ParamErrorException([code=&gt; , message=&gt;]), 我们就会知道这个错误大致属于前端参数的错误）</p><p>notice :<br>1.不管是什么框架，我们定义的异常都一定继承于最原始的php \Exception</p><p>2.常用的方法 $e-&gt;getMessage(),获取错误信息</p><p>3.注意异常类因为继承自exception，我们一定不能定义exception中有的属性，比如我之前在异常类中定义过一个message属性，这个属性是exception 中的protected，然后在参数验证那块会出现莫名其妙的异常错误</p><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>说实话，我到现在还没有明白验证器的具体作用，平时那种</p><p>new Vdalidate()</p><p>-&gt;bitch()-&gt;check()</p><p>感觉就能符合需要，可是要是真的每次在valiate里面写上同样的验证规则， 确实可能会有重复定义的嫌疑</p><p>但我感觉要真的发挥验证器的作用，必须介乎scene() 场景来使用，一个validate 对应一个类，或者model，这个validate有各个属性的校验，通过定义scene ，让我们不会定义过多的validate 类</p><p>在 $rule 里面</p><p>有各个报错信息 $message =  [‘id.require’ =&gt;] 这种细致的分层，让错误信息准确的定位，或者直接 id =&gt; ,这样可能id对应多个验证规则的时候，需要把错误信息都加上，如果出错了，不知道具体是哪条规则出错了</p><p>scene ,对应场景，可能某个实体过来了，我需要验证其中valdiate 类中的某几个属性，我就用scene 去细分，如果不用scene 的话，想象一下，这个地方比如user 模型需要name 和 sex ，另一个地方需要 name 和 img ，难道我们需要为此定义两个validate ，感觉一点都不灵活（exception如果遇到这种通过向里面传入不同的参数来解决）</p><p>重写validate 和 重写 exception 不一样，重写valdiate ，其实是对传统 validate check 方法的封装，和 定义方法的更多加入，因为check 之后，所有的错误信息都会储存在 error  这个属性中（或者 $this-&gt;geterror()来获取），然后通过异常把这个错误信息抛出去给前台页面</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-993df227105522ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="https://upload-images.jianshu.io/upload_images/5525740-e8860b37d1293f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>laravel 中也有相似功能，感觉就和路由中间件一样，在执行到这一步之前都会先执行这个验证操作</p><p>感觉这个比那个__initze() 什么方法方便多了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>还有太多太多我不会用的，所以后面的路还很长啊，只是 为了更好的入门</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习，为了更好地适应未来的工作。简单的解除了下tp和laravel，总体来说tp比laravel简单多了，封装的也没有那么深，所以用起来还是很方便的，用的是5.0，5.1和5.0区别就挺大了，不如有了门脸，又是一个使用类不知道到底用哪个命名空间下类比较好的时候了，还有获取参数的方式，5.1已经没有getInstance()这种东西了，记录一下这几天的感觉,方便交流&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 关于blade</title>
    <link href="http://yoursite.com/2018/10/10/Laravel-%E5%85%B3%E4%BA%8Eblade(%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E)/"/>
    <id>http://yoursite.com/2018/10/10/Laravel-关于blade(模板引擎)/</id>
    <published>2018-10-10T08:45:23.000Z</published>
    <updated>2019-01-03T16:03:57.512Z</updated>
    
    <content type="html"><![CDATA[<p>其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。</p><a id="more"></a><p>itbasic 用的也是模板引擎，名twig，其实和blade没有多少不同的地方，只是自己发现的twig新功能还比较少，只是一直在原先的基础上堆代码，感觉上在模板引擎里面还是不要做过多的逻辑判断，否则后面会越写越复杂，而且难于维护。</p><p>对于web网站，我们有很多页面，但这些页面大部分都是相同的？因为我们的布局需要相同，这个其实在写itbasic的时候应该能感觉到，我们似乎只需要填充中间的content部分就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;@yield(&apos;title&apos;,&apos;测试&apos;)&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        @yield(&apos;content&apos;)</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>什么是yield ,就是让继承者可以填充的东西，继承者通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@extends(&apos;layout.blade&apos;) //继承上一个模板</span><br><span class="line">@section(&apos;title&apos;, &apos;cy&apos;)  //填充数据</span><br><span class="line"></span><br><span class="line">@section(&apos;content&apos;)   //这种方式填充数据要有结束符号</span><br><span class="line">&lt;h1&gt;222&lt;/h1&gt;</span><br><span class="line">@stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@include(&apos;default.ce&apos;)  // 包含额外的页面</span><br><span class="line">//传递变量，include(&apos;default.ce&apos;, [&apos;user&apos;=&gt;$user])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//判断</span><br><span class="line">@if ($a &gt; 0)</span><br><span class="line">&lt;h1&gt;cc&lt;/h1&gt;</span><br><span class="line">@endif</span><br><span class="line"></span><br><span class="line">//循环</span><br><span class="line">@foreach($counts as $count)</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">@endforeach</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>网站升级https</title>
    <link href="http://yoursite.com/2018/09/11/%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7https/"/>
    <id>http://yoursite.com/2018/09/11/网站升级https/</id>
    <published>2018-09-11T06:23:14.000Z</published>
    <updated>2018-09-11T06:57:58.961Z</updated>
    
    <content type="html"><![CDATA[<p>升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。</p><a id="more"></a><p>https原理<br>HTTPS采用共享密钥加密(对称加密)和公开密钥加密(非对称加密，比较出名的有RSA)两者并用的混合加密机制。在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式<br>之所以传输过程中用对称加密，是因为非对称很浪费资源</p><p>(hash加密是单向的，例如md5,不能解密)<br>和对称加密还有非对称加密都是不一样的，不管是对称加密还是非对称加密，通过秘钥都是能解密的，但是hash，只能维持 hash(内容)之后的值保持一致，这也是我们数据库中只保存用户密码加密后的值就可以验证用户的密码是否正确了，因为我们可以每次获取到用户信息之后只要hash一下，然后和数据库中做下对比就可以了。</p><p>https ,首先让服务器和ca交互，获取服务器的公钥，这个过程是非对称加密，获取到公钥</p><p>https升级过程中遇到的问题:</p><ul><li>不允许脚本调用http，可以先把接口转发到我们本地的服务起的https上，然后通过nginx转发到别人网站上的接口，因为本身调用外来接口接口比较少，这样能符合我们的需求</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5525740-442e10f7747a4d2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>https证书申请无效（每个域名都需要申请单独的证书，之前以为只要申请一个www.chenye2017.cn证书就可以了，chrome直接显示https不安全，其实通过微软的edage浏览器访问，能清楚的看到证书不匹配的原因）</li></ul><p>（证书申请是通过腾讯云，腾讯云上有详细的教程，唯一不足的是没有给文件夹权限，导致第一次访问403）</p><p>（https配置虚拟主机应该就和我们在vhost文件里面配置虚拟主机一样，现在是在ssl配置文件里面写）<br>（话说我现在的服务器，域名用的是阿里的，服务器用的是京东的，https证书用的是腾讯的，zz）<br>（还有不知道是hexo的原因还是github page 的原因，我的网站上有http的资源竟然不会显示https错误，不知道他是怎么解决这种http资源不出错的，有空可以了解下）</p><p>https和http的区别</p><p>简单看就是 https = http + SSL</p><p>SSL的运行机制，可以参考<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">阮一峰老师的文章</a>，我对上面的一些内容做了些自己理解的笔记</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-260206ef40194be3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>其中加密传播是因为我们的传播内容都是通过生成一个第三方不知道的公钥，这个公钥是怎么来的呢，首先通过ca证书，因为系统内容ca的公钥，ca用私钥加密文件内容（私钥加密，公钥解密，不被篡改），我们获取服务器的公钥，这个公钥是干什么的呢，并不是用来进行数据的加密的，而是用来加密传递的数据给服务器（公钥加密，私钥解密，不被获取），服务器接收到客户端的数据进行生成公共密钥，这个密钥是我们以后加密数据用来传递的<br>(感觉只要记住证书里面的内容都是能保证绝对正确就好了)</li><li>具有校验机制，是因为我们的证书具有这个作用，比如我上次把我从www.chenye2017.cn 上获取的证书放到虚拟站点blog.chenye2017.cn就直接报错</li><li>配备身份证书，估计也是这个意思</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5525740-62f2352ceaf4787a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>所以ssl 和 tsl 是一样的意思嘛</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-95302aaf96bdae3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>感觉这个握手不是tcp的那个三次握手，这个开始的时候tcp那个三次握手应该都搭建好了，而且这个也是4次握手</p><p>剩下的内容就是4次握手的详细内容了，为什么要4次握手，写的都很详细，就不再补充了，总之这个生成传输加密内容的秘钥也是通过非对称加密，再后面就是http了。</p><p>总结一下：</p><ol><li>通过CA 证书，发送服务器公钥，利用的是非对称加密算法，用的公钥和私钥来自CA（证书的作用是为了保证服务器公钥的正确性，不被篡改）</li><li>通过CA得到的服务器公钥，大家都可能有，但是我们通过公钥加密，私钥才能解密，和服务器交互，让两端都能生成一致的对称加密算法钥匙（随机因素可以通过客户端利用服务器公钥加密传给服务器）</li><li>利用生成的公共密钥进行对称加密，传输数据（这个公共密钥在每次连接的时候生成，别人不知道）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于git</title>
    <link href="http://yoursite.com/2018/09/07/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%9C%E5%8D%8A%E7%90%83%E6%9C%80%E5%A5%BD%E7%9A%84git%E5%85%A5%E9%97%A8%E4%BA%86/"/>
    <id>http://yoursite.com/2018/09/07/这可能是东半球最好的git入门了/</id>
    <published>2018-09-07T07:51:06.000Z</published>
    <updated>2019-05-08T06:57:53.031Z</updated>
    
    <content type="html"><![CDATA[<p>公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨</p><a id="more"></a><ul><li><p>首先是分布式和集中式的区别</p><p>分布式就是在每个人的个人电脑上都有仓库，称作本地仓库，本地仓库也会保存整个项目的提交记录，让我们在不连网的情况下也能进行代码的提交，当我们可以连网的时候，再把代码推送到远程仓库，远程仓库只是一个让我们各个工作者可以相互交换提交记录的中转站，我们的提交在git commit 的时候已经完成(我们唯一的提交信息就是在commit 时候写的)，也就是在git log 历史里面已经占据了位置，我们在push 的时候只是用本地的提交记录去覆盖远端的提交记录。而集中式代表着我们在不联网的情况下完全工作提交不了代码，那个中央仓库才是我们的唯一仓库，往里面提交代码才会产生log。所以我们在用集中式的时候，查看log都是通过查看远端log，对比diff也是，所以断网的情况下完全用不了,而分布式完全没有这个问题。</p></li><li><p>git add .</p><p>我们每次修改代码之后都需要git add 文件名(. 代表所有文件)添加到暂存区，当我们添加一次之后，又修改了文件，还得git add 一次，因为git add 只是把当前文件现在的修改添加到了暂存区，如果后面修改了，还得重新添加一次，这个可能和svn 的只需要add 这个文件到管理文件夹内，后面修改直接commit 有点不同</p></li><li><p>up-to-date</p><p>最新的，有的时候可能显示before one  commit 这种，代表你要给远程分支push啦</p></li><li><p>git clone</p><p>做了两件事情 下载了.git 本地仓库，然后把当前目录当做工作目录，把master 最新的提交内容填充当前目录</p></li><li><p>.git </p><p>.git 就是本地仓库，下面的index 代表了暂存区</p></li><li><p>git 提交流程</p><p>git add .</p><p>git commit -m</p><p>git pull 冲突发生的地方，pull 只会把需要的内容拉下来，并不能把你之前提交到本地仓库的内容push, 所以pull 之后还是需要push的（感觉这个pull还是挺智能的，在pull的时候如果有冲突，比如修改了同一个文件，还是没有提交到暂存区的那种，需要你先commit 或者废弃，想象一下pull 中包含merge 操作，merge 操作的对象是线上的commit 和 你最新的commit，所以如果有未提交的内容，一定要注意啦，别被覆盖了，但是如果没有关联的文件修改，pull的时候有没有commit 没关系）</p><p>git push</p></li><li><p>git comment</p><p>git comment 是实际的提交，会产生log 日志，像我在做itbasic 的时候经常一个功能提交多次，因为有的代码忘记提交了，可以把comment 合并，产生一个log</p><p>git comment –amend ,修正上次的提交，很方便</p></li><li><p>git push</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-01fba848b36b83eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>git branch</p><p>branch 字面上是分支的意思，其实就是一次提交的引用，类似head, master （远端分支head 一定指向master， 可是我们本地head 可以切换到别的分支上呀，而且对应的好像是这个分支的最新提交）</p><p>因为branch 是一个引用，所以我们删掉任何的branch ，都不会删除commit</p><p>自己的分支，因为回退之类的不能修改，那就强行 ， git push origin branch1 -f ，但这种只针对自己吧 （千万别在master 上强行push）</p></li><li><p>git checkout</p><p>git checkout -b  feature, 我们新建一个分支并切换到这个分支上面，想把本地分支提交到远端只需要git push origin feature：feature 就好了</p><p>还有就是注意我们在切换分支的时候一定要commit ,想象一下，如果我们没有commit ，在下次切换回来的时候，很多内容是不是就没有了，因为切换到的是这个分支最新的commit 上面 （但是如果是没有冲突的文件变动，是不需要的） </p></li><li><p>git 常用的工作流程</p><p>master fork 出feature 分支，开发完毕merge master 分支，推送到远端feature分支，等待merge 到master 分支上</p></li><li><p>git rebase<br>主要是用来分支合并的，比如之前在master 分支上开出来的feature 分支，开发完了再合并到master分支上，这时候master分支已经不是原先的master了，可能有向前的提交，就会出现分支的合并，如果不希望出现多条分支合并的情况，可以通过切换到feature分支上，然后git reabase mater, 以新的master分支作为起点，然后git checkout master, git merge feature, 把head 移动到最新的master 开始处</p></li><li><p>git reset –hard</p><p>git reset –hard 目标commit 到达任意一个commit ，我觉得直接用sha-1码很方便，小册中说的回退，但是用sha-1码的话，我感觉能到任意一个commit</p></li><li><p>git revert</p><p>上面那个感觉是切换到任意一个commit ，如果我们希望重新弄出一个commit，这样提交的时候就不会用冲突（revert 就是把 那个commit 的修改全部撤销）</p><p>感觉上面的两个回退就能满足绝大部分场景了</p></li></ul><ul><li>关于分支. git branch -a ，可以查看项目的本地分支和远程分支（分支有本地分支和远程分支这两种，本地分支推送到远程就变成了远程分支，以后别人clone的时候就会包含这个分支）。当我们git clone 远程项目的时候，会把这个项目的远程分支都拉下来，我们可以在本地切换各个分支。各个分支的作用？可以作为开发的时间节点来用，比如慕课网上各个讲课阶段，每次代码开发前，先开个本地分支，开发完了推送到远程，然后和并到主分支上。我们通过切换到各个分支，就知道老师讲到哪了，还能对比代码有哪些变化，以后查看的时候还可以通过编辑器<img src="https://upload-images.jianshu.io/upload_images/5525740-502973ccb71c0779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>来进行切换，注意切换的时候会在本地自动新建一个分支，不用担心，你想啊，本地要是不新建，你直接改动的内容算哪的。</p><ul><li><p>git 和 github 的互动</p><p>git 在我们日常生活中用的最多的就是github，当我们一台崭新的电脑希望从github 中clone 代码的时候（比如git clone xxxx），我们需要ssh 连接到github 上，不做任何处理的情况下会被告知ssh 连接失败，我们需要做的就是在本地电脑上先生成ssh 公钥和私钥（如果没有的话），然后把公钥贴到github 上，公钥的生成过程中需要一个email， 这个其实随便填都是可以的（既然email 是随便填的，但怎么识别这个公钥对应这个用户呢，我觉得应该是这个公钥被贴到对应用户的账号setting处，所以github能识别这个ssh key 对应这个用户，<a href="https://debugtalk.com/post/head-first-git-authority-verification/" target="_blank" rel="noopener">这里有篇文章写得https 和 ssh 之间的区别</a>）。</p><p>我们在仓库的提交过程中也需要配置email 和 用户名，其实这个只是代表着你显示在git log 日志上的用户名和email ，并没有实际的作用</p></li></ul><ul><li><p>今天给easy swoole 提交pr ,详细过程<a href="http://www.ruanyifeng.com/blog/2017/07/pull_request.html" target="_blank" rel="noopener">阮一峰</a></p><p>首先是从fork代码从easyswoole 到自己仓库中的时候，注意fork的是哪个分支（好像不能把所有的分支都fork下来），然后git clone 到本地仓库，这时候通过编辑器打开，可以把fork 的所有版本都打开，通过</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5525740-c79941821a60d76c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>编辑器右下角的切换，可以在本地创建对应分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch   本地分支</span><br><span class="line">git branch -a  远程分支</span><br><span class="line">git branch -vv 分支对应情况</span><br></pre></td></tr></table></figure><p>通过编辑器切换可以自动添加分支关联，如果想手动关联不同分支，查看这篇<a href="https://www.jianshu.com/p/fc433b1686bd" target="_blank" rel="noopener">文章</a></p><p>总结：所以 git push origin master , 这个master代表的就是分支名称喽 （git push origin master:master 其实是这样的，origin 代表的是远端仓库名称，两个master 分别代表本地的和远程分支名称）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于单点登陆的那些事</title>
    <link href="http://yoursite.com/2018/09/04/%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/09/04/关于单点登陆的那些事/</id>
    <published>2018-09-04T02:15:49.000Z</published>
    <updated>2018-09-04T03:38:30.788Z</updated>
    
    <content type="html"><![CDATA[<p>最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.<br><a id="more"></a><br>单点登录：简单理解成一处登陆，到处登陆，一处登出，各处登出。其实在生活中的应用还是满广泛的。比如你登录淘宝的网站，可能当你跳转到天猫上，也不需要登陆，光从界面上看，也能分辨这是两个网站，这两个网站肯定有各自的登陆机制，其实内部就是用了单点登录的原理，让用户无感知的情况下实现一个账户在各个网站下的登陆登出。<br>后来在写的过程中，发现这个单点登录也有点第三方登陆的意思，这个第三方就是sso登陆中心。<br>很多人广从字面意义上看，可能会觉的单点登录应该是这样：一个用户在这个地方登陆了，比如手机上或者上海登陆了，当在电脑上登陆或者安徽登陆了，之前登陆过的账号会下线，但这并不是单点登录哦，想了下，上述功能实现起来也挺简单，比如我们经常存取 token =》 用户信息这样的登陆凭证，又或者是session_id =&gt; session 信息（用户信息）这样的登陆凭证，不妨我们在用户登陆的时候，再存储一封 用户id =&gt; 用户信息，这样我们可以很方便的统计有哪些在线用户，哪个用户是否在线（前面第一种的话需要遍历所有的session文件取出用户id）。当我们登陆接口产生了一个新的token =》 用户信息的时候，我们检测下这个用户是否在已登录列表，如果有，我们服务端直接让之前的token失效就可以了，就能实现前面账号的下线。<br>回归正题，关于单点登录<br><img src="https://upload-images.jianshu.io/upload_images/5525740-5f9c1b27e370fabf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="797930-20161203152650974-276822362.png"><br>单点登录的原理大致就是上面了：<br>1.先登录普通web1，web1后台检测是否登陆了，如果登陆过，直接跳转到web1,如果没有登陆，跳转到sso登陆中心。sso中心检测这个用户是否登陆过，如果没有登陆，跳转到sso登陆界面，输入用户名和密码（之前为什么说单点登录很像第三方登陆呢，因为接入单点登录的web1也不知道即使能登陆到他这个平台上的用户的用户名和密码，用户登陆的操作逻辑都是sso 这个第三方维护的，web1只是在登陆sso成功之后维护一个用户和web1的登陆态，比如web1派发给用户一把钥匙，以后拿着这把钥匙就代表你是web用户了），用户成功登陆sso这个中央站点后（用户和sso之间的登陆成功搭建成，之前我是通过jwt的方式维护用户和sso之间的，jwt相比较传统的cookie和session就是通过签名的方式能防止用户篡改已登录人的信息），sso会回调web1站点上提前设置好的接口（这个我当时是在跳转到登陆中心的时候附带在url后面参数，其实这个可以提前设定好，然后通过传入一个参数web1，sso去后台查找需要的会掉地址），传给他一个参数，可以理解成一个ticket，web1拿着这个ticket可以换取正在登陆的用户的用户信息，拿到之后web1就能实现自己的业务逻辑了，比如检测这个用户是不是第一次登陆，如果是第一次登陆的话需要绑定用户信息之类的，然后维护用户和web1之间的登陆状态建成。<br>上面需要注意的点就是客户端如何接受服务端生成的登陆凭证.<br>首先是用户和sso中心，这个好解决，因为我们的登陆页面可以可以当做一个静态页面，我们可以在上面写js，这就方便了，我们发送一个ajax请求给sso，成功后把返回的登陆凭证放在cookie中，每次调用sso接口比如验证用户是否登陆的时候都会携带着这个cookie，！！！千万要注意，携带这个中在客户端浏览器的cookie的前提是通过ajax之类的访问，你别通过curl之类的访问，curl需要自己手动设置cookie，并不会像浏览器一样自动添加上，所以我们在后台一般要用header  location之类的跳转，而不是curl.<br>web1和用户之间登陆态的维护：<br>这块我没有使用header location跳转，用的是ajax返回给前端页面，前端页面去跳转，之所以这么做，好像是用第一种好像有点问题，没有去研究了，因为时间赶啊！！！前端拿着这个ticket，哈哈哈，你是不是担心不安全，我也担心呢！！而且我这块直接用的url跳转，为什么呢，因为我的后台是获取用户信息之后直接跳转，并不需要ajax那种返回了，如果这里用返回，首先是前台页面并不知道维护好登陆信息之后需要挑战的地址（这个静态页面是sso的），然后呢，如果通过ajax，后台跳转可能有些错误，之前那个sso登陆成功后台跳转不到web1，可能就是这个问题。<br>web1的回调地址里面通过ticket拿到用户信息之后可以做很多自己事情了，比如绑定用户，比如验证用户是否合法等等</p><p>2.单点退出<br>一处退出，处处退出。<br>我是这样做的，当登陆成功后，会在数据库中写入，这个用户的登出地址，当我们登出的时候，查询数据库，所有用户的登出地址，循环调用，需要注意的是我们传给用户的是只能是user_id之类的公有信息，各个子网站接收到之后，需要拿这个信息获取用户的登陆凭证，然后让其失效。我是这样做的：redis中存储着phpsessid（我们用的传统的cookie session）,然后curl 模拟请求的时候cookie带上这个，··然后就实现啦</p><p>思考：如果我们模拟请求的时候带上完全一样的头信息，是不是就能达到和浏览器一样的效果了，··有些能，比如上面的登出，但是设置cookie不可以，明明就是header加上点信息嘛，为什么不可以呢，因为cookie只能在浏览器上使用？<br>还有很多优化的空间，比如回调多个登出接口，用的消息队列，如果一个出错，是记日志吗，还是什么zzz<br>每个网站需要自己的登陆界面嘛，这样每次未登录定位到登陆界面之后就只有个登陆按钮，点击之后才能进入sso输入用户名和密码，相比较之前略麻烦，但是如果sso登陆之后，我们点击就能直接跳转到我们的网站，感觉这样更符合单点登录。<br>而且住校之后我们可以定位到普通网站的登陆界面，而且点击因为可以加回调地址，我觉得还是不能省略的。<br>代码就不放了，放些接口的函数吧<br>sso :<br>login :检测是直接跳转到登陆页面还是检测cookie是否有效，有效回调web1站点地址，无效跳转到登陆界面（看了下仿佛ajax中header location 就是有点问题）<br>logout</p><p>web1:<br>login: 判断是去sso还是直接登陆<br>logout:退出，需要回调 sso 的logout, 注销sso还有各个子网站<br>ssologin:回调登陆地址<br>ssologout：回调登出地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于nginx的那些事</title>
    <link href="http://yoursite.com/2018/08/20/%E5%85%B3%E4%BA%8Enginx%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/08/20/关于nginx的那些事/</id>
    <published>2018-08-20T03:42:26.000Z</published>
    <updated>2018-08-20T03:42:26.033Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel  数据库相关操作</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-数据库相关操作/</id>
    <published>2018-07-29T15:42:59.000Z</published>
    <updated>2018-07-29T15:42:59.679Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel seeder 数据填充</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-seeder-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-seeder-数据填充/</id>
    <published>2018-07-29T15:42:33.000Z</published>
    <updated>2018-07-29T15:42:33.200Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel migrate 数据迁移</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-migrate-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-migrate-数据迁移/</id>
    <published>2018-07-29T15:42:19.000Z</published>
    <updated>2018-10-11T02:32:25.730Z</updated>
    
    <content type="html"><![CDATA[<p>虽然表哥说他们都不用这种方式，但这种方式确实很方便的解决了团队合作的时候数据库表的同步问题，像我们itbasic 就每次上线或者给队友同步数据库的时候都得自己手动去处理，而且这种方式更多的把sql语句转换成php语言处理，不知道建索引那些会不会很方便.</p><a id="more"></a><p>文件位置和命名：</p><ul><li>database/migrations/2014_10_12_000000_create_users_table.php</li></ul><p>通过artisan 命令能直接生成对应目录下的文件</p><p>注意up 和 down 方法，分别是的执行的时候，还有回滚的时候的执行</p><p>注意create 和 update 表结构的时候的区别</p><p>自增：increment </p><p>字符串： string  ， 方法的第二个参数限制最大长度</p><p>唯一： unique，感觉就像数据库的唯一索引</p><p>创建时间和修改时间，通过 timestamps 就能生成</p><p>记住我： rememberToken, 虽然一直不太清楚这个干啥的</p><p>create =&gt;  dropIfExists() , 创建 回滚的时候对应 删除</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然表哥说他们都不用这种方式，但这种方式确实很方便的解决了团队合作的时候数据库表的同步问题，像我们itbasic 就每次上线或者给队友同步数据库的时候都得自己手动去处理，而且这种方式更多的把sql语句转换成php语言处理，不知道建索引那些会不会很方便.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
