<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-31T08:41:16.580Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>同步 异步 阻塞 非阻塞</title>
    <link href="http://yoursite.com/2019/07/20/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2019/07/20/同步-异步-阻塞-非阻塞/</id>
    <published>2019-07-20T07:54:07.000Z</published>
    <updated>2019-07-31T08:41:16.580Z</updated>
    
    <content type="html"><![CDATA[<p>灵感来源别人利用多进程写了个python 的下载器，于是想自己用php试一下</p><a id="more"></a><p>先说下多进程和单进程</p><p>lnmp请求过程</p><p>http请求到达nginx，nginx 转发给php-fpm(一个php进程管理器，~so，这个地方就是多进程啦)，每个进程中实现了fast-cgi 协议(请求完毕，并不重启进程，而是等待下一个请求的到来，除非到达该线程接受http请求最大数量，会自动重启，目的是为了防止一些代码不好，导致内存泄漏)，每个进程中其实就是 php index.php（请求处理完逐个往回返回）, 所以我们可以把lnmp 模型理解成多进程模型，同一时刻并发的数量就是php-fpm配置的进程数量，但为什么别人说php是单进程呢，因为我们平时在开发的过程中，所有的代码都是跑在一个请求中，也就是一个进程中，所以我们可以说php就是单进程的，但php真的只是单进程的吗，不是，php有个扩展叫pcntl ，这个扩展不建议在php-fpm模式下使用，但是在php-cli 下可以正常使用，也就是说我们不建议在php-fpm的工作进程中再fork新的子进程（同理swoole 中也不建议在worker进程中new process 新的进程），既然在工作进程中不涉及fork 子进程，而php也很少操作线程，那么php就和异步搭不上边了。</p><p>同步，异步区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</span><br><span class="line">  异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</span><br></pre></td></tr></table></figure><p>最常见的异步莫过于前端的ajax，</p><p>ajax 允许浏览器在发出请求的时候浏览器（一个进程）还可以去做别的事情，而不用干等着（同步就不行了，同步阻塞显然不行，同步非阻塞呢？同步虽然进程还可以去做别的事情，但是进程但过一会还得再来询问一下，请求是否完成，所以哪怕是同步非阻塞，代码流程执行到这会，始终会停住，不会继续向下走，这和异步代码能继续往下跑是不一样的，所以同步更符合我们的日常习惯。</p><p>比如异步编程，我们不知道ajax执行的函数啥时候回给我们返回内容，所以我们无法用  $a = ajax(xxx), 去获取ajax 执行的内容，大部分情况下用的是回调函数，然而为什么php中也有回调函数呢，php中的回调更类似于js中的匿名函数，他只是代码同步执行到用户定义的函数中，调用了之前定义的一个匿名函数，和js的回调存在本质上的区别。js中的回调，更类似swoole的回调，发现了嘛，都是通过事件的触发机制（但是这个应该和事件io不一样，之前看的阻塞io 非阻塞io 事件io 信号io都属于同步，只有异步io属于异步方式）</p><p>所以我们平时在看php的代码中就不要考虑异步方式了，基本没有，因为都是同步的，又因为阻塞和非阻塞都会有返回值，所以我们平时的那些函数基本都有返回值，但是有些回调形式的函数返回值有没有用，那就另说，看定义这个函数的人怎么想了。（其实看同步和异步看函数的return 也能看出来，如果return外面能接收到，那就是同步,比如php-fpm,包了那么多header头信息，还是return就能返回，你看swoole中的return ，在事件回调中，他是通过 $response 返回给别的进程的，所以属于异步）。</p><p>(可能有小伙伴看klein 或者larave中的路由函数觉得可能是回调，因为callback 中的内容总在 callback 外面先输出，首先，你在 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/test/test/[test|cry:test]/[i:id]&apos;, function ($request, $response) &#123;</span><br><span class="line"></span><br><span class="line">    $obj = Box::getObject(&apos;out&apos;, &apos;controller&apos;);</span><br><span class="line">    return $obj-&gt;oop($request);</span><br><span class="line">&#125;);</span><br><span class="line">的 respond 方法中返回 值，看外面能不能接收到，能接收到就是同步</span><br></pre></td></tr></table></figure><p>再者，他这个地方绑定了callback，并没有执行callback呀，所以这个地方并没有执行是很正常的，但是php这种没有触发机制，必须得执行呀，看后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;dispath() // 其实是在这里面执行了</span><br></pre></td></tr></table></figure><p>)</p><p>为什么说swoole 的task任务是异步任务，因为我们在worker进程中调用task添加异步任务的时候，当异步任务执行完的时候，我们能在之前的worker进程 中收到task返回的消息（onFinishi事件中）。(在没有swoole 之前，php中对于异步的实现都是通过第三方软件，比如把耗时任务放到消息队列中，由消费者自己去消费，消费者可以通过crontab 这种去轮训消息队列，虽然不太环保，但还是能完成任务)    </p><p>swoole进程模型</p><p>master 整除ractor 线程和manager 进程，</p><p>manager 进程 生出 worker进程（异步非阻塞）和特殊worker进程（task进程，同步阻塞），负责进程重启和 回收</p><p>ractor 线程检查连接，还有可写的socket 发送给worker进程处理</p><p>swoole4之前请求过程</p><p>单个请求被单个worker处理，处理完再处理下一个</p><p>swoole4 之后</p><p>woker可以同时接受多个，遇到io，协程切换，处理下一个请求，当上一个请求io完毕，再切回来（感觉通过fd -&gt; 运行环境），继续往下执行（注意就是这儿，虽然说协程本质上还是异步，但是他的运行方式类似同步，更好理解）</p><p>相较于异步的不容易理解，比如回调地狱，swoole 希望我们仍旧用同步的方式编写代码，但是对于一些io操作同步返回太慢了，所以就出现了异步io，redis, mysql，没有用过~~，swoole4中为了把这个异步摒弃，又引入了上述的协程，协程是比进程线程粒度更小的资源管理。</p><p>关于阻塞和非阻塞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</span><br><span class="line">有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。</span><br><span class="line">非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</span><br></pre></td></tr></table></figure><p>php中虽然sleep， file_get_contents 中有同步阻塞io，但是string， arr这些函数还是同步非阻塞函数</p><p>当我们在项目在swoole的http server中，没有用上面的同步阻塞io的时候，我们整个项目代码就是异步的，但凡用了，那我们的项目代码就是同步的，所以这个同步和异步由两部分决定，一个是swoole server， 一个是我们的项目代码。</p><p>swoole 本质上是为了对标php-fpm,和php本身没有什么关系，他对项目的性能提升类似php7对项目代码的提升，我们不用修改源代码，就能提升并发量，只是php7是对php中函数的改造，而swoole 是对php-fpm的改造或者说php的运行环境的改造，他吧php-fpm 的功能也纳入到我们项目代码中。</p><p>所以总结一下：</p><p>php多进程 ： 针对php-fpm， 或者php-cli 模式下的php进程而言</p><p>php单进程：针对php-fpm模式下php进程而言</p><p>同步: 针多 php-fpm 而言</p><p>异步：针对 swoole 封装的一些io操作而言，比如redis ,mysql ，还有http tcp server，</p><p>还有之前的多进程下载的实现，遍历url，每个url都放到task中执行，完美多进程，easy(不要想着在worker 在生成新的process 哦， 官网上说很占资源)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;灵感来源别人利用多进程写了个python 的下载器，于是想自己用php试一下&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>PHP常用函数</title>
    <link href="http://yoursite.com/2019/07/13/PHP%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/07/13/PHP常用函数/</id>
    <published>2019-07-12T16:07:33.000Z</published>
    <updated>2019-07-31T08:41:10.526Z</updated>
    
    <content type="html"><![CDATA[<p>看别人代码的时候会发现一些自己用的很少但很实用的函数，还有一些自己经常遗忘的函数，记录下来方便查找</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看别人代码的时候会发现一些自己用的很少但很实用的函数，还有一些自己经常遗忘的函数，记录下来方便查找&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://yoursite.com/2019/07/06/docker/"/>
    <id>http://yoursite.com/2019/07/06/docker/</id>
    <published>2019-07-06T07:23:39.000Z</published>
    <updated>2019-07-31T08:41:07.133Z</updated>
    
    <content type="html"><![CDATA[<p>学习docker主要是因为他部署环境太方便了，相比较传统的傻瓜式yum还有稍微高大上一点的自己编译，docker在搭建环境速度上真的是太快了，而且可以避免一系列的乱七八糟的问题，就比如用安装easyswoole 这个框架，当我们用composer + easyswoole install 生成目录结构的时候或多或少出现一点问题，但是当我们下载easyswoole 提供的Dockerfile 的时候，我们只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . (包含Dockerfile的文件目录)</span><br></pre></td></tr></table></figure><p>就能快速生成一个运行着easyswoole框架的环境，但是我不知道怎么把宿主机也就是本机的目录映射到docker app中，虽然通过docker run -v 可以，但是当我docker cp (docker app 中的easyswoole初始目录) (宿主机目录)，我发现总是有些文件夹没有复制出来，问题还没有解决，还有docker compose， docker 多app 分工合作还是没有弄回,慢慢学吧</p><a id="more"></a><p>docker 软件的安装</p><p>docker 是 cs 结构(类似 mysql, redis 都是，只是docker 客户端和服务端连接用的restful，感觉像走的http协议)，我们安装好docker之后，通过修改docker 的国内镜像，加速docker pull 拉取镜像的速度（如果是yum，修改/etc/docker/damon.json文件，可能重启systemctl reload docker 会报错，是因为systemctl start docker 的时候 -t 指定了resposity远程仓库，我们修改一下，删除这个参数就好了）</p><p>镜像</p><p>docker pull    //从远程仓库拉取镜像(docker hub, 类似github的存在,像阿里云这些都是对docker hub的备份，可能有几秒的延迟，没啥事)</p><p>docker images  //  查看本地所有镜像</p><p>docker search  imagesName// 查找镜像</p><p>(关于镜像名称， 仓库名(所有者)/镜像名称:tag, 要是没有仓库名就是官方镜像，tag 是标签，比如php-7.2:cli,这种细分一下)</p><p>docker run  imagesName (镜像名称)  //  默认先从本地找，找不到去远程仓库找</p><p>(特别要注意的就是run centos 这种操作系统的时候，我么需要docker run -it  镜像名称 /bin/bash ， 这样才能让这个app一直运行，否则他会立刻断开，没有实际的意义, 像一些简版的centos 比如 alpine 版本，可能没有 /bin/bash, 我们可以 /bin/sh)</p><p>(还有就是 不同版本的centos 安装软件的方式可能不同，可能是yum,可能是agp-get install, 可能是别的，我们只需要换源，然后百度安装对应resposity库下面的软件就好了)</p><p>(-r 代表运行结束就删除了， -d 守护进程方式， -p 8000:80 端口 映射， -v  /home:/home, 文件夹挂载， -name 给容器取个名字，否则默认分配个名字)</p><p>docer cp  (从宿主机到虚拟机或者从虚拟机到宿主机)</p><p>docker inspect imagesName // 查看一个镜像的详细信息，比如挂载了哪些目录，暴露了哪些端口</p><p>dokcer rmi  imagesName // 删除镜像 </p><p>容器 container</p><p>docker images 启动之后就产生了 container，容器</p><p>docker ps  //查看运行的容器</p><p>docker ps -a // 查看所有运行过的容器</p><p>docker exec -it containerid(容器名称) //进入容器内部</p><p>docker rm containerId //删除容器</p><p>Dockerfile 编写</p><p>docker compose</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习docker主要是因为他部署环境太方便了，相比较传统的傻瓜式yum还有稍微高大上一点的自己编译，docker在搭建环境速度上真的是太快了，而且可以避免一系列的乱七八糟的问题，就比如用安装easyswoole 这个框架，当我们用composer + easyswoole install 生成目录结构的时候或多或少出现一点问题，但是当我们下载easyswoole 提供的Dockerfile 的时候，我们只需要&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker build . (包含Dockerfile的文件目录)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就能快速生成一个运行着easyswoole框架的环境，但是我不知道怎么把宿主机也就是本机的目录映射到docker app中，虽然通过docker run -v 可以，但是当我docker cp (docker app 中的easyswoole初始目录) (宿主机目录)，我发现总是有些文件夹没有复制出来，问题还没有解决，还有docker compose， docker 多app 分工合作还是没有弄回,慢慢学吧&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重庆</title>
    <link href="http://yoursite.com/2019/05/15/%E9%87%8D%E5%BA%86/"/>
    <id>http://yoursite.com/2019/05/15/重庆/</id>
    <published>2019-05-15T02:32:36.000Z</published>
    <updated>2019-07-31T08:41:42.300Z</updated>
    
    <content type="html"><![CDATA[<p>第一次一个人出门，记录一下~</p><a id="more"></a><p>携带物品<br>all need:身份证，钥匙(不要企图你的室友帮你开门，我们都是独立的个体，自己的事情自己做啦），充电宝(！！！一定要带一个安卓头的充电线，因为你可能需要给充电器充电呀，充电宝要注意实际的毫安大小，避免过大不能携带上飞机的尴尬，知乎上有具体的参数)， 零钱(虽然重庆做公交可以用腾讯小程序乘车码，轻轨也是，但是有的地方轻轨买票好像只能用零钱，但是换100的零钱把，有十元有1元的那种，免去做公交付10元的尴尬)<br>person need: 充电牙刷，牙膏，毛巾，睡衣</p><p>坐飞机<br>虽然不是第一次坐飞机，但距离上次坐飞机已经一年了，还是记录下，因为下次坐飞机可能又忘了呢。携程上订的票，提前一个半小时到达机场，到不同航空公司的窗口下办登机牌，登机牌就是把网购的票换成实际的票，可以选位置，托运行李，电脑是不能托运的哦（小su哥说航旅纵横可以直接用电子版的登机牌，下次有空试一下），然后就是找登机口啦，机票上有写，不同机场不一样，比如上海浦东分国内起飞和国外起飞的口，这个口进去实际上是安检，把你身上的电子产品拿出来检查，但是重庆的因为是国内机场嘛，所以会把比如c1~c99走这个口安检，c100~c102 走那个口安检，安检过后才是走去正真的口等飞机排队<br>总结： 网上订票—&gt;特定口办理登机牌—&gt;过安检—&gt;特定口等飞机</p><p>出机场：<br>跟着人流走喽，其实就是找地铁或者你需要的交通工具，重庆是江北机场，出了航站楼，有机场大巴（叫k01?忘记了），因为我住在解放碑旁边的大溪沟，所以做机场大巴很方便，15元，直达<img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8688115645624835559.jpg" alt="IMG_0965.JPG"><br>重庆大致就是这种场景，刚开始看很壮观，后面就习惯了，低头玩手机（重庆是个3D城市，所以我觉得还是自己多走走路比较好，重庆打车很便宜，基本上都是不超过20元，南山那边老城区更便宜）</p><p>住宿：<br>我在知乎上查了一下，大家都推荐民宿，名宿相比较七天，速八，同等价位比如200，感觉还是名宿划算点，但其实不是环境，而是位置，给个对比你们看下，网上：<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6332015645624837919.png" alt="IMG_0591.PNG"><br>实际：<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1778415645624843201.jpg" alt="IMG_0747.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/439615645624845699.jpg" alt="IMG_0748.JPG"><br>没有那么夸张，但我住的地方位置还不错，虽然是瞎选的，出门就是大溪沟轻轨站，还有公交站，重庆的轻轨比较挤，那就打车把，重庆的出租车司机人都挺好的，其实你自己开着导航就知道他绕没绕路了呗。还有！！！一定要注意轻轨的标志，因为重庆的轻轨站在有些地方还是比较少的，所以我上次去鹅岭公园坐轻轨始终找不到，其实就在我旁边，一个绿绿的标志，别到处找上海那个蓝蓝的地铁标志了，哈哈哈，（网红李子坝,体验下，sry ，忘记拍照了，如果从大溪沟去鹅岭二厂就会路过啦）<br>这是我刚下机场大巴看到我住的地方<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5001015645624848143.jpg" alt="IMG_0745.JPG"><br>楼基本都是40层</p><p>day1:<br>4点下飞机 —&gt; 5点到家—&gt;7点出门—&gt;解放碑—-&gt;八一好吃街—-&gt;洪崖洞—-&gt;千x桥—-&gt;回家<br>解放碑就是带着一个碑的步行街<img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8356315645624851504.jpg" alt="IMG_0753.JPG"><br>挺小的，如果不购物的话，走不到一个小时吧，中间碰到国家图书馆<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4628315645624854088.jpg" alt="IMG_0751.JPG"><br>然后去八一好吃街吃东西，因为我不爱吃辣嘛，所以吃的都是甜的，比如糍粑，冰汤圆，芋头这种东西，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3431715645624856663.jpg" alt="IMG_0755.JPG"><br>吃完了就可以去洪崖洞啦，洪崖洞比较好的观看场景是千x桥，我是周六去的，桥上人不太多，桥也挺短的，我走了个来回<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5701815645624858953.jpg" alt="IMG_0759.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9698815645624861283.jpg" alt="IMG_0764.JPG"><br>这是桥的对面<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6671515645624863588.jpg" alt="IMG_0769.JPG"><br>可以在桥的对面玩一下再回去，比如南滨路，大剧院<br>这是洪崖洞<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8957315645624866394.jpg" alt="IMG_0771.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9116515645624869018.png" alt="IMG_0775.PNG"><br>你们可以趁早先排队进洪崖洞，晚点的时候人就挺多的了，我当时只是看了远景，没有去洪崖洞里面看，所以9点我的行程就结束了，其实这个时间还早，对于重庆来说，真正的夜生活可能才刚开始</p><p>day2:<br>轻轨—&gt;李子坝地铁站—&gt;鹅岭二厂—-&gt;鹅岭公园—-&gt;川美虎溪—&gt;磁器口—&gt;回家–&gt;观音桥<br>第二天应该是我最开心的一天，唯一的遗憾就是出了虎溪我的行程就结束了，所以大概是10点到3点，本来是有个朋友来，所以我在4点之后就回家等他了，可是他临时鸽了，要不然可以更丰富。<br>从李子坝地铁站出来，走到鹅岭二厂可能比在鹅岭二厂玩起来更开心，当时天下着蒙蒙雨，路上没有多少人，跟着百度地图走着盘山公路，差点走过了<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1115645624879743.jpg" alt="IMG_0799.JPG"><br>一条大马路上，开了个小口，忘记叫什么路了，很陡，蛮有意思<br>走了不久，就看到鹅岭二厂啦，原谅我忘记拍logo，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6083315645624887525.jpg" alt="IMG_0809.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/330561564562489024.jpg" alt="IMG_0800.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3826915645624892779.jpg" alt="IMG_0801.JPG"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/26815645624895795.jpg" alt="IMG_0808.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2097015645624898487.jpg" alt="IMG_0811.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9744815645624907554.jpg" alt="IMG_0821.JPG"></p><p>小店老板说晚上来比较热闹，好吧，我是好孩子，10点之后不出门。</p><p>鹅岭鹅厂其实就是几栋废弃的楼改造的，出来之后就继续去看鹅岭公园啦</p><p><img src="http://img.chenye2017.cn/eling.jpg" alt="鹅岭"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2885515645624909655.jpg" alt="IMG_0828.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4313215645624911936.jpg" alt="IMG_0829.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1582315645624914543.jpg" alt="IMG_0824.JPG"></p><p>小朋友们在正儿八经的写生，可是你们画的太丑啦，哈哈哈哈</p><p>下山做地铁去川美喽（川美虎溪那边比黄那边好挺多，建议时间不够的话去那边，那边还有别的很多大学）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3111715645624917285.jpg" alt="IMG_0838.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6224015645624919703.jpg" alt="IMG_0840.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5812615645624922812.jpg" alt="IMG_0842.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4405215645624928312.jpg" alt="IMG_0845.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6519015645624931228.jpg" alt="IMG_0849.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3460815645624934409.jpg" alt="IMG_0855.JPG"></p><p><img src="http://img.chenye2017.cn/luo2.jpg" alt=""></p><p><img src="http://img.chenye2017.cn/luo3.jpg" alt=""></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4730515645624937179.jpg" alt="IMG_0860.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6164915645624939203.jpg" alt="IMG_0861.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/909315645624941563.jpg" alt="IMG_0862.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9556815645624943892.jpg" alt="IMG_0865.JPG"></p><p><img src="http://img.chenye2017.cn/luo4.jpg" alt=""></p><p>晚上去了观音桥，还有个什么书店来着，忘记了，那就放图吧<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/667961564562494603.jpg" alt="IMG_0883.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7804915645624948852.jpg" alt="IMG_0884.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8740615645624951562.jpg" alt="IMG_0885.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4660915645624954314.jpg" alt="IMG_0889.JPG"></p><p>这应该是我最喜欢的壁画了<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2315615645624957249.jpg" alt="IMG_0890.JPG"></p><p>观音桥看到了很多人跳广场舞，然后是观音桥小吃街，卖生蚝的店家真的黑心，不要去</p><p>day3:<br>长江索道—&gt;南山一棵树观景台—&gt;南山植物园—&gt;山鬼—&gt;南山书店—&gt;南山书店之小森林—&gt;山下逛了逛—&gt;回家<br>第三天应该是这次旅行最失败的一天，完全可以纳到某天晚上的行程，因为南山那边完全就是看夜景，白天没啥看头，下了长江索道（长江索道不要期望太大，很普通）,因为观光巴士要等很久，所以直接打车上山（长江索道那边可以买套票，还好没有买观光巴士的票），司机师傅是个日语说的很6的男人，在日本呆了挺久，人很好说话，！！！开了那么久竟然只有11元，到了南山一棵树，当时人太少了，所以我一个人不敢上山，还下着雨，所以呢，我花了30的门票就在门口呆了30分钟，上照片<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6603715645624959872.jpg" alt="IMG_0902.JPG"></p><p>出了门做了一个大叔的车去南山植物园，他收了30元，因为百度地图显示打车25元，所以同意了（真的相比较别的地方景区太良心了），植物园也挺没意思的，主要一个人懒得走，所以也是只是去了室内植物园就出来了，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7966315645624962559.jpg" alt="IMG_0906.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4556215645624965821.jpg" alt="IMG_0910.JPG"></p><p>继续往上走，去找南山书店喽，中途路过山鬼，重庆很多网红地方入口普通的就和不存在一样，比如这个山鬼，小红书上到处种草，可是我路过竟然没发现，（山鬼就是个面朝大山的玻璃屋，哈哈哈），南山的那些网红书店其实也蛮普通的，就是用来拍照的，里面的点心挺普通，虽然我每家都不好意思不点<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7366415645624968525.jpg" alt="IMG_0912.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2693015645624971543.jpg" alt="IMG_0913.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3440315645624974297.jpg" alt="IMG_0915.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9600115645624980407.jpg" alt="IMG_0920.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2693415645624982834.jpg" alt="IMG_0923.JPG"></p><p>下山之后就是给网红建筑拍拍照，据说夜景挺好，第三天完全可以一晚上搞定</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4895315645624985274.jpg" alt="IMG_0925.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3820715645624988179.jpg" alt="IMG_0927.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/988315645624990895.jpg" alt="IMG_0928.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2195115645624993532.jpg" alt="IMG_0932.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1048215645624995833.jpg" alt="IMG_0935.JPG"></p><p>day4：<br>川美（黄x校区）—&gt;涂鸦一条街–&gt;钟书阁—&gt;坐飞机回家</p><p>川美这个老校区很小，没什么人，可能是周二吧，那就上图喽</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8732415645625000255.jpg" alt="IMG_0945.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/72191564562500407.jpg" alt="IMG_0946.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8746515645625006678.jpg" alt="IMG_0950.JPG"></p><p>川美有个门对面是一个创意基地，里面是工作的地方，外面有些涂鸦，那就打卡下吧</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6777215645625009024.jpg" alt="IMG_0951.JPG"><br>涂鸦街就是一条路上房子被涂鸦了，其实也挺一般，有个交通茶馆，哈哈哈，挺难找，因为入口处太普通了，进去了就是老年人的酒吧，因为都是老人，就没有长时间都留了，去钟书阁喽。</p><p>钟书阁在一个商场里面，不要跟着百度地图绕着那个商场走，···我真的太傻了，随便进一个商场口，问一下就好了，在三楼，不算大，其实我感觉不管是南山书店还是这个钟书阁，实际意义上更像一个咖啡厅，因为一直有着轻柔的音乐，没有图书馆那么安静<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/891271564562501164.jpg" alt="IMG_0955.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6045515645625014386.jpg" alt="IMG_0957.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3862915645625016845.jpg" alt="IMG_0958.JPG"></p><p>因为下午5点的飞机，我12点就没事了，所以在这个地方看了1小时比赛，1点的时候往飞机场赶，其实能呆更久，但我做事比较着急啦</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2497115645625020811.jpg" alt="IMG_0961.JPG"></p><p>最后：<br>这次去重庆因为第一次一个人出门嘛，虽然做的事情不多，但是收货还是蛮大的，毕竟只能靠自己，后来我觉得我可能更喜欢泸沽湖那样的地方，有山有水，重庆是一个网红城市，更适合拍照</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次一个人出门，记录一下~&lt;/p&gt;
    
    </summary>
    
      <category term="旅游" scheme="http://yoursite.com/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="重庆" scheme="http://yoursite.com/tags/%E9%87%8D%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>持续交付</title>
    <link href="http://yoursite.com/2019/03/20/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    <id>http://yoursite.com/2019/03/20/持续交付/</id>
    <published>2019-03-20T06:28:18.000Z</published>
    <updated>2019-07-31T08:41:20.590Z</updated>
    
    <content type="html"><![CDATA[<p>上面要求代码从svn改成git,需要一个私有化的代码管理工具，于是想到了gitlab, 其实我们人这么少，一般一个前端，一个后端，流程简单，svn和git 用起来没啥区别，可是呢上面说了，那就改吧<br><a id="more"></a></p><ul><li>gitlab 搭建<br><a href="https://blog.csdn.net/Abysscarry/article/details/79402695" target="_blank" rel="noopener">https://blog.csdn.net/Abysscarry/article/details/79402695</a><br>慕课网教程上那么复杂是因为配置了本地https<br>唯一一点没有提到的就是自定义域名的文件位置，如果用yum安装的话<br>在 /etc/gitlab/gitlab.rb下面。</li><li>gitlab使用<br>默认有个root账户，自己设置密码，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/800415645624780513.png" alt="image.png"></li></ul><ol><li><p>可以创建用户和项目<br>创建项目类似github 上创建项目，后面项目的提交就是git 的使用<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/748391564562478477.png" alt="image.png"><br>创建用户的话如上，主要是那个reqular和admin, 这块不是项目权限，应该是类似整个gitlab 的权限， 新建的用户可以给个初始密码，然后用户登陆的时候可以修改，用户提交代码需要把ssh 公钥粘贴到gitlab 上，一切和github类似</p></li><li><p>配置项目权限 （管理员才有这些权限，比如root）<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6845315645624787314.png" alt="image.png"></p></li></ol><p>点击项目，给项目配置人员信息</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5573915645624793171.png" alt="image.png"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9647115645624801071.png" alt="image.png"></p><p>目前只配置了develop和 master ,develop 是开发者，开发者不能向master 分支提交代码。只能自己开个feature分支，提交之后再gitlab 上面提交merge 申请，这个项目的master 可以merge , 这个项目的master 可以直接向master 分支提交代码</p><p>上面的administrator / test , administrator  是用户名， test 是项目名</p><ol><li>监控系统信息(感觉这个可以放在一般的管理系统中，掌握服务器情况)</li></ol><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9805515645624803533.png" alt="image.png"></p><p>今天新建一个项目的时候总是显示密码错误，主要原因可能是项目建成了private ， 没有解决问题，但发现了另一个问题，我下载项目的时候总是显示password ,那他是怎么识别我的name呢，答案是gitlab 上贴的ssh key，我们的每一个gitlab 用户或者 github 用户都要至少绑定一个ssh key,就是通过这个ssh key 识别我们用户名称的,我们在用gitlab 提交代码时候总是显示要配置用户名和密码，可以全局配置也可以在单个项目中配置，所以这个并不是我们登陆github 或者gitlab 的用户名，这个只是我们提交时候日志上面显示的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上面要求代码从svn改成git,需要一个私有化的代码管理工具，于是想到了gitlab, 其实我们人这么少，一般一个前端，一个后端，流程简单，svn和git 用起来没啥区别，可是呢上面说了，那就改吧&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PHP 反射</title>
    <link href="http://yoursite.com/2019/03/06/PHP-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/03/06/PHP-反射/</id>
    <published>2019-03-06T02:43:51.000Z</published>
    <updated>2019-07-31T08:41:08.050Z</updated>
    
    <content type="html"><![CDATA[<p>故事背景：在做文件上传的时候，对图片的上传和视频的上传走的是相同的接口，可是视频和图片有些参数是不同的，于是通过一个基类base,扩展出多个子类，image,video ···上传类，根绝参数的不同调用不同类的upload方法。</p><blockquote><p>简单点说反射的就是让你拥有剖析类、函数的能力。</p><p>有的同学可能会问我剖析类有什么用，我为什么要学反射，我只能说不学反射并不会对你实现业务有任何影响，但是如果你想写出结构优雅的程序，想写出维护性和扩展性都很高的程序，学习反射是必不可少的。</p></blockquote><p>Laravel 中依赖注入用的就是反射。<a href="http://www.dahouduan.com/2017/08/21/php-refleciton-1/" target="_blank" rel="noopener">参考文章</a></p><a id="more"></a><p>base类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;&apos;;</span><br><span class="line">  public function upload()</span><br><span class="line">  &#123;</span><br><span class="line">  var_dump($this-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>video 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Video extends Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;video&apos;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Image extends Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;image&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Upload</span><br><span class="line">&#123;</span><br><span class="line">  public static alias()</span><br><span class="line">  &#123;</span><br><span class="line">  return [</span><br><span class="line">  &apos;video&apos; =&gt; \App\Video,</span><br><span class="line">  &apos;image&apos; =&gt; \App\Image</span><br><span class="line">]</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  public fileUpload($type)</span><br><span class="line">  &#123;</span><br><span class="line">  $classArr = self::alias();</span><br><span class="line">  $className = $classArr[$type];</span><br><span class="line">  $reflection = new ReflectionClass($className); // 获取反射对象</span><br><span class="line">  return $ref-&gt;newInstance() // 获取类实例化对象</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是一段很简单的使用反射实现的代码，其中对实例化参数的判断，类是否能实例化等诸多反射的方法都未使用到。</p><p>总结一下我在使用easyswoole 写代码过程中的感觉：</p><ul><li><p>首先想熟练的使用easyswoole,必须得熟悉swoole,比如对swoole http server 的配置，举个例子，当上传文件大于easyswoole 默认上传文件总的大小的时候，easyswoole(包括swoole)的tcp 链接会主动断掉，但是swoole的服务器端会打印一个warning ,显示传输文件过大，但是easyswoole 不会，服务器端不报异常，只是客户端建立不了链接，这就很尴尬了，之前还以为是端口号或者自己代码哪里出了问题。（ps:php文件上传和两个参数有关，一个是php.ini 里面的upload size, 一个是post size, 如果是swoole 上传的话，还和swoole 的配置项有关，在easyswoole 中对http server 的配置和swoole 中对http server 配置一样，只是参数修改的位置不一样罢了）</p></li><li><p>再者是对easy swoole 的使用，之前习惯于查看文档或者手册去学习（比如laravel 和 php 手册），对其中的所有的方法都有详细的解释，我们应该学会通过查看源码去学习其中方法的使用，比如easy swoole 中对获取参数这些都没有doc 文档，我们可以在request 类下面查看有哪些可以调用的方法，或者是通过编辑器补全</p></li><li><p>说到编辑器补全，之前发现的一个问题就是比如上传类，当可能返回上传类或者null 的时候，通过链式调用，上传类的方法得不到补全，可是我们通过php7的返回结果限制，就能让编辑器自动补全了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Request</span><br><span class="line">&#123;</span><br><span class="line">   public function uploadFile($name) :?UploadFile</span><br><span class="line">    &#123;</span><br><span class="line">  if ($file[$name]) &#123;</span><br><span class="line">          return $file[$name]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         return null</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">// ?代表可能是Null</span><br></pre></td></tr></table></figure></li><li><p>当我们想知道这个结果有哪些可以调用的方法的时候，我们可以直接打印这个结果，查看属于哪个类，然后我们到这个类下面查找，比如我之前想知道反射的 getParamtes  方法返回结果的foreach 中的value 有哪些可以调用的方法的时候，查看这个value 的类，然后查看这个类有哪些方法，比如getClass()-&gt;name, 就是获取参数提示符（这个参数提示符还是蛮奇怪的，Bag 这种自定义的类可以提示， 但是 string int 这种类却不提示）</p></li><li><p>今天在查看easyswoole源码的时候,发现自己对public protected private 都忘记了,首先public 是最简单的，protected 本类和继承类中可以使用，private只有本类中可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"> class A &#123;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function test1()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected function test2()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function test3()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public function test4()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$b = new B();</span><br><span class="line"></span><br><span class="line">$b-&gt;test1();</span><br><span class="line"></span><br><span class="line">$b-&gt;test4();</span><br><span class="line"></span><br><span class="line">$b-&gt;test2();</span><br><span class="line"></span><br><span class="line">//$b-&gt;test3();</span><br></pre></td></tr></table></figure><p>​</p></li></ul><p>下面<a href="http://www.dahouduan.com" target="_blank" rel="noopener">文章来源</a></p><p>PHP 内置了一组反射类来实现类的反射，常用的有：</p><ul><li>ReflectionClass 解析类</li><li>ReflectionProperty 类的属性的相关信息</li><li>ReflectionMethod 类方法的有关信息</li><li>ReflectionParameter 取回了函数或方法参数的相关信息</li></ul><p>想看全的就翻手册去。</p><p>今天先通过一段演示代码简单看下php的反射到底是个什么东西。</p><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Hero &#123;</span><br><span class="line"></span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    protected $skills = [];</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $skills = []) &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;skills = $skills;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function attack($hero) &#123;</span><br><span class="line">        echo &quot;Attack &#123;$hero-&gt;name&#125;&quot; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function execute($index) &#123;</span><br><span class="line">        echo &quot;Axecute &#123;$index&#125; skill&quot; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ref = new ReflectionClass(&apos;Hero&apos;); // 参数类名</span><br><span class="line"></span><br><span class="line">if ($ref-&gt;isInstantiable()) &#123;</span><br><span class="line">    echo &apos;可以实例化&apos; . PHP_EOL; // 判断是否可以实例化，比如单例或者静态类的存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取类的构造函数</span><br><span class="line">$constructor = $ref-&gt;getConstructor();</span><br><span class="line">print_r($constructor); //ReflectionMethod  E对象</span><br><span class="line"></span><br><span class="line">//获取属性</span><br><span class="line">if ($ref-&gt;hasProperty(&apos;name&apos;)) &#123;</span><br><span class="line">    $attr = $ref-&gt;getProperty(&apos;name&apos;);</span><br><span class="line">    print_r($attr); //ReflectionProperty  对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取属性列表</span><br><span class="line">$attributes = $ref-&gt;getProperties();</span><br><span class="line">foreach ($attributes as $row) &#123;</span><br><span class="line">    //row 为 ReflectionProperty 的实例</span><br><span class="line">    echo $row-&gt;getName() . &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法</span><br><span class="line">if ($ref-&gt;hasMethod(&apos;attack&apos;)) &#123;</span><br><span class="line">    $method = $ref-&gt;getMethod(&apos;attack&apos;);</span><br><span class="line">    //$method 为 ReflectionMethod 的实例</span><br><span class="line">    print_r($method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法列表</span><br><span class="line">$methods = $ref-&gt;getMethods();</span><br><span class="line">foreach ($methods as $row) &#123;</span><br><span class="line">    //这的row 是 ReflectionMethod 的实例</span><br><span class="line">    echo $row-&gt;getName() . PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想知道上面代码的用途，最好的办法就是执行一下，自己打印一遍(如果用xdebug 对这种脚本式的执行是再方便不过了)</p><p>上面例子想表达的效果就是：仅仅通过类名，就能了解类的内部结构，进而去实例化类</p><p>例子2：</p><p>student</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Bag&#123;</span><br><span class="line"></span><br><span class="line">    public function name()&#123;</span><br><span class="line">        return  &quot;学生包&quot;.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">    public $id;</span><br><span class="line"></span><br><span class="line">    public $name;</span><br><span class="line">    public function __construct($id,$name,Bag $bag)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;id = $id;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line">    public function study()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;name.&apos; is learning.....&apos;.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showBag()&#123;</span><br><span class="line">        echo &quot;My bag have &quot;.$this-&gt;bag-&gt;all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">require &apos;student.php&apos;;</span><br><span class="line">function make($class, $vars = []) &#123;</span><br><span class="line">    $ref = new ReflectionClass($class);</span><br><span class="line"></span><br><span class="line">    if(!$ref-&gt;isInstantiable()) &#123;</span><br><span class="line">        throw new Exception(&quot;类&#123;$class&#125; 不存在&quot;); // 感觉这块应该是累不可以实例化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $constructor = $ref-&gt;getConstructor();</span><br><span class="line">    if(is_null($constructor)) &#123;</span><br><span class="line">        return new $class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $params = $constructor-&gt;getParameters();</span><br><span class="line">    $resolveParams = [];</span><br><span class="line">    foreach ($params as $key=&gt;$value) &#123;</span><br><span class="line">        $name = $value-&gt;getName();</span><br><span class="line">        if(isset($vars[$name])) &#123;</span><br><span class="line">            $resolveParams[] = $vars[$name];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $default = $value-&gt;isDefaultValueAvailable() ? $value-&gt;getDefaultValue() : null;</span><br><span class="line">            if(is_null($default)) &#123;</span><br><span class="line">           </span><br><span class="line">                if($value-&gt;getClass()) &#123;</span><br><span class="line">                // 依赖注入的实现，以这个为例子</span><br><span class="line">                // 需要Bag $bag ，却没有传入 bag，自动实例化</span><br><span class="line">                // 如果需要参数，直接在vars 里面加，但感觉参数名称不能和原本的冲突</span><br><span class="line">                    $resolveParams[] = make($value-&gt;getClass()-&gt;getName(), $vars);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new Exception(&quot;&#123;$name&#125; 没有传值且没有默认值。&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $resolveParams[] = $default;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $ref-&gt;newInstanceArgs($resolveParams);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有提供name 值</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提供name 值</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要 Bag ，却没有传入</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">    $stu-&gt;showBag();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到构造函数的第三个参数 <code>$bag</code> ,被自动实例化了，然后传递给了 <code>Student</code> 类的构造函数，这个部分很关键，这个地方可以用来实现依赖注入，我们不必在手动实例化对象了，我们可以根据参数的对应的类来自动实例化对象，从而实现类之间的解耦。</p><p>// 感觉这个解耦就是不用手动去传参数，避免类修改的时候自己大片代码需要修改</p></blockquote><p>例子3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// 这个不能算是容器，容器是反射的一种高级应用，下面的只是反射的一种基础应用</span><br><span class="line">if (PHP_SAPI != &apos;cli&apos;) &#123;</span><br><span class="line">    exit(&apos;Please run it in terminal!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">if ($argc &lt; 3) &#123;</span><br><span class="line">    exit(&apos;At least 2 arguments needed!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">$controller = ucfirst($argv[1]) . &apos;Controller&apos;;</span><br><span class="line">$action = &apos;action&apos; . ucfirst($argv[2]);</span><br><span class="line">// 检查类是否存在</span><br><span class="line">if (!class_exists($controller)) &#123;</span><br><span class="line">    exit(&quot;Class $controller does not existed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 获取类的反射</span><br><span class="line">$reflector = new ReflectionClass($controller);</span><br><span class="line">// 检查方法是否存在</span><br><span class="line">if (!$reflector-&gt;hasMethod($action)) &#123;</span><br><span class="line">    exit(&quot;Method $action does not existed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 取类的构造函数</span><br><span class="line">$constructor = $reflector-&gt;getConstructor();</span><br><span class="line">// 取构造函数的参数</span><br><span class="line">$parameters = $constructor-&gt;getParameters();</span><br><span class="line">// 遍历参数</span><br><span class="line">foreach ($parameters as $key =&gt; $parameter) &#123;</span><br><span class="line">    // 获取参数声明的类</span><br><span class="line">    $injector = new ReflectionClass($parameter-&gt;getClass()-&gt;name);</span><br><span class="line">    // 实例化参数声明类并填入参数列表</span><br><span class="line">    $parameters[$key] = $injector-&gt;newInstance();</span><br><span class="line">&#125;</span><br><span class="line">// 使用参数列表实例 controller 类</span><br><span class="line">$instance = $reflector-&gt;newInstanceArgs($parameters);</span><br><span class="line">// 执行</span><br><span class="line">$instance-&gt;$action();</span><br><span class="line">class HelloController</span><br><span class="line">&#123;</span><br><span class="line">    private $model;</span><br><span class="line">    public function __construct(TestModel $model)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;model = $model;</span><br><span class="line">    &#125;</span><br><span class="line">    public function actionWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;model-&gt;property, PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TestModel</span><br><span class="line">&#123;</span><br><span class="line">    public $property = &apos;property&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（以上代码非原创）将以上代码保存为 <code>run.php</code></p><p>（以上代码非原创）将以上代码保存为 <code>run.php</code><br>运行方式，在终端下执行<code>php run.php Hello World</code></p><p>可以看到，我们要执行 <code>HelloController</code> 下的 <code>WorldAction</code>,</p><p>可以看到，我们要执行 <code>HelloController</code> 下的 <code>WorldAction</code>,<br><code>HelloController</code> 的构造函数需要一个 <code>TestModel</code>类型的对象,</p><p>通过php 反射，我们实现了, <code>TestModel</code> 对象的自动注入，</p><p>上面的例子类似于一个请求分发的过程,是路由请求的分发的一部分，假如我们要接收一个请求 地址例如： <code>/Hello/World</code></p><p>意思是要执行 <code>HelloController</code> 下的 <code>WorldAction</code> 方法。</p></blockquote><p>上面的例子有个最大的缺陷就是所有类写在一个文件中，导致没有使用bind 也不会出错 （注意container 中没有自动加载）</p><p>发现：感觉依赖注入的类的参数都是空的，都是直接就能实例化的那种</p><p>感觉上面那个发现并不多</p><p>控制反转：就是通过一个container 容器去解决依赖关系，把类的实例化从类的内部改成从外部传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public function buy($obj)</span><br><span class="line">    &#123;</span><br><span class="line">       // $obj = new Car(); 改成依赖注入的模式</span><br><span class="line">        $obj-&gt;pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个obj 我们不希望手动传入，希望可以帮我们自动生成，于是就出现了依赖注入（通过类的反射实例化类，但这个类我们要提前绑定到容器中，要不然可能找不到，我们的容器可没有自动加载机制，容器一般有两个方法bind 和 make, bind 一般是 一个类的标识 和一个匿名函数，make 实例化这个类的标识，执行之前绑定的匿名函数，这就是最简单的container）</p><p>能解决的问题：</p><p>当我们把依赖类通过注入的方式传入的时候，我们可以只是传入这个类的类型（接口），当我们使用的时候可以在这个容器中为这个类型不同的实体类，达到switch 切换的效果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事背景：在做文件上传的时候，对图片的上传和视频的上传走的是相同的接口，可是视频和图片有些参数是不同的，于是通过一个基类base,扩展出多个子类，image,video ···上传类，根绝参数的不同调用不同类的upload方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单点说反射的就是让你拥有剖析类、函数的能力。&lt;/p&gt;
&lt;p&gt;有的同学可能会问我剖析类有什么用，我为什么要学反射，我只能说不学反射并不会对你实现业务有任何影响，但是如果你想写出结构优雅的程序，想写出维护性和扩展性都很高的程序，学习反射是必不可少的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Laravel 中依赖注入用的就是反射。&lt;a href=&quot;http://www.dahouduan.com/2017/08/21/php-refleciton-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>小程序</title>
    <link href="http://yoursite.com/2019/02/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/25/小程序/</id>
    <published>2019-02-25T10:15:03.000Z</published>
    <updated>2019-07-31T08:41:17.456Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了下小程序的编写，理由：</p><ol><li>vue 还有 react 没学会，小程序是真的简单 ，类似后台模板引擎</li><li>微信不会弹广告，vue或者react 编写的webapp 在一些安卓手机浏览器上，比如魅族自带的浏览器，访问的时候会有很多广告的出现</li><li>不用记域名，之前在做itbasic的时候，就发现大家都记不住域名，导致pc端还好，大家可以收藏域名，手机端完全不会去使用</li><li>练习js, 熟悉es6<br>这篇文章的目的不是介绍小程序的简单使用，只是想记录下容易忽略的知识点（包括es6中），完成了项目的时候才发现，<strong>代码是练出来的，而不是看出来的</strong><a id="more"></a></li></ol><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7561415645624765844.png" alt="image.png"></p><h6 id="app-wxss"><a href="#app-wxss" class="headerlink" title="app.wxss"></a>app.wxss</h6><p> 是全局样式文件，比如我们想让每个page页面的背景色从白色变成灰色，可以在这里面定义，又比如我们对iconfont 的使用。</p><h6 id="iconfont-的使用"><a href="#iconfont-的使用" class="headerlink" title="iconfont 的使用"></a>iconfont 的使用</h6><p>我们在编写前端页面的时候经常会需要小图标，现在比较流行iconfont, 我们在阿里的那个官网上选择好图标<img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3152415645624767823.png" alt="image.png"><br>然后选择添加至项目<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1989115645624770024.png" alt="image.png"></p><p>选择项目名称<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7890515645624772404.png" alt="image.png"></p><p>选择font class ,在线链接，查看线上地址，复制所有css ,保存到本地，然后在这个全局css 中引入，就可以全局使用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;styles/iconfont.wxss&apos;;</span><br></pre></td></tr></table></figure></p><p>我们通过修改font-size 和 color 可以修改图标的大小和颜色（毕竟实际上这些图标都是字体）</p><h6 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h6><p>主要是页面pages 路径的配置，一些基础配置，tabBar (注意tabBar 没有对应的pages ，pages页面上是不会显示tabBar的)， 引入的组件如果想全局使用，也可以在这个页面上配置</p><h5 id="components"><a href="#components" class="headerlink" title="components"></a>components</h5><p>编写的组件位置，其实和pages文件夹差不多，感觉就是组件里面文件一般用index 命名，而pages 里面一般用文件夹名称命名</p><p>其他的文件夹都是可以自己定义的，其实小程序只是给了一个标准的最简单的项目目录，很多时候都可以自己定义文件夹，然后引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">引入 js</span><br><span class="line">import &#123;config&#125; from &apos;../config.js&apos;</span><br><span class="line"></span><br><span class="line">这个config.js 中被引入的内容需要在文件中导出</span><br><span class="line">const config = 4;</span><br><span class="line">export &#123;config&#125;</span><br><span class="line"></span><br><span class="line">感觉和PHP 不一样的地方就是php 一般都是include 文件，而不是对具体变量的引入和导出，当然现在很多时候php 一个文件就是一个class,也是类似一个变量的存在</span><br></pre></td></tr></table></figure></p><h2 id="小程序知识"><a href="#小程序知识" class="headerlink" title="小程序知识"></a>小程序知识</h2><h6 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h6><p>页面，<br>wx:if , wx:for  去判断，循环页面元素，<br>rpx 是小程序上的计量单位，没听懂，反正知道通过使用它，可以实现页面的自适应<br>flex 页面布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">flex-direction: row;</span><br><span class="line">just-content: (主轴) row 横着排列（横 主 纵 副）column (纵 主 横 副) space-between 等（todo: flex 均分怎么实现）</span><br><span class="line">align-item: （副轴）</span><br></pre></td></tr></table></figure></p><p>positon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position:relative (相较于自身)</span><br><span class="line">position:absolute(因为一般只有固定在底部或者首部用到，所以一般这样定位的话就是相对于页面)</span><br></pre></td></tr></table></figure></p><p>目前用到的元素：view ,image(类似view)<br>绑定点击事件 bind:tap, bind:like<br>引入组件：在该pages json 文件中引入，或者全局json 中引入，（父组件给子组件传值通过属性）然后用组件名称使用，在父组件上定义属性，传入子组件定义的data中（子组件给父组件传值通过事件，子组件抛出事件，触发父组件绑定的事件）</p><h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><p>let 新的定义变量方式，if 或者 for 中定义的，外面获取不到<br>const 不能改变的量<br>onLoad 方法中一般写入初始化的时候对后台接口的请求（蛋疼的就是经常页面加载的时候出现抖动，当返回数据比较慢的时候）<br>自定义的方法就写在最外层就好了<br>data : 定义页面中的值，初始化<br>setData :改变页面中的值<br>wx.getStorage()  感觉这些就是类似调用系统接口，应该安卓和ios 中用的比较多，这是微信封装的，注意其中的同步和异步之分</p><h3 id="推荐组件"><a href="#推荐组件" class="headerlink" title="推荐组件"></a>推荐组件</h3><p>vant 有赞出的小程序组件，只有用过小程序原生组件才会知道vant 用起来有多么方便，npm 安装</p><p>值的注意的是：事件 event.detail 能获取到这个组件本身，之前我们经常用event.detail.value 获取组件传递的值，通过event.detail去调用组件自身的一些方法，比如日期picker 上显示的日期大小</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了下小程序的编写，理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vue 还有 react 没学会，小程序是真的简单 ，类似后台模板引擎&lt;/li&gt;
&lt;li&gt;微信不会弹广告，vue或者react 编写的webapp 在一些安卓手机浏览器上，比如魅族自带的浏览器，访问的时候会有很多广告的出现&lt;/li&gt;
&lt;li&gt;不用记域名，之前在做itbasic的时候，就发现大家都记不住域名，导致pc端还好，大家可以收藏域名，手机端完全不会去使用&lt;/li&gt;
&lt;li&gt;练习js, 熟悉es6&lt;br&gt;这篇文章的目的不是介绍小程序的简单使用，只是想记录下容易忽略的知识点（包括es6中），完成了项目的时候才发现，&lt;strong&gt;代码是练出来的，而不是看出来的&lt;/strong&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>框架学习-获取请求参数</title>
    <link href="http://yoursite.com/2019/02/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2019/02/25/框架学习-获取请求参数/</id>
    <published>2019-02-25T06:51:45.000Z</published>
    <updated>2019-07-31T08:41:22.755Z</updated>
    
    <content type="html"><![CDATA[<p>PHP属于一门高级语言，感觉就是那种语言里面偏向于应用层的语言，再加上lnmp架构还有框架的存在，对于http请求过程中的细节封装了太多层，导致我们实际在使用过程中得到的参数已经是面目全非的样子，记录下对其探索的历程</p><a id="more"></a><p>问题出现在很久之前，有一次我用json数据去请求我们itbasic的接口，可惜没法解析，我原本以为是框架的原因，于是我开始打印$_POST中数据(post 方式提交)，可是其中也是毫无结果，算了，不处理了，搞不定，反正用不到~昨天，前端小朋友再次发现这个问题，感觉很简单，为了维护自己的高大形象，就处理下吧。</p><p>首先是关于content-type 的理解：</p><blockquote><p>一般是指网页中存在的Content-Type，Content-Type属性指定请求和响应的HTTP内容类型。如果未指定 ContentType，默认为text/html。</p></blockquote><p>上述问题中为什么会出现指定请求和响应的HTTP内容类型，因为content-type 在request中可以设置，在response中也可以设置，在request 中设置代表我发送的请求，在response中的设置代表从服务器返回的内容。</p><p>常见的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.text/html</span><br><span class="line">2.text/plain</span><br><span class="line">3.text/css</span><br><span class="line">4.text/javascript</span><br><span class="line">5.application/x-www-form-urlencoded</span><br><span class="line">6.multipart/form-data</span><br><span class="line">7.application/json</span><br><span class="line">8.application/xml</span><br></pre></td></tr></table></figure><p>我们在接口调用的时候常用的是后面4个</p><h3 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h3><blockquote><p>会将表单内的数据转换拼接成 key-value 对（非 ASCII 码进行编码）</p><p>编码方式应该是urlencode</p></blockquote><p>还记得自己刚写php代码时候吗，那时候最基础的功能是实现一个表单提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form enctype=&quot;application/x-www-form-urlencoded&quot; action=&quot;http://homeway.me/post.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;homeway&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;key&quot; value=&quot;nokey&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后服务器端就可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$name = $_POST[&apos;name&apos;];</span><br><span class="line">$key = $_POST[&apos;key&apos;]</span><br></pre></td></tr></table></figure><p>实际接收到的内容（通过swoole rowContent 打印出来，获取原始的<code>POST</code>包体，用于非<code>application/x-www-form-urlencoded</code>格式的<code>Http POST</code>请求，返回原始<code>POST</code>数据，此函数等同于PHP的<code>fopen(&#39;php://input&#39;)</code>）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6376115645624808334.png" alt="image.png"></p><p>所以其实$_POST 就是对上述dept_name 进行 &amp; explode, 然后urldecode 一下</p><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>最先接触这个东西的时候是文件上传的时候</p><blockquote><p><form> 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。</form></p></blockquote><p>postman 中发送请求</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/585115645624810549.png" alt="image.png"></p><p>平时我测试接口的时候经常用的是form-data, 服务端实际接受到的数据如下(swoole)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件</span><br><span class="line">这种方式不会对中文进行编码</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8569915645624812587.png" alt="image.png"></p><blockquote><p>既可以上传文件等二进制数据，也可以上传表单键值对，</p></blockquote><p>所以本该用来进行上传文件的请求方式，我平时用它来进行普通接口的测试，通过这种方式提交数据也可以通过PHP 的 $_POST 来获取到    ，上述中的boundary用来分割数据</p><p>看到了postman 上面的raw吗</p><blockquote><p>raw 原始类型，可以上传任意格式的文本，比如 text、json、xml、html（中文不进行编码）</p></blockquote><p>其中 json,text,html 都是通过这种方式，然后添加content-type</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7545215645624814697.png" alt="image.png"></p><h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>微信中经常用这种方式，之前在开发企业号的时候经常遇到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.homeway.me HTTP/1.1 </span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">    &lt;id&gt;123&lt;/id&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;name&gt;</span><br><span class="line">            &lt;value&gt;homeway&lt;/value&gt;</span><br><span class="line">        &lt;/name&gt;</span><br><span class="line">        &lt;age&gt;</span><br><span class="line">            &lt;value&gt;22&lt;/value&gt;</span><br><span class="line">        &lt;/age&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure><blockquote><p>php中<code>$_POST</code>只能读取<code>application/x-www-form-urlencoded</code>数据，<code>$_FILES</code>只能读取<code>multipart/form-data</code>类型数据，(感觉$_POST 也能读取multipart/form-data 中的数据)</p></blockquote><p>要读取那里面的数据只能用最原始的方法(同理json)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = file_get_contents(‘php://input’);</span><br><span class="line">$request-&gt;rawContent() // swoole</span><br></pre></td></tr></table></figure><p>notice:</p><blockquote><p>一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。(我根据这个新增框架中json 数据的解析)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$getArr = static::$request-&gt;get;</span><br><span class="line">        $getArr = count($getArr) &gt; 0 ? $getArr : [];</span><br><span class="line"></span><br><span class="line">        $postArr = static::$request-&gt;post;</span><br><span class="line">        $postArr = count($postArr) &gt; 0 ? $postArr : []; //后面的覆盖前面的，所有post写在后面</span><br><span class="line"></span><br><span class="line">        if (isset(static::$request-&gt;header[&apos;content-type&apos;])) &#123;</span><br><span class="line">            if (static::$request-&gt;header[&apos;content-type&apos;] == &apos;application/json&apos;) &#123;</span><br><span class="line">                $rawContent = static::$request-&gt;rawContent() ?: &apos;&apos;;</span><br><span class="line">                $rawContent = json_decode($rawContent, true);</span><br><span class="line">                $postArr    = array_merge($postArr, $rawContent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return array_merge($getArr, $postArr);</span><br></pre></td></tr></table></figure><p>notice:</p><p>千万要注意：不能上来没有判断是json 就对rawContent 取到的内容进行切割，因为只有json 的时候切割才会符合我们预期，别的时候不会</p><p>上面就是post方式提交数据的几种情况，接下来我们说get方式（现在的restful api 还有delete put 等方式，我在各个文章上都没找到关于上面内容的解释，猜测一下，是不是delete put 本质上还是属于put 方式）</p><p>起因：之所以注意到get请求的这种方式，是因为再一次偶然的过程中发现get 请求的content-type 不存在，想了下确实合乎道理，get的参数都是拼接在url 上面 （file_get_contents(‘php://input’) 只能获取post请求中的输入）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4666915645624818122.png" alt="image.png"></p><p>注意就算是urlencode 加密，他们都是有字符编码的限制的，如果字符编码不一致，那么加密出来的结果将会不一样</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7052815645624820177.png" alt="image.png"></p><p>同理可以联想之前做的aes-128-ecb 加密，为什么有那么多可选项，也是这个原因</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8406415645624822588.png" alt="image.png"></p><p><a href="https://blog.csdn.net/andyzhaojianhui/article/details/5181902" target="_blank" rel="noopener">这篇文章对于编码的解释很透彻</a></p><p><a href="https://segmentfault.com/a/1190000015800019" target="_blank" rel="noopener">这篇文章和上面那篇文章都有简单描述urlencode是怎么实现的</a></p><p>(这篇文章中的很多坑我们写的时候没有碰到是因为很多默认配置的原因，比如php 字符集默认配置utf8,页面配置字符集 utf-8)</p><p>所以呢在通过get 方式传递参数的时候，我们一定要注意那些中文字符 urlencode 的时候（或者别的编码方式的时候设置的字符集是什么，是gbk 还是utf8,我们忽略这个问题是因为我们经常就默认都设置成utf8 导致很多时候这些细节会被忽略）</p><p>同理联想php中也有urlencode 函数，他的字符集是怎么设置的</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4356115645624825068.png" alt="image.png"></p><p>所以呢，当我们出现乱码的时候我们还可以这样考虑下：</p><ol><li>客户端传递过来的数据进行了怎么样的加密（字符集），get方式，post方式中的www-formedate-urlencode</li><li>服务端传递过来的数据进行了怎么样的解密（字符集）</li></ol><blockquote><p>在post方法里所要传送的数据也要URL encode，那么他是用什么编码方式的呢？<br>   在form所在的html文件里如果有段<meta http-equiv="Content-Type" content="text/html; charset=字符集（GBK，utf-8等）">，那么post就会用此处指定的编码方式编码。一般大家都认为这段代码是为了让浏览器知道用什么字符集来对网页解释，所以网站都会把它放在html代码的最前端，尽量不出现乱码，其实它还有个作用就是指定form表单的post方法提交数据的 URL encode编码方式。从这里可以看出对于get方法来说，浏览器对数据的URL encode的编码方式是有浏览器设置来决定(或者在请求之前，我们提前对非asii码进行编码设置，这样决定权就从浏览器变成我们开发者)，（可以用js做统一指定），而post方法，开发人员可以指定。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP属于一门高级语言，感觉就是那种语言里面偏向于应用层的语言，再加上lnmp架构还有框架的存在，对于http请求过程中的细节封装了太多层，导致我们实际在使用过程中得到的参数已经是面目全非的样子，记录下对其探索的历程&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="框架，HTTP" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6%EF%BC%8CHTTP/"/>
    
  </entry>
  
  <entry>
    <title>加密解密</title>
    <link href="http://yoursite.com/2019/02/21/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>http://yoursite.com/2019/02/21/加密解密/</id>
    <published>2019-02-21T03:50:59.000Z</published>
    <updated>2019-07-31T08:41:16.578Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个底层码农，其实加密解密平时是用不到的，毕竟平时写的就是cms 的curd, 但随着API的流行以及老大对代码质量的重视，还有和别的部门的交互，于是需要加解密啦。<a href="https://t.ti-node.com/thread/6497068236977209344" target="_blank" rel="noopener">原文</a></p><a id="more"></a><p>hash 和 加解密 </p><p>hash :  md5, sha1, hamc</p><p>加解密：base64, aes</p><p>用途：</p><p>hash ： 因为不能解密，所以一般用在签名过程中，怎么验证是否数据被用户修改了呢，用相同的密钥对于传递过来的数据重新加密一遍，和sign 比对，如果相等，那就没有人修改签名(注意这个密钥一定不能被知道，因为一旦被知道，劫持者可以根据密钥帮修改后的数据生成对应sign, 起不到保护的作用)</p><p><a href="https://blog.csdn.net/dengjiexian123/article/details/53313913" target="_blank" rel="noopener">这篇文章是关于上面3种hash的解释</a></p><p>md5: 经常用到，有时候我们需要固定长度的字符串，就可以用md5加密一下,md5 可以生成32位或者64位，依据不同的算法，js 好像经常出64位的，和php对接的时候要注意一下</p><p>sha1: 感觉和上面的md5类似（感觉就是两种不同的加密算法）</p><blockquote><p>其实跟前面的MD5同期的还有一个SHA1加密方式的，不过也是算法比较简单，所以这里就一笔带过吧。而这里即将要说到的<code>SHA256</code> 和 <code>SHA512</code>都是来自于SHA2家族的加密函数，看名字可能你就猜的出来了。</p></blockquote><p>hmac: hmac 其实就是用上面两种算法（hmac-sha256, hmac-md5），再加上一个密钥进行加密（这个密钥感觉又类似salt 的存在）</p><p>bcrypt : <a href="https://www.jianshu.com/p/2b131bfc2f10" target="_blank" rel="noopener">关于bcrypt 这里有个解释很清楚</a>， 感觉上其实就是另一种算法的hash</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712143357.png" alt=""></p><p>我之前很好奇这种hash, 怎么验证，也不能解密呀，当看到上面这张图片的时候，完全明白了，他的salt 存在了他加密后的字符串中，有了salt 就和以前的md5加解密一样了(注意上面各个字段的意思，10代表hash 10次)，php现在经常用的一种加密密码的方式也很好用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5(‘123456’) e10adc3949ba59abbe56e057f20f883e </span><br><span class="line">md5(‘123456’ . ($salt = ‘salt’)) 207acd61a3c1bd506d7e9a4535359f8a </span><br><span class="line">sha1(‘123456’) 40位密文 </span><br><span class="line">hash(‘sha256’, ‘123456’) 64位密文  // sha2</span><br><span class="line">hash(‘sha512’, ‘123456’) 128位密文 // sha2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$str = password_hash(123, PASSWORD_DEFAULT);  //默认 bcrypt， PASSWORD_DEFAULT 也代表了 PASSWORD_BCRYPT.二者都是1</span><br><span class="line">password_verify(123, $str); // 验证</span><br><span class="line"></span><br><span class="line">password_hash() – 对密码加密.</span><br><span class="line">password_verify() – 验证已经加密的密码，检验其hash字串是否一致. </span><br><span class="line">password_needs_rehash() – 给密码重新加密. // 其实感觉没啥必要，主要是因为感觉algo或者cost hash次数改变就会改变</span><br><span class="line">password_get_info() – 返回加密算法的名称和一些相关信息.</span><br></pre></td></tr></table></figure><p><a href="https://www.codecasts.com/blog/post/php-password-hash-in-the-right-way" target="_blank" rel="noopener">这篇文章php的password api说的挺好的</a></p><blockquote><h2 id="散列消息身份验证码-Hashed-Message-Authentication-Code-。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥-秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。"><a href="#散列消息身份验证码-Hashed-Message-Authentication-Code-。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥-秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。" class="headerlink" title="散列消息身份验证码 Hashed Message Authentication Code 。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥/秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。"></a>散列消息身份验证码 Hashed Message Authentication Code 。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥/秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。</h2><p>HMAC-SHA1简要来说，就是采用sha1算法，与HMAC机制相结合，制造出更加难以破解的加密串。</p><p>hash_hmac</p><p>在php中hash_hmac函数就能将HMAC和一部分哈希加密算法相结合起来实现HMAC-SHA1  HMAC-SHA256 HMAC-MD5等等算法。函数介绍如下：</p><p>string hash_hmac(string $algo, string $data, string $key, bool $raw_output = false)</p><p>algo：要使用的哈希算法名称，可以是上述提到的md5,sha1等</p><p>data：要进行哈希运算的消息，也就是需要加密的明文。</p><p>key：使用HMAC生成信息摘要是所使用的密钥。</p><p>raw_output：该参数为可选参数，默认为false，如果设为true，则返回原始二进制数据表示的信息摘要，否则返回16进制小写字符串格式表示的信息摘要（注意是16进制数，而非简单的字母加数字）。</p></blockquote><p>加解密：数据</p><p>base64:</p><p>base64_encode</p><p>base64_decode</p><p>(感觉url_encode 也不能算是加密，只能算是字符转换，因为那个转换之后得到的内容基本都能分辨出来)</p><p>这种最原始的方式，因为不需要密钥，感觉不能算上加解密，确实在各个网站上也是这么感觉的</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712150709.png" alt=""></p><p>首先的区分下加解密和hash 的不同，对于md5() 这样加密之后理论上就不能解密的方式，我们一般称之为hash,在我们以往的网站编程中，对于用户的密码保存一般都是通过hash这种方式，通过把用户的密码拼接一个字符串，然后md5下生成的值保存到数据库中，下次用户登陆的时候，再次把用户输入的密码做上次同样的操作，对比和数据库中值是否一致，如果一致说明密码正确，否则密码错误。</p><p>加密我们平时生活中遇到最多的应该就是https 解析过程，因为非对称加密太消耗性能，所以我们传输过程需要对称加密（对称加密就是加密密钥和解密密钥一致，非对称反之），而对于密钥的传输我们用的是非对称（非对称因为密钥的不同又有公钥和私钥之分：公钥加密，私钥解密，数据不会被获取；私钥加密，公钥解密，数据不会被篡改）。</p><p>对称加密算法一般有AES(itbasic 请求datrix 那边用的就是这种，ecb 没有$iv 偏移量，cbc 有偏移量 ),DES,3DES，非对称有RSA</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712235429.png" alt=""></p><p>上图中，123456 就是对称加密过程中的密钥</p><blockquote><p>最一开始的时候，我朝人民一般都是倾向于使用“天王盖地虎”，“宝塔镇河妖”这种加解密技术；然而，美帝用了一种叫做DES的技术进行对称加解密，这玩意一度成为业界通用的对称加解密技术，银行、五角大楼都爱用这玩意，可惜好景不长、世风日下、世态炎凉，这玩意的破解成本越来越低越来越低～～ 于是，为了续命，就又有一些白胡子老头给DES打补丁，缝缝补补搞出来一个玩意叫做3DES，继续用，又不是不能用…这个顾名思义就行了，别打我，真的：3DES就是用DES处理（注意是处理，我没说是加密）了三次的意思。就目前看来，3DES实际上用的可能也并不是十分广泛了，所以如果大家在选择对称加解密技术的时候，尽量避开DES和3DES就可以了。</p><p>呵呵，喜新厌旧的沙雕人类…虽然DES已经没人用了，但毕竟也是辉煌过，我觉得还是得动手表演一波儿。我们知道，<strong>在php7里，原来的mcrypt系列加解密已经被放弃掉了，官方建议我们使用openssl系列来进行加解密</strong>，所以确保你的PHP环境里安装了openssl标准扩展。</p></blockquote><p>上面是原文中对于DES 和 3DES 的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 这个函数打印出来openssl支持的所有加密方法以及模式的组合</span><br><span class="line">$arr_ava_methods = openssl_get_cipher_methods(true);</span><br><span class="line">print_r( $arr_ava_methods );</span><br><span class="line">exit;</span><br><span class="line">// 返回值</span><br><span class="line">    [123] =&gt; aes-192-cfb8</span><br><span class="line">    [124] =&gt; aes-192-ctr</span><br><span class="line">    [125] =&gt; aes-192-ecb</span><br><span class="line">    [126] =&gt; aes-192-gcm</span><br><span class="line">    [127] =&gt; aes-192-ocb</span><br><span class="line">    [128] =&gt; aes-192-ofb</span><br><span class="line">    [129] =&gt; aes-256-cbc</span><br><span class="line">    [130] =&gt; aes-256-ccm</span><br><span class="line">    [131] =&gt; aes-256-cfb</span><br><span class="line">    [132] =&gt; aes-256-cfb1</span><br><span class="line">    [133] =&gt; aes-256-cfb8</span><br><span class="line">    [134] =&gt; aes-256-ctr</span><br></pre></td></tr></table></figure><blockquote><p>其中带有ede的，比如des-ede*这样的就表示是3DES</p></blockquote><p>其中des 有如下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">des-cbc</span><br><span class="line">des-cfb*（注意后面的通配符星号）</span><br><span class="line">des-ecb</span><br><span class="line">des-ofb</span><br></pre></td></tr></table></figure><p>下面是如何通过des-ecb 的方式加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 我们就选用des-ecb方法进行一次des加密</span><br><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">$my_method   = &apos;des-ecb&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123;</span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">$key  = &quot;123456&quot;;</span><br><span class="line">$data = &quot;helloMOTO&quot;;</span><br><span class="line">echo &quot;明文：&quot;.$data.PHP_EOL;</span><br><span class="line">$enc_data  = openssl_encrypt( $data, $my_method, $key );</span><br><span class="line">echo &quot;密文：&quot;.$enc_data.PHP_EOL;</span><br><span class="line">$dec_data  = openssl_decrypt( $enc_data, $my_method, $key );</span><br><span class="line">echo &quot;明文：&quot;.$dec_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">明文：helloMOTO</span><br><span class="line">密文：IbpWiZbAoNMiknX3jdeqmQ==</span><br><span class="line">明文：helloMOTO</span><br></pre></td></tr></table></figure><p>接下来我们说说aes 的加密方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">// 选用aes-128-ecb</span><br><span class="line">$my_method   = &apos;aes-128-ecb&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123; </span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">// 加密用的密码</span><br><span class="line">$key  = &quot;1234567812345678&quot;;</span><br><span class="line">// 加密的内容</span><br><span class="line">$data = &quot;12345678abcdxxoo12345678abcdxxoo&quot;;</span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA );</span><br><span class="line">$hex = bin2hex( $enc_data );</span><br><span class="line">echo $hex.&apos; : &apos;.strlen( $hex ).PHP_EOL;</span><br></pre></td></tr></table></figure><p>aes-128-ecb, 其中128代表密钥的长度，多余的长度会被直接街去掉(这个可以通过代码验证下，比如12345 用密钥1234567812345678和12345678123456789分别加密，看结果是否一样，最后再用不满128bit来加密123456781234567 )，128bit</p><p>128/8=16 位，aes-192-ecb, aes-256-ecb, 这其中的192 ，256，都是同样的意思。</p><blockquote><p>最后一个参数是OPENSSL_RAW_DATA，如果选用这个option的话，经过加密后的数据会是奇怪的二进制数据，无法直接通过文本方式查看，所以要看的话必须先使用bin2hex函数处理一下。</p></blockquote><p>上面这段话一定要注意理解，反正我第一次没有理解，导致第一次加密数据失败，网上的很多aes-128-ecb 这种加密代码的封装中都携带着自己的逻辑，所以会误导视野。上述opensssl_encrypt(),如果没有用最后一个参数，直接返回的结果是加密结果base64 的结果，如果有了，返回的是一段奇怪的二进制数据数据，这里我们可以理解成原始数据（加密数据最原始的样子），我们可以通过base64或者 bin2hex 转换城对应的base64格式或者16进制格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">明文：</span><br><span class="line">12345678abcdxxoo12345678abcdxxoo</span><br><span class="line">密文：c1391e34caf38f8c2a477cbda3772533c1391e34caf38f8c2a477cbda3772533d96aa42b59151a9e9b5925fc9d95adaf</span><br><span class="line">// 上面密文切分的结果</span><br><span class="line">c1391e34caf38f8c2a477cbda3772533 | c1391e34caf38f8c2a477cbda3772533 | d96aa42b59151a9e9b5925fc9d95adaf</span><br><span class="line"></span><br><span class="line">难道说明文“12345678abcdxxoo”被密钥“1234567812345678”加密后后的密文就是“c1391e34caf38f8c2a477cbda3772533”？</span><br><span class="line"></span><br><span class="line">DES和3DES会将明文以64bit（8字节）作为一个单元进行分组；</span><br><span class="line">AES则会将明文以128bit（16字节）作为一个单元进行分组；</span><br><span class="line">无论是AES还是DES，当最后一个分组的数据长度不满足分组标准长度的时候，会用某种填充方式进行填充；</span><br><span class="line">AES对一个16字节分组加密完毕后，分组大小依然为16字节；DES也一样</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712235458.png" alt=""></p><p>上面就是aes ecb 的处理过程</p><p>如果我们把加密的内容分组之后稍微修改下分组顺序再解密，可以得到原文分组顺序的不同</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712235511.png" alt=""></p><p>ecb太不靠谱了，竟然能修改，出现了cbc 模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">$my_method   = &apos;aes-128-cbc&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123;</span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">// 密钥 和 明文</span><br><span class="line">$key  = &quot;1234567812345678&quot;;</span><br><span class="line">$data = &quot;12345678abcdxxooxxooabcd12345678i&quot;;</span><br><span class="line">// 每种方法都有自己需要的iv向量的长度</span><br><span class="line">$iv_length = openssl_cipher_iv_length( $my_method );</span><br><span class="line">// 根据长度生成相应iv</span><br><span class="line">$iv        = openssl_random_pseudo_bytes( $iv_length, $cstrong ); // 我就是一直把这玩意当成一个随机的字符串看待的，他真的就是一个随机字符串</span><br><span class="line">echo &quot;明文：&quot;.$data.PHP_EOL;</span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA, $iv );</span><br><span class="line">$dec_data = openssl_decrypt( $enc_data, $my_method, $key, OPENSSL_RAW_DATA, $iv );</span><br><span class="line">echo &quot;解密：&quot;.$dec_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line">// 神器的代码</span><br><span class="line">test2(1,$c); // 这样竟让不会报错</span><br><span class="line">function test2 ($a, &amp;$b) &#123;</span><br><span class="line">        var_dump($a+$b, $b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>今天和我司员工对接cbc模式，~~不出意外，这条产品线的小伙伴也是在网上copy网上代码，结果直接没有给我iv向量，没有iv向量怎么可以解密呢，哈哈哈，其实之前我也不知道解密需要iv，我以为这个iv是包自带的，不需要我们管，但是当我在网上的在线平台使用的时候，发现cbc必须填写iv向量，最少还是16个字节，也就是16个英文字符（吐槽一下php自身生成的那个应该是二进制，需要转换一下，否则根本复制不下来，复制下来也不是16个字符长度），怎么办呢，这时候我逐渐意识到是不是加解密还需要iv,老李代码中反正有，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA, $iv ); // 加密</span><br><span class="line">$dec_data = openssl_decrypt( $enc_data, $my_method, $key, OPENSSL_RAW_DATA, $iv ); // 解密</span><br></pre></td></tr></table></figure><p>其实老李上面那段代码也写了注释，把iv当做一个随机的字符串，看来真的可能需要iv,这时候就开始翻他的go代码，但是他的go代码中没有传递iv变量这个值呀，看到了下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])</span><br></pre></td></tr></table></figure><p>~~对了，就是这个 这个key[:blocksS]，这个就是iv,怪不得他不用传递，原来是约定的,</p><blockquote><h2 id="初始化向量-IV"><a href="#初始化向量-IV" class="headerlink" title="初始化向量(IV)"></a><a href="http://blog.csdn.net/xiaohu50/article/details/51682849" target="_blank" rel="noopener">初始化向量(IV)</a></h2><p><a href="http://blog.csdn.net/xiaohu50/article/details/51682849" target="_blank" rel="noopener">http://blog.csdn.net/xiaohu50/article/details/51682849</a></p><p>初始化向量（IV，Initialization Vector）是许多工作模式中用于随机化加密的一块数据，因此可以由相同的明文，相同的密钥产生不同的密文，而无需重新产生密钥，避免了通常相当复杂的这一过程。</p><p>初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。</p><p>因为刚做了一个接口的用户信息加解密，加密至URL，然后那边后台解析，一开始IV不一致老是有一个参数解析不了，后来问同事是IV的问题，所以在这边做个记录，对这个还不是很了解。。。</p><p>如果加解密的IV不一致的话会导致数据不一致，所以解密失败，IV如果不变的话会导致不安全</p></blockquote><p>上面是我在百度go cbc 加解密的时候看到的， 起初还以为go的cbc加密iv有什么特殊化，看来是我多虑了，就像很多时候aes加密本身不需要base64，但很多时候网上代码都加上了，因为默认约定这样好看点，或者字符长度确定了便于存储</p><blockquote><p>这个传说中的iv向量终于他妈出现了！相对于ECB模式，CBC在加密之前多了一个XOR异或运算的环节，但是第一个明文分组和谁做异或呢？所以这个iv向量就是初始化后给第一个明文分组做XOR异或运算用的，第二个明文分组就与第一个密文分组做XOR异或运算，然后再加密得到第二个密文分组…依次重复下去。</p><p>xor 就是异或，相同的取0，不同的取1</p></blockquote><p>总结：</p><blockquote><p>AES和DES以及3DES这种加密方式被称为分组密码，分组密码每次只能加密固定长度的明文，所以如果明文很长的话，就需要轮流为每个分组明文进行加密，AES的分组长度是128bit，而DES的分组长度为64bit；如果一旦需要对多个分组进行轮流加密，加入明文被分成了三个明文分组，那么就需要对三个明文进行迭代加密（粗暴理解就是轮流加密），然而会有很多种不同的迭代方式，这种不同的迭代方式专业名词就叫“模式”，这些模式有：ECB、CBC、OFB、CFB、CTR… …</p><p>对明文进行分组的方式是固定的，唯一不同的就是分组长度不一样而已；模式是指对多个明文从第一个开始轮流加密到最后一个的这个过程，是怎么轮流执行的。</p></blockquote><p>非对称加解密就不copy了，以后用到的时候再看吧</p><p>自己的总结：</p><p>其实上面用到的也就怎么用php 进行aes-128-ecb加密，加密出来的数据让别的语言可以解析出来</p><p>这其中会遇到很多问题，比如之前曾经遇到过但是没有记录的和java通信过程中的padding 填充问题，以后遇到了再补充吧。</p><p>顺带补充一下：</p><p><a href="https://www.devglan.com/online-tools/aes-encryption-decryption" target="_blank" rel="noopener">https://www.devglan.com/online-tools/aes-encryption-decryption</a></p><p>这个网站以及下面的php代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$data = &apos;陈野&apos;;</span><br><span class="line">$key = &apos;1234567812345678&apos;;</span><br><span class="line"></span><br><span class="line">echo $key.PHP_EOL;</span><br><span class="line"></span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA);</span><br><span class="line">echo $enc_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo base64_encode($enc_data).PHP_EOL;</span><br><span class="line"></span><br><span class="line">echo bin2hex( $enc_data );</span><br></pre></td></tr></table></figure><p>默认的填充方式</p><p>pkcs5padding or pkcs7padding (不确定)</p><p>字符集（utf8）</p><p><a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="noopener">http://tool.chacuo.net/cryptaes</a></p><p>上面这个网站才是真正意义上详细的加密，参数可以选择</p><p>今天着重研究了下pkcs5padding 和 pkcs7padding , 网上说的 5p 是7 p的子集， 7p的填充 1 到255 字节都可以， 5p的填充只能 1 到 8字节 ，可是我发现aes 是16字节分组的（不管是 128 还是 256 算法，都是16字节分组），按理说5p只能填充 1到8 那如果只有1个字符的话，怎么填充呢，是填充7个字节还是15字节呢，反正，当我填充15的时候php的openssl nopading  出来的数据和 openssl  raw data 出来的数据是一样的，那么应该就是填充15了</p><p>网上看到7p和5p的区别大致上都是：5p是7p子集，5p只支持到8的block，7p可以支持到255，所以</p><p><a href="https://github.com/keel/aes-cross/blob/master/info-cn/README.md" target="_blank" rel="noopener">这篇文章上说的aes 5p和7p是一样的</a>， 感觉是错的，就是aes没有5p的padding</p><p>关于nopadding， 字面意思上就是不填充，对于aes，不填充的话，必须保证是16字节整数倍，否则会加密失败</p><p>关于zeropadding, php的 openssl 虽然有这个参数，但是要是不满16字节，仍然是会报错，既然这样，zeropadding 感觉和nopadding 就差不多了，实践了一下，果然zero_padding 就是base64了一下no_padding的结果</p><p>关于老版本的加密函数的转换，据说是老版本因为是zero_padding 导致数据出来和新版本不一样，zero_padding ,在末尾填充的是 chr(0), 代表0 这个ascii 对应的 字符，很多网上写的是 \0(很奇怪的是chr(\0)  能得到和 chr(0) 一样的字符，但是这个字符我们键盘是不能表示出来的，  chr(\1) 和 chr(1) 却不一样) ，当我们拼凑到16字节之后，再解密，只需要过滤掉\0这个特殊字符就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 这是php 的7padding ,</span><br><span class="line">function pad($data, $blocksize = 16)</span><br><span class="line">&#123;</span><br><span class="line">    $pad = $blocksize - (strlen($data) % $blocksize);</span><br><span class="line">    return $data . str_repeat(chr($pad), $pad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为最后7padding 最后一个字符肯定是填充的自己长度，所以只需要截取未填充的部分就好</span><br><span class="line"> function unpad($text)</span><br><span class="line">&#123;</span><br><span class="line">    $pad = ord($text[strlen($text) - 1]); // 填充的字符</span><br><span class="line">  // var_dump($pad);</span><br><span class="line">                        </span><br><span class="line">    if ($pad &gt; strlen($text))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">                            </span><br><span class="line">    if (strspn($text, chr($pad), strlen($text) - $pad) != $pad)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">                        </span><br><span class="line">    return substr($text, 0, -1 * $pad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下填充时候的length, 我们计算的时候都是用的strlen, 并不是 中文字符的len</p><p>注意一下，我们没填充之前，已经是一个完整的string, 我们每次填充的内容，都是我们肉眼可以识别的字符，或者说是我们可以处理的字符，所以我们可以裁剪substr， 或者trim过滤掉我们添加的字符</p><p>总结：hash 和 加解密大致就是上面那些东西了，后面jwt 这些认证方式，其实就是 hash 和 加解密的实际运用，本质上并不是一个新的东西</p><p>现在重看， <a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">阮一峰</a> 老师的这篇jwt，讲解的真的好，jwt首先就可以看做一个token,自带token 相比较传统的cookie session,更便于扩展，由客户端自己维持登陆态。缺点token 签发了没法主动让他失效，除非到达失效时间，或者像我们一样添加额外逻辑，token 必须在redis中有对应内容，才能生效。</p><p>jwt token ,是由三个字符串base64加密而成,  因为base64解密不需要密钥，所以我们很容易根据base64解密出来</p><p>第一段是 alg + type. 算法 + 类型（JWT）</p><p>第二段是我们自定义的一个数组，当然可能有些属性是必须的，比如签发时间和过期时间</p><p>第三段是sign，为了防止第二段被别人修改，利用的加密算法是前面的alg (可能更确切的说是hash)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712225542.png" alt=""></p><p>综上：所以事先起来感觉很简单，前面两段都是base64, 就是最后一个用hash，之后再base64, 有个问题就是这块的base64不是普通的base64, base64之后再替换三个字符，我的感觉是怕用户把这个字段连接在url后面当做get请求发送，base64中的参数影响到这个url的正确性</p><p>当我们明白过程之后，我们就很容易自己实现一个jwt，就不需要用网上的加密包了，我们可以看看php的 firebase/php-jwt 包，蛮简单的，默认hsh256, php 的hash_hmac 很容易实现。</p><p>到此为止 ，我们就剩rs256 公钥和私钥没有去研究，以后遇到了再去研究这个firebase的包（从下面也可以看出，hash_hmac 用来hash的函数，openssl 一般是用来加密的函数）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712234533.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个底层码农，其实加密解密平时是用不到的，毕竟平时写的就是cms 的curd, 但随着API的流行以及老大对代码质量的重视，还有和别的部门的交互，于是需要加解密啦。&lt;a href=&quot;https://t.ti-node.com/thread/6497068236977209344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
      <category term="JWT" scheme="http://yoursite.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试题</title>
    <link href="http://yoursite.com/2019/02/21/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/21/PHP面试题/</id>
    <published>2019-02-21T02:50:35.000Z</published>
    <updated>2019-07-31T08:41:10.545Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些总是考的面试题</p><a id="more"></a><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">怎么会导致跨域，为什么会出现跨域</span><br><span class="line">schema，或者ip地址，或者端口号 不同都会出现跨域，为了防止前端随意调用别人的后端接口</span><br><span class="line"></span><br><span class="line">怎么解决跨域</span><br><span class="line">jsonp(用的比较少,好像是通过拼凑返回内容,让前端主动调用某个申明好的js文件), cors(通过在返回头中添加header信息,比如允许的域名,允许的调用方法，允许的自定义参数)</span><br><span class="line"></span><br><span class="line">什么是简单请求，什么是非简单请求</span><br><span class="line">好像是除了get post 之外的跨域请求都属于非简单请求，除此之外携带额外的参数也属于非简单请求。在发送非简单请求之前都会发送一个options请求，options请求没有请求体内容，你只需要把预定的header信息返回就好了，如果返回的header请求信息做了跨域处理，那么后面浏览器就不会屏蔽掉返回内容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get post 区别</span><br><span class="line">get 可以浏览器收藏，参数会被缓存，post 不可以 ，</span><br><span class="line">get 参数只能被url 编码， post 支持多种方式编码 （比如 application/x-www-form-urlencoded， 比如json 格式）</span><br><span class="line">get 长度一般由浏览器决定，比较短 ， post 比较长</span><br><span class="line">get 传递的参数一般直接显示在url 地址栏， 相比较的话，post会比较安全，get不要放敏感信息， get 参数放在url 中，post参数放在request body 中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http请求过程</span><br><span class="line">浏览器开始在host文件中查找对应网址的ip地址，找不到的话再在本地浏览器缓存中查找，再找不到去dns解析中查找，找到服务器ip地址之后，一般会先去监听的web服务器上，比如nginx，nginx对于静态文件直接返回，对于php类似文件有转发作用，比如转发给9000端口的php-fpm, 或者swoole， 然后他们再交给单个的工作进程中的php处理</span><br><span class="line"></span><br><span class="line">为什么http请求需要三次握手4次挥手</span><br><span class="line">第一次握手，验证cli 可以发消息到 server， server确定cli 可以推送消息，</span><br><span class="line">第二次握手，server验证自己可以推送消息，cli知道自己能推送消息并能收到返回消息，此时已经可以发送消息</span><br><span class="line">第三次握手，server知道自己可以同送消息，也能接收到消息，于是握手结束</span><br><span class="line"></span><br><span class="line">第一次挥手，通知sever 我要关闭了</span><br><span class="line">第二次挥手，server 通知cli， 好的，你关闭吧</span><br><span class="line">第三次挥手，server通知cli</span><br><span class="line">第四次挥手，cli告知server， 收到</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https 和 http的区别</span><br><span class="line">https基于http， 有个ssl 包裹住用户信息</span><br><span class="line">https加密原理，服务端下发一份数据(感觉就是证书)，客户端上传一份数据，生成一个对称加密的密钥，然后利用这个密钥进行数据传输</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">什么是socket编程</span><br><span class="line">Socket 又称网络套接字，是一种操作系统提供的进程间通信机制。</span><br><span class="line"></span><br><span class="line">工作流程：</span><br><span class="line">1. 服务端先用 socket 函数来建立一个套接字，并调用 listen 函数，使服务端的这个端口和 IP 处于监听状态，等待客户端的连接</span><br><span class="line">2. 客户端用 socket 函数建立一个套接字，设定远程 IP 和端口，并调用 connect 函数</span><br><span class="line">3. 服务端用 accept 函数来接受远程计算机的连接，建立起与客户端之间的通信</span><br><span class="line">4. 完成通信以后，最后使用 close 函数关闭 socket 连接。</span><br><span class="line"></span><br><span class="line">感觉类似swoole, swoole 先开启监听，new 一个server</span><br><span class="line">然后写监听事件，用于cli的请求的接受</span><br><span class="line">请求处理完，关闭</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OAuth(Open Authorization) 协议为用户资源的授权提供了一个安全的、开放而又简易的标准，第三方无需使用用户的用户名与密码，就可以申请获得该用户资源的授权。</span><br><span class="line"></span><br><span class="line">运行流程：</span><br><span class="line"></span><br><span class="line">1. 用户打开客户端以后，客户端要求用户给予授权。</span><br><span class="line">2. 用户同意给予客户端授权</span><br><span class="line">3. 客户端使用上一步获得的授权，向认证服务器申请令牌。</span><br><span class="line">4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</span><br><span class="line">5. 客户端使用令牌，向资源服务器申请获取资源。</span><br><span class="line">6. 资源服务器确认令牌无误，同意向客户端开放资源</span><br><span class="line"></span><br><span class="line">OAuth 2.0 定义了四种授权方式，授权码模式、简化模式、密码模式、客户端模式，具体的授权流程，请看阮一峰老师的文章理解OAuth 2.0。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csrf 攻击</span><br><span class="line">防止因为浏览器请求本域名接口自动携带着cookie， 在第三方者在用户没有感知的情况下，调用api。解决办法是携带参数token</span><br><span class="line">xss 攻击</span><br><span class="line">用户输入信息没有做合理过滤，导致让前端页面调用非法的js等内容。用户信息过滤 </span><br><span class="line">sql 注入</span><br><span class="line">用户输入信息不合法, 导致sql执行用户命令。 用pdo，sql语句预处理功能，或者用户输入过滤。</span><br></pre></td></tr></table></figure><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP 位运算符 </span><br><span class="line">| 或</span><br><span class="line">&amp; 且</span><br><span class="line">^ 异或</span><br><span class="line">~ 取反 （其实最常见的就是error_reporting(E_ALL ~E_NOTICE)）</span><br><span class="line">3 | 5 7</span><br><span class="line">3 &amp; 5 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">常用string ,arr 函数</span><br><span class="line">array:</span><br><span class="line">array_merge</span><br><span class="line">array_slice</span><br><span class="line">array_values</span><br><span class="line">array_keys</span><br><span class="line">array_columns</span><br><span class="line">is_array</span><br><span class="line">array_key_exists</span><br><span class="line"></span><br><span class="line">string:</span><br><span class="line">explode</span><br><span class="line">substr</span><br><span class="line">strpos</span><br><span class="line">preg_split</span><br><span class="line">strstr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_merge 和 +  的区别</span><br><span class="line">+ 同key, 前面覆盖后面 （index 或者 关联）</span><br><span class="line">merge 关联后面覆盖前面，index 直接扩展开了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">php7新特性</span><br><span class="line"></span><br><span class="line">1.错误也会报出异常，可以捕获</span><br><span class="line">2.太空舱运算符</span><br><span class="line">3.三目运算符的缩写</span><br><span class="line">4.define可以定义常量数组</span><br><span class="line">5.返回值也能严格要求返回类型</span><br><span class="line">6.传入参数类型声明的扩展，比如int</span><br><span class="line">7.命名空间合并</span><br><span class="line">8.closure call 替代bindTo 更加的方便</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php7为什么相较于php5性能有很大提升？</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php垃圾回收机制</span><br><span class="line">1、以php的引用计数机制为基础（php5.3以前只有该机制）（refcount 是1 的时候就删除， is_ref 是否是引用类型）</span><br><span class="line">2、同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题（php5.3开始引入该机制）（为了防止子变量中引用父变量，父变量unset 之后refcount 到不了0 一直得不到回收）</span><br><span class="line">其实最简单的防止那种慢性内存溢出的方式就是php-fpm 的连接重启(当然你要是一次性消耗了太多内存，还是会内存溢出的)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何解决php内存溢出问题（phpexcel中经常出现，第二个很管用）</span><br><span class="line">1. 增大 PHP 脚本的内存分配</span><br><span class="line">2. 变量引用之后及时销毁</span><br><span class="line">3. 将数据分批处理</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$z = 0.58;</span><br><span class="line">var_dump(intval($z * 100));</span><br></pre></td></tr></table></figure><p>答案是 57，所有语言对于小数的存取都是不精确的， 0.58其实是0.57999999，而且intval() 总是从遇到第一个不是数字开始截取，导致了0.57，比较通用的方法是转成别用intval, 或者用数学函数，bcmath扩展计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie 和 session 的 区别</span><br><span class="line">cookie 更像一个钥匙，因为没有加密，所以客户端可以查看和随意更改cookie的数据，cookie 对应的 session 才是服务端真正存储的序列化数据，</span><br><span class="line">php 中 cookie 默认名称是 phpsessid , 通过这个值，服务端php能识别客户端对应的用户</span><br><span class="line"></span><br><span class="line">什么是jwt， jwt 和 cookie, session 的区别</span><br><span class="line">jwt 是一种token 的实现方式，由base64 处理过，因为base64可以放解码，所以不要存储重要信息，存放一些基本的辨识用户的信息就好了。</span><br><span class="line">他是三段组成的，第一段是签名的加密算法，第二段是用户数据（载体）, 第三段是前面数据的签名，防止用户数据被修改。</span><br><span class="line">jwt相较于cookie 和session ,不需要服务端存储用户的基本信息，token下发到client ,完全由客户端保存, 可以防止csrf 攻击。但是jwt 下发之后除非做特殊处理比如服务端，否则不能失效，蛮尴尬的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register和 _autoload 的区别</span><br><span class="line">现在的自动加载已经不用_autoload 了，这个只支持一个方法，现在一般用spl_autoload_register, 或者全部用composer， 但composer本质上还是spl_autload_register,他可以支持多个函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">判断一个日期是否合法</span><br><span class="line">// 思路</span><br><span class="line">把一个日期转用strtotime 转换成时间戳再通过 date(), 转换成标准时间，和原先的日期比对是否相同，相同就合法，不同不合法</span><br><span class="line">// 注意：错误的时间date 也能转换，只是可能转换成1970 这样的时间</span><br><span class="line">// 字符串的比对比较耗时</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单引号，双引号区别</span><br><span class="line">单引号解析变量</span><br><span class="line">双引号不解析变量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include require 区别</span><br><span class="line">include 包含文件不存在 warning</span><br><span class="line">require 错误</span><br><span class="line">required_once</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中文截取字符串</span><br><span class="line">mb_substr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">平时开发用的设计模式</span><br><span class="line"></span><br><span class="line">单例  保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个，同时这个类还必须提供一个访问该类的全局访问点。</span><br><span class="line"></span><br><span class="line">工厂 定义一个创建对象的接口，但是让子类去实例化具体类。工厂方法模式让类的实例化延迟到子类中。（但是感觉和static 的延迟绑定不太一样）</span><br><span class="line"></span><br><span class="line">注册树</span><br><span class="line"></span><br><span class="line">门面  方便静态调用</span><br><span class="line"></span><br><span class="line">生产者消费者 异步任务或者花费时间多的任务放入队列中,让消费者消费</span><br><span class="line"></span><br><span class="line">订阅发布 主体对象状态发生改变,与之关联的观察者对象会收到通知，并进行相应操作</span><br><span class="line"></span><br><span class="line">装饰模式（laravel 的路由，核心 array_reduce）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常用的魔术方法</span><br><span class="line">__construct  类初始化</span><br><span class="line">__destruct  对象销毁的时候</span><br><span class="line">__call  调用的方法不能访问 （redis 类封装的时候很好用）</span><br><span class="line">__callStatic  调用的静态方法不能访问</span><br><span class="line">__get  获取的属性不能访问</span><br><span class="line">__set  设置的属性不能访问</span><br><span class="line">__isset  isset empty 不能访问的属性</span><br><span class="line">__unset unset 不能访问的属性</span><br><span class="line">__sleep  序列化一个对象的时候</span><br><span class="line">__wakeup  反序列一个对象的时候</span><br><span class="line">__clone 对象（作为两个实体的存在)</span><br><span class="line">__invoke 调用类实例像调用方法那样自动触发，像closure类自带这个方法，php中所有的匿名函数默认都是closure的实例，所以我们执行保存匿名函数的变量自动执行了这个方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php 错误信息控制</span><br><span class="line">error_reporting(E_ALL)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trait Singleton &#123;&#125;</span><br><span class="line">多继承的实现</span><br><span class="line"></span><br><span class="line">class Db</span><br><span class="line">&#123;</span><br><span class="line">  use Singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象类只能继承， extend ，接口可以实现多个，比如我想我这个类拥有foreach, 之类的功能， implement</span><br><span class="line"></span><br><span class="line">abstract 抽象类</span><br><span class="line">抽象类不能实例化</span><br><span class="line">抽象类中方法可以有方法体，没有方法体的只能定义abstract</span><br><span class="line"></span><br><span class="line">abstract 介于 class 和 interface 之间</span><br><span class="line"></span><br><span class="line">interface 接口</span><br><span class="line">interface 中不能用变量,但是可以有常量</span><br><span class="line">interface 中方法的访问权限只能是public, 不能是protected或者prviate</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">static ,延迟静态绑定，</span><br><span class="line">self, parent 调用的方法的时候都是以当前类为标准,</span><br><span class="line">static 根据实际调用对象，每当到了static 的 时候调用的上一个确定了调用类的对象方法 (parent self 都不能改变调用对象)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function test()</span><br><span class="line">    &#123;</span><br><span class="line">        static::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    protected static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); // 调用不了， 在 a 中调用b的protected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public static function foo()</span><br><span class="line">    &#123;</span><br><span class="line">        static::who();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public static function test()</span><br><span class="line">    &#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        parent::foo();</span><br><span class="line">        self::foo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B &#123;</span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();</span><br><span class="line"></span><br><span class="line">A C C</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">防止sql 注入</span><br><span class="line">sql 注入本质上就是害怕用户拼接sql, 在sql后面携带着用户传入的内容</span><br><span class="line"></span><br><span class="line">select name from user limit 10 offset . $offset;</span><br><span class="line"></span><br><span class="line">$offset = &apos; 0; select * from user&apos;;</span><br><span class="line"></span><br><span class="line">上述代码在pgsql 扩展中可以直接执行， 索然mysqli 中执行不了，</span><br><span class="line"></span><br><span class="line">handle:</span><br><span class="line">最好的方法就是利用预处理语句（那种 绑定??， 不能单纯的理解成嵌套变量进去，如果真的那样那还是防止不了sql注入）</span><br><span class="line"></span><br><span class="line">参数类型限定</span><br><span class="line">我们平时可以通过 转义 str_replace 之类的，但感觉这样很容易误伤，所以干脆还是用pdo的预处理语句吧</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">红包，我能想到比较简单的方法</span><br><span class="line">存在一定可能性死循环，就是后面数字的和已经不够一人一个了，已解决，每次计算剩余的最小值至少是每个1分，如果少于，则重新计算</span><br><span class="line">// mt_rand 只能产生随机整数，对于现实生活中的分，可以通过扩大100倍来解决</span><br><span class="line">// mt_getrandmx() 那个例子产生随机浮点数也是同样的道理</span><br><span class="line">// arr 是目前产生的数组</span><br><span class="line">// num 是剩余的值</span><br><span class="line">function productRand($arr, $num, $leave)</span><br><span class="line">&#123;</span><br><span class="line">    $tmp = mt_rand(0, $num);</span><br><span class="line">    $leveTotal = $num - $tmp; // 剩余的钱不能少于每个红包1分钱</span><br><span class="line">    if ($tmp == 0 || $tmp == $num || $leaveTotal &lt; $leave * 1) &#123;</span><br><span class="line">        return productRand($arr, $num);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $arr[] = $tmp;</span><br><span class="line">        $num -= $tmp;</span><br><span class="line">        return [$arr, $num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// $total 代表总数量</span><br><span class="line">// $count 代表红包个数</span><br><span class="line">function hongbao($total, $count)</span><br><span class="line">&#123;</span><br><span class="line">    $num = $num * 100;</span><br><span class="line">    $arr = [];</span><br><span class="line">    $top = $num;</span><br><span class="line">    for ($i = 0; $i &lt; $cishu - 1; $i++) &#123;</span><br><span class="line">    $leave = $count - $i - 1; // 剩余红包个数</span><br><span class="line">        $res = productRand($arr, $top, $leave);</span><br><span class="line">        $arr = $res[0];</span><br><span class="line">        $top = $res[1]; </span><br><span class="line">    &#125;</span><br><span class="line">    $arr[] = $num - array_sum($arr);</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(hongbao(11, 4));</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步，异步区别 阻塞非阻塞区别</span><br><span class="line">同步，异步主要是获取返回值内容的时候，同步如果一次性不能获取返回内容，需要不断的轮训获取返回内容，异步返回内容会主动通知（swoole task异步任务， php-fpm模式下同步代码）</span><br><span class="line">阻塞和非阻塞主要是进程方面，阻塞api所在进程会被系统直接挂起，直到完成（sleep， io比如redis mysqli pdo 等），非阻塞的时候所在进程不受影响，可以做别的事情（array, string 函数）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ab 测试</span><br><span class="line">-n  发送的请求总数</span><br><span class="line">-c  并发量</span><br><span class="line">ab -n 5000 -c 200 http://www.baidu.com/ (注意末尾的斜线)</span><br><span class="line">Requests per second  每秒钟完成的请求书</span><br><span class="line">Time per request  客户端等待时间</span><br><span class="line">Time per request 服务端等待时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yield  感觉就类似分页，有效减少内存的消耗（大数据量一次性读入内存吃不消），注意yield 的使用和数组还是有区别的.</span><br><span class="line">就相当于我们值读入部分数据到yield 中，我们还得forea yield 抛出的数据（iterator 实现了迭代器，所以可以循环），循环去插入 取出yield 中的数据</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">  for($i = 1; $i&lt;5; $i++) &#123;</span><br><span class="line">      yield $i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$data = test();</span><br><span class="line">foreach ($data as $value) &#123;</span><br><span class="line">    var_dump($data-&gt;current(),$value);</span><br><span class="line">&#125; </span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">自带的接口</span><br><span class="line">iterator // 可以循环，下面的那些方法都是为了foreach能正确数据准备的</span><br><span class="line">class test implements Iterator</span><br><span class="line">&#123;</span><br><span class="line">    public $arr = [];</span><br><span class="line">    public $keyArr = [];</span><br><span class="line">    public $keyP = 0;</span><br><span class="line">    </span><br><span class="line">    public function __construct($arr)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;arr = $arr;</span><br><span class="line">        $this-&gt;keyArr = array_keys($arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function rewind()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement rewind() method.</span><br><span class="line">        reset($this-&gt;arr);</span><br><span class="line">        $this-&gt;keyP = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function current()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement current() method.</span><br><span class="line">        return pos($this-&gt;arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function next()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement next() method.</span><br><span class="line">        $this-&gt;keyP++;</span><br><span class="line">        return next($this-&gt;arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function key()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement key() method.</span><br><span class="line">        return $this-&gt;keyArr[$this-&gt;keyP];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function valid()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement valid() method.</span><br><span class="line">        return isset($this-&gt;keyArr[$this-&gt;keyP]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php 进程间通信的方式</span><br><span class="line"></span><br><span class="line">第三方，比如redis</span><br><span class="line">消息队列， 也可以属于第三方</span><br><span class="line">共享内存， 不如swoole_table</span><br><span class="line">socket 文件</span><br><span class="line">管道 （应该类似 grep ）</span><br><span class="line">信号  字进程结束给父进程结束信号，请求回收</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">几个预定义接口 spl标准类库</span><br><span class="line">ArrayAccess , 让类可以类似数组方式访问</span><br><span class="line">Countab  , 让类可以被 count()</span><br><span class="line">iterator  让对象能循环，几个必须实现的方法（current, 当前key, key, 就是 key 的名称， next 往下走， rewind, 重置，valid 是否有效，本身php 的数组就包含上述的实现，$arr[$key], key,next, reset, isset）</span><br><span class="line">iteratorAggregate 感觉就是方便的创造一个迭代器比较方便（官网上直接调用spl 的一个标准库, ArrayIterator, 数组对象转成 Iterator 方便）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">php 多进程写入同一个文件</span><br><span class="line">file_put_contents() // 添加第三个参数ex_lock</span><br><span class="line"></span><br><span class="line">对文件加锁，并对锁设置超时时间（类似给redis 那种锁 sex 锁， setnx 不能同时设置锁的时间，不具有原子性，这里面的锁，其实就是一个key-value）</span><br><span class="line"></span><br><span class="line">$resource = fopen(&apos;./tmp.log&apos;);</span><br><span class="line">$try = 0;</span><br><span class="line">while(!flock($resource, LOCK_EX) &amp;&amp; $try != 100)</span><br><span class="line"> &#123;</span><br><span class="line">$try++;</span><br><span class="line">&#125; </span><br><span class="line">if ($try == 100) &#123;</span><br><span class="line">  return false; // 测试太多失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fwrite($res, &apos;ceshi&apos;);</span><br><span class="line">fclose($res); // 一般就能删除锁， 或者 flock($resource, UN_LOCK);</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">关于php这种锁，进程结束了就自动消失了，文档上说是脚本结束了，其实是一个意思（想一下我们用redis实现的锁，也是这样的，redis要是挂了，锁是不是没了）</span><br><span class="line">（当我用用了排它锁，我们再打开文件就是空的）</span><br><span class="line">(感觉写文件也不是直接往磁盘文件中写，而是写入一个缓存中，之后合并，因为当我用排它锁锁定一个文件的时候，fwrite 能立刻写入成功，虽然此时文件还没有修改)</span><br></pre></td></tr></table></figure><h1 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">laravel 调优</span><br><span class="line">1. 开启Opcache</span><br><span class="line">   2.关闭debug</span><br><span class="line">   3.缓存配置 php artisan config:cache</span><br><span class="line">   4.缓存路由 php artisan router:cache</span><br><span class="line">   5.类映射加载优化 php artisan optimize</span><br><span class="line">   6.根据需要只加载必要的中间件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel 生命周期</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loc ,facade, contract, 服务提供者是什么</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel 和 其他框架的区别</span><br></pre></td></tr></table></figure><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql 性能优化</span><br><span class="line">1. 建立索引，优化索引</span><br><span class="line">2. 读写分离 （怎么保证一致性）</span><br><span class="line">3. 保证单表数据量，分库分表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql(1) 和 mysql(11)的区别</span><br><span class="line">都是占用 4个字节，1 和 11 代表显示长度，除非添加 zerofill 要不然没区别</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">varchar 和 char 区别</span><br><span class="line">varchar 会根据内容长度确定大小，最大长度是定义的长度 * 3,varchar 中会存储字符的长度</span><br><span class="line">char 是固定大小，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hash索引和b+索引的区别</span><br><span class="line">hash 索引只能用来进行等值匹配, 也不能排序，b+索引能用来排序，可以范围取值</span><br><span class="line"></span><br><span class="line">什么是聚簇索引</span><br><span class="line">索引本质上是树，聚簇索引的叶子结点是用户记录</span><br><span class="line">普通索引</span><br><span class="line">普通索引的叶子结点是主键(id), 索引字段， 主键主要是为了回表，通过id 去 聚簇索引中查找用户记录</span><br><span class="line">覆盖索引</span><br><span class="line">因为回表属于不连续的io， 比较耗时，如果不用回表，索引字段包含select 的内容，那就会很快，这种索引就叫覆盖索引</span><br><span class="line">联合索引</span><br><span class="line">给多个字段建立索引，联合索引是最左原则，得在前面的字段是等值的情况下，后面的字段才能符合要求（比如前面的字段是范围索引，那么取出来的数据是无序的，在无序的情况下，联合索引第二个字段是起不到排序的作用的）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb 和 myisam 存储引擎的区别</span><br><span class="line">innodb 是行锁，myisam表锁</span><br><span class="line">innodb 支持事务，myisam不支持</span><br><span class="line">innodb 数据和索引存储文件一样，myisam是分开的</span><br><span class="line">innodb 中的聚簇索引的叶子结点就是数据记录或者主键，myisam中叶子结点只是数据的存储位置，所以肯定需要回表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么样的字段适合建立索引 （索引建立的标准）</span><br><span class="line">区分度大的字段，查找起来更容易确定具体的记录，减少回表的内容</span><br><span class="line">对于字符串，需要先确定首部字符串，才能匹配类似字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常见的索引</span><br><span class="line">主键， 唯一索引，复合索引，普通索引</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql 中的事务有什么作用，请列举事务的隔离级别</span><br><span class="line">我好像只用到了 事务的原子性（一起执行或者不执行）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql_fetch_row, mysql_fetch_assoc, mysql_fetch_array 区别</span><br><span class="line">row 好像是数组，assoc 关联数组， array 是前面二者的结合体</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">limit, left join ,order by ,group by, where , select , from ,having </span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">left join</span><br><span class="line">where </span><br><span class="line">group by </span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">limit</span><br><span class="line"></span><br><span class="line">执行顺序： 先连接，再筛选，再分组，再having, 再select, 最后order by</span><br><span class="line">FROM</span><br><span class="line">ON</span><br><span class="line">JOIN</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">WITH CUBE 或 WITH ROLLUP</span><br><span class="line">HAVING</span><br><span class="line">SELECT</span><br><span class="line">DISTINCT</span><br><span class="line">ORDER BY</span><br><span class="line">TOP</span><br></pre></td></tr></table></figure><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190718195208.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">404   最长匹配原则，但是只能匹配到 a</span><br><span class="line">500   ~* 不区分大小写， 权重比 / 高</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nginx 负载均衡（属于反向代理）upstream prox_pass关键字</span><br><span class="line">轮询（默认）</span><br><span class="line">权重</span><br><span class="line">ip_hash</span><br><span class="line">url_hash</span><br><span class="line"></span><br><span class="line">upstream  test&#123;</span><br><span class="line">   server 127.0.0.1:8081 weight=1;</span><br><span class="line">   server  127.0.0.1:8082 weight=2;</span><br><span class="line">&#125;</span><br><span class="line">prox_pass http://test # 还可以配置back 备胎机器</span><br></pre></td></tr></table></figure><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 和 memecached的区别</span><br><span class="line">1. 更丰富的数据结构，除了缓存，更多的使用场景</span><br><span class="line">2. 单进程，只能利用单核</span><br><span class="line">3. redis 可以持久化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 怎么持久化</span><br><span class="line">AOF 记录每条命令，后面重新执行一遍</span><br><span class="line">RDB 类似快照，把缓存中数据都存储下来（利用back，防止始终阻塞）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 的常用数据类型</span><br><span class="line">string  key value 形式</span><br><span class="line">hash  数组，关联数组，索引数组</span><br><span class="line">list  队列，</span><br><span class="line">set  集合</span><br><span class="line">sort set  有序集合</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 的使用场景</span><br><span class="line">点赞，利用 incr</span><br><span class="line">排行榜，有序集合，分数sorce 作为排序标准</span><br><span class="line">api 限流（sort set 滑动窗口）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">linux 常用命令</span><br><span class="line">cd  进入</span><br><span class="line">ls -la  展示</span><br><span class="line">tar 解压缩</span><br><span class="line">mkdir -p 新建文件夹</span><br><span class="line">touch 新建文件</span><br><span class="line">rm -rf  删除文件夹</span><br><span class="line">vim 编辑文件</span><br><span class="line">tail -f  动态查看文件变化</span><br><span class="line">netstat -antp 查看tcp 连接</span><br><span class="line">ps -ef  查看进程</span><br><span class="line">free 查看系统资源</span><br><span class="line">top  查看系统进程消耗资源</span><br><span class="line">df -h 查看系统盘</span><br><span class="line">alias -p 查看取别名</span><br><span class="line">find / -name 查找</span><br><span class="line">locate  查找</span><br><span class="line">chmod  修改权限</span><br><span class="line">chown  修改用户组用户</span><br><span class="line">wc -l 统计行数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase 变基，比如把当前分支的分叉点移动到主分支最新节点，为的就是log日志中不产生分支</span><br><span class="line">git push origin master:master  推送本地master分支到远程master分支</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk 的使用</span><br><span class="line">awk -F &apos; &apos; &#123;&apos;print $1&apos;&#125; ./access.log |sort|uniq|wc -l   uniq只能合并相邻的不同的，所以要先排序</span><br></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">4种排序</span><br><span class="line">从小到大</span><br><span class="line">1. 冒泡 (核心：每次一个数据到达最终位置，第一次确定最大的数字)</span><br><span class="line">   $arr = [20, 19, 88, 76, 43, 1];</span><br><span class="line"></span><br><span class="line">function maopao($arr) &#123;</span><br><span class="line">    $count = count($arr); </span><br><span class="line">    for($i=0; $i &lt; $count -1; $i++) &#123; // 最后一个数不用变动，位置自动确定</span><br><span class="line">        for ($j= 0; $j &lt; $count - 1 - $i; $j++) &#123; // 每次上浮的数字都要和没有确定的比较</span><br><span class="line">            if ($arr[$j] &gt; $arr[$j+1]) &#123;</span><br><span class="line">                list($arr[$j+1], $arr[$j]) = [$arr[$j], $arr[$j+1]];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.选择排序 (和冒泡的区别，这个每次选出一个最小的数，和冒泡一样，但是不移动数据，只是最终和确定的数组比较，如果不一致，才会移动)</span><br><span class="line">function xuanze1($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    for($i= 0; $i &lt; $count - 1; $i++) &#123;</span><br><span class="line">        $p = $i;</span><br><span class="line">        for ($j = $i; $j &lt; $count; $j++) &#123;</span><br><span class="line">            if ($arr[$j] &lt; $arr[$p]) &#123;</span><br><span class="line">                $p = $j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ($i != $p) &#123;</span><br><span class="line">            list($arr[$i], $arr[$p]) = [$arr[$p], $arr[$i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">3.插入排序 (核心，前面排好序的字段不断扩展，用来容纳新插入的数据)</span><br><span class="line">function charu($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    for ($i=1; $i &lt; $count; $i++) &#123;</span><br><span class="line">       </span><br><span class="line">        if ($arr[$i-1] &gt; $arr[$i]) &#123;</span><br><span class="line">            $tmp = $arr[$i];</span><br><span class="line">            for($j=$i-1; $j&gt;=0 &amp;&amp; $arr[$j] &gt; $tmp;$j--) &#123;</span><br><span class="line">                $arr[$j+1] = $arr[$j];</span><br><span class="line">            &#125;</span><br><span class="line">            $arr[$j+1] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">       // var_dump($arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">1. 快排：以一个数为基准，分原数组成两列，递归调用</span><br><span class="line">   function quick($arr)</span><br><span class="line">   &#123;</span><br><span class="line">    if (!$arr) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $tmp = $arr[0];</span><br><span class="line">    $left = $right = [];</span><br><span class="line">    $count = count($arr);</span><br><span class="line"></span><br><span class="line">    if ($count &gt; 1) &#123;</span><br><span class="line">        for ($i = 1; $i &lt; $count; $i++) &#123;</span><br><span class="line">            if ($arr[$i] &lt;= $tmp) &#123;</span><br><span class="line">                $left[] = $arr[$i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $right[] = $arr[$i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array_merge(quick($left), [$tmp], quick($right));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return $arr;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">查找 （注意查找的算法都是在排好序的基础上）</span><br><span class="line">1.二分查找</span><br><span class="line">function search1($arr, $num, $min, $max) &#123;</span><br><span class="line"></span><br><span class="line">    if ($min == $max &amp;&amp; $num != $arr[$min]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $tmp = ceil(($min + $max) / 2);</span><br><span class="line">    if ($num == $arr[$tmp]) &#123;</span><br><span class="line">        return $tmp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ($num &lt; $arr[$tmp]) &#123;</span><br><span class="line">            $max = $tmp-1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $min = $tmp + 1;</span><br><span class="line">        &#125;</span><br><span class="line">       return search1($arr, $num, $min, $max);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1000000个数字的整数， 大小是0 到 999999， 找出其中重复的数字.</span><br><span class="line"></span><br><span class="line">1. 最简单的。先排序，排序玩比较相邻数字是否相同，相同就添加进结果集。（二分 nlogn）</span><br><span class="line">2. 利用hash, 时间复杂度n, 空间复杂度n. 我们知道php 的数组就是一个hash, 我们可以遍历这个大的原始数据，然后把其中的数字都往一个预先的hash 里面塞，如果之前有值就代表重复.</span><br><span class="line">3. 因为大小是0 到 99999， 所以我们可以foreach ,然后把对应数据换算到我们要的位置上来，如果最后没有调回来，代表这个数字重复</span><br><span class="line"></span><br><span class="line">$arr = [2,3,1,0,2,5,3];</span><br><span class="line">// 转变过程</span><br><span class="line">// [1,3,2,0,2,5,3]</span><br><span class="line">// [3,1,2,0,2,5,3]</span><br><span class="line">// [0,1,2,3,2,5,3]</span><br><span class="line">// 2, 3 入结果集</span><br><span class="line">// foreach 的时候，如果 &amp;value,可以改变这次遍历的内容，单单$arr[$key] 只能改变下次遍历时候的$arr</span><br><span class="line"> function chongfu($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $chongfu = [];</span><br><span class="line">    foreach ($arr as $key =&gt; &amp;$value) &#123;</span><br><span class="line">        if ($value == $key) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            jiaohuan($arr, $chongfu, $key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return $chongfu;</span><br><span class="line">&#125;</span><br><span class="line">function jiaohuan(&amp;$arr, &amp;$chongfu, $key)</span><br><span class="line">&#123;</span><br><span class="line">    if ($key != $arr[$key]) &#123;</span><br><span class="line">       // var_dump($key, $arr[$key]);</span><br><span class="line">        $value = $arr[$key];</span><br><span class="line">        if ($value == $arr[$value]) &#123;</span><br><span class="line">            $chongfu[] = $value;//var_dump($chongfu, $key, $value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list($arr[$key], $arr[$value]) = [$arr[$value], $arr[$key]];</span><br><span class="line">            //var_dump($arr, $key);</span><br><span class="line">            jiaohuan($arr, $chongfu, $key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(chongfu($arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单系统</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100件商品高并发，先到先得</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">30w 的ip地址,类似如下</span><br><span class="line">10.23.25.0  10.23.25.255    湖南省 长沙市</span><br><span class="line">请设计出一个实现方式,可以给某个IP找到对应的省和市。要求效率尽可能的高。</span><br><span class="line"></span><br><span class="line">利用redis的zset, 把ip地址变成数字作为score 存储，然后把各个省市的最大ip和最小ip村春，利用 zset 的范围，取到第一个最大的城市就是该城市</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.请设计一个投票系统,满足如下要求</span><br><span class="line">a.一个用户10分钟内对一个投票只能成功完成一次。</span><br><span class="line">b.一个用户每个自然日最多只能成功完成50个不同的投票。</span><br><span class="line"></span><br><span class="line">每次投票成功， 就往set 里面塞入一个投票类型，每次投片前都检测下，有没有超过50</span><br><span class="line">利用redis, userid_投的票  =&gt; 时间，如果 时间 + 10 分钟 &gt;= 现在时间就给投票</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.用php写一个函数，获取一个文本文件最后$n行内容，要求尽可能效率更高，并可以跨平台使用</span><br><span class="line"></span><br><span class="line">利用exec 执行 tail -f , 主要就是tail -f 没有停止，会持续获取，但也没关系，手动停了就好了，注意的是这块没停止的话，进程一直阻塞着，不能去往下执行，打印 exec 执行后的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$filename = &apos;/opt/httpd/logs/access_log&apos;;</span><br><span class="line">$xie = &apos;./xie.log&apos;;</span><br><span class="line"></span><br><span class="line">function kan($line, $file, $xie)</span><br><span class="line">&#123;</span><br><span class="line">    $line = $line -1;</span><br><span class="line">    $x = fopen($xie, &apos;a+&apos;);</span><br><span class="line">    $res = fopen($file, &apos;a+&apos;);</span><br><span class="line">    $postion = -2;</span><br><span class="line">   </span><br><span class="line">    $str = fgets($res);</span><br><span class="line">   </span><br><span class="line">    while ($line) &#123;</span><br><span class="line">        fseek($res, $postion, SEEK_END);</span><br><span class="line">        $tmp = fgetc($res);</span><br><span class="line">        $postion -= 1;</span><br><span class="line">       </span><br><span class="line">        if ($tmp == PHP_EOL) &#123;</span><br><span class="line">            </span><br><span class="line">            $str .= fgets($res);</span><br><span class="line">            $line -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var_dump($str);exit;</span><br><span class="line">    fwrite($x, $str);</span><br><span class="line">&#125;</span><br><span class="line">kan( 5, $filename, $xie);</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">有两个文本文件 A.txt B.txt</span><br><span class="line">A.txt 3000万行，userid唯一，userid和username以空格分隔，如下所示：</span><br><span class="line">userid  username</span><br><span class="line">1       yi</span><br><span class="line">2       er</span><br><span class="line">3       san</span><br><span class="line">...     ...</span><br><span class="line">B.txt 3000万行，userid唯一，userid和realname以空格分隔，如下所示：</span><br><span class="line">userid  realname</span><br><span class="line">1       一</span><br><span class="line">2       二</span><br><span class="line">3       三</span><br><span class="line"></span><br><span class="line">感觉可以把 a读入一个数组中，然后遍历 b ，往b中写入相应数据 。 a可以看做一个hash，所以查找一个数据就是1， 然后遍历 b文件，n， 所以总的复杂度是 n.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集一些总是考的面试题&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="interview" scheme="http://yoursite.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>laravel 核心技术读书笔记</title>
    <link href="http://yoursite.com/2019/01/03/laravel-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/03/laravel-核心技术读书笔记/</id>
    <published>2019-01-03T15:31:06.000Z</published>
    <updated>2019-07-31T08:41:07.184Z</updated>
    
    <content type="html"><![CDATA[<p>关于laravel 框架核心技术一书的阅读感受<br><a id="more"></a></p><p>###1.关于命名空间<br>我理解的命名空间是文件中的namespace 可以定义成任意的值，但是composer 的自动加载因为符合psr4 ，所以要求命名空间和文件路径一致，文件名和类名保持一样。当我们不适用composer的自动加载的时候，就可以随便指定文件中的namespace是多少了，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace test;</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以保存在任意位置任意名称的文件中，但是不能写在composer autoload 驱动的框架中，除非改成别的方式加载，比如map<br>还记得我们在控制器中引用别的类吗，通过use,然后就能直接使用new classname()了，但是我们在脚本中使用的时候，我们一定要用到include 先去包含这个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace test;</span><br><span class="line"></span><br><span class="line">include &apos;test2.php&apos;;</span><br><span class="line"></span><br><span class="line">use test2\test5;</span><br><span class="line"></span><br><span class="line">class test </span><br><span class="line">&#123;</span><br><span class="line">  public function test2()</span><br><span class="line">  &#123;</span><br><span class="line">      test1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$a = new test();</span><br><span class="line">$a-&gt;test2();</span><br><span class="line"></span><br><span class="line">$b = new test5();</span><br><span class="line">$b-&gt;test3();</span><br></pre></td></tr></table></figure></p><p>可能你在想，既然我们都include 了，那为啥还要使用use，use在这个地方的作用是什么，当你使用 use test2\test5的时候，你在使用 new test5(), 它实际new 的是 test2\test5(), 如果没有 new test5(), 当前命名空间下的test5类，所以你明白了use 并不是导入包含文件，只是引入一个类的前缀，想不适用前缀，那就 new \test5() ，绝对路径吧，如果想使用当前命名空间下的 test5(),那就把外来引入的换个名称吧，比如 as。现在想想，其实我们平时同一个文件夹下面命名空间一样，本质上是写在一个文件中的，只是我们为了方便好看，才把分到多个文件中，但是我们互相引用的时候，同一个命名空间下面，不用use，因为默认就在当前文件夹下面找。</p><p>当我接触use 的时候，书中还有一句话，use只能引用类，并不能引用常量，函数··！！难道还可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace test;</span><br><span class="line"></span><br><span class="line">//include &apos;test2.php&apos;;</span><br><span class="line"></span><br><span class="line">use test2\test5;</span><br><span class="line"></span><br><span class="line">class test </span><br><span class="line">&#123;</span><br><span class="line">  public function test2()</span><br><span class="line">  &#123;</span><br><span class="line">      test1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* class test5</span><br><span class="line">&#123;</span><br><span class="line">    public function test3()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function autoload($class) &#123;</span><br><span class="line">    echo $class;</span><br><span class="line">    include &apos;./test2.php&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(&apos;test\autoload&apos;);</span><br><span class="line"></span><br><span class="line">$a = new test();</span><br><span class="line">$a-&gt;test2();</span><br><span class="line"></span><br><span class="line">$b = new test5();</span><br><span class="line">$b-&gt;test3();</span><br></pre></td></tr></table></figure></p><p>对，你没看错，class 的外面还能定义function, 然后我们当前命名空间中可以直接使用，如果是不同的命名空间，需要加前缀</p><p>###2.spl_autoload<em>register 和 __autoload<br>\</em>_autoload已经被废弃了，在7.2 中。__autoload 如果在一个库中出现多次，会出错的，虽然是魔术方法，但可以不在类中定义，spl_autolad_register ，可以绑定多个自动加载，还可以删除，composer的自动加载机制中就用到了删除。他是类似一种方法的执行，可以写在任意地方，可以直接是方法名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register(&apos;test\autoload&apos;);</span><br></pre></td></tr></table></figure></p><p>可以是面向对象的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register([$this, &apos;autoload&apos;], true, true);</span><br></pre></td></tr></table></figure></p><p>第二个参数true 代表异常可以捕获，__autoload 就不行，第三个参数说实话不知道咋用，队列头部和队列尾部，就是先加载哪个自动加载函数的意思呗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于laravel 框架核心技术一书的阅读感受&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>LBS 和 redis mongodb</title>
    <link href="http://yoursite.com/2018/12/24/LBS-%E5%92%8C-redis-mongodb/"/>
    <id>http://yoursite.com/2018/12/24/LBS-和-redis-mongodb/</id>
    <published>2018-12-24T14:00:01.000Z</published>
    <updated>2019-07-31T08:41:08.013Z</updated>
    
    <content type="html"><![CDATA[<p>LBS,刚听起来挺高大上的，其实简单理解就是附近的人。其实这个需求蛮常见的，比如大众点评中搜索摸某一个店铺按照离我当前位置距离进行排序，又或者某些社交软件中的附近的人，实现的方式有很多，php + mysql ， php + redis ， php+ mongodb， 其中mysql 的话，就是把所有的点的坐标保存下来，然后通过编写sql语句，直接通过sql去查询每个点离我们的距离，然后排序返回，但数据量大的时候，可能不太好，所以就有了后面的nosql ， redis 和 mongodb 的相关应用，其中 mongodb 在这方面应该是我听得最多的，当初想试这个功能也是因为想教一下前端朋友mongodb的相关功能，方便他面试，但后来发现其实还是redis 实现比较方便，因为php的mongodb扩展 mongo(php5） 和 mongodb(php7) 接口一点都不一样，而且中文文档比较少啦。其实通过es 也是可以实现的，方法很多.<br><a href="https://zhuanlan.zhihu.com/p/31380780" target="_blank" rel="noopener">详细见这篇文章</a><br><a id="more"></a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>(<a href="https://yq.aliyun.com/articles/62844" target="_blank" rel="noopener">参考</a>)redis 自从3.2就有了对于经纬度的处理，但注意并不是新增了一个一个数据结构，这个经纬度是在 有序集合zset 的基础上发展而来的，所以我们对于zset 的操作都能对经纬度使用，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrange key 0 10 #  把key 中所有的member 都取出来 zrange cy1 0 10</span><br><span class="line">zcard key   # key 中有多少个member, zcard cy1</span><br><span class="line">zsore  key member #  key 中具体的member 的score，对于经纬度这个取出来看不懂</span><br></pre></td></tr></table></figure></p><p>穿插一句：刚开始使用redis 的时候，虽然他的api很简单，便于理解，但是和sql编程还是不同的，为什么我们一个对象有了member 这个名称还需要key 呢，你想啊，我么需要从一个集合中获取离这个点比较近的点，这个集合的名称就是 key,这个是事先我们往集合中塞就定好的，后面我们可能变化的是member 的名称，需要我们从外边传入。<br>关于php使用redis, 大致分成两种方法，有通过编译c扩展，还有就是通过composer 安装predis,这是两种方法，我们不要混淆了，平时我们大部分用的是c扩展额，然后自己封装其中基本的方法和连接方式，需要注意的是关于重连啊，或者单例模式是的使用啊之类的，还有就是其中__call方法的使用，如果有那些我们没有封装的方法，但是自己还使用了，默认就会调用这个方法。一般很多时候调用方法正确的放回是0和1，所以我们不能根据0和1来判定方法是否执行成功，很多时候他代表着影响的行数，比如新增返回1，修改返回0。还有c扩展方式安装的，比如 geoRadiusByMember, 不知道这个方法的参数都是啥，也不知道在哪能找到，只能凭着redis的使用去猜测，比如最后一个option 应该传数组，但其实如果传错的话，也有提示，感谢扩展报错信息的详细<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3280215645624671911.png" alt="image.png"></p><p>geoadd: 增加地理位置的坐标。<br>geodist: 获取两个地理位置的距离。<br>geohash: 获取地理位置的GeoHash值。<br>geopos: 获取地理位置的坐标。<br>georadius: 根据给定经纬度坐标获取指定范围内的地理位置集合。<br>georadiusbymember: 根据给定地理位置获取指定范围内的地理位置集合。</p><p>georadius 和 georadiusbymember 的参数</p><p>WITHDIST: 同时返回地理位置与给定位置的距离<br>WITHCOORD: 同时返回地理位置的经纬度坐标<br>WITHHASH: 同时返回Redis内部的GeoHash值（非标准算法值），一般用于debug<br>ASC|DESC：结果按距离升降序排序<br>STORE|STOREDIST: 结果存到新的有序集合中，前者以GeoHash值做score，后者以与指定位置的距离作score，该选项与WITH[DIST|COORD|HASH]选项冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public function addLocation()</span><br><span class="line">    &#123;</span><br><span class="line">        $redis = new Redis();</span><br><span class="line"></span><br><span class="line">        //var_dump($redis-&gt;geodist(&apos;cy1&apos;, &apos;a&apos;, &apos;b&apos;));exit;</span><br><span class="line"></span><br><span class="line">        $lnt = Request::instance()-&gt;post(&apos;lnt&apos;);</span><br><span class="line">        $lat = Request::instance()-&gt;post(&apos;lat&apos;);</span><br><span class="line">        $name = Request::instance()-&gt;post(&apos;name&apos;);</span><br><span class="line">      // 1 成功 新增</span><br><span class="line">        // 0 也可能是成功  修改</span><br><span class="line"></span><br><span class="line">        $res = $redis-&gt;geoadd(&apos;cy1&apos;, $lnt ,$lat, $name); // 相同的名称就直接替换了</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function dist()</span><br><span class="line">    &#123;</span><br><span class="line">        $member1 = Request::instance()-&gt;post(&apos;member1&apos;);</span><br><span class="line">        $member2 = Request::instance()-&gt;post(&apos;member2&apos;);</span><br><span class="line"></span><br><span class="line">        $redis = new Redis();</span><br><span class="line">        var_dump($redis-&gt;geodist(&apos;cy1&apos;, $member1, $member2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function fujin()</span><br><span class="line">    &#123;</span><br><span class="line">        $radius = Request::instance()-&gt;post(&apos;radius&apos;); // 多少半径</span><br><span class="line">        $member = Request::instance()-&gt;post(&apos;member&apos;); // 点的名称</span><br><span class="line">        $unit = Request::instance()-&gt;post(&apos;unit&apos;); // 单位</span><br><span class="line"></span><br><span class="line">        $option = [&apos;withdist&apos;, &apos;withcoord&apos;];</span><br><span class="line"></span><br><span class="line">        $redis = new Redis();</span><br><span class="line">        var_dump($redis-&gt;georadiusbymember(&apos;cy1&apos;, $member, $radius, $unit, $option</span><br><span class="line"></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证方法，通过求得两个点的距离之后按照多少米之内半径调整圆的大小，来观察另一点是否在圆圈内来验证.</p><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><p>关于mongodb的安装就看菜鸟教程吧，也是解压完就能用，类似redis,然后服务端启动是 mongod, 客户端shell是 mongo(然后据说是js shell，不知道需不需要node的支持，反正我的服务器上node 是必须的，因为vue 啊 或者 hexo 啊 都需要node), 启动的时候要设置 dbpath 和 log path,直接写到配置文件中就可以 mongod启动了。</p><p>小插曲：因为这个mongo启动的时候输了一堆的信息，然后又看不懂，所以就像通过检查端口号来看是否启动成功，这又到了用ps 和 netstat 的时候了。先通过ps -ef|grep 27017 没有，是不是这个命令本来就不输出端口号呢？ps -ef |grep nginx,果然没有端口号，于是netstat -antp|grep 27017,看到了，害怕这个应用层服务不是基于tcp (也许是多虑吧)，我把t 去掉了，查到了。完事之后自己思考了下，ps 主要是用来检查进程的，netstat 是用来检查网络连接的，拿nginx 来举例，他可能有一个manage 进程，然后有个master 子进程，然后每个master还有worker进程，然后他监听了 80 ，443 等端口，所以ps 查出来的只能是进程相关，netstat 查出来的才是各种提供的服务和端口号。</p><p>mongodb 和 redis 同属于nosql，拿现在比较流行的话说，他也是对标mysql的产品，很多教程拿他和mysql做对比，确实也更容易理解<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9864415645624675608.png" alt="image.png"></p><p>我们刚开始进入shell :<br>show dbs   显示有哪些数据库，默认 local 和 admin<br>可是默认我们在test 下面，为什么test 没有显示，因为test 中没有内容呀，但凡我们插入数据，就可以有了</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>use test 切换数据库，如果没有就新建</p><p>db 显示当前数据库</p><p>db.dropdatabase  删除当前数据库</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>db.runoob.drop 删除当前表/collection</p><p>show tables   显示当前数据库中有哪些表 </p><p>show collections  同上</p><p>db.createCollection(‘test’)   创建表</p><p>db.createCollection(“mycol”, { capped : true, autoIndexId : true, size :<br>   6142800, max : 10000 } ) 创建表</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>db.runoob.insert({“name”:”菜鸟教程”})  插入数据 ，这个runoob 是表的名字，在mongodb 中是文档的意思，然后mongo 中table 中 field 不需要统一</p><p>db.col.insert({title: ‘MongoDB 教程’,<br>    description: ‘MongoDB 是一个 Nosql 数据库’,<br>    by: ‘菜鸟教程’,<br>    url: ‘<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>‘,<br>    tags: [‘mongodb’, ‘database’, ‘NoSQL’],<br>    likes: 100<br>})   // 往col 表里面插入数据</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>db.col.find({title:’cy’, sex:’boy’})   //查找col 表里面数据,and 条件<br>db.col.find().pretty() 更好的显示出来</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8883215645624677668.png" alt="image.png"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}})</p><blockquote><p>db.col.save({<br>    “_id” : ObjectId(“56064f89ade2f21f36b03136”),<br>    “title” : “MongoDB”,<br>    “description” : “MongoDB 是一个 Nosql 数据库”,<br>    “by” : “Runoob”,<br>    “url” : “<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“,<br>    “tags” : [<br>            “mongodb”,<br>            “NoSQL”<br>    ],<br>    “likes” : 110<br>})</p></blockquote><p>save 的话，保存id 就是更新，没有id 的话就是新增</p><p>默认的话只能更新一条，如下可以更新多条，因为第二个布尔值代表多条的意思</p><p>db.col.update( { “count” : { $gt : 3 } } , { $set : { “test2” : “OK”} },false,true );</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>db.col.remove({‘title’:’MongoDB 教程’})<br>db.col.remove({‘title’:’MongoDB 教程’}， 1)  // 只想删除一个，just one 参数设置为1</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>db.col.find({likes : {$lt :200, $gt : 100}})</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>db.col.find({“title” : {$type : 2}})</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>db.COLLECTION_NAME.find().sort({KEY:1})</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>db.col.createIndex({“title”:1})<br>db.values.createIndex({open: 1, close: 1}, {background: true})，第二个是参数，前面的1是升序，-1是降序</p><p>未完待续····（坑爹的php 的 mongodb扩展，感觉不知道咋用呀）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LBS,刚听起来挺高大上的，其实简单理解就是附近的人。其实这个需求蛮常见的，比如大众点评中搜索摸某一个店铺按照离我当前位置距离进行排序，又或者某些社交软件中的附近的人，实现的方式有很多，php + mysql ， php + redis ， php+ mongodb， 其中mysql 的话，就是把所有的点的坐标保存下来，然后通过编写sql语句，直接通过sql去查询每个点离我们的距离，然后排序返回，但数据量大的时候，可能不太好，所以就有了后面的nosql ， redis 和 mongodb 的相关应用，其中 mongodb 在这方面应该是我听得最多的，当初想试这个功能也是因为想教一下前端朋友mongodb的相关功能，方便他面试，但后来发现其实还是redis 实现比较方便，因为php的mongodb扩展 mongo(php5） 和 mongodb(php7) 接口一点都不一样，而且中文文档比较少啦。其实通过es 也是可以实现的，方法很多.&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31380780&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详细见这篇文章&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>常用的接口(-)</title>
    <link href="http://yoursite.com/2018/12/07/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/07/常用的接口/</id>
    <published>2018-12-06T16:34:57.000Z</published>
    <updated>2019-07-31T08:41:18.041Z</updated>
    
    <content type="html"><![CDATA[<p>关于登陆，现在的网站有第三方登陆（qq,微信，微博）， 手机号登陆，用户名密码登陆，sso登陆，找回密码，注销 感觉其实都差不多<br><a id="more"></a></p><p><strong>第三方登陆</strong><br>其实国内的大多数第三方登陆都是基于oauth 2.0的变种，同理还有微信上消息more按钮点击能跳转到公司网站同样实现登陆都是基于这个，那什么是oauth2.0呢，阮老师这篇文章讲解的很清楚<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">oauth2.0</a>，而我们用的更多的又是其中的授权码模式，大致逻辑如下</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9459615645624774616." alt=""></p><p>其中比较重要的两点就是用户授权code和access_token, code作用代表用户同意登陆了，access_token 代表这个用户资源（有时候像之前的小程序，是拿着用户同意之后返回的code 去换回openid, 这个openid 类似这个access_token, 他在每个应用中是唯一的，代表了一个用户，如果我们想把不同app上同一个微信用户绑在一起，需要我们去微信联合平台绑定需要处理的app，然后下次请求的时候会返回一个unit id ，这个对于同一个微信用户在不同的app内部是唯一的）</p><p>for example 微信消息跳转itbasic网站<br>1.引导用户点击授权链接，微信给的授权链接上会有参数绑定回调地址和state参数，当用户点击的时候，微信会重定向（注意不是回调）填写的会掉地址，并携带参数state,还有code ,也就是用户授权码，下面是我们的重定向地址代码<br>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public function dologin($req)</span><br><span class="line">    &#123;</span><br><span class="line">        $code = $req-&gt;param(&apos;code&apos;);  # 用户授权码</span><br><span class="line">        $state = $req-&gt;param(&apos;state&apos;);  # 自己定义的参数，比如这次登陆来自微信，或者登陆之后需要跳转的地址</span><br><span class="line">        $accesstoken = $this-&gt;getAccessToken(); # 微信这块的access_token不需要用户的授权即可获取，但后面获取用户信息还是需要授权码，所以原理和上面是一样的</span><br><span class="line">         </span><br><span class="line">        $url = &apos;https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=&apos;.$accesstoken.&apos;&amp;code=&apos;.$code;  </span><br><span class="line"></span><br><span class="line">        $res =$this-&gt;http($url); #获取用户信息</span><br><span class="line"></span><br><span class="line">        if (!array_key_exists(&apos;UserId&apos;, $res[&apos;result&apos;])) &#123;</span><br><span class="line">             // 记录错误信息（微信）到日志,获取用户信息出错</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">           // 根据实际业务处理，我这块是登陆</span><br><span class="line">          // 你可以根据返回的用户名称，判断是新用户，还是老用户，新用户的话会往数据库插入数据</span><br><span class="line">            $user_model = Box::getObject(&apos;user&apos;, model);</span><br><span class="line">            $res = $user_model-&gt;search($res[&apos;name&apos;]);</span><br><span class="line"></span><br><span class="line">            if (!$res) &#123;</span><br><span class="line">                // 记录错误信息（itbaisc） 到日志，查找用户失败</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            $userinfo = $res;</span><br><span class="line">            $userinfo = [&apos;userid&apos; =&gt; $userinfo[&apos;id&apos;], &apos;username&apos; =&gt; $userinfo[&apos;username&apos;], &apos;status&apos; =&gt; $userinfo[&apos;status&apos;], &apos;deptsid&apos; =&gt; $userinfo[&apos;deptsid&apos;], &apos;postsid&apos; =&gt; $userinfo[&apos;postsid&apos;], &apos;role&apos; =&gt; $userinfo[&apos;role&apos;], &apos;long&apos; =&gt; true];</span><br><span class="line">            Session::set(&apos;userinfo&apos;, $userinfo);  //实现登陆</span><br><span class="line">        </span><br><span class="line">        $state = urldecode($state);  // 之前我们自己绑定的参数，因为url在http参数中需要加密，防止多余的http这些参数</span><br><span class="line">        header( &quot;Location: $state&quot; );exit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>手机号登陆</strong><br>首先生成验证码,存入缓存中，手机号=》验证码（过期时间，离开当前页面让其失效，只能使用一次），然后调用第三方接口发送给手机上这个验证码，用户收到验证码之后调用新的接口进行验证，我们在缓存中寻找手机号验证码是否匹配，如果匹配代表成功，后面是登陆啊，还是绑定啊看自己的业务需求</p><p><strong>sso登陆</strong><br>一处登陆处处登陆，一处注销，处处注销<br>(itbasic的原理类似oauth2。首先用户验证是否在的登陆中心登陆，如果没有，先登录，登陆中心成功后返回一个access_token,重定向到你来时候那个地址，相当于帮你发出请求，你拿着这个access_token获取用户信息，干啥都是你自己的事情。下次用户再来的时候，验证中心已经登陆上了，直接返回access_token然后重定向)<br>（注销，我们在每次去验证中心验证的时候，都记住有哪些来的网站，注销的时候都请求他们注销的地址就好了，这个时候可以直接请求，不用重定向，因为不用种cookie,直接销毁服务端数据就好了）</p><p><strong>找回密码</strong><br>通过邮箱。首先填写用户名和邮箱（为了防止别人恶意找回用户），确保用户名和邮箱和登陆的时候绑定一致，才发送修改密码的邮件，邮件内容是</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/633115645624777185.png" alt="image.png"></p><p>这样其实就足够了，这个token 是我们之前发送邮件时候生成的，我们只需要保证 用户名 =&gt;token,当用户请求这个接口的时候（注意一定是get请求，因为是点击），我们通过这个token,知道是哪个用户就好了，然后返回一个界面让用户修改密码就可以了.</p><p>熟悉了几个函数的使用</p><p>http_query_build ,拼接http请求参数（这个对url 好像还会进行urlencode加密）</p><p>parse_str, 把上面的拼接内容分开</p><p>当然上面各个案例的解决方案很多，比如找回密码用手机而不是用邮箱，只是简单记录下常用的方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于登陆，现在的网站有第三方登陆（qq,微信，微博）， 手机号登陆，用户名密码登陆，sso登陆，找回密码，注销 感觉其实都差不多&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>日志 awk sed</title>
    <link href="http://yoursite.com/2018/11/28/%E6%97%A5%E5%BF%97-awd-sed/"/>
    <id>http://yoursite.com/2018/11/28/日志-awd-sed/</id>
    <published>2018-11-28T10:32:20.000Z</published>
    <updated>2019-07-31T08:41:20.830Z</updated>
    
    <content type="html"><![CDATA[<p>日志很重要</p><blockquote><p>日志可以进行数据挖掘，分析用户的喜好，比如什么资源被用户频繁访问（对应面试题：取出访问量前20的网址）  –来自百度某朋友</p><p>你线上要是有错误怎么办，你们平时是不是都不看日志，只有错误了才解决，··balabal （一顿嘲讽）  –来自平安好房某专家表哥</p><p>为啥本地开发的时候，错误信息能输出在页面，线上环境直接就是个500页面，好奇怪，好奇怪     –来自17年的me</p></blockquote><a id="more"></a><p>###了解日志<br>我们itbasic用的其实是lamp, 通过apache的模块处理php, php的错误日志可以在虚拟域名里面进行配置<br>lnmp,nginx 起到静态文件处理的作用，php 转给php-fpm 进行处理，虽然网上说nginx 记录不了错误日志，但其实当我在虚拟站点里面配置error-log的时候，也是有记录的，和php-fpm中是一样的。<br>php-fpm 中开启日志需要修改php.fpm 的配置文件（还可以添加慢查询日志，<a href="https://juejin.im/post/5b9394a0e51d450e686747e3" target="_blank" rel="noopener">据说很重要</a>，有空的话可以把itbasic改成lnmp,有空的话看看php-fpm 中各个参数的作用，）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5401815645624805999.png" alt="image.png"><br>特别是这块，php_flag和php_value 的作用是一致的，不知道为什么要搞两个一样的，还有就是他们的使用是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_flag[error_reporting] = 0</span><br></pre></td></tr></table></figure></p><p>来覆盖代码中的error_reporting ,····原先以为还有什么作用呢</p><p>###分析日志</p><p>我不会告诉你最开始接触sed和awk 是因为面试题，很多时候，当我们分析一个大日志文件的时候，我们甚至都打不开这个文件，因为太大了， 但是我们可以通过这些文本处理工具对数据加以筛选。</p><p>awk（参照<a href="http://www.ruanyifeng.com/blog/2018/11/awk.html" target="_blank" rel="noopener">阮一峰</a>老师，很可惜，没有出sed 入门）</p><p><strong>基本用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">$ awk 动作 文件名</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">$ awk &apos;&#123;print $0&#125;&apos; demo.txt</span><br><span class="line"></span><br><span class="line">$ echo &apos;this is a test&apos; | awk &apos;&#123;print $0&#125;&apos;</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure></p><p>print 和 echo 都是标准输出，stdin ,这个东西最近经常看到，感觉就是输出在控制台上，比如php cli 模式下，普通php 脚本中 echo,  print,  var_dump都可以打印在控制台上（但好像记得之前子进程中输出好像只有父进程中才能看到，不记得是return 还是 输出了），这种标准输出好像都可以通过管道进行连接然后进行处理<br>上面的分割， \$1 代表第一个元素，$0 代表整体元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 练习（test.log）：</span><br><span class="line">root:x:0:0:root:/root:/usr/bin/zsh</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line"></span><br><span class="line"># 想输出第一个字符的话</span><br><span class="line">cat test.log|awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos;</span><br></pre></td></tr></table></figure></p><p> 想一下，我们通过cat ,是不是能把文件默认输出在页面上，然后我们通过awk去处理，设置分隔符号 ‘:’,默认的分隔符符号是 ‘ ‘.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 练习：提取nginx 500 日志，并统计总数</span><br><span class="line"># 78.181.37.209 - - [28/Nov/2018:15:01:56 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&quot;</span><br><span class="line">cat access.log|awk -F &apos; &apos; &apos;if ($9 == 500) print $0&apos; | wc -l</span><br></pre></td></tr></table></figure><p>注意这个分隔符号是空格，即使双引号里面有空格，也会把切割开， wc -l 可以统计行数</p><p><strong>变量</strong><br>内置一些变量，比如行数NR，这一行有多少个字段NF(这两个应该是最常用)，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILENAME：当前文件名</span><br><span class="line">FS：字段分隔符，默认是空格和制表符。</span><br><span class="line">RS：行分隔符，用于分割每一行，默认是换行符。</span><br><span class="line">OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。</span><br><span class="line">ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</span><br><span class="line">OFMT：数字输出的格式，默认为％.6g。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">练习：</span><br><span class="line">      2 345</span><br><span class="line">      2 123</span><br><span class="line">      1 789</span><br><span class="line">      1 1234</span><br><span class="line"></span><br><span class="line">awk &apos;&#123;print NR&quot; &quot; $2&#125;&apos; log  # 行数  第二个字段中间用空格连接</span><br><span class="line">awk &apos;&#123;print NR&quot; &quot; $(NF)&#125;&apos; # 行数 最后一个字段中间用空格连接，运行的时候中间的值会被替换</span><br></pre></td></tr></table></figure><p><strong>函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tolower()：字符转为小写。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">substr()：返回子字符串。</span><br><span class="line">sin()：正弦。</span><br><span class="line">cos()：余弦。</span><br><span class="line">sqrt()：平方根。</span><br><span class="line">rand()：随机数。</span><br></pre></td></tr></table></figure></p><p><strong>条件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;条件 动作&apos; 文件名</span><br><span class="line">awk &apos;条件 动作&apos; 文件名awk -F &apos;:&apos; &apos;/usr/ &#123;print $1&#125;&apos; demo.txt</span><br><span class="line">awk -F &apos;:&apos; &apos;NR % 2 == 0 &#123;print $0&#125;&apos; demo.text #输出偶数行</span><br><span class="line">awk -F &apos;:&apos; &apos;&#123;if (NR % 2 == 0) print $0; else print &quot;error&quot; &apos;&#125;&apos; demo.text</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">练习</span><br><span class="line">[例]：有如下文件test,请统计每个网址出现次数，用一句shell实现。</span><br><span class="line">a [www.baidu.com]  20:00</span><br><span class="line">b [www.qq.com]  14:00</span><br><span class="line">d [www.baidu.com] 23:00</span><br><span class="line">e [www.qq.com]  20:30</span><br><span class="line">f [www.360.com] 20:30</span><br><span class="line"></span><br><span class="line"> cat url.txt|awk &apos;&#123;print $2&#125;&apos;|sort|uniq -c|sort -rn</span><br><span class="line"># cat 查看文件内容， 输出第二行的内容，排序，因为 uniq 只能把连接在一起的文件重复文件合并，然后再倒序</span><br></pre></td></tr></table></figure><p>uniq -c  把重复的行数显示在前，但是只能合并连续的<br>sort 排序， -rn   r是倒序，n是按照数字处理<br>head -n 5  取出前五行，这也是查询的时候经常要用到的</p><p>补充一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 取出cpu 或者内存占用前五，top 查看占用</span><br><span class="line">ps -aux|sort -k3rn|head -n 5</span><br><span class="line"># sort 自带切割，</span><br><span class="line"># ps -aux 可以查看所有进程， 比如之前我想查看我的一个脚本 server.php,可以通过 ps -aux|grep server.php, 相比较netstat -antp|grep 9000,查看端口占用情况， ps -aux 查看更加清楚，比如swoole 的进程，1个 master ,1个manage,剩下的work ，所有的进程都能查看到，但是netstat 只能查看到一个</span><br></pre></td></tr></table></figure></p><p>统计某接口的调用次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log| grep &apos;GET /app/kevinContent&apos; | wc -l</span><br></pre></td></tr></table></figure><p>统计报错接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log| awk &apos;&#123;if ($9 == 500) print $0&#125;&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志很重要&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日志可以进行数据挖掘，分析用户的喜好，比如什么资源被用户频繁访问（对应面试题：取出访问量前20的网址）  –来自百度某朋友&lt;/p&gt;
&lt;p&gt;你线上要是有错误怎么办，你们平时是不是都不看日志，只有错误了才解决，··balabal （一顿嘲讽）  –来自平安好房某专家表哥&lt;/p&gt;
&lt;p&gt;为啥本地开发的时候，错误信息能输出在页面，线上环境直接就是个500页面，好奇怪，好奇怪     –来自17年的me&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP常用工具</title>
    <link href="http://yoursite.com/2018/11/23/PHP%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/23/PHP常用工具/</id>
    <published>2018-11-23T15:26:05.000Z</published>
    <updated>2019-07-31T08:41:10.529Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThinkPHP的感觉</title>
    <link href="http://yoursite.com/2018/11/12/ThinkPHP%E7%9A%84%E6%84%9F%E8%A7%89/"/>
    <id>http://yoursite.com/2018/11/12/ThinkPHP的感觉/</id>
    <published>2018-11-12T10:12:27.000Z</published>
    <updated>2019-07-31T08:41:14.754Z</updated>
    
    <content type="html"><![CDATA[<p>学习，为了更好地适应未来的工作。简单的解除了下tp和laravel，总体来说tp比laravel简单多了，封装的也没有那么深，所以用起来还是很方便的，用的是5.0，5.1和5.0区别就挺大了，不如有了门脸，又是一个使用类不知道到底用哪个命名空间下类比较好的时候了，还有获取参数的方式，5.1已经没有getInstance()这种东西了，记录一下这几天的感觉,方便交流</p><a id="more"></a><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4694815645624705617.png" alt="image.png"></p><p>首先是模块的创建，主要是为了方便后台模块和 api 模块的分开</p><p>后台模块， 这个项目中主要是通过接口能返回html 模板</p><p>但是 api 模块，单单只用返回json 数据</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>关于api 模块的json 返回，我们只要调用json() 方法就可以了，不需要做进一步的配置，  我们还可以通过json 方法的进一步封装，让调用起来更加方便</p><p>[图片上传失败…(image-14c2c0-1542018168779)]</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/810621564562470764.png" alt="image.png"></p><p>这种方法其实就是在返回头上加上个别的信息</p><p>这种公共的方法我们可以写在 common.php 文件中</p><p>控制器中获取传过来的参数</p><p>有个坑就是5.0 和 5.1 通过request 获取参数的方式竟然就不一样了，</p><p>5.0 中 其中一种 Request::instance()-&gt;get()</p><p>5.1 Request::get() (5.1中已经开始出现faceade这种看不懂的东西了)</p><p>其实用助手函数就没有上述问题了，···但无奈我不喜欢用，但感觉助手函数的话对不同版本的tp代码都是通用的</p><p>对于put 参数，我们在用postman 提交代码的时候需要通过第二种方式提交，第一种方式是获取不到的，可能是因为表单默认屏蔽了put delete 提交方式</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6614015645624709869.png" alt="image.png"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/472831564562471279.png" alt="image.png"></p><p>这个header 头信息是真的坑，解决这个办法就是先把$header 信息保留成数组，然后再通过数组去寻找这个变量</p><p>讲道理，还是有点不明白_initialize 和 __construct(） 的区别</p><p>关于文件的定义，基本上除了配置文件，剩下的都是class 文件，按照psr4 ,类名要和文件名一样，我之前有过类名和文件名不一样，导致文件加载失败</p><p>异常处理那块，当调用父的 异常处理函数，需要return ,否则会报错，感觉和调用模板也需要return 是一个道理</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>关于 tp 的路由，好久之前就知道被吐槽pathinfo 模式，虽然我不知道是因为什么被吐槽，除了pathinfo 还有别的模式吗？</p><p>除了默认的pathinfo, 我们对于api 接口（admin 那种返回html 的可以不用管），可以使用路由注册的形式，就是在route.php 中进行路由注册，他会首先匹配,没找到的会使用pathinfo 模式，这块需要我们在配置文件中进行配置</p><p>（可以完全关闭pathinfo 或者 路由注册的形式）</p><p>（关于路由注册这块，tp 的路由注册和laravel 的还不一样，他不是使用命名空间的形式，用的是感觉自己定义的形式， 但感觉因为这个方面，路tp的路由方面应该不能单独拆出来给别的项目使用），但其实也挺好理解， 注意</p><p>完全路由匹配，还有路由参数的限制</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8861315645624715465.png" alt="image.png"></p><p>参照： <a href="https://www.jianshu.com/p/73ed6e42d389" target="_blank" rel="noopener">https://www.jianshu.com/p/73ed6e42d389</a></p><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>今天因为不太知道config() 助手函数都是从哪里获取的数据，查了一下，这篇文章写得还是蛮好的</p><p><a href="https://www.jianshu.com/p/cd8b68143fde" target="_blank" rel="noopener">https://www.jianshu.com/p/cd8b68143fde</a></p><p>比如我们那个api模块的接口需要很多额外的参数，我们只需要在application 最外层定义一个extra 的目录，然后会自动引入里面的文件</p><p>我们配置文件的数据返回大致如下</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/684601564562471785.png" alt="image.png"></p><p>通过 config() 可以看到全局的配置参数</p><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p>model 最近用的都是orm,不管是后台admin 还是api接口，都可以公用，所以新建了一个common模块，在里面写入了model,通过model() 或者命名空间的方式都能使用（我比较喜欢用命名空间的方式去使用，tp的orm可以分离出来去别的项目中使用，当然model()方法引入model类就不可以了，只能通过命名空间的方式）</p><p>题外话 ：关于为什么用model() 就能引入common 模块下的model，我们可以理解成约定俗成，甚至可以理解成1 + 1  = 2， 之前我纠结这些问题很久，但其实他就像我们使用别的约定俗成的概念是一样的，只是这个可能是由于框架的封装，在我们的印象中很难站住脚 ，或者没有看到官方给的白纸黑字的文档，能做的就是看源码，model 是怎么执行加载的，表哥说过，你可以画上 1年半载去弄懂框架的源码，但如果你弄不懂的话，你也可以通过专注业务区提升自己的能力，有些东西能用就好了。</p><p>基本的方法:</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2795015645624720051.png" alt="image.png"></p><p>通过在数据库配置文件中设置表前缀，默认类名称是  ‘表前缀_类名’ ， laravel 是表名单数</p><p><strong>查询</strong></p><p>select   获取集合  ，这个直接json 返回外面就是array ,在项目里面打印是 是object ,这个项目里面转换成 array 需要 collection($arr)-&gt;toArray()， 这个Db::  用select , 查出来竟让也是 object ,想变成 array,可以通过toArray()</p><p>find   只能获取一条 ,这个直接 就是数组</p><p>column, 查询单列</p><p>value  查询单个值（那种集合的查询调用 value 也是只返回一个值）</p><p>field  获取哪些对应字段,还可以给字段取别名（感觉很强大，还能用函数 sum(score)）</p><p>order   同上</p><p>limit  5 size</p><p>page  1  页码  (感觉这个page 还是和limit 分开来使用比较方便)</p><p><strong>查询方法</strong></p><p>where  =&gt;   [‘id’=&gt; 1, ‘status’=&gt; 1],  多条件等于情况， [‘id’, ‘status’]  代表两个column</p><p>where =&gt; [‘id’ =&gt; [‘&gt;’, 3]]   id 大于3的情况</p><p>whereOr</p><p><strong>插入</strong></p><p>insert</p><p>insertAll  批量插入</p><p>insertGetId  插入成功之后返回id</p><p>getLastInsID  返回最新插入的id</p><p><strong>更新</strong></p><p>update</p><p>setField 更新某个字段</p><p>setInc   自增</p><p>setDec 自减</p><p><strong>删除</strong></p><p>delete </p><p>关于链式操作，注意select() ，table 这些不属于链式操作，所以需要放在最后面，剩下的那些链式操作没有顺序要求</p><p>alias  给表取别名</p><p>groupby  分组</p><p>having  （最好在group by 中使用count这种的聚合函数）</p><p>子查询和 union 基本不用</p><p>distinct 唯一不同的值，不同的值，比如这个返回admin和chunice</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1597715645624722466.png" alt="image.png"></p><p>count  这个好像需要放在 where 条件后面，要不然也会报错</p><p>orm 之所以能调用这些db的方法是因为orm 的基础是db</p><p>自动写入时间戳都是针对orm 这种操作可以的，db 操作是不可以的， 上面的操作都是db 的操作</p><p>注意用Db 进行操作的时候，命名前缀已经失效了，记住要用表的全名</p><p>关于join 表，老师和表哥说都不要join ,因为数据多的时候join会出问题，对于用户和用户名的对应的时候，利用先找出所有数据，再把userid 取出来进行in 的查询，再通过遍历之前需要处理的数据，把username 链接进去，这样是可以的，但是对于zan这种，可能不存在这条数据</p><p>这几种join是当初面试的时候经常问的</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/887215645624725236.png" alt="image.png"></p><p>comment  给sql语句增加注释（··感觉好没用啊）</p><p>fetchSql 返回sql 语句 （ 感觉挺好，可以知道执行了什么，但用with 那种关联关系，只能返回第一条语句···，太废物了）</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>其实，感觉：查询出来的是object 对象，还是纯种的array ,就是看调用者，如果是 Db::table 调用，就是 数组</p><p>如果是 User::  这种方式调用，就是 object， object 又有 user  和 collection 之分</p><p><strong>新增</strong></p><p>save   插入 这个不能用静态方法，只能实例化调用</p><p>saveAll 批量</p><p>返回值是受影响的行数，我们想获取到自增id ,可以通过 </p><p>$user = new User()</p><p>$user-&gt;save([])</p><p>echo $user-&gt;id ,这种方式获取到，因为save 不能非静态化的调用， save() 返回值是受影响的行数</p><p>批量新增 saveAll()</p><p>create  静态调用</p><p>User::create() , 返回值是自增id</p><p><strong>修改</strong></p><p>save ,需要传入主键</p><p>saveAll  批量</p><p>update 静态调用 ,这个方法也可以直接调用，Db和模型都有这个方法</p><p>据说通过 -&gt;where-&gt;update() 这种就不能使用tp模型的事件功能（什么是事件功能？就是那种更新表前会有什么操作，类似钩子）</p><p>感觉这个方法除了静态调用，就不知道有什么比较方便的地方了，感觉那种直接通过模型只使用update() 方法不太好，不太直观，感觉很多时候应该是不止是就是用一个update 方法这么简单</p><p><strong>删除</strong></p><p>delete 删除，也是模型和Db 都能使用的</p><p>destroy 删除</p><p><strong>查询</strong></p><p>get （条件） </p><p>，find</p><p>感觉查询的功能真的是各种强大，慢慢学习吧</p><p>获取器的重要作用：</p><p>其实我们在平时的开发中总会遇到类似的问题，就是数据库中对于status 存储着各种数字，然后给前端展示的时候，循环结果，把结果中的每条数据的status 对应的中文取出来，然后再加上，读取器就是为了这个产生的，我们在读取一个</p><p>attr 的时候，类似定义一个钩子，他会自动帮我们把取到的数据进行修改（其实有两个参数的，第一个是这个值，第二个是整条数据的值）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/720931564562472744.png" alt="image.png"></p><p>all (条件) select ()</p><p><strong>软删除</strong></p><p>这种事很常用的，我们平时使用的时候通过加入一个标志位，然后tp中也是使用标志位，delete_time ,但筛选数据的时候不用我们处理，仿佛真的就删除一样，可是在管理工具中还是能看见</p><p>关于orm 的执行日志，或者是说sql日志，统一的开启数据库调试模式，然后直接在log中查看就好了</p><p>notice : 就是很灵活，因为orm 也是基于数据库的，所以数据库中的很多方法在orm 中也可以用，甚至同名，比如update,但返回的内容不一样，orm 的update 返回的是更新的实例，数据库的update 返回的是兽影响的行数</p><p>感觉就是模型的话要是不用with 这些关联属性，意义会小很多，可是后来发现，那些处理orm 查出来的的数据，确实会方便很多</p><p>关联：</p><p>1对 1 ： </p><p>虽然感觉有时候反着写也是对的，但最好还是遵从 （虽然七月老师说是二者是不对等的，比如 user 和 userinfo  ,userinfo 有 userid ,但user 找不到 userinfo ,但如果是 1对 1 ，是真的都能通过定义 hasOne 和 belongsTo 去获取对方）</p><p>（按照编辑器的推荐，确实 hasOne 更准确点）</p><p>（user  hasOne  userinfo   这个也更符合我们的习惯）</p><p>感觉上反正很怪，如果编辑器能提醒就好了，但只能提醒是主键还是外键，并不是提醒是哪种表的主键，那张表的外键</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/348871564562472971.png" alt="image.png"></p><p>user  -&gt; info</p><p>user 中定义 hasOne</p><p>$this-&gt;hasOne(‘info’, ‘user_id’,’id’），这个提示比较符合大众的想法</p><p>info 中定义 belongsTo</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3707915645624732446.png" alt="image.png"></p><p>$this-&gt;belongsTo(‘user’, ‘user_id,’id’)</p><p>单个模型还能通过</p><p>$banner-&gt;hidden([‘update_time’, ‘delete_time’]); 来隐藏对应的字段</p><p><em>感觉最好还是在model 的定义的时候隐藏</em></p><p><em>注意select () 这种查找出来的都是数据集合 collection</em></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3186415645624734785.png" alt="image.png"></p><p>看一下这个例子，通过嵌套关系，可以实现images 内部数据的排序，所以关联关系也是可以嵌套的</p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>自己新建的缓存文件不要和 thinkphp里面的字段名称一样，否则回报错误</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a><strong>Exception</strong></h3><p>配置文件中开启debug 模式，要不然总是 ‘tp 专为api而生，十年磨一剑’的错误信息</p><p>开启之后还需要处理，因为我们前台只需要json数据，我们需要考虑程序上线之后如果发生错误了我们该怎么处理，其实没法处理，因为我们不知道什么时候会发生，想象一下如果我们知道他会发生，那我们为什么不去阻止而让他发生呢，此时我们需要一个监听全局异常事件的东西，当php抛出异常的时候我们只要去捕获他，然后处理就好了，类似前端的钩子 。 </p><p>知道吗 ？在我们原生的php当中，其实有个专门对全局异常进行处理的函数，可以自己定义，可是呢··我没有自己去试过，首先是异常自己理解的比较浅，再者对于框架的使用比较少，</p><p>tp的全局异常处理应该也是这个原理，本质上应该还是修改这个函数，当我们在tp中想改变全局异常处理函数只需要修改配置文件中的异常处理函数名称，改成自己需要配置的就好了</p><p>接下来我们重写下全局异常处理函数，让他更符合我们的要求</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4308715645624736836.png" alt="image.png"></p><p>首先需要继承tp自带的异常处理，然后重写他的render 方法，，为什么？因为我们在bug模式的时候需要tp给我们提示错误信息，总比我们自己看 $e-&gt;getMessage() 方便详细的多</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1986215645624739049.png" alt="image.png"></p><p>接下来， Basci Exception 是自己默认定义的exception， 既然是自己定义的错误，自然不用tp的异常处理，直接返回前台json 数据就好了，因为自己定义的错误，一般是手动抛出，自己了解错误的原因</p><p>然后是非自己定义，首先要是判断是否开启了debug 模式，如果开启了，说明在调试，直接使用tp自带的就好了，千万注意要加上return ,要不然会报错，毕竟是html 页面的返回（类似可以想象一下tp中模板的返回）</p><p>再者是如果是上线环境，只需要告知前台服务器错误就好了，定义个固定的数组，返回给前端，然后记日志</p><p>（记录日志也是很简单的，log::error(), 写在runtime的log下面）</p><p>异常处理定义完毕，就要开始定义异常类了。使用异常类的原因就是告别传统的遇到错误的返回方式，还记得之前我们在嵌套函数中执行错误后怎么返回的吗，只能层层往上抛出，到了最外层的controller 返回，可是异常就不一样了，当异常处理检测到这个地方抛出的异常，就能直接进入异常处理函数中，多方便。</p><p>（还有一点我觉得定义异常的好处，就是之前我们对错误信息的输出总是 code =&gt; message =&gt; ,有时候为了规范我们通过写一个方法，通过code 去获取message ，但你想象一下，当你写完接口之后，满屏的 code ，你也不知道这个code 代表的啥意思，当然我们可以约定code的规范，如果我们通过throw new ParamErrorException([code=&gt; , message=&gt;]), 我们就会知道这个错误大致属于前端参数的错误）</p><p>notice :<br>1.不管是什么框架，我们定义的异常都一定继承于最原始的php \Exception</p><p>2.常用的方法 $e-&gt;getMessage(),获取错误信息</p><p>3.注意异常类因为继承自exception，我们一定不能定义exception中有的属性，比如我之前在异常类中定义过一个message属性，这个属性是exception 中的protected，然后在参数验证那块会出现莫名其妙的异常错误</p><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>说实话，我到现在还没有明白验证器的具体作用，平时那种</p><p>new Vdalidate()</p><p>-&gt;bitch()-&gt;check()</p><p>感觉就能符合需要，可是要是真的每次在valiate里面写上同样的验证规则， 确实可能会有重复定义的嫌疑</p><p>但我感觉要真的发挥验证器的作用，必须介乎scene() 场景来使用，一个validate 对应一个类，或者model，这个validate有各个属性的校验，通过定义scene ，让我们不会定义过多的validate 类</p><p>在 $rule 里面</p><p>有各个报错信息 $message =  [‘id.require’ =&gt;] 这种细致的分层，让错误信息准确的定位，或者直接 id =&gt; ,这样可能id对应多个验证规则的时候，需要把错误信息都加上，如果出错了，不知道具体是哪条规则出错了</p><p>scene ,对应场景，可能某个实体过来了，我需要验证其中valdiate 类中的某几个属性，我就用scene 去细分，如果不用scene 的话，想象一下，这个地方比如user 模型需要name 和 sex ，另一个地方需要 name 和 img ，难道我们需要为此定义两个validate ，感觉一点都不灵活（exception如果遇到这种通过向里面传入不同的参数来解决）</p><p>重写validate 和 重写 exception 不一样，重写valdiate ，其实是对传统 validate check 方法的封装，和 定义方法的更多加入，因为check 之后，所有的错误信息都会储存在 error  这个属性中（或者 $this-&gt;geterror()来获取），然后通过异常把这个错误信息抛出去给前台页面</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9710215645624742651.png" alt="image.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2148015645624745182.png" alt="image.png"></p><p>laravel 中也有相似功能，感觉就和路由中间件一样，在执行到这一步之前都会先执行这个验证操作</p><p>感觉这个比那个__initze() 什么方法方便多了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>还有太多太多我不会用的，所以后面的路还很长啊，只是 为了更好的入门</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习，为了更好地适应未来的工作。简单的解除了下tp和laravel，总体来说tp比laravel简单多了，封装的也没有那么深，所以用起来还是很方便的，用的是5.0，5.1和5.0区别就挺大了，不如有了门脸，又是一个使用类不知道到底用哪个命名空间下类比较好的时候了，还有获取参数的方式，5.1已经没有getInstance()这种东西了，记录一下这几天的感觉,方便交流&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 关于blade</title>
    <link href="http://yoursite.com/2018/10/10/Laravel-%E5%85%B3%E4%BA%8Eblade(%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E)/"/>
    <id>http://yoursite.com/2018/10/10/Laravel-关于blade(模板引擎)/</id>
    <published>2018-10-10T08:45:23.000Z</published>
    <updated>2019-07-31T08:41:07.172Z</updated>
    
    <content type="html"><![CDATA[<p>其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。</p><a id="more"></a><p>itbasic 用的也是模板引擎，名twig，其实和blade没有多少不同的地方，只是自己发现的twig新功能还比较少，只是一直在原先的基础上堆代码，感觉上在模板引擎里面还是不要做过多的逻辑判断，否则后面会越写越复杂，而且难于维护。</p><p>对于web网站，我们有很多页面，但这些页面大部分都是相同的？因为我们的布局需要相同，这个其实在写itbasic的时候应该能感觉到，我们似乎只需要填充中间的content部分就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;@yield(&apos;title&apos;,&apos;测试&apos;)&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        @yield(&apos;content&apos;)</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>什么是yield ,就是让继承者可以填充的东西，继承者通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@extends(&apos;layout.blade&apos;) //继承上一个模板</span><br><span class="line">@section(&apos;title&apos;, &apos;cy&apos;)  //填充数据</span><br><span class="line"></span><br><span class="line">@section(&apos;content&apos;)   //这种方式填充数据要有结束符号</span><br><span class="line">&lt;h1&gt;222&lt;/h1&gt;</span><br><span class="line">@stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@include(&apos;default.ce&apos;)  // 包含额外的页面</span><br><span class="line">//传递变量，include(&apos;default.ce&apos;, [&apos;user&apos;=&gt;$user])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//判断</span><br><span class="line">@if ($a &gt; 0)</span><br><span class="line">&lt;h1&gt;cc&lt;/h1&gt;</span><br><span class="line">@endif</span><br><span class="line"></span><br><span class="line">//循环</span><br><span class="line">@foreach($counts as $count)</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">@endforeach</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>网站升级https</title>
    <link href="http://yoursite.com/2018/09/11/%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7https/"/>
    <id>http://yoursite.com/2018/09/11/网站升级https/</id>
    <published>2018-09-11T06:23:14.000Z</published>
    <updated>2019-07-31T08:41:23.535Z</updated>
    
    <content type="html"><![CDATA[<p>升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。</p><a id="more"></a><p>https原理<br>HTTPS采用共享密钥加密(对称加密)和公开密钥加密(非对称加密，比较出名的有RSA)两者并用的混合加密机制。在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式<br>之所以传输过程中用对称加密，是因为非对称很浪费资源</p><p>(hash加密是单向的，例如md5,不能解密)<br>和对称加密还有非对称加密都是不一样的，不管是对称加密还是非对称加密，通过秘钥都是能解密的，但是hash，只能维持 hash(内容)之后的值保持一致，这也是我们数据库中只保存用户密码加密后的值就可以验证用户的密码是否正确了，因为我们可以每次获取到用户信息之后只要hash一下，然后和数据库中做下对比就可以了。</p><p>https ,首先让服务器和ca交互，获取服务器的公钥，这个过程是非对称加密，获取到公钥</p><p>https升级过程中遇到的问题:</p><ul><li>不允许脚本调用http，可以先把接口转发到我们本地的服务起的https上，然后通过nginx转发到别人网站上的接口，因为本身调用外来接口接口比较少，这样能符合我们的需求</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5525740-442e10f7747a4d2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>https证书申请无效（每个域名都需要申请单独的证书，之前以为只要申请一个www.chenye2017.cn证书就可以了，chrome直接显示https不安全，其实通过微软的edage浏览器访问，能清楚的看到证书不匹配的原因）</li></ul><p>（证书申请是通过腾讯云，腾讯云上有详细的教程，唯一不足的是没有给文件夹权限，导致第一次访问403）</p><p>（https配置虚拟主机应该就和我们在vhost文件里面配置虚拟主机一样，现在是在ssl配置文件里面写）<br>（话说我现在的服务器，域名用的是阿里的，服务器用的是京东的，https证书用的是腾讯的，zz）<br>（还有不知道是hexo的原因还是github page 的原因，我的网站上有http的资源竟然不会显示https错误，不知道他是怎么解决这种http资源不出错的，有空可以了解下）</p><p>https和http的区别</p><p>简单看就是 https = http + SSL</p><p>SSL的运行机制，可以参考<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">阮一峰老师的文章</a>，我对上面的一些内容做了些自己理解的笔记</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3923915645624827681.png" alt="image.png"></p><ol><li>其中加密传播是因为我们的传播内容都是通过生成一个第三方不知道的公钥，这个公钥是怎么来的呢，首先通过ca证书，因为系统内容ca的公钥，ca用私钥加密文件内容（私钥加密，公钥解密，不被篡改），我们获取服务器的公钥，这个公钥是干什么的呢，并不是用来进行数据的加密的，而是用来加密传递的数据给服务器（公钥加密，私钥解密，不被获取），服务器接收到客户端的数据进行生成公共密钥，这个密钥是我们以后加密数据用来传递的<br>(感觉只要记住证书里面的内容都是能保证绝对正确就好了)</li><li>具有校验机制，是因为我们的证书具有这个作用，比如我上次把我从www.chenye2017.cn 上获取的证书放到虚拟站点blog.chenye2017.cn就直接报错</li><li>配备身份证书，估计也是这个意思</li></ol><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5535015645624829909.png" alt="image.png"><br>所以ssl 和 tsl 是一样的意思嘛</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9207815645624833023.png" alt="image.png"><br>感觉这个握手不是tcp的那个三次握手，这个开始的时候tcp那个三次握手应该都搭建好了，而且这个也是4次握手</p><p>剩下的内容就是4次握手的详细内容了，为什么要4次握手，写的都很详细，就不再补充了，总之这个生成传输加密内容的秘钥也是通过非对称加密，再后面就是http了。</p><p>总结一下：</p><ol><li>通过CA 证书，发送服务器公钥，利用的是非对称加密算法，用的公钥和私钥来自CA（证书的作用是为了保证服务器公钥的正确性，不被篡改）</li><li>通过CA得到的服务器公钥，大家都可能有，但是我们通过公钥加密，私钥才能解密，和服务器交互，让两端都能生成一致的对称加密算法钥匙（随机因素可以通过客户端利用服务器公钥加密传给服务器）</li><li>利用生成的公共密钥进行对称加密，传输数据（这个公共密钥在每次连接的时候生成，别人不知道）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于git</title>
    <link href="http://yoursite.com/2018/09/07/%E5%85%B3%E4%BA%8Egit/"/>
    <id>http://yoursite.com/2018/09/07/关于git/</id>
    <published>2018-09-07T07:51:06.000Z</published>
    <updated>2019-07-31T08:41:16.305Z</updated>
    
    <content type="html"><![CDATA[<p>公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨</p><a id="more"></a><ul><li><p>首先是分布式和集中式的区别</p><p>分布式就是在每个人的个人电脑上都有仓库，称作本地仓库，本地仓库也会保存整个项目的提交记录，让我们在不连网的情况下也能进行代码的提交，当我们可以连网的时候，再把代码推送到远程仓库，远程仓库只是一个让我们各个工作者可以相互交换提交记录的中转站，我们的提交在git commit 的时候已经完成(我们唯一的提交信息就是在commit 时候写的)，也就是在git log 历史里面已经占据了位置，我们在push 的时候只是用本地的提交记录去覆盖远端的提交记录。而集中式代表着我们在不联网的情况下完全工作提交不了代码，那个中央仓库才是我们的唯一仓库，往里面提交代码才会产生log。所以我们在用集中式的时候，查看log都是通过查看远端log，对比diff也是，所以断网的情况下完全用不了,而分布式完全没有这个问题。</p></li><li><p>git add .</p><p>我们每次修改代码之后都需要git add 文件名(. 代表所有文件)添加到暂存区，当我们添加一次之后，又修改了文件，还得git add 一次，因为git add 只是把当前文件现在的修改添加到了暂存区，如果后面修改了，还得重新添加一次，这个可能和svn 的只需要add 这个文件到管理文件夹内，后面修改直接commit 有点不同</p></li><li><p>up-to-date</p><p>最新的，有的时候可能显示before one  commit 这种，代表你要给远程分支push啦</p></li><li><p>git clone</p><p>做了两件事情 下载了.git 本地仓库，然后把当前目录当做工作目录，把master 最新的提交内容填充当前目录</p></li><li><p>.git </p><p>.git 就是本地仓库，下面的index 代表了暂存区</p></li><li><p>git 提交流程</p><p>git add .</p><p>git commit -m</p><p>git pull 冲突发生的地方，pull 只会把需要的内容拉下来，并不能把你之前提交到本地仓库的内容push, 所以pull 之后还是需要push的（感觉这个pull还是挺智能的，在pull的时候如果有冲突，比如修改了同一个文件，还是没有提交到暂存区的那种，需要你先commit 或者废弃，想象一下pull 中包含merge 操作，merge 操作的对象是线上的commit 和 你最新的commit，所以如果有未提交的内容，一定要注意啦，别被覆盖了，但是如果没有关联的文件修改，pull的时候有没有commit 没关系）</p><p>git push</p></li><li><p>git comment</p><p>git comment 是实际的提交，会产生log 日志，像我在做itbasic 的时候经常一个功能提交多次，因为有的代码忘记提交了，可以把comment 合并，产生一个log</p><p>git comment –amend ,修正上次的提交，很方便</p></li><li><p>git push</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/482341564562475487.png" alt="image.png"></p></li><li><p>git branch</p><p>branch 字面上是分支的意思，其实就是一次提交的引用，类似head, master （远端分支head 一定指向master， 可是我们本地head 可以切换到别的分支上呀，而且对应的好像是这个分支的最新提交）</p><p>因为branch 是一个引用，所以我们删掉任何的branch ，都不会删除commit</p><p>自己的分支，因为回退之类的不能修改，那就强行 ， git push origin branch1 -f ，但这种只针对自己吧 （千万别在master 上强行push）</p></li><li><p>git checkout</p><p>git checkout -b  feature, 我们新建一个分支并切换到这个分支上面，想把本地分支提交到远端只需要git push origin feature：feature 就好了</p><p>还有就是注意我们在切换分支的时候一定要commit ,想象一下，如果我们没有commit ，在下次切换回来的时候，很多内容是不是就没有了，因为切换到的是这个分支最新的commit 上面 （但是如果是没有冲突的文件变动，是不需要的） </p></li><li><p>git 常用的工作流程</p><p>master fork 出feature 分支，开发完毕merge master 分支，推送到远端feature分支，等待merge 到master 分支上</p></li><li><p>git rebase<br>主要是用来分支合并的，比如之前在master 分支上开出来的feature 分支，开发完了再合并到master分支上，这时候master分支已经不是原先的master了，可能有向前的提交，就会出现分支的合并，如果不希望出现多条分支合并的情况，可以通过切换到feature分支上，然后git reabase mater, 以新的master分支作为起点，然后git checkout master, git merge feature, 把head 移动到最新的master 开始处</p></li><li><p>git reset –hard</p><p>git reset –hard 目标commit 到达任意一个commit ，我觉得直接用sha-1码很方便，小册中说的回退，但是用sha-1码的话，我感觉能到任意一个commit</p></li><li><p>git revert</p><p>上面那个感觉是切换到任意一个commit ，如果我们希望重新弄出一个commit，这样提交的时候就不会用冲突（revert 就是把 那个commit 的修改全部撤销）</p><p>感觉上面的两个回退就能满足绝大部分场景了</p></li></ul><ul><li>关于分支. git branch -a ，可以查看项目的本地分支和远程分支（分支有本地分支和远程分支这两种，本地分支推送到远程就变成了远程分支，以后别人clone的时候就会包含这个分支）。当我们git clone 远程项目的时候，会把这个项目的远程分支都拉下来，我们可以在本地切换各个分支。各个分支的作用？可以作为开发的时间节点来用，比如慕课网上各个讲课阶段，每次代码开发前，先开个本地分支，开发完了推送到远程，然后和并到主分支上。我们通过切换到各个分支，就知道老师讲到哪了，还能对比代码有哪些变化，以后查看的时候还可以通过编辑器<img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/992415645624757352.png" alt="image.png"></li></ul><p>来进行切换，注意切换的时候会在本地自动新建一个分支，不用担心，你想啊，本地要是不新建，你直接改动的内容算哪的。</p><ul><li><p>git 和 github 的互动</p><p>git 在我们日常生活中用的最多的就是github，当我们一台崭新的电脑希望从github 中clone 代码的时候（比如git clone xxxx），我们需要ssh 连接到github 上，不做任何处理的情况下会被告知ssh 连接失败，我们需要做的就是在本地电脑上先生成ssh 公钥和私钥（如果没有的话），然后把公钥贴到github 上，公钥的生成过程中需要一个email， 这个其实随便填都是可以的（既然email 是随便填的，但怎么识别这个公钥对应这个用户呢，我觉得应该是这个公钥被贴到对应用户的账号setting处，所以github能识别这个ssh key 对应这个用户，<a href="https://debugtalk.com/post/head-first-git-authority-verification/" target="_blank" rel="noopener">这里有篇文章写得https 和 ssh 之间的区别</a>）。</p><p>我们在仓库的提交过程中也需要配置email 和 用户名，其实这个只是代表着你显示在git log 日志上的用户名和email ，并没有实际的作用</p></li></ul><ul><li><p>今天给easy swoole 提交pr ,详细过程<a href="http://www.ruanyifeng.com/blog/2017/07/pull_request.html" target="_blank" rel="noopener">阮一峰</a></p><p>首先是从fork代码从easyswoole 到自己仓库中的时候，注意fork的是哪个分支（好像不能把所有的分支都fork下来），然后git clone 到本地仓库，这时候通过编辑器打开，可以把fork 的所有版本都打开，通过</p></li></ul><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4524515645624759596.png" alt="image.png"></p><p>编辑器右下角的切换，可以在本地创建对应分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch   本地分支</span><br><span class="line">git branch -a  远程分支</span><br><span class="line">git branch -vv 分支对应情况</span><br></pre></td></tr></table></figure><p>通过编辑器切换可以自动添加分支关联，如果想手动关联不同分支，查看这篇<a href="https://www.jianshu.com/p/fc433b1686bd" target="_blank" rel="noopener">文章</a></p><p>总结：所以 git push origin master , 这个master代表的就是分支名称喽 （git push origin master:master 其实是这样的，origin 代表的是远端仓库名称，两个master 分别代表本地的和远程分支名称）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>关于单点登陆的那些事</title>
    <link href="http://yoursite.com/2018/09/04/%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/09/04/关于单点登陆的那些事/</id>
    <published>2018-09-04T02:15:49.000Z</published>
    <updated>2019-07-31T08:41:16.565Z</updated>
    
    <content type="html"><![CDATA[<p>最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.<br><a id="more"></a><br>单点登录：简单理解成一处登陆，到处登陆，一处登出，各处登出。其实在生活中的应用还是满广泛的。比如你登录淘宝的网站，可能当你跳转到天猫上，也不需要登陆，光从界面上看，也能分辨这是两个网站，这两个网站肯定有各自的登陆机制，其实内部就是用了单点登录的原理，让用户无感知的情况下实现一个账户在各个网站下的登陆登出。<br>后来在写的过程中，发现这个单点登录也有点第三方登陆的意思，这个第三方就是sso登陆中心。<br>很多人广从字面意义上看，可能会觉的单点登录应该是这样：一个用户在这个地方登陆了，比如手机上或者上海登陆了，当在电脑上登陆或者安徽登陆了，之前登陆过的账号会下线，但这并不是单点登录哦，想了下，上述功能实现起来也挺简单，比如我们经常存取 token =》 用户信息这样的登陆凭证，又或者是session_id =&gt; session 信息（用户信息）这样的登陆凭证，不妨我们在用户登陆的时候，再存储一封 用户id =&gt; 用户信息，这样我们可以很方便的统计有哪些在线用户，哪个用户是否在线（前面第一种的话需要遍历所有的session文件取出用户id）。当我们登陆接口产生了一个新的token =》 用户信息的时候，我们检测下这个用户是否在已登录列表，如果有，我们服务端直接让之前的token失效就可以了，就能实现前面账号的下线。<br>回归正题，关于单点登录<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5747315645624763173.png" alt="797930-20161203152650974-276822362.png"><br>单点登录的原理大致就是上面了：<br>1.先登录普通web1，web1后台检测是否登陆了，如果登陆过，直接跳转到web1,如果没有登陆，跳转到sso登陆中心。sso中心检测这个用户是否登陆过，如果没有登陆，跳转到sso登陆界面，输入用户名和密码（之前为什么说单点登录很像第三方登陆呢，因为接入单点登录的web1也不知道即使能登陆到他这个平台上的用户的用户名和密码，用户登陆的操作逻辑都是sso 这个第三方维护的，web1只是在登陆sso成功之后维护一个用户和web1的登陆态，比如web1派发给用户一把钥匙，以后拿着这把钥匙就代表你是web用户了），用户成功登陆sso这个中央站点后（用户和sso之间的登陆成功搭建成，之前我是通过jwt的方式维护用户和sso之间的，jwt相比较传统的cookie和session就是通过签名的方式能防止用户篡改已登录人的信息），sso会回调web1站点上提前设置好的接口（这个我当时是在跳转到登陆中心的时候附带在url后面参数，其实这个可以提前设定好，然后通过传入一个参数web1，sso去后台查找需要的会掉地址），传给他一个参数，可以理解成一个ticket，web1拿着这个ticket可以换取正在登陆的用户的用户信息，拿到之后web1就能实现自己的业务逻辑了，比如检测这个用户是不是第一次登陆，如果是第一次登陆的话需要绑定用户信息之类的，然后维护用户和web1之间的登陆状态建成。<br>上面需要注意的点就是客户端如何接受服务端生成的登陆凭证.<br>首先是用户和sso中心，这个好解决，因为我们的登陆页面可以可以当做一个静态页面，我们可以在上面写js，这就方便了，我们发送一个ajax请求给sso，成功后把返回的登陆凭证放在cookie中，每次调用sso接口比如验证用户是否登陆的时候都会携带着这个cookie，！！！千万要注意，携带这个中在客户端浏览器的cookie的前提是通过ajax之类的访问，你别通过curl之类的访问，curl需要自己手动设置cookie，并不会像浏览器一样自动添加上，所以我们在后台一般要用header  location之类的跳转，而不是curl.<br>web1和用户之间登陆态的维护：<br>这块我没有使用header location跳转，用的是ajax返回给前端页面，前端页面去跳转，之所以这么做，好像是用第一种好像有点问题，没有去研究了，因为时间赶啊！！！前端拿着这个ticket，哈哈哈，你是不是担心不安全，我也担心呢！！而且我这块直接用的url跳转，为什么呢，因为我的后台是获取用户信息之后直接跳转，并不需要ajax那种返回了，如果这里用返回，首先是前台页面并不知道维护好登陆信息之后需要挑战的地址（这个静态页面是sso的），然后呢，如果通过ajax，后台跳转可能有些错误，之前那个sso登陆成功后台跳转不到web1，可能就是这个问题。<br>web1的回调地址里面通过ticket拿到用户信息之后可以做很多自己事情了，比如绑定用户，比如验证用户是否合法等等</p><p>2.单点退出<br>一处退出，处处退出。<br>我是这样做的，当登陆成功后，会在数据库中写入，这个用户的登出地址，当我们登出的时候，查询数据库，所有用户的登出地址，循环调用，需要注意的是我们传给用户的是只能是user_id之类的公有信息，各个子网站接收到之后，需要拿这个信息获取用户的登陆凭证，然后让其失效。我是这样做的：redis中存储着phpsessid（我们用的传统的cookie session）,然后curl 模拟请求的时候cookie带上这个，··然后就实现啦</p><p>思考：如果我们模拟请求的时候带上完全一样的头信息，是不是就能达到和浏览器一样的效果了，··有些能，比如上面的登出，但是设置cookie不可以，明明就是header加上点信息嘛，为什么不可以呢，因为cookie只能在浏览器上使用？<br>还有很多优化的空间，比如回调多个登出接口，用的消息队列，如果一个出错，是记日志吗，还是什么zzz<br>每个网站需要自己的登陆界面嘛，这样每次未登录定位到登陆界面之后就只有个登陆按钮，点击之后才能进入sso输入用户名和密码，相比较之前略麻烦，但是如果sso登陆之后，我们点击就能直接跳转到我们的网站，感觉这样更符合单点登录。<br>而且住校之后我们可以定位到普通网站的登陆界面，而且点击因为可以加回调地址，我觉得还是不能省略的。<br>代码就不放了，放些接口的函数吧<br>sso :<br>login :检测是直接跳转到登陆页面还是检测cookie是否有效，有效回调web1站点地址，无效跳转到登陆界面（看了下仿佛ajax中header location 就是有点问题）<br>logout</p><p>web1:<br>login: 判断是去sso还是直接登陆<br>logout:退出，需要回调 sso 的logout, 注销sso还有各个子网站<br>ssologin:回调登陆地址<br>ssologout：回调登出地址</p><p>关于上面跳转的问题：</p><p>今天看到群里面说的header 跳转不了疑问，其实我之前也遇到过，当时说是ajax 里面不给跳转，验证一下：</p><p>首先我们在一个接口中调用header跳转成功，说明接口没问题，ajax中调用，跳转不了。console.log 中报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response to preflight request doesn&apos;t pass access control check: Redirect is not allowed for a preflight request</span><br><span class="line"></span><br><span class="line">对预检请求的响应未通过访问控制检查：预检请求不允许重定向</span><br></pre></td></tr></table></figure><p>也就是options 请求没有带回我们想要的内容，其实这个options请求是对于我们header的那个url 的返回，和我们ajax的url 返回没啥关系，所以我把那个header 那个url 链接从原来的baidu改成我可以控制返回内容的请求，这下果然访问成功了，可是出现了新的问题页面没有改变，打开network ，发现有请求新的url,开始考虑原因: 我们在地址栏输入的api 接口可以看做是全局的，整个页面显示的是他的返回，ajax是局部的请求，他只能得到一个值，页面并不能跟随他的返回而改变，毕竟ajax是啥时候返回我们并不知道，我们平时看见的局部改变是我们根据ajax的返回主动修改页面内容的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
