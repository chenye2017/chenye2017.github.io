<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-27T02:17:09.577Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云南</title>
    <link href="http://yoursite.com/2019/08/26/%E4%BA%91%E5%8D%97/"/>
    <id>http://yoursite.com/2019/08/26/云南/</id>
    <published>2019-08-26T07:55:22.000Z</published>
    <updated>2019-08-27T02:17:09.577Z</updated>
    
    <content type="html"><![CDATA[<p>女朋友想让我陪她去洱海，因为上海直达大理的机票太贵啦┭┮﹏┭┮(后来算上住宿, 中间的火车,花的钱差不多)，我决定带着她从昆明，丽江再到大理，最后从大理再回昆明坐飞机会上海。</p><a id="more"></a><ul><li>购买机票</li></ul><p>我是买的早上7点45的飞机票，这个时间段和晚上9 10点的飞机都比较便宜，但不好的就是这么早很难赶到飞机场，再加上如果路途遥远，堵车等元素，很容易误车，然后我惊奇的发现美团上在机场旁边有那种精品酒店，其实就是机场周边的农村盖得房子，提供接送机！！！而且不贵，大概就100来块（当然也有贵的，O(∩_∩)O哈哈~），挺干净，噪音也不大，正常人完全能睡着，酒店阿姨会为你登机送机时间，提前半小时给你打电话，很暖心。</p><ul><li>起飞前的那晚</li></ul><p>这是破蛋25年来第一次带女生出去玩，再加上第一次住这种地方，还有见到女朋友的激动，最最重要的是我每次坐火车或者飞机起码检票前1个小时到目的地，那晚很紧张，没有睡着。后面因为从昆明到丽江，再从丽江到大理，从大理到昆明，这样来回折腾，其实都习惯，哪有那么多的特殊情况，安心睡吧，提前半小时到就好了。</p><ul><li>下飞机</li></ul><p>女票比我先到机场，然后因为天生自带shy属性，我在下飞机之后又在厕所呆了半小时，差点把她气疯了，还好她出门没化妆，在机场打发了一点时间。我们在美团上定的民宿在昆明的五华区，离翠湖公园还有南屏街，云南大学很近，因为担心媳妇嫌弃转车麻烦，我们直接打车过去，相比较重庆50元南山区和渝北区随便跑，80元的车票还是蛮贵的，司机师傅确认了2遍我们是否要开发票被我们说不用后，可能在想这两个瓜娃子是不是钱多了。</p><ul><li>昆明初印象</li></ul><p>昆明这座城市还是蛮破的，可能因为我们在市区的原因，还有时间是8月20日，没有书本中的花城的样子，周围都是破破的，相比较重庆没有那么繁华，现代化</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1d7a86c5c7cd42a59852d9eba53dc3f.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4d723356cb20e57a611ca43cddc8685.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7eefd14ba6a55263a396eb33ee5f132.jpg" width="400"></div></div></div></div><ul><li>玩在昆明</li></ul><p>昆明的景点还是有挺多的，比如翠湖公园，云南大学，南屏街，滇池，海埂公园 （打算去的，可是女朋友嫌弃太晒了，所以我们最后只去了翠湖公园 + 看了场哪吒！！！，翠湖公园很一般，和普通公园差不多），如果时间充足，可以去看一些石林呀，云南名族村，或者11月份之后去，可以在海埂公园喂海鸥。</p><ul><li>吃在昆明</li></ul><p>我们选择了大众点评上的第一家云南菜，云海肴，相比较那么多的好评，其实菜的味道一般般，但价格还是蛮实惠的(民宿老板推荐茄子恰恰)。 我们点了纳西族烤鱼(纳西族是云南这边的主要名族)，鱼腥草(女朋友爱吃，我实在难以下咽), 白切鸡倒上辣椒油(上海的一个味道, 女票爱吃)，还有一个豆尖豆腐汤(豆尖吃不习惯，泥土的味道)，后来想想是因为可能是让女票点菜的原因，没有吃上特色菜，下次就跟着点评上的top走。我们只在昆明呆了1天，所以只吃了3顿饭，其余的两顿中一个是世界级连锁kfc的桶饭，真的难吃，媳妇只是喝了点汤，一个是早餐，昆明的早餐很难找到喝粥的地方，只有米线，我们点了个清汤的和一笼包子，不知道为啥，米线有股臭臭的味道，包子也是皮蛮厚的，华夏大地应该都能吃到。</p><ul><li>昆明总结</li></ul><p>感觉很一般，可能是因为我们去的地方比较少，不推荐住在五华区，也就是市区，这边的景点可能就是翠湖公园</p><ul><li>丽江古城</li></ul><p>从丽江站到丽江古城有公交车可以直达，蛮方便的。相比较之前知乎上写的丽江站有很多黑车拉你去拉市海不骑马不给回，好像是因为政府整治了，丽江站可能是我去过的最干净的一个站，没有任何一家黑车，公交站台比较少，每一站中间距离很大，所以一定不要坐过站，我们住在古城中，在古城停车场下车。古城中有很多客栈，大部分都是木质的房子，不隔音，晚上睡觉的时候时不时有路过宿醉的年轻男女，放声高歌，这都是女票告诉我的，因为男生一般都睡得比较死的哈哈，所以如果你喜欢安静，那就去新城住吧。（ps:不知道是不是女票叫的太大声，客栈老板给我取了个外号，睡哥~^_^。)老板很热心，虽然可能是因为紫外线比较强的原因，皮肤黝黑，但是给我们仔细介绍了古城有哪些景点，大水车，木府（商业化，都是卖茶叶的不推荐），五一街，四方街（酒吧街），狮子山（最高点，可以看到古城全景），忠义市场（水果比较便宜，我们买了，到底便宜不，无从考证，可是没有网上说的日照时间足，甜）。</p><ul><li>古城总结</li></ul><p>丽江古城可能是我去过的最好玩的一个古城，古城的地面都是转头，所以行李箱只能拎着！！古城的道路上还有很多狗屎，似乎踩狗屎是这边的一个风俗了，古城里面有个丽江之眼 的观景台，看到的风景和狮子山上差不多。四方街也就是酒吧街很适合拍照，古城中的嘉华鲜花饼是真的好香，袋装的大概32，盒装的56，晚上和女票闹矛盾，如果有时间的一定要去试吃一下。古城的晚上超级多的人，如果怕挤的话，那就白天逛逛，但是肯定没有晚上热闹了，女票买了一个鸡血藤55，原价150，后来在别的地方看到10元三个。陪着女票去了狮子山，她看到一个清吧就钻进去了，点了两杯喝的，一盒瓜子，一盒牦牛肉，175，客栈老板说蛮坑的，但是女票想看夜景呀，后来发现古城的夜景真的好垃圾哦，但也可能我们那个地方不够高，不推荐狮子山上的商业清吧。我们在丽江迟了一顿，滇厨餐厅，还可以，他家的水性杨花（一定要在云南吃水性杨花）很好吃，腊排骨分量太大，两个人吃不完，红豆酸奶味道和别的地方一样，铜锅饭两个人吃刚好，但味道一般，鸡豆凉粉一般，玫瑰糍粑有花的味道，对于我这种很少吃糍粑的人来说一定要点，土豆泥不好吃。</p><ul><li>玉龙雪山</li></ul><p>我们在美团上团了雪山的一日游，320一位，小索道 + 甘海子 + 蓝月谷 + 云杉坪，蛮推荐的，早上八点的时候有师傅来接我们，晚上5点能回到古城。索道一共分成3种，大索道（冰川公园），牦牛坪中索道，云杉坪小索道。当时我们一车8个人，只有我和女票是小索，剩下的都是挑战4680的玉龙雪山，当时害怕死了，以为女票要和我发火，可是后来呢师傅说我们这个季节小索道最好玩，11月到来年2月大索道才好玩，因为现在山顶都是雾，看不到东西，而且没有雪（媳妇夸我功课做得足，嘿嘿），而且大索道需要排队很久。上午的行程就是坐小索道去半山腰，然后徒步去云杉坪，路途很短，中间可能遇到马，可以喂食，所以带点面包或者买个玉米喽，路途的风景就是类似高海拔的林区。栈道的尽头就是云杉坪了，很大的一片草场，有一些牦牛在吃草，还有很多新人在拍照。这边的天气阴晴不定，要随身带着伞，或者纯玩团发的羽绒服，也是可以防雨的。</p><p>小索道的行程一点不紧张，中午有团餐，真的这是我来云南吃的最好吃的一顿（水月阁老山鸡火锅），第一次发现火锅中烫鸡肉能这么好吃，汤汁特别鲜美，泡上米饭，让人欲罢不能，而且可以随便加肉加菜，胃口大的小伙伴们有福了。</p><p>下午我们逛的是蓝月谷，蓝月谷的湖水真的像网上那般蓝绿，但小瀑布处的水又白的那么彻底，从下游走到上游，一路上很多拍婚纱的新人，希望他们的爱情也能永远和这湖水一样纯净，没有杂质，配着远处白云缭绕的玉龙雪山，真的美不胜收。</p><p>逛完蓝月谷之后我们的行程就基本结束了，做大巴（免费的，都包含在门票中，所以看到大巴就可以随便上）来到入山口，等着纯玩团的小伙伴们集合，一起坐导游师傅的车回古城，沿途路过甘海子，司机会让拍拍照，^_^因为这也算一个景点啦（总共4个），因为太累了，男生们都没有下车，女生会出来走走，其实就是一个大片的小树林。</p><ul><li>大理</li></ul><p>在大理住宿的话，大概有两个主要地方，一个是古城，感觉住宿情况应该类似丽江，但肯定只会比丽江差，因为我们去古城玩的时候会看到很多民宿，真的就是那种农村自建的房屋，肯定看不到海，另一个就是双廊，双廊那边因为紧靠洱海，可以看到海，所以住宿比较贵。我们呢选的是滨海俊园，在大理白族自治州博物馆旁边，那家住宿真的除了甲醛味道，应该是我们这次旅行最满意的地方了，所有可能用到的物品（矿泉水，棉花棒，byt，熨斗，雨伞…）能想到的都有，而且很多小设计很贴心，比如浴室的感控灯，浴室的喷头是对着墙，所以刚开始放水的时候喷不到身上，方便我们调整水温，还有因为云南那边四季如春，loft的房屋基本都没有空调。</p><p>我们在大理一共吃了两顿，一家是遇见小仙女，点了豆腐，汽锅鸡，野生菌，因为媳妇不饿，所以我们店的不多。不太好吃，^_^，豆腐很油，汽锅鸡以为和昨天的老山鸡火锅一样才点的，其实他更像是炖鸡，媳妇比较爱吃。最坑的应该hi那个野山菌了，80元，但味道一般，也不下饭。还有一家是方胖子厨房，我们点的是野山菌火锅，点了三种菌加两个蔬菜，加一个鲜牛肉，锅底中有鸡肉，所以两个人能吃的很饱，同样没有很惊艳，汤汁肯定没有老山鸡鲜美啦（哈哈哈，水月阁老山鸡火锅是我的最爱）</p><ul><li>大理景点</li></ul><p>大理古城：一般，肯定比不上丽江古城，也没有什么景点</p><p>大理白族自治州博物馆：很安静，我对历史没有什么兴趣，但值得一去</p><p>花语牧场： 门票蛮贵的，两个人80，媳妇说就拍了几张照片，我感觉还好，要是有喜欢拍照的朋友，还是可以拍出很多漂亮的照片的</p><p>喜洲古镇：一般，没有逛，牛奶冰棒和喜洲粑粑，可能我们没迟到正宗的，一般</p><p>双廊古镇：一般，但是媳妇吃到她最喜欢的猪大肠，还给她妈买了个银镯子，8元一克，后来发现别的家只用6元</p><p>小普陀：停车费10元，然后就没有啥印象啦</p><p>洱海：如果想环洱海的话最好租车，电瓶车肯定不行，而且挺晒的， 价格大概是 80 vs 500, 小伙伴们自行斟酌</p><p>挖色镇，太阳宫都没怎么去，基本都差不多，我们租了车（媳妇说很难开，500一天，蛮贵的当时感觉，我当时想订的是350，但是看到她发朋友圈就感觉蛮值得，毕竟我想订的那个确实不太好看）</p><p>上面大概就是这次云南的五日游，总的来说，丽江最好玩，昆明和大理（农村）一般，但也算是圆了女票的一个梦，这就够了吧，拜拜~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;女朋友想让我陪她去洱海，因为上海直达大理的机票太贵啦┭┮﹏┭┮(后来算上住宿, 中间的火车,花的钱差不多)，我决定带着她从昆明，丽江再到大理，最后从大理再回昆明坐飞机会上海。&lt;/p&gt;
    
    </summary>
    
      <category term="旅游" scheme="http://yoursite.com/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="云南" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-middleware和hook</title>
    <link href="http://yoursite.com/2019/08/09/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-middleware%E5%92%8Chook/"/>
    <id>http://yoursite.com/2019/08/09/tp源码分析-middleware和hook/</id>
    <published>2019-08-09T01:48:42.000Z</published>
    <updated>2019-08-09T06:29:32.503Z</updated>
    
    <content type="html"><![CDATA[<p>这块的中间件主要值的是route 中间件，对于请求发送到controller之前进行一系列的判断，是否缺胳膊少腿不符合要求，如果不符合，返回false, 符合 next($response)</p><p>钩子就是流程执行到某个点，触发用户绑定的方法，之所以这么做是为了用户可以在框架的层面做某些修改，而不用修改框架源码。</p><a id="more"></a><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;start&apos;.&quot;&lt;br&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">        // 在触发钩子之前，绑定行为到指定钩子</span><br><span class="line">        Hook::add(&apos;test_1&apos;,&apos;app\\test\\behavior\\BehaviorTest&apos;); // 添加钩子处理</span><br><span class="line">        Hook::add(&apos;test_2&apos;,&apos;app\\test\\behavior\\BehaviorTest&apos;);</span><br><span class="line"> </span><br><span class="line">        // 调用设置了钩子的函数来触发钩子，进行测试</span><br><span class="line">        Hook::listen(&apos;test_1&apos;,[&apos;name&apos;=&gt;&apos;cy&apos;]); // 设置钩子，并执行钩子绑定的函数方法，第二个变量是数组方式传入钩子函数需要的变量</span><br><span class="line">         Hook::listen(&apos;test_2&apos;,[&apos;name&apos;=&gt;&apos;cy&apos;]);</span><br><span class="line">    </span><br><span class="line"> class BehaviorTest &#123;</span><br><span class="line">    public function test_1($param) &#123;</span><br><span class="line"> </span><br><span class="line">        var_dump($param[&apos;name&apos;])</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public function  test_2($param) &#123;</span><br><span class="line">   var_dump($param[&apos;name&apos;])</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>php 因为是同步的，所以他这个钩子函数和别的语言理解起来还不一样，比如这个listen， 在监听的同时并且执行了后面类中绑定的方法，而不像一些异步语言，listen之后等待着事件的触发。</p><p>还有就是我们绑定的是类，一个类中会有多个方法，默认的初始方法是run ,这个类中还可以有多个方法，多个方法对应多个钩子，方法名和钩子名一样</p><p>分析一下Hook</p><p>tags   核心属性，不同的钩子对应不同的类（可以是多个类组成的数组）</p><p>bind   别名，也是给类绑定别名</p><p>portal  入口方法名称，默认run</p><p>app 应用对象，App的实例，也是单例模式</p><p>__construct</p><p>构造方法，注入App 实例 $app</p><p>portal</p><p>设置入口函数名称</p><p>alias</p><p>修改bind 属性，给行为（对应某个类中特定方法，也是唯一一个方法，所以这个behavior 方法就是是class）绑定别名</p><p>add</p><p>添加点对应的行为，行为可以是关联数组，key _overlay 会让添加的value 覆盖之前的value, key  first 会让添加的value 排在第一位</p><p>import</p><p>批量导入 点对应的行为，可以是让import 和之前的tags 标签合并，也可以是让之前的tags 覆盖import 导入的内容</p><p>get</p><p>获取tags 属性</p><p>listen </p><p>其实就是执行某个点中绑定的类中的方法</p><p>exec</p><p>执行某个类中方法（方法名确定，就是portal）</p><p>execTag</p><p>执行绑定的类中的方法，先去执行listen 的点对应的method是否存在，如果能执行，执行默认方法 </p><h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>中间件用的设计模式是装饰器模式，每个装饰器类中只有一个方法，handle，第一个参数是Request请求，第二个参数是匿名函数 next， 还可以接受额外的参数，他这块也用的是反射，所以你如果没有添加第三个参数，在方法内部用func_get_args() 是获取不到额外的参数的，即使你在路由上middleware 传入了这个参数。因为反射没有获取到第三个参数的存在，所以执行的时候就不会传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace app\http\middleware;</span><br><span class="line"></span><br><span class="line">class Check</span><br><span class="line">&#123;</span><br><span class="line">    public function handle($request, \Closure $next, $pa1 = 1, $pa2 = 2) // 难道只能装一个参数吗</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($pa1,&apos;|&apos;, $pa2);exit;</span><br><span class="line">        $request-&gt;name = &apos;cy&apos;;</span><br><span class="line">        return $next($request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Route::get(&apos;/testhook&apos;, &apos;index/testhook&apos;)-&gt;middleware([&apos;Check:name&apos;]);</span><br></pre></td></tr></table></figure><p>如果我们在application下面的middleware.php 中写入，那么全局所有的route都会经过这个中间件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这块的中间件主要值的是route 中间件，对于请求发送到controller之前进行一系列的判断，是否缺胳膊少腿不符合要求，如果不符合，返回false, 符合 next($response)&lt;/p&gt;
&lt;p&gt;钩子就是流程执行到某个点，触发用户绑定的方法，之所以这么做是为了用户可以在框架的层面做某些修改，而不用修改框架源码。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="TinkPHP" scheme="http://yoursite.com/tags/TinkPHP/"/>
    
      <category term="中间件" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="钩子" scheme="http://yoursite.com/tags/%E9%92%A9%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-facecde和ioc</title>
    <link href="http://yoursite.com/2019/08/09/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-facecde%E5%92%8Cioc/"/>
    <id>http://yoursite.com/2019/08/09/tp源码分析-facecde和ioc/</id>
    <published>2019-08-09T01:47:55.000Z</published>
    <updated>2019-08-09T05:32:05.269Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们梳理一下关系，ioc 作为一个容器，是个单例的存在，它存在于自身container的instance 属性中，他还有个instances 属性，作为一个关联数组，key的内容是类名，value 内容是某个类的实例(这个类并不一定要是单例)， 当我们下次再去容器中取这个类实例的时候，还是之前的实例 (!!!千万注意一定是容器中取，才能保证是上次的类实例), 我们从容器中获取类实例，并不一定要提前bindto, bind 本质只是绑定一个别名，通过别名最终还是找到实际的类名，所以没有绑定直接传类名也是可以的。 那什么是facade 呢， 通过返回容器中的类别名或者类实际的名称，去容器中找类实例，然后调用该实际类的方法</p><a id="more"></a><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>Container 实现了arrayAccess (方便数组调用)， iteratorAggregate (方便foreach循环) , countable(方便 count()) 调用</p><p>instance    container 的单例</p><p>instances  []    装的类的实例</p><p>bind  类标识，通过标识寻找实际类</p><p>name  别名，感觉和前面bind差不太多</p><p>getInstance </p><p>获取container 的单例</p><p>setInstance</p><p>设置container 的单例</p><p>get</p><p>从container 的单例instance 的属性 instances 中获取类的实例，对于container 的单例调用 make 方法</p><p>set</p><p>container 实例 绑定一个类、闭包、实例、接口实现到容器，注意可能并没有生成类的实例，也就是instances属性中可能并没有</p><p>remove </p><p>container 实例中instances 属性删除某个类实例</p><p>clear</p><p>bindTo</p><p>修改bind属性，包括关联数组（merge）, 闭包直接赋值，string 修改bind, 对象，修改bind ,并把 instances中绑定这个实例</p><p>instance </p><p>绑定一个实例到容器中，感觉作用相当于bindTo的一部分</p><p>bound</p><p>判断容器中是否存在类标识或者实例</p><p>exists</p><p>判断容器中是否有该类实例</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190809123749.png" alt=""></p><p>从这个方法很容易判断，instances 中key 是实际的类名</p><p>has</p><p>调用的上面bound 方法</p><p>make</p><p>创建类的实例， 第三个参数newInstance 类似我之前写的那个token 文件的第三个参数 force，强制刷新实例。</p><p>make 会先去查看是否有别名，然后换算成实际类的名称，去instances属性中查找。如果没有只能生成啦。如果是匿名函数，通过反射获取参数，然后绑定参数，如果有依赖注入，首先查看是否有传入这个实例，没有的话生成。如果是类的话，会先判断是否有__make 方法，没有的话调用constructor 构造函数，执行函数的过程类似上面执行匿名函数</p><p>delete</p><p>删除instances中的实例</p><p>all</p><p>输出instances内容，也就是生成的所有实例</p><p>flush</p><p>置空 instances ， bind， name 属性</p><p>invokeFunction</p><p>从一个方法中获取反射，然后执行这个方法</p><p>invokeMethod</p><p>从一个类的方法中获取反射，然后执行这个方法</p><p>invokeReflectMethod</p><p>这个方式要求传入实例还有反射，还有参数，（所有的参数都给备齐了）就相当于上面方法的子方法，上面方法也是调用这个方法去实际执行反射类中的方法</p><p>invoke</p><p>实现方法</p><p>invokeClass</p><p>实现类</p><p>bindParams </p><p>生成类或者方法需要的参数，支持依赖注入</p><p>getObjectParam</p><p>bindParams 对于依赖注入的处理需要用到这个方法</p><p>后面的方法都是为了上面那几个接口中方法的实现，操作的都是instance 实例中的instances属性</p><h3 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h3><p>bind 别名，类似container 中的bind</p><p>alwaysNewInstance ，因为facade 本质上也是从container 中取实例，所以也需要这个强制刷新属性</p><p>bind</p><p>绑定别名</p><p>createFacade</p><p>先根据继承了facade 的类中getFacadeClass 返回的内容中确定类，如果没有，去bind属性中查找（注意这里是self）,都没有的话就用传入的类名。确定了类名去container 中找实例，没有的话自动生成</p><p>getFacadeClass </p><p>返回容器中类的别名或者直接返回类的名称</p><p>instance</p><p>make</p><p>和createFacade 差不多</p><p>__callStatic</p><p>facade 的核心，通过createFacade 实例化实际类，然后用这个实例去调用method方法 （一定要注意我们在调用类中的方法的时候除了static都是在一个类实例上调用的方法，我们的方法中可能会用到\$this ,这个\$this就是对象）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以Config 举例，\Config 通过class_alias 实际找到的是 \think\facade\config,然后这个类中没有我们想要的方法，调用的是父类 facade中的__callStatic, 这个方法先通过createFacade 生成实例，实例是先从container 中查找别名换成真的类名，然后去instance中查找实例，有就返回，没有再生成。实例获取到后，再去执行方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们梳理一下关系，ioc 作为一个容器，是个单例的存在，它存在于自身container的instance 属性中，他还有个instances 属性，作为一个关联数组，key的内容是类名，value 内容是某个类的实例(这个类并不一定要是单例)， 当我们下次再去容器中取这个类实例的时候，还是之前的实例 (!!!千万注意一定是容器中取，才能保证是上次的类实例), 我们从容器中获取类实例，并不一定要提前bindto, bind 本质只是绑定一个别名，通过别名最终还是找到实际的类名，所以没有绑定直接传类名也是可以的。 那什么是facade 呢， 通过返回容器中的类别名或者类实际的名称，去容器中找类实例，然后调用该实际类的方法&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="facecde" scheme="http://yoursite.com/tags/facecde/"/>
    
      <category term="ioc" scheme="http://yoursite.com/tags/ioc/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-Config</title>
    <link href="http://yoursite.com/2019/08/09/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Config/"/>
    <id>http://yoursite.com/2019/08/09/tp源码分析-Config/</id>
    <published>2019-08-09T01:47:22.000Z</published>
    <updated>2019-08-09T03:49:27.107Z</updated>
    
    <content type="html"><![CDATA[<p>thinkphp config 源码阅读，为了更好的使用~</p><a id="more"></a><p>首先 config  implements ArrayAccess, 所以我们可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$z = new \think\Config();</span><br><span class="line">$z-&gt;load(__DIR__.&apos;test.ini&apos;,&apos;test&apos;);  // test 作为前缀，用来分割不同文件的配置项，如果不加，会放在一级目录，不太合适</span><br><span class="line">// test 内容</span><br><span class="line">[boy]</span><br><span class="line">name=cy</span><br><span class="line">sex=1</span><br><span class="line"></span><br><span class="line">var_dump($z[&apos;test&apos;][&apos;boy&apos;][name]); // cy</span><br></pre></td></tr></table></figure><p>分析Config的几个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config . 核心，配置文件内容加载进来的存放</span><br><span class="line">prefix   默认前缀，set的时候，如果key 是个string , 默认前缀， 注意set 的内容如果是个数组，那就直接合并</span><br><span class="line">path 初始化构造函数，配置文件的位置</span><br><span class="line">ext  初始化构造函数，配置文件的类型</span><br><span class="line">yaconf 布尔值或者字符串，用来支持yaconf</span><br></pre></td></tr></table></figure><p>__construct </p><p> 配置一些基本的参数，比如path 配置文件路径，ext 配置文件后缀，yaconf 判断是否安装了yaconf扩展</p><p>__make </p><p>获取注入类app 中config文件路径和ext 文件后缀，初始化一个config类</p><p>setYaconf</p><p>注意这个一定要在属性yaconf true 的时候才能设置</p><p>getYaconf </p><p>获取</p><p>setDeafultPrefix</p><p> 设置前缀，比如app</p><p>parse  </p><p>把一个配置文件（config driver 下面支持的类型，默认ini, json, xml）加载到 \$this-&gt;config 属性中</p><p>load </p><p>加载文件(先判断该文件是否存在，不存在添加上文件夹前缀和文件后缀)解析放到config中，调用parse，并添加支持php,yaml.</p><p>getYaconfName  </p><p>Yconf::get(key), 获取的就是这个key</p><p>yaconf </p><p> 获取yaconf 中内容，感觉比如直接调用yaconf 的get</p><p>loadfile</p><p>load = loadfile + yaconf</p><p>has </p><p>判断是否有某个key , 如果没有添加前缀，会添加默认前缀. (默认所有的config 都得挂在某个 一级key 下面，比如app(默认)， 比如 log)</p><p>pull</p><p>获取所有的config 中一级配置，或者yaconf 中的某个属性 + config 中的一级配置</p><p>get</p><p>获取配置，key 中没有 . ,默认添加app 前缀，支持获取多层嵌套</p><p>set</p><p>只能支持两级key ,不包括文件名，如果传入数组，合并原先 config属性（只有在key 是string 的时候才会添加默认prefix ）</p><p>remove </p><p>移除key</p><p>reset</p><p>重置某个key</p><p>剩下arrayAccess 需要实现的方法，方便数组方式调用</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>config 文件中支持 yaconf 和 \$this-&gt;config, 可有的方法是从二者中某个取值(一般都是yaconf优先)， 有的是yaconf 和 config 合并。</p><p>yaconf 的key中，第一个肯定是文件名</p><p>config key 中，如果没有. 默认都会拼上prefix , 想获取一个文件中所有内容，key 可以这样 app. , 感觉没有yaconf 直观，规范</p><h3 id="关于yaconf-具体可以参考鸟哥博客"><a href="#关于yaconf-具体可以参考鸟哥博客" class="headerlink" title="关于yaconf(具体可以参考鸟哥博客)"></a>关于yaconf(具体可以参考鸟哥博客)</h3><p>yaconf 是鸟哥写的一个常驻内存的配置文件扩展，（windows下使用有些问题）</p><p>很简单，默认两个配置项，一个是dir (把该文件夹下的所有的ini文件都加载进内存，不支持文件夹是为了简单，不支持别的类型文件是为了简单),一个是check 更新时间(每隔比如2s检测一下文件是否改动, 只能用mv, 不能用cp, 可能是根据文件修改时间来进行判断是否改动)</p><p>api 也只有两个，</p><p>// test 是文件名，name是属性</p><p>get(‘test.name’)  // 获取内容</p><p>has(‘test.name’) //  判断是否有内容</p><p>我们来想想yaconf 解决的问题：我们在开发itbasic 的时候经常被这样的问题困扰，对于配置项，线上环境和本地环境不一样，所以导致我们每次提交代码都很麻烦，但凡用到配置参数的文件都会和线上文件冲突。后来我们把配置项都写到一个文件中，通过config 去获取，并且不把config文件纳入版本库，其实yaconf的本质也是这样，只是他分的更彻底，把config 完全移除项目代码，和项目代码分离，放到一个单独的文件夹中，可以让运维人员或者任何人员去修改。</p><h3 id="关于配置文件格式"><a href="#关于配置文件格式" class="headerlink" title="关于配置文件格式"></a>关于配置文件格式</h3><p>tp 中有ini, json, xml, yaml, php 文件</p><p>对于ini 文件（.env文件也是ini ）可以直接调用方法解析</p><p>json ,我们直接读取文件内容，然后json_decode </p><p>xml ,我们直接调用方法解析</p><p>yaml ,我们需要安装yaml 扩展（centos7 中安装yaml 工具）</p><p>php, 我们直接include , 文件中的return 内容会被include 返回</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;thinkphp config 源码阅读，为了更好的使用~&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
      <category term="Config" scheme="http://yoursite.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-composer加载</title>
    <link href="http://yoursite.com/2019/08/03/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-composer%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/08/03/tp源码分析-composer加载/</id>
    <published>2019-08-03T15:04:50.000Z</published>
    <updated>2019-08-09T02:21:51.474Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇文章是关于composer 的基本用法，这篇文章是composer源码的简单阅读和thinkphp5.1的自动加载。</p><a id="more"></a><p>先来熟悉一个函数，get_declared_classes, 这个函数是干嘛的？是获取当前脚本中已经加载的类的，但凡这个返回结果中有的类，我们都可以直接生成，默认在一个空脚本中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump(get_declared_classes());</span><br></pre></td></tr></table></figure><p>是当前php中包含的所有扩展类，那如果没有包含在这其中的类我们应该怎么生成实例对象呢？远古时代是通过 require_once，想想添加每个新脚本的时候都要在上面写个require, 这样太不智能了，php给我们提供了一个函数spl_autoload_register, 通过不断的调用这个函数，可以绑定自定义的函数到一个队列中，如果我们生的对象的类在内存中找不到，他就会执行这个队列中的所有自定义方法，直到找到为止， composer 本质上也是基于这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">来自composer ClassLoader.php</span><br><span class="line">&lt;?php</span><br><span class="line">public function register($prepend = false)</span><br><span class="line">    &#123;</span><br><span class="line">        spl_autoload_register(array($this, &apos;loadClass&apos;), true, $prepend);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们在github上安装一个包（或者叫库）， 我们先composer require, 安装完了之后再在我们的脚本中加上 vendor/autoload.php, 然后就能用了，注意一定要require_once vendor/autoload.php 这个文件，否则你只是下载了包，当生成对象的时候，内存中还是没有这个类的存在(以klein举例)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190803232124.png" alt=""></p><p>那我们开看一下这个autoload .php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// autoload.php @generated by Composer</span><br><span class="line"></span><br><span class="line">require_once __DIR__ . &apos;/composer/autoload_real.php&apos;;</span><br><span class="line"></span><br><span class="line">return ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378::getLoader();</span><br></pre></td></tr></table></figure><p>调用的是composer 包中autoload_real 中的getLoader 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static function getLoader()</span><br><span class="line">    &#123;</span><br><span class="line">        if (null !== self::$loader) &#123;</span><br><span class="line">            return self::$loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spl_autoload_register(array(&apos;ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378&apos;, &apos;loadClassLoader&apos;), true, true); // 这个为了能让生成classLoader 的实例对象</span><br><span class="line">        self::$loader = $loader = new \Composer\Autoload\ClassLoader();</span><br><span class="line">        spl_autoload_unregister(array(&apos;ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378&apos;, &apos;loadClassLoader&apos;));</span><br><span class="line"></span><br><span class="line">        $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&apos;HHVM_VERSION&apos;) &amp;&amp; (!function_exists(&apos;zend_loader_file_encoded&apos;) || !zend_loader_file_encoded()); // true</span><br><span class="line">        if ($useStaticLoader) &#123; // 走的这个逻辑</span><br><span class="line">            require_once __DIR__ . &apos;/autoload_static.php&apos;;  // 包含这个文件是因为要调用他的getInitialize()方法，也就是这个方法</span><br><span class="line"></span><br><span class="line">            call_user_func(\Composer\Autoload\ComposerStaticInit23a88103aab8adc5d1263de38cceb378::getInitializer($loader)); // 这个方法的作用就是让一个闭包复制给ClassLoad类(核心类)上，让这个闭包可以访问classLoad 的私有变量 prefixLengthsPsr4， prefixDirsPsr4， classMap （psr0 过时了，不看）。classMap 文件就是composer.json 中classMap, 他会把一个文件夹中的文件中包含的类和文件名对应出来，自动加载的时候通过类名作为key, 去寻找这个文件的位置。想laravel thinkphp 生成类和文件的对应关系，也是基于这个原理</span><br><span class="line">            // 说说prefixlengthsPsr4 还有prefixDirsPsr4 吧，当我们在composer.json 中自定义composer autoload psr4 ,就是就是往这里面写对应关系，首先去类的第一个字母在prefixlengths 中寻找，找到之后再去prefixDirsPsr4中找具体的命名空间对应的文件夹，然后通过把命名空间依据psr4转换成文件名称，在之前找到的文件夹下面寻找这个文件，具体的验证方法可以看classLoad的 loadClass,也就是spl_autoload_register 中注册的</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $map = require __DIR__ . &apos;/autoload_namespaces.php&apos;;</span><br><span class="line">            foreach ($map as $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;set($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $map = require __DIR__ . &apos;/autoload_psr4.php&apos;;</span><br><span class="line">            foreach ($map as $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;setPsr4($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $classMap = require __DIR__ . &apos;/autoload_classmap.php&apos;;</span><br><span class="line">            if ($classMap) &#123;</span><br><span class="line">                $loader-&gt;addClassMap($classMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $loader-&gt;register(true); //注册ClassLoader 的 loadClass 方法作为最终的spl_autoload 方法</span><br><span class="line"></span><br><span class="line">        if ($useStaticLoader) &#123; // true ,走的这个逻辑</span><br><span class="line">            $includeFiles = Composer\Autoload\ComposerStaticInit23a88103aab8adc5d1263de38cceb378::$files; // autoload_static 中的文件，这个文件咋来的，composer.json 中的autload files 选项</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $includeFiles = require __DIR__ . &apos;/autoload_files.php&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123;</span><br><span class="line">            composerRequire23a88103aab8adc5d1263de38cceb378($fileIdentifier, $file); //这个方法就是包含上面的文件，所以 composer.json 中的files 是我们包含了vendor 目录下的autload.php就直接包含进来了，不是后期通过spl_autoload_register 中的方法生成的。为了验证我们可以在这些files 中定义class, 然后不new生成对象，也就没有触发spl_autoload_register中方法，看内存中有没有这个类</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好了，我们来总结一下composer 文件夹中的几个比较重要的文件，autoload_real.php 是注册Classload .php 成为spl_autoload_register中的方法，autoload_static.php类似一个配置文件，把他包含的类对应文件夹的属性都绑定到ClassLoad 上，ClassLoad 调用自己的loadClass 方法，根据类名，去自己的属性上找对应的类所在文件位置。</p><p>现在抛出问题，我们如何不通过composer require去安装一个库文件？</p><p>其实很简单，composer require 做了两个工作，首先git clone 那个库到你本地vendor目录，再接着配置autoload_static.php 文件中的两个属性，prefixLengthsPsr4， prefixDirsPsr4，第一个属性是命名空间的首字母对应命名空间，第二个是命名空间对应类的文件位置，配置好了之后，我们就可以试着new class了，看会不会报错，一般情况下不会，除非这个类库中除了psr4 还有classMap 或者files 或者psr0,这样我们一点点的添加，就能完成。</p><p>接着我们看看thinkphp5.1 的自动加载机制，thinkphp的自动加载其实就是composer的翻版，他为了兼容composer, composer 中的文件没有动，只是他没有require vendor 下面的autoload.php， 转而是通过think 库 base.php -&gt;load.php,这个load.php 作用类似composer 的autoload_real 和 CLassLoader, </p><p>load.php 中的register 方法通过获取composer 的autload_static 中的prefixLengthsPsr4’, ‘prefixDirsPsr4 属性，绑定到自身，获取了composer 中通过psr4 加载的类，顺便把自己的think 和 trait也加入其中.</p><p> 对于classMap, 他获取的自己runtime 文件夹下的classMap.php 文件中的内容，该内容需要调用命令生成，就是thinkphp 自身的类和对应文件位置的集合。</p><p>最后是自动加载目录，他的功能类似psr4,就是把自动加载的目录当做根目录，类文件按照psr4，由这个相对根目录展开。</p><p>thinkphp 还有个classAlias 功能，classAlias 利用的是class_alias 这个方法，让两个类一模一样，除了类名，这样可以简写我们的类名长度，注意使用的时候一定要加上根命名空间\，否则可能会在当前命名空间下寻找改类，这个在laravel中用的也很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 注册类库别名</span><br><span class="line">Loader::addClassAlias([</span><br><span class="line">    &apos;App&apos;      =&gt; facade\App::class,</span><br><span class="line">    &apos;Build&apos;    =&gt; facade\Build::class,</span><br><span class="line">    &apos;Cache&apos;    =&gt; facade\Cache::class,</span><br><span class="line">    &apos;Config&apos;   =&gt; facade\Config::class,</span><br><span class="line">    &apos;Cookie&apos;   =&gt; facade\Cookie::class,</span><br><span class="line">    &apos;Db&apos;       =&gt; Db::class,</span><br><span class="line">    &apos;Debug&apos;    =&gt; facade\Debug::class,</span><br><span class="line">    &apos;Env&apos;      =&gt; facade\Env::class,</span><br><span class="line">    &apos;Facade&apos;   =&gt; Facade::class,</span><br><span class="line">    &apos;Hook&apos;     =&gt; facade\Hook::class,</span><br><span class="line">    &apos;Lang&apos;     =&gt; facade\Lang::class,</span><br><span class="line">    &apos;Log&apos;      =&gt; facade\Log::class,</span><br><span class="line">    &apos;Request&apos;  =&gt; facade\Request::class,</span><br><span class="line">    &apos;Response&apos; =&gt; facade\Response::class,</span><br><span class="line">    &apos;Route&apos;    =&gt; facade\Route::class,</span><br><span class="line">    &apos;Session&apos;  =&gt; facade\Session::class,</span><br><span class="line">    &apos;Url&apos;      =&gt; facade\Url::class,</span><br><span class="line">    &apos;Validate&apos; =&gt; facade\Validate::class,</span><br><span class="line">    &apos;View&apos;     =&gt; facade\View::class,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>好了，大致就这么多了，所以我们可以猜测一波（没有仔细看啦）</p><p>composer dump-autoload,主要是因为我们修改了composer.json文件中的autoload.psr4选项，没有及时修改autload_static 文件，</p><p>composer require 1. git clone 2.修改autoload_static 文件</p><h3 id="实战：如何用命令行的方式运行tp，测试tp中的函数"><a href="#实战：如何用命令行的方式运行tp，测试tp中的函数" class="headerlink" title="实战：如何用命令行的方式运行tp，测试tp中的函数"></a>实战：如何用命令行的方式运行tp，测试tp中的函数</h3><p> 首先因为tp重写了composer 的加载方式（但没有修改composer 的文件, 为了方便composer update, install )， 所以我们用不了vendor 中的_autoload.php, tp起到相同作用的是 Loader::register 方法，这个方法中 对app 文件夹，和 think\composer 进行了psr4 加载，同时把thinkphp 核心文件夹library 下的think 和traits 也进行psr4 进行加载，这样我们就能访问app , think\composer, thinkphp\libraray\think和thinkphp\libraray\traits 下的所有文件了。同时他还通过loader 的addAutoLoadDir 把extend 文件夹做成classmap 进行加载，所以为了测试我建立了cy文件夹，也需要Load::addAutoLoadDir(realpath(‘cy’))。 当然如果我们还可能为了方便使用系统的一些类，需要class_alias。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm.</span><br><span class="line"> * User: cy</span><br><span class="line"> * Date: 2019/8/4</span><br><span class="line"> * Time: 13:08</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//require_once &apos;../vendor/autoload.php&apos;;</span><br><span class="line">require_once &apos;../thinkphp/library/think/Loader.php&apos;; // 为了使用Load中的方法</span><br><span class="line">require_once &apos;../thinkphp/helper.php&apos;; // 为了使用助手函数</span><br><span class="line"></span><br><span class="line">$nowDir = realpath(__DIR__); //获取当前文件夹的绝对位置，方便函数调用</span><br><span class="line"></span><br><span class="line">//var_dump($nowDir);</span><br><span class="line"></span><br><span class="line">\think\Loader::register(); // 把composer 的自动加载接管过来;</span><br><span class="line">\think\Loader::addAutoLoadDir(realpath(__DIR__)); // 加载当前脚本下的类进入psr4</span><br><span class="line"></span><br><span class="line">// 注册类库别名，方便直接调用，比如 \Config</span><br><span class="line">\think\Loader::addClassAlias([  </span><br><span class="line">    &apos;Config&apos;      =&gt; \think\facade\Config::class, </span><br><span class="line">    &apos;Env&apos; =&gt; \think\facade\Env::class</span><br><span class="line"></span><br><span class="line">]);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇文章是关于composer 的基本用法，这篇文章是composer源码的简单阅读和thinkphp5.1的自动加载。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="composer" scheme="http://yoursite.com/tags/composer/"/>
    
  </entry>
  
  <entry>
    <title>同步 异步 阻塞 非阻塞</title>
    <link href="http://yoursite.com/2019/07/20/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2019/07/20/同步-异步-阻塞-非阻塞/</id>
    <published>2019-07-20T07:54:07.000Z</published>
    <updated>2019-07-31T08:41:16.580Z</updated>
    
    <content type="html"><![CDATA[<p>灵感来源别人利用多进程写了个python 的下载器，于是想自己用php试一下</p><a id="more"></a><p>先说下多进程和单进程</p><p>lnmp请求过程</p><p>http请求到达nginx，nginx 转发给php-fpm(一个php进程管理器，~so，这个地方就是多进程啦)，每个进程中实现了fast-cgi 协议(请求完毕，并不重启进程，而是等待下一个请求的到来，除非到达该线程接受http请求最大数量，会自动重启，目的是为了防止一些代码不好，导致内存泄漏)，每个进程中其实就是 php index.php（请求处理完逐个往回返回）, 所以我们可以把lnmp 模型理解成多进程模型，同一时刻并发的数量就是php-fpm配置的进程数量，但为什么别人说php是单进程呢，因为我们平时在开发的过程中，所有的代码都是跑在一个请求中，也就是一个进程中，所以我们可以说php就是单进程的，但php真的只是单进程的吗，不是，php有个扩展叫pcntl ，这个扩展不建议在php-fpm模式下使用，但是在php-cli 下可以正常使用，也就是说我们不建议在php-fpm的工作进程中再fork新的子进程（同理swoole 中也不建议在worker进程中new process 新的进程），既然在工作进程中不涉及fork 子进程，而php也很少操作线程，那么php就和异步搭不上边了。</p><p>同步，异步区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</span><br><span class="line">  异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</span><br></pre></td></tr></table></figure><p>最常见的异步莫过于前端的ajax，</p><p>ajax 允许浏览器在发出请求的时候浏览器（一个进程）还可以去做别的事情，而不用干等着（同步就不行了，同步阻塞显然不行，同步非阻塞呢？同步虽然进程还可以去做别的事情，但是进程但过一会还得再来询问一下，请求是否完成，所以哪怕是同步非阻塞，代码流程执行到这会，始终会停住，不会继续向下走，这和异步代码能继续往下跑是不一样的，所以同步更符合我们的日常习惯。</p><p>比如异步编程，我们不知道ajax执行的函数啥时候回给我们返回内容，所以我们无法用  $a = ajax(xxx), 去获取ajax 执行的内容，大部分情况下用的是回调函数，然而为什么php中也有回调函数呢，php中的回调更类似于js中的匿名函数，他只是代码同步执行到用户定义的函数中，调用了之前定义的一个匿名函数，和js的回调存在本质上的区别。js中的回调，更类似swoole的回调，发现了嘛，都是通过事件的触发机制（但是这个应该和事件io不一样，之前看的阻塞io 非阻塞io 事件io 信号io都属于同步，只有异步io属于异步方式）</p><p>所以我们平时在看php的代码中就不要考虑异步方式了，基本没有，因为都是同步的，又因为阻塞和非阻塞都会有返回值，所以我们平时的那些函数基本都有返回值，但是有些回调形式的函数返回值有没有用，那就另说，看定义这个函数的人怎么想了。（其实看同步和异步看函数的return 也能看出来，如果return外面能接收到，那就是同步,比如php-fpm,包了那么多header头信息，还是return就能返回，你看swoole中的return ，在事件回调中，他是通过 $response 返回给别的进程的，所以属于异步）。</p><p>(可能有小伙伴看klein 或者larave中的路由函数觉得可能是回调，因为callback 中的内容总在 callback 外面先输出，首先，你在 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/test/test/[test|cry:test]/[i:id]&apos;, function ($request, $response) &#123;</span><br><span class="line"></span><br><span class="line">    $obj = Box::getObject(&apos;out&apos;, &apos;controller&apos;);</span><br><span class="line">    return $obj-&gt;oop($request);</span><br><span class="line">&#125;);</span><br><span class="line">的 respond 方法中返回 值，看外面能不能接收到，能接收到就是同步</span><br></pre></td></tr></table></figure><p>再者，他这个地方绑定了callback，并没有执行callback呀，所以这个地方并没有执行是很正常的，但是php这种没有触发机制，必须得执行呀，看后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;dispath() // 其实是在这里面执行了</span><br></pre></td></tr></table></figure><p>)</p><p>为什么说swoole 的task任务是异步任务，因为我们在worker进程中调用task添加异步任务的时候，当异步任务执行完的时候，我们能在之前的worker进程 中收到task返回的消息（onFinishi事件中）。(在没有swoole 之前，php中对于异步的实现都是通过第三方软件，比如把耗时任务放到消息队列中，由消费者自己去消费，消费者可以通过crontab 这种去轮训消息队列，虽然不太环保，但还是能完成任务)    </p><p>swoole进程模型</p><p>master 整除ractor 线程和manager 进程，</p><p>manager 进程 生出 worker进程（异步非阻塞）和特殊worker进程（task进程，同步阻塞），负责进程重启和 回收</p><p>ractor 线程检查连接，还有可写的socket 发送给worker进程处理</p><p>swoole4之前请求过程</p><p>单个请求被单个worker处理，处理完再处理下一个</p><p>swoole4 之后</p><p>woker可以同时接受多个，遇到io，协程切换，处理下一个请求，当上一个请求io完毕，再切回来（感觉通过fd -&gt; 运行环境），继续往下执行（注意就是这儿，虽然说协程本质上还是异步，但是他的运行方式类似同步，更好理解）</p><p>相较于异步的不容易理解，比如回调地狱，swoole 希望我们仍旧用同步的方式编写代码，但是对于一些io操作同步返回太慢了，所以就出现了异步io，redis, mysql，没有用过~~，swoole4中为了把这个异步摒弃，又引入了上述的协程，协程是比进程线程粒度更小的资源管理。</p><p>关于阻塞和非阻塞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</span><br><span class="line">有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。</span><br><span class="line">非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</span><br></pre></td></tr></table></figure><p>php中虽然sleep， file_get_contents 中有同步阻塞io，但是string， arr这些函数还是同步非阻塞函数</p><p>当我们在项目在swoole的http server中，没有用上面的同步阻塞io的时候，我们整个项目代码就是异步的，但凡用了，那我们的项目代码就是同步的，所以这个同步和异步由两部分决定，一个是swoole server， 一个是我们的项目代码。</p><p>swoole 本质上是为了对标php-fpm,和php本身没有什么关系，他对项目的性能提升类似php7对项目代码的提升，我们不用修改源代码，就能提升并发量，只是php7是对php中函数的改造，而swoole 是对php-fpm的改造或者说php的运行环境的改造，他吧php-fpm 的功能也纳入到我们项目代码中。</p><p>所以总结一下：</p><p>php多进程 ： 针对php-fpm， 或者php-cli 模式下的php进程而言</p><p>php单进程：针对php-fpm模式下php进程而言</p><p>同步: 针多 php-fpm 而言</p><p>异步：针对 swoole 封装的一些io操作而言，比如redis ,mysql ，还有http tcp server，</p><p>还有之前的多进程下载的实现，遍历url，每个url都放到task中执行，完美多进程，easy(不要想着在worker 在生成新的process 哦， 官网上说很占资源)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;灵感来源别人利用多进程写了个python 的下载器，于是想自己用php试一下&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>PHP常用函数</title>
    <link href="http://yoursite.com/2019/07/13/PHP%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/07/13/PHP常用函数/</id>
    <published>2019-07-12T16:07:33.000Z</published>
    <updated>2019-07-31T08:41:10.526Z</updated>
    
    <content type="html"><![CDATA[<p>看别人代码的时候会发现一些自己用的很少但很实用的函数，还有一些自己经常遗忘的函数，记录下来方便查找</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看别人代码的时候会发现一些自己用的很少但很实用的函数，还有一些自己经常遗忘的函数，记录下来方便查找&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://yoursite.com/2019/07/06/docker/"/>
    <id>http://yoursite.com/2019/07/06/docker/</id>
    <published>2019-07-06T07:23:39.000Z</published>
    <updated>2019-07-31T08:41:07.133Z</updated>
    
    <content type="html"><![CDATA[<p>学习docker主要是因为他部署环境太方便了，相比较传统的傻瓜式yum还有稍微高大上一点的自己编译，docker在搭建环境速度上真的是太快了，而且可以避免一系列的乱七八糟的问题，就比如用安装easyswoole 这个框架，当我们用composer + easyswoole install 生成目录结构的时候或多或少出现一点问题，但是当我们下载easyswoole 提供的Dockerfile 的时候，我们只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build . (包含Dockerfile的文件目录)</span><br></pre></td></tr></table></figure><p>就能快速生成一个运行着easyswoole框架的环境，但是我不知道怎么把宿主机也就是本机的目录映射到docker app中，虽然通过docker run -v 可以，但是当我docker cp (docker app 中的easyswoole初始目录) (宿主机目录)，我发现总是有些文件夹没有复制出来，问题还没有解决，还有docker compose， docker 多app 分工合作还是没有弄回,慢慢学吧</p><a id="more"></a><p>docker 软件的安装</p><p>docker 是 cs 结构(类似 mysql, redis 都是，只是docker 客户端和服务端连接用的restful，感觉像走的http协议)，我们安装好docker之后，通过修改docker 的国内镜像，加速docker pull 拉取镜像的速度（如果是yum，修改/etc/docker/damon.json文件，可能重启systemctl reload docker 会报错，是因为systemctl start docker 的时候 -t 指定了resposity远程仓库，我们修改一下，删除这个参数就好了）</p><p>镜像</p><p>docker pull    //从远程仓库拉取镜像(docker hub, 类似github的存在,像阿里云这些都是对docker hub的备份，可能有几秒的延迟，没啥事)</p><p>docker images  //  查看本地所有镜像</p><p>docker search  imagesName// 查找镜像</p><p>(关于镜像名称， 仓库名(所有者)/镜像名称:tag, 要是没有仓库名就是官方镜像，tag 是标签，比如php-7.2:cli,这种细分一下)</p><p>docker run  imagesName (镜像名称)  //  默认先从本地找，找不到去远程仓库找</p><p>(特别要注意的就是run centos 这种操作系统的时候，我么需要docker run -it  镜像名称 /bin/bash ， 这样才能让这个app一直运行，否则他会立刻断开，没有实际的意义, 像一些简版的centos 比如 alpine 版本，可能没有 /bin/bash, 我们可以 /bin/sh)</p><p>(还有就是 不同版本的centos 安装软件的方式可能不同，可能是yum,可能是agp-get install, 可能是别的，我们只需要换源，然后百度安装对应resposity库下面的软件就好了)</p><p>(-r 代表运行结束就删除了， -d 守护进程方式， -p 8000:80 端口 映射， -v  /home:/home, 文件夹挂载， -name 给容器取个名字，否则默认分配个名字)</p><p>docer cp  (从宿主机到虚拟机或者从虚拟机到宿主机)</p><p>docker inspect imagesName // 查看一个镜像的详细信息，比如挂载了哪些目录，暴露了哪些端口</p><p>dokcer rmi  imagesName // 删除镜像 </p><p>容器 container</p><p>docker images 启动之后就产生了 container，容器</p><p>docker ps  //查看运行的容器</p><p>docker ps -a // 查看所有运行过的容器</p><p>docker exec -it containerid(容器名称) //进入容器内部</p><p>docker rm containerId //删除容器</p><p>Dockerfile 编写</p><p>docker compose</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习docker主要是因为他部署环境太方便了，相比较传统的傻瓜式yum还有稍微高大上一点的自己编译，docker在搭建环境速度上真的是太快了，而且可以避免一系列的乱七八糟的问题，就比如用安装easyswoole 这个框架，当我们用composer + easyswoole install 生成目录结构的时候或多或少出现一点问题，但是当我们下载easyswoole 提供的Dockerfile 的时候，我们只需要&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker build . (包含Dockerfile的文件目录)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就能快速生成一个运行着easyswoole框架的环境，但是我不知道怎么把宿主机也就是本机的目录映射到docker app中，虽然通过docker run -v 可以，但是当我docker cp (docker app 中的easyswoole初始目录) (宿主机目录)，我发现总是有些文件夹没有复制出来，问题还没有解决，还有docker compose， docker 多app 分工合作还是没有弄回,慢慢学吧&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>重庆</title>
    <link href="http://yoursite.com/2019/05/15/%E9%87%8D%E5%BA%86/"/>
    <id>http://yoursite.com/2019/05/15/重庆/</id>
    <published>2019-05-15T02:32:36.000Z</published>
    <updated>2019-07-31T08:41:42.300Z</updated>
    
    <content type="html"><![CDATA[<p>第一次一个人出门，记录一下~</p><a id="more"></a><p>携带物品<br>all need:身份证，钥匙(不要企图你的室友帮你开门，我们都是独立的个体，自己的事情自己做啦），充电宝(！！！一定要带一个安卓头的充电线，因为你可能需要给充电器充电呀，充电宝要注意实际的毫安大小，避免过大不能携带上飞机的尴尬，知乎上有具体的参数)， 零钱(虽然重庆做公交可以用腾讯小程序乘车码，轻轨也是，但是有的地方轻轨买票好像只能用零钱，但是换100的零钱把，有十元有1元的那种，免去做公交付10元的尴尬)<br>person need: 充电牙刷，牙膏，毛巾，睡衣</p><p>坐飞机<br>虽然不是第一次坐飞机，但距离上次坐飞机已经一年了，还是记录下，因为下次坐飞机可能又忘了呢。携程上订的票，提前一个半小时到达机场，到不同航空公司的窗口下办登机牌，登机牌就是把网购的票换成实际的票，可以选位置，托运行李，电脑是不能托运的哦（小su哥说航旅纵横可以直接用电子版的登机牌，下次有空试一下），然后就是找登机口啦，机票上有写，不同机场不一样，比如上海浦东分国内起飞和国外起飞的口，这个口进去实际上是安检，把你身上的电子产品拿出来检查，但是重庆的因为是国内机场嘛，所以会把比如c1~c99走这个口安检，c100~c102 走那个口安检，安检过后才是走去正真的口等飞机排队<br>总结： 网上订票—&gt;特定口办理登机牌—&gt;过安检—&gt;特定口等飞机</p><p>出机场：<br>跟着人流走喽，其实就是找地铁或者你需要的交通工具，重庆是江北机场，出了航站楼，有机场大巴（叫k01?忘记了），因为我住在解放碑旁边的大溪沟，所以做机场大巴很方便，15元，直达<img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8688115645624835559.jpg" alt="IMG_0965.JPG"><br>重庆大致就是这种场景，刚开始看很壮观，后面就习惯了，低头玩手机（重庆是个3D城市，所以我觉得还是自己多走走路比较好，重庆打车很便宜，基本上都是不超过20元，南山那边老城区更便宜）</p><p>住宿：<br>我在知乎上查了一下，大家都推荐民宿，名宿相比较七天，速八，同等价位比如200，感觉还是名宿划算点，但其实不是环境，而是位置，给个对比你们看下，网上：<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6332015645624837919.png" alt="IMG_0591.PNG"><br>实际：<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1778415645624843201.jpg" alt="IMG_0747.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/439615645624845699.jpg" alt="IMG_0748.JPG"><br>没有那么夸张，但我住的地方位置还不错，虽然是瞎选的，出门就是大溪沟轻轨站，还有公交站，重庆的轻轨比较挤，那就打车把，重庆的出租车司机人都挺好的，其实你自己开着导航就知道他绕没绕路了呗。还有！！！一定要注意轻轨的标志，因为重庆的轻轨站在有些地方还是比较少的，所以我上次去鹅岭公园坐轻轨始终找不到，其实就在我旁边，一个绿绿的标志，别到处找上海那个蓝蓝的地铁标志了，哈哈哈，（网红李子坝,体验下，sry ，忘记拍照了，如果从大溪沟去鹅岭二厂就会路过啦）<br>这是我刚下机场大巴看到我住的地方<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5001015645624848143.jpg" alt="IMG_0745.JPG"><br>楼基本都是40层</p><p>day1:<br>4点下飞机 —&gt; 5点到家—&gt;7点出门—&gt;解放碑—-&gt;八一好吃街—-&gt;洪崖洞—-&gt;千x桥—-&gt;回家<br>解放碑就是带着一个碑的步行街<img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8356315645624851504.jpg" alt="IMG_0753.JPG"><br>挺小的，如果不购物的话，走不到一个小时吧，中间碰到国家图书馆<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4628315645624854088.jpg" alt="IMG_0751.JPG"><br>然后去八一好吃街吃东西，因为我不爱吃辣嘛，所以吃的都是甜的，比如糍粑，冰汤圆，芋头这种东西，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3431715645624856663.jpg" alt="IMG_0755.JPG"><br>吃完了就可以去洪崖洞啦，洪崖洞比较好的观看场景是千x桥，我是周六去的，桥上人不太多，桥也挺短的，我走了个来回<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5701815645624858953.jpg" alt="IMG_0759.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9698815645624861283.jpg" alt="IMG_0764.JPG"><br>这是桥的对面<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6671515645624863588.jpg" alt="IMG_0769.JPG"><br>可以在桥的对面玩一下再回去，比如南滨路，大剧院<br>这是洪崖洞<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8957315645624866394.jpg" alt="IMG_0771.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9116515645624869018.png" alt="IMG_0775.PNG"><br>你们可以趁早先排队进洪崖洞，晚点的时候人就挺多的了，我当时只是看了远景，没有去洪崖洞里面看，所以9点我的行程就结束了，其实这个时间还早，对于重庆来说，真正的夜生活可能才刚开始</p><p>day2:<br>轻轨—&gt;李子坝地铁站—&gt;鹅岭二厂—-&gt;鹅岭公园—-&gt;川美虎溪—&gt;磁器口—&gt;回家–&gt;观音桥<br>第二天应该是我最开心的一天，唯一的遗憾就是出了虎溪我的行程就结束了，所以大概是10点到3点，本来是有个朋友来，所以我在4点之后就回家等他了，可是他临时鸽了，要不然可以更丰富。<br>从李子坝地铁站出来，走到鹅岭二厂可能比在鹅岭二厂玩起来更开心，当时天下着蒙蒙雨，路上没有多少人，跟着百度地图走着盘山公路，差点走过了<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1115645624879743.jpg" alt="IMG_0799.JPG"><br>一条大马路上，开了个小口，忘记叫什么路了，很陡，蛮有意思<br>走了不久，就看到鹅岭二厂啦，原谅我忘记拍logo，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6083315645624887525.jpg" alt="IMG_0809.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/330561564562489024.jpg" alt="IMG_0800.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3826915645624892779.jpg" alt="IMG_0801.JPG"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/26815645624895795.jpg" alt="IMG_0808.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2097015645624898487.jpg" alt="IMG_0811.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9744815645624907554.jpg" alt="IMG_0821.JPG"></p><p>小店老板说晚上来比较热闹，好吧，我是好孩子，10点之后不出门。</p><p>鹅岭鹅厂其实就是几栋废弃的楼改造的，出来之后就继续去看鹅岭公园啦</p><p><img src="http://img.chenye2017.cn/eling.jpg" alt="鹅岭"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2885515645624909655.jpg" alt="IMG_0828.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4313215645624911936.jpg" alt="IMG_0829.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1582315645624914543.jpg" alt="IMG_0824.JPG"></p><p>小朋友们在正儿八经的写生，可是你们画的太丑啦，哈哈哈哈</p><p>下山做地铁去川美喽（川美虎溪那边比黄那边好挺多，建议时间不够的话去那边，那边还有别的很多大学）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3111715645624917285.jpg" alt="IMG_0838.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6224015645624919703.jpg" alt="IMG_0840.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5812615645624922812.jpg" alt="IMG_0842.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4405215645624928312.jpg" alt="IMG_0845.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6519015645624931228.jpg" alt="IMG_0849.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3460815645624934409.jpg" alt="IMG_0855.JPG"></p><p><img src="http://img.chenye2017.cn/luo2.jpg" alt=""></p><p><img src="http://img.chenye2017.cn/luo3.jpg" alt=""></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4730515645624937179.jpg" alt="IMG_0860.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6164915645624939203.jpg" alt="IMG_0861.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/909315645624941563.jpg" alt="IMG_0862.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9556815645624943892.jpg" alt="IMG_0865.JPG"></p><p><img src="http://img.chenye2017.cn/luo4.jpg" alt=""></p><p>晚上去了观音桥，还有个什么书店来着，忘记了，那就放图吧<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/667961564562494603.jpg" alt="IMG_0883.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7804915645624948852.jpg" alt="IMG_0884.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8740615645624951562.jpg" alt="IMG_0885.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4660915645624954314.jpg" alt="IMG_0889.JPG"></p><p>这应该是我最喜欢的壁画了<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2315615645624957249.jpg" alt="IMG_0890.JPG"></p><p>观音桥看到了很多人跳广场舞，然后是观音桥小吃街，卖生蚝的店家真的黑心，不要去</p><p>day3:<br>长江索道—&gt;南山一棵树观景台—&gt;南山植物园—&gt;山鬼—&gt;南山书店—&gt;南山书店之小森林—&gt;山下逛了逛—&gt;回家<br>第三天应该是这次旅行最失败的一天，完全可以纳到某天晚上的行程，因为南山那边完全就是看夜景，白天没啥看头，下了长江索道（长江索道不要期望太大，很普通）,因为观光巴士要等很久，所以直接打车上山（长江索道那边可以买套票，还好没有买观光巴士的票），司机师傅是个日语说的很6的男人，在日本呆了挺久，人很好说话，！！！开了那么久竟然只有11元，到了南山一棵树，当时人太少了，所以我一个人不敢上山，还下着雨，所以呢，我花了30的门票就在门口呆了30分钟，上照片<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6603715645624959872.jpg" alt="IMG_0902.JPG"></p><p>出了门做了一个大叔的车去南山植物园，他收了30元，因为百度地图显示打车25元，所以同意了（真的相比较别的地方景区太良心了），植物园也挺没意思的，主要一个人懒得走，所以也是只是去了室内植物园就出来了，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7966315645624962559.jpg" alt="IMG_0906.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4556215645624965821.jpg" alt="IMG_0910.JPG"></p><p>继续往上走，去找南山书店喽，中途路过山鬼，重庆很多网红地方入口普通的就和不存在一样，比如这个山鬼，小红书上到处种草，可是我路过竟然没发现，（山鬼就是个面朝大山的玻璃屋，哈哈哈），南山的那些网红书店其实也蛮普通的，就是用来拍照的，里面的点心挺普通，虽然我每家都不好意思不点<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7366415645624968525.jpg" alt="IMG_0912.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2693015645624971543.jpg" alt="IMG_0913.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3440315645624974297.jpg" alt="IMG_0915.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9600115645624980407.jpg" alt="IMG_0920.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2693415645624982834.jpg" alt="IMG_0923.JPG"></p><p>下山之后就是给网红建筑拍拍照，据说夜景挺好，第三天完全可以一晚上搞定</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4895315645624985274.jpg" alt="IMG_0925.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3820715645624988179.jpg" alt="IMG_0927.JPG"><br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/988315645624990895.jpg" alt="IMG_0928.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2195115645624993532.jpg" alt="IMG_0932.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1048215645624995833.jpg" alt="IMG_0935.JPG"></p><p>day4：<br>川美（黄x校区）—&gt;涂鸦一条街–&gt;钟书阁—&gt;坐飞机回家</p><p>川美这个老校区很小，没什么人，可能是周二吧，那就上图喽</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8732415645625000255.jpg" alt="IMG_0945.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/72191564562500407.jpg" alt="IMG_0946.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8746515645625006678.jpg" alt="IMG_0950.JPG"></p><p>川美有个门对面是一个创意基地，里面是工作的地方，外面有些涂鸦，那就打卡下吧</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6777215645625009024.jpg" alt="IMG_0951.JPG"><br>涂鸦街就是一条路上房子被涂鸦了，其实也挺一般，有个交通茶馆，哈哈哈，挺难找，因为入口处太普通了，进去了就是老年人的酒吧，因为都是老人，就没有长时间都留了，去钟书阁喽。</p><p>钟书阁在一个商场里面，不要跟着百度地图绕着那个商场走，···我真的太傻了，随便进一个商场口，问一下就好了，在三楼，不算大，其实我感觉不管是南山书店还是这个钟书阁，实际意义上更像一个咖啡厅，因为一直有着轻柔的音乐，没有图书馆那么安静<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/891271564562501164.jpg" alt="IMG_0955.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6045515645625014386.jpg" alt="IMG_0957.JPG"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3862915645625016845.jpg" alt="IMG_0958.JPG"></p><p>因为下午5点的飞机，我12点就没事了，所以在这个地方看了1小时比赛，1点的时候往飞机场赶，其实能呆更久，但我做事比较着急啦</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2497115645625020811.jpg" alt="IMG_0961.JPG"></p><p>最后：<br>这次去重庆因为第一次一个人出门嘛，虽然做的事情不多，但是收货还是蛮大的，毕竟只能靠自己，后来我觉得我可能更喜欢泸沽湖那样的地方，有山有水，重庆是一个网红城市，更适合拍照</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次一个人出门，记录一下~&lt;/p&gt;
    
    </summary>
    
      <category term="旅游" scheme="http://yoursite.com/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="重庆" scheme="http://yoursite.com/tags/%E9%87%8D%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>持续交付</title>
    <link href="http://yoursite.com/2019/03/20/%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98/"/>
    <id>http://yoursite.com/2019/03/20/持续交付/</id>
    <published>2019-03-20T06:28:18.000Z</published>
    <updated>2019-07-31T08:41:20.590Z</updated>
    
    <content type="html"><![CDATA[<p>上面要求代码从svn改成git,需要一个私有化的代码管理工具，于是想到了gitlab, 其实我们人这么少，一般一个前端，一个后端，流程简单，svn和git 用起来没啥区别，可是呢上面说了，那就改吧<br><a id="more"></a></p><ul><li>gitlab 搭建<br><a href="https://blog.csdn.net/Abysscarry/article/details/79402695" target="_blank" rel="noopener">https://blog.csdn.net/Abysscarry/article/details/79402695</a><br>慕课网教程上那么复杂是因为配置了本地https<br>唯一一点没有提到的就是自定义域名的文件位置，如果用yum安装的话<br>在 /etc/gitlab/gitlab.rb下面。</li><li>gitlab使用<br>默认有个root账户，自己设置密码，<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/800415645624780513.png" alt="image.png"></li></ul><ol><li><p>可以创建用户和项目<br>创建项目类似github 上创建项目，后面项目的提交就是git 的使用<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/748391564562478477.png" alt="image.png"><br>创建用户的话如上，主要是那个reqular和admin, 这块不是项目权限，应该是类似整个gitlab 的权限， 新建的用户可以给个初始密码，然后用户登陆的时候可以修改，用户提交代码需要把ssh 公钥粘贴到gitlab 上，一切和github类似</p></li><li><p>配置项目权限 （管理员才有这些权限，比如root）<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6845315645624787314.png" alt="image.png"></p></li></ol><p>点击项目，给项目配置人员信息</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5573915645624793171.png" alt="image.png"></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9647115645624801071.png" alt="image.png"></p><p>目前只配置了develop和 master ,develop 是开发者，开发者不能向master 分支提交代码。只能自己开个feature分支，提交之后再gitlab 上面提交merge 申请，这个项目的master 可以merge , 这个项目的master 可以直接向master 分支提交代码</p><p>上面的administrator / test , administrator  是用户名， test 是项目名</p><ol><li>监控系统信息(感觉这个可以放在一般的管理系统中，掌握服务器情况)</li></ol><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9805515645624803533.png" alt="image.png"></p><p>今天新建一个项目的时候总是显示密码错误，主要原因可能是项目建成了private ， 没有解决问题，但发现了另一个问题，我下载项目的时候总是显示password ,那他是怎么识别我的name呢，答案是gitlab 上贴的ssh key，我们的每一个gitlab 用户或者 github 用户都要至少绑定一个ssh key,就是通过这个ssh key 识别我们用户名称的,我们在用gitlab 提交代码时候总是显示要配置用户名和密码，可以全局配置也可以在单个项目中配置，所以这个并不是我们登陆github 或者gitlab 的用户名，这个只是我们提交时候日志上面显示的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上面要求代码从svn改成git,需要一个私有化的代码管理工具，于是想到了gitlab, 其实我们人这么少，一般一个前端，一个后端，流程简单，svn和git 用起来没啥区别，可是呢上面说了，那就改吧&lt;br&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>PHP 反射</title>
    <link href="http://yoursite.com/2019/03/06/PHP-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2019/03/06/PHP-反射/</id>
    <published>2019-03-06T02:43:51.000Z</published>
    <updated>2019-07-31T08:41:08.050Z</updated>
    
    <content type="html"><![CDATA[<p>故事背景：在做文件上传的时候，对图片的上传和视频的上传走的是相同的接口，可是视频和图片有些参数是不同的，于是通过一个基类base,扩展出多个子类，image,video ···上传类，根绝参数的不同调用不同类的upload方法。</p><blockquote><p>简单点说反射的就是让你拥有剖析类、函数的能力。</p><p>有的同学可能会问我剖析类有什么用，我为什么要学反射，我只能说不学反射并不会对你实现业务有任何影响，但是如果你想写出结构优雅的程序，想写出维护性和扩展性都很高的程序，学习反射是必不可少的。</p></blockquote><p>Laravel 中依赖注入用的就是反射。<a href="http://www.dahouduan.com/2017/08/21/php-refleciton-1/" target="_blank" rel="noopener">参考文章</a></p><a id="more"></a><p>base类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;&apos;;</span><br><span class="line">  public function upload()</span><br><span class="line">  &#123;</span><br><span class="line">  var_dump($this-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>video 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Video extends Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;video&apos;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>image 类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Image extends Base</span><br><span class="line">&#123;</span><br><span class="line">  public $name = &apos;image&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App</span><br><span class="line"></span><br><span class="line">class Upload</span><br><span class="line">&#123;</span><br><span class="line">  public static alias()</span><br><span class="line">  &#123;</span><br><span class="line">  return [</span><br><span class="line">  &apos;video&apos; =&gt; \App\Video,</span><br><span class="line">  &apos;image&apos; =&gt; \App\Image</span><br><span class="line">]</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">  public fileUpload($type)</span><br><span class="line">  &#123;</span><br><span class="line">  $classArr = self::alias();</span><br><span class="line">  $className = $classArr[$type];</span><br><span class="line">  $reflection = new ReflectionClass($className); // 获取反射对象</span><br><span class="line">  return $ref-&gt;newInstance() // 获取类实例化对象</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码只是一段很简单的使用反射实现的代码，其中对实例化参数的判断，类是否能实例化等诸多反射的方法都未使用到。</p><p>总结一下我在使用easyswoole 写代码过程中的感觉：</p><ul><li><p>首先想熟练的使用easyswoole,必须得熟悉swoole,比如对swoole http server 的配置，举个例子，当上传文件大于easyswoole 默认上传文件总的大小的时候，easyswoole(包括swoole)的tcp 链接会主动断掉，但是swoole的服务器端会打印一个warning ,显示传输文件过大，但是easyswoole 不会，服务器端不报异常，只是客户端建立不了链接，这就很尴尬了，之前还以为是端口号或者自己代码哪里出了问题。（ps:php文件上传和两个参数有关，一个是php.ini 里面的upload size, 一个是post size, 如果是swoole 上传的话，还和swoole 的配置项有关，在easyswoole 中对http server 的配置和swoole 中对http server 配置一样，只是参数修改的位置不一样罢了）</p></li><li><p>再者是对easy swoole 的使用，之前习惯于查看文档或者手册去学习（比如laravel 和 php 手册），对其中的所有的方法都有详细的解释，我们应该学会通过查看源码去学习其中方法的使用，比如easy swoole 中对获取参数这些都没有doc 文档，我们可以在request 类下面查看有哪些可以调用的方法，或者是通过编辑器补全</p></li><li><p>说到编辑器补全，之前发现的一个问题就是比如上传类，当可能返回上传类或者null 的时候，通过链式调用，上传类的方法得不到补全，可是我们通过php7的返回结果限制，就能让编辑器自动补全了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Request</span><br><span class="line">&#123;</span><br><span class="line">   public function uploadFile($name) :?UploadFile</span><br><span class="line">    &#123;</span><br><span class="line">  if ($file[$name]) &#123;</span><br><span class="line">          return $file[$name]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         return null</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">// ?代表可能是Null</span><br></pre></td></tr></table></figure></li><li><p>当我们想知道这个结果有哪些可以调用的方法的时候，我们可以直接打印这个结果，查看属于哪个类，然后我们到这个类下面查找，比如我之前想知道反射的 getParamtes  方法返回结果的foreach 中的value 有哪些可以调用的方法的时候，查看这个value 的类，然后查看这个类有哪些方法，比如getClass()-&gt;name, 就是获取参数提示符（这个参数提示符还是蛮奇怪的，Bag 这种自定义的类可以提示， 但是 string int 这种类却不提示）</p></li><li><p>今天在查看easyswoole源码的时候,发现自己对public protected private 都忘记了,首先public 是最简单的，protected 本类和继承类中可以使用，private只有本类中可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line"> class A &#123;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function test1()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected function test2()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function test3()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public function test4()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$b = new B();</span><br><span class="line"></span><br><span class="line">$b-&gt;test1();</span><br><span class="line"></span><br><span class="line">$b-&gt;test4();</span><br><span class="line"></span><br><span class="line">$b-&gt;test2();</span><br><span class="line"></span><br><span class="line">//$b-&gt;test3();</span><br></pre></td></tr></table></figure><p>​</p></li></ul><p>下面<a href="http://www.dahouduan.com" target="_blank" rel="noopener">文章来源</a></p><p>PHP 内置了一组反射类来实现类的反射，常用的有：</p><ul><li>ReflectionClass 解析类</li><li>ReflectionProperty 类的属性的相关信息</li><li>ReflectionMethod 类方法的有关信息</li><li>ReflectionParameter 取回了函数或方法参数的相关信息</li></ul><p>想看全的就翻手册去。</p><p>今天先通过一段演示代码简单看下php的反射到底是个什么东西。</p><p>例子1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Hero &#123;</span><br><span class="line"></span><br><span class="line">    protected $name;</span><br><span class="line"></span><br><span class="line">    protected $skills = [];</span><br><span class="line"></span><br><span class="line">    public function __construct($name, $skills = []) &#123;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">        $this-&gt;skills = $skills;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function attack($hero) &#123;</span><br><span class="line">        echo &quot;Attack &#123;$hero-&gt;name&#125;&quot; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function execute($index) &#123;</span><br><span class="line">        echo &quot;Axecute &#123;$index&#125; skill&quot; . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ref = new ReflectionClass(&apos;Hero&apos;); // 参数类名</span><br><span class="line"></span><br><span class="line">if ($ref-&gt;isInstantiable()) &#123;</span><br><span class="line">    echo &apos;可以实例化&apos; . PHP_EOL; // 判断是否可以实例化，比如单例或者静态类的存在</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取类的构造函数</span><br><span class="line">$constructor = $ref-&gt;getConstructor();</span><br><span class="line">print_r($constructor); //ReflectionMethod  E对象</span><br><span class="line"></span><br><span class="line">//获取属性</span><br><span class="line">if ($ref-&gt;hasProperty(&apos;name&apos;)) &#123;</span><br><span class="line">    $attr = $ref-&gt;getProperty(&apos;name&apos;);</span><br><span class="line">    print_r($attr); //ReflectionProperty  对象</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取属性列表</span><br><span class="line">$attributes = $ref-&gt;getProperties();</span><br><span class="line">foreach ($attributes as $row) &#123;</span><br><span class="line">    //row 为 ReflectionProperty 的实例</span><br><span class="line">    echo $row-&gt;getName() . &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法</span><br><span class="line">if ($ref-&gt;hasMethod(&apos;attack&apos;)) &#123;</span><br><span class="line">    $method = $ref-&gt;getMethod(&apos;attack&apos;);</span><br><span class="line">    //$method 为 ReflectionMethod 的实例</span><br><span class="line">    print_r($method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取方法列表</span><br><span class="line">$methods = $ref-&gt;getMethods();</span><br><span class="line">foreach ($methods as $row) &#123;</span><br><span class="line">    //这的row 是 ReflectionMethod 的实例</span><br><span class="line">    echo $row-&gt;getName() . PHP_EOL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想知道上面代码的用途，最好的办法就是执行一下，自己打印一遍(如果用xdebug 对这种脚本式的执行是再方便不过了)</p><p>上面例子想表达的效果就是：仅仅通过类名，就能了解类的内部结构，进而去实例化类</p><p>例子2：</p><p>student</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Bag&#123;</span><br><span class="line"></span><br><span class="line">    public function name()&#123;</span><br><span class="line">        return  &quot;学生包&quot;.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">    public $id;</span><br><span class="line"></span><br><span class="line">    public $name;</span><br><span class="line">    public function __construct($id,$name,Bag $bag)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;id = $id;</span><br><span class="line">        $this-&gt;name = $name;</span><br><span class="line">    &#125;</span><br><span class="line">    public function study()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;name.&apos; is learning.....&apos;.PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function showBag()&#123;</span><br><span class="line">        echo &quot;My bag have &quot;.$this-&gt;bag-&gt;all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line"></span><br><span class="line">require &apos;student.php&apos;;</span><br><span class="line">function make($class, $vars = []) &#123;</span><br><span class="line">    $ref = new ReflectionClass($class);</span><br><span class="line"></span><br><span class="line">    if(!$ref-&gt;isInstantiable()) &#123;</span><br><span class="line">        throw new Exception(&quot;类&#123;$class&#125; 不存在&quot;); // 感觉这块应该是累不可以实例化</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $constructor = $ref-&gt;getConstructor();</span><br><span class="line">    if(is_null($constructor)) &#123;</span><br><span class="line">        return new $class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $params = $constructor-&gt;getParameters();</span><br><span class="line">    $resolveParams = [];</span><br><span class="line">    foreach ($params as $key=&gt;$value) &#123;</span><br><span class="line">        $name = $value-&gt;getName();</span><br><span class="line">        if(isset($vars[$name])) &#123;</span><br><span class="line">            $resolveParams[] = $vars[$name];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $default = $value-&gt;isDefaultValueAvailable() ? $value-&gt;getDefaultValue() : null;</span><br><span class="line">            if(is_null($default)) &#123;</span><br><span class="line">           </span><br><span class="line">                if($value-&gt;getClass()) &#123;</span><br><span class="line">                // 依赖注入的实现，以这个为例子</span><br><span class="line">                // 需要Bag $bag ，却没有传入 bag，自动实例化</span><br><span class="line">                // 如果需要参数，直接在vars 里面加，但感觉参数名称不能和原本的冲突</span><br><span class="line">                    $resolveParams[] = make($value-&gt;getClass()-&gt;getName(), $vars);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new Exception(&quot;&#123;$name&#125; 没有传值且没有默认值。&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $resolveParams[] = $default;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return $ref-&gt;newInstanceArgs($resolveParams);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有提供name 值</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 提供name 值</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要 Bag ，却没有传入</span><br><span class="line">try &#123;</span><br><span class="line">    $stu = make(&apos;Student&apos;, [&apos;id&apos; =&gt; 1, &apos;name&apos; =&gt; &apos;li&apos;]);</span><br><span class="line">    print_r($stu);</span><br><span class="line">    $stu-&gt;study();</span><br><span class="line">    $stu-&gt;showBag();</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo $e-&gt;getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到构造函数的第三个参数 <code>$bag</code> ,被自动实例化了，然后传递给了 <code>Student</code> 类的构造函数，这个部分很关键，这个地方可以用来实现依赖注入，我们不必在手动实例化对象了，我们可以根据参数的对应的类来自动实例化对象，从而实现类之间的解耦。</p><p>// 感觉这个解耦就是不用手动去传参数，避免类修改的时候自己大片代码需要修改</p></blockquote><p>例子3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// 这个不能算是容器，容器是反射的一种高级应用，下面的只是反射的一种基础应用</span><br><span class="line">if (PHP_SAPI != &apos;cli&apos;) &#123;</span><br><span class="line">    exit(&apos;Please run it in terminal!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">if ($argc &lt; 3) &#123;</span><br><span class="line">    exit(&apos;At least 2 arguments needed!&apos;);</span><br><span class="line">&#125;</span><br><span class="line">$controller = ucfirst($argv[1]) . &apos;Controller&apos;;</span><br><span class="line">$action = &apos;action&apos; . ucfirst($argv[2]);</span><br><span class="line">// 检查类是否存在</span><br><span class="line">if (!class_exists($controller)) &#123;</span><br><span class="line">    exit(&quot;Class $controller does not existed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 获取类的反射</span><br><span class="line">$reflector = new ReflectionClass($controller);</span><br><span class="line">// 检查方法是否存在</span><br><span class="line">if (!$reflector-&gt;hasMethod($action)) &#123;</span><br><span class="line">    exit(&quot;Method $action does not existed!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">// 取类的构造函数</span><br><span class="line">$constructor = $reflector-&gt;getConstructor();</span><br><span class="line">// 取构造函数的参数</span><br><span class="line">$parameters = $constructor-&gt;getParameters();</span><br><span class="line">// 遍历参数</span><br><span class="line">foreach ($parameters as $key =&gt; $parameter) &#123;</span><br><span class="line">    // 获取参数声明的类</span><br><span class="line">    $injector = new ReflectionClass($parameter-&gt;getClass()-&gt;name);</span><br><span class="line">    // 实例化参数声明类并填入参数列表</span><br><span class="line">    $parameters[$key] = $injector-&gt;newInstance();</span><br><span class="line">&#125;</span><br><span class="line">// 使用参数列表实例 controller 类</span><br><span class="line">$instance = $reflector-&gt;newInstanceArgs($parameters);</span><br><span class="line">// 执行</span><br><span class="line">$instance-&gt;$action();</span><br><span class="line">class HelloController</span><br><span class="line">&#123;</span><br><span class="line">    private $model;</span><br><span class="line">    public function __construct(TestModel $model)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;model = $model;</span><br><span class="line">    &#125;</span><br><span class="line">    public function actionWorld()</span><br><span class="line">    &#123;</span><br><span class="line">        echo $this-&gt;model-&gt;property, PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class TestModel</span><br><span class="line">&#123;</span><br><span class="line">    public $property = &apos;property&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（以上代码非原创）将以上代码保存为 <code>run.php</code></p><p>（以上代码非原创）将以上代码保存为 <code>run.php</code><br>运行方式，在终端下执行<code>php run.php Hello World</code></p><p>可以看到，我们要执行 <code>HelloController</code> 下的 <code>WorldAction</code>,</p><p>可以看到，我们要执行 <code>HelloController</code> 下的 <code>WorldAction</code>,<br><code>HelloController</code> 的构造函数需要一个 <code>TestModel</code>类型的对象,</p><p>通过php 反射，我们实现了, <code>TestModel</code> 对象的自动注入，</p><p>上面的例子类似于一个请求分发的过程,是路由请求的分发的一部分，假如我们要接收一个请求 地址例如： <code>/Hello/World</code></p><p>意思是要执行 <code>HelloController</code> 下的 <code>WorldAction</code> 方法。</p></blockquote><p>上面的例子有个最大的缺陷就是所有类写在一个文件中，导致没有使用bind 也不会出错 （注意container 中没有自动加载）</p><p>发现：感觉依赖注入的类的参数都是空的，都是直接就能实例化的那种</p><p>感觉上面那个发现并不多</p><p>控制反转：就是通过一个container 容器去解决依赖关系，把类的实例化从类的内部改成从外部传入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    public function buy($obj)</span><br><span class="line">    &#123;</span><br><span class="line">       // $obj = new Car(); 改成依赖注入的模式</span><br><span class="line">        $obj-&gt;pay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个obj 我们不希望手动传入，希望可以帮我们自动生成，于是就出现了依赖注入（通过类的反射实例化类，但这个类我们要提前绑定到容器中，要不然可能找不到，我们的容器可没有自动加载机制，容器一般有两个方法bind 和 make, bind 一般是 一个类的标识 和一个匿名函数，make 实例化这个类的标识，执行之前绑定的匿名函数，这就是最简单的container）</p><p>能解决的问题：</p><p>当我们把依赖类通过注入的方式传入的时候，我们可以只是传入这个类的类型（接口），当我们使用的时候可以在这个容器中为这个类型不同的实体类，达到switch 切换的效果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事背景：在做文件上传的时候，对图片的上传和视频的上传走的是相同的接口，可是视频和图片有些参数是不同的，于是通过一个基类base,扩展出多个子类，image,video ···上传类，根绝参数的不同调用不同类的upload方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;简单点说反射的就是让你拥有剖析类、函数的能力。&lt;/p&gt;
&lt;p&gt;有的同学可能会问我剖析类有什么用，我为什么要学反射，我只能说不学反射并不会对你实现业务有任何影响，但是如果你想写出结构优雅的程序，想写出维护性和扩展性都很高的程序，学习反射是必不可少的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Laravel 中依赖注入用的就是反射。&lt;a href=&quot;http://www.dahouduan.com/2017/08/21/php-refleciton-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>小程序</title>
    <link href="http://yoursite.com/2019/02/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/02/25/小程序/</id>
    <published>2019-02-25T10:15:03.000Z</published>
    <updated>2019-07-31T08:41:17.456Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习了下小程序的编写，理由：</p><ol><li>vue 还有 react 没学会，小程序是真的简单 ，类似后台模板引擎</li><li>微信不会弹广告，vue或者react 编写的webapp 在一些安卓手机浏览器上，比如魅族自带的浏览器，访问的时候会有很多广告的出现</li><li>不用记域名，之前在做itbasic的时候，就发现大家都记不住域名，导致pc端还好，大家可以收藏域名，手机端完全不会去使用</li><li>练习js, 熟悉es6<br>这篇文章的目的不是介绍小程序的简单使用，只是想记录下容易忽略的知识点（包括es6中），完成了项目的时候才发现，<strong>代码是练出来的，而不是看出来的</strong><a id="more"></a></li></ol><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7561415645624765844.png" alt="image.png"></p><h6 id="app-wxss"><a href="#app-wxss" class="headerlink" title="app.wxss"></a>app.wxss</h6><p> 是全局样式文件，比如我们想让每个page页面的背景色从白色变成灰色，可以在这里面定义，又比如我们对iconfont 的使用。</p><h6 id="iconfont-的使用"><a href="#iconfont-的使用" class="headerlink" title="iconfont 的使用"></a>iconfont 的使用</h6><p>我们在编写前端页面的时候经常会需要小图标，现在比较流行iconfont, 我们在阿里的那个官网上选择好图标<img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3152415645624767823.png" alt="image.png"><br>然后选择添加至项目<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1989115645624770024.png" alt="image.png"></p><p>选择项目名称<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7890515645624772404.png" alt="image.png"></p><p>选择font class ,在线链接，查看线上地址，复制所有css ,保存到本地，然后在这个全局css 中引入，就可以全局使用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;styles/iconfont.wxss&apos;;</span><br></pre></td></tr></table></figure></p><p>我们通过修改font-size 和 color 可以修改图标的大小和颜色（毕竟实际上这些图标都是字体）</p><h6 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h6><p>主要是页面pages 路径的配置，一些基础配置，tabBar (注意tabBar 没有对应的pages ，pages页面上是不会显示tabBar的)， 引入的组件如果想全局使用，也可以在这个页面上配置</p><h5 id="components"><a href="#components" class="headerlink" title="components"></a>components</h5><p>编写的组件位置，其实和pages文件夹差不多，感觉就是组件里面文件一般用index 命名，而pages 里面一般用文件夹名称命名</p><p>其他的文件夹都是可以自己定义的，其实小程序只是给了一个标准的最简单的项目目录，很多时候都可以自己定义文件夹，然后引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">引入 js</span><br><span class="line">import &#123;config&#125; from &apos;../config.js&apos;</span><br><span class="line"></span><br><span class="line">这个config.js 中被引入的内容需要在文件中导出</span><br><span class="line">const config = 4;</span><br><span class="line">export &#123;config&#125;</span><br><span class="line"></span><br><span class="line">感觉和PHP 不一样的地方就是php 一般都是include 文件，而不是对具体变量的引入和导出，当然现在很多时候php 一个文件就是一个class,也是类似一个变量的存在</span><br></pre></td></tr></table></figure></p><h2 id="小程序知识"><a href="#小程序知识" class="headerlink" title="小程序知识"></a>小程序知识</h2><h6 id="wxml"><a href="#wxml" class="headerlink" title="wxml"></a>wxml</h6><p>页面，<br>wx:if , wx:for  去判断，循环页面元素，<br>rpx 是小程序上的计量单位，没听懂，反正知道通过使用它，可以实现页面的自适应<br>flex 页面布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">flex-direction: row;</span><br><span class="line">just-content: (主轴) row 横着排列（横 主 纵 副）column (纵 主 横 副) space-between 等（todo: flex 均分怎么实现）</span><br><span class="line">align-item: （副轴）</span><br></pre></td></tr></table></figure></p><p>positon<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">position:relative (相较于自身)</span><br><span class="line">position:absolute(因为一般只有固定在底部或者首部用到，所以一般这样定位的话就是相对于页面)</span><br></pre></td></tr></table></figure></p><p>目前用到的元素：view ,image(类似view)<br>绑定点击事件 bind:tap, bind:like<br>引入组件：在该pages json 文件中引入，或者全局json 中引入，（父组件给子组件传值通过属性）然后用组件名称使用，在父组件上定义属性，传入子组件定义的data中（子组件给父组件传值通过事件，子组件抛出事件，触发父组件绑定的事件）</p><h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><p>let 新的定义变量方式，if 或者 for 中定义的，外面获取不到<br>const 不能改变的量<br>onLoad 方法中一般写入初始化的时候对后台接口的请求（蛋疼的就是经常页面加载的时候出现抖动，当返回数据比较慢的时候）<br>自定义的方法就写在最外层就好了<br>data : 定义页面中的值，初始化<br>setData :改变页面中的值<br>wx.getStorage()  感觉这些就是类似调用系统接口，应该安卓和ios 中用的比较多，这是微信封装的，注意其中的同步和异步之分</p><h3 id="推荐组件"><a href="#推荐组件" class="headerlink" title="推荐组件"></a>推荐组件</h3><p>vant 有赞出的小程序组件，只有用过小程序原生组件才会知道vant 用起来有多么方便，npm 安装</p><p>值的注意的是：事件 event.detail 能获取到这个组件本身，之前我们经常用event.detail.value 获取组件传递的值，通过event.detail去调用组件自身的一些方法，比如日期picker 上显示的日期大小</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习了下小程序的编写，理由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;vue 还有 react 没学会，小程序是真的简单 ，类似后台模板引擎&lt;/li&gt;
&lt;li&gt;微信不会弹广告，vue或者react 编写的webapp 在一些安卓手机浏览器上，比如魅族自带的浏览器，访问的时候会有很多广告的出现&lt;/li&gt;
&lt;li&gt;不用记域名，之前在做itbasic的时候，就发现大家都记不住域名，导致pc端还好，大家可以收藏域名，手机端完全不会去使用&lt;/li&gt;
&lt;li&gt;练习js, 熟悉es6&lt;br&gt;这篇文章的目的不是介绍小程序的简单使用，只是想记录下容易忽略的知识点（包括es6中），完成了项目的时候才发现，&lt;strong&gt;代码是练出来的，而不是看出来的&lt;/strong&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>框架学习-获取请求参数</title>
    <link href="http://yoursite.com/2019/02/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2019/02/25/框架学习-获取请求参数/</id>
    <published>2019-02-25T06:51:45.000Z</published>
    <updated>2019-07-31T08:41:22.755Z</updated>
    
    <content type="html"><![CDATA[<p>PHP属于一门高级语言，感觉就是那种语言里面偏向于应用层的语言，再加上lnmp架构还有框架的存在，对于http请求过程中的细节封装了太多层，导致我们实际在使用过程中得到的参数已经是面目全非的样子，记录下对其探索的历程</p><a id="more"></a><p>问题出现在很久之前，有一次我用json数据去请求我们itbasic的接口，可惜没法解析，我原本以为是框架的原因，于是我开始打印$_POST中数据(post 方式提交)，可是其中也是毫无结果，算了，不处理了，搞不定，反正用不到~昨天，前端小朋友再次发现这个问题，感觉很简单，为了维护自己的高大形象，就处理下吧。</p><p>首先是关于content-type 的理解：</p><blockquote><p>一般是指网页中存在的Content-Type，Content-Type属性指定请求和响应的HTTP内容类型。如果未指定 ContentType，默认为text/html。</p></blockquote><p>上述问题中为什么会出现指定请求和响应的HTTP内容类型，因为content-type 在request中可以设置，在response中也可以设置，在request 中设置代表我发送的请求，在response中的设置代表从服务器返回的内容。</p><p>常见的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.text/html</span><br><span class="line">2.text/plain</span><br><span class="line">3.text/css</span><br><span class="line">4.text/javascript</span><br><span class="line">5.application/x-www-form-urlencoded</span><br><span class="line">6.multipart/form-data</span><br><span class="line">7.application/json</span><br><span class="line">8.application/xml</span><br></pre></td></tr></table></figure><p>我们在接口调用的时候常用的是后面4个</p><h3 id="x-www-form-urlencoded"><a href="#x-www-form-urlencoded" class="headerlink" title="x-www-form-urlencoded"></a>x-www-form-urlencoded</h3><blockquote><p>会将表单内的数据转换拼接成 key-value 对（非 ASCII 码进行编码）</p><p>编码方式应该是urlencode</p></blockquote><p>还记得自己刚写php代码时候吗，那时候最基础的功能是实现一个表单提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form enctype=&quot;application/x-www-form-urlencoded&quot; action=&quot;http://homeway.me/post.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;homeway&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; name=&quot;key&quot; value=&quot;nokey&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; value=&quot;submit&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>然后服务器端就可以用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$name = $_POST[&apos;name&apos;];</span><br><span class="line">$key = $_POST[&apos;key&apos;]</span><br></pre></td></tr></table></figure><p>实际接收到的内容（通过swoole rowContent 打印出来，获取原始的<code>POST</code>包体，用于非<code>application/x-www-form-urlencoded</code>格式的<code>Http POST</code>请求，返回原始<code>POST</code>数据，此函数等同于PHP的<code>fopen(&#39;php://input&#39;)</code>）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6376115645624808334.png" alt="image.png"></p><p>所以其实$_POST 就是对上述dept_name 进行 &amp; explode, 然后urldecode 一下</p><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>最先接触这个东西的时候是文件上传的时候</p><blockquote><p><form> 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 “multipart/form-data”。</form></p></blockquote><p>postman 中发送请求</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/585115645624810549.png" alt="image.png"></p><p>平时我测试接口的时候经常用的是form-data, 服务端实际接受到的数据如下(swoole)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multipart/form-data，将表单的数据处理为一条消息，以标签为单元，用分隔符分开。既可以上传键值对，也可以上传文件</span><br><span class="line">这种方式不会对中文进行编码</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8569915645624812587.png" alt="image.png"></p><blockquote><p>既可以上传文件等二进制数据，也可以上传表单键值对，</p></blockquote><p>所以本该用来进行上传文件的请求方式，我平时用它来进行普通接口的测试，通过这种方式提交数据也可以通过PHP 的 $_POST 来获取到    ，上述中的boundary用来分割数据</p><p>看到了postman 上面的raw吗</p><blockquote><p>raw 原始类型，可以上传任意格式的文本，比如 text、json、xml、html（中文不进行编码）</p></blockquote><p>其中 json,text,html 都是通过这种方式，然后添加content-type</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7545215645624814697.png" alt="image.png"></p><h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>微信中经常用这种方式，之前在开发企业号的时候经常遇到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.homeway.me HTTP/1.1 </span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;resource&gt;</span><br><span class="line">    &lt;id&gt;123&lt;/id&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;name&gt;</span><br><span class="line">            &lt;value&gt;homeway&lt;/value&gt;</span><br><span class="line">        &lt;/name&gt;</span><br><span class="line">        &lt;age&gt;</span><br><span class="line">            &lt;value&gt;22&lt;/value&gt;</span><br><span class="line">        &lt;/age&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/resource&gt;</span><br></pre></td></tr></table></figure><blockquote><p>php中<code>$_POST</code>只能读取<code>application/x-www-form-urlencoded</code>数据，<code>$_FILES</code>只能读取<code>multipart/form-data</code>类型数据，(感觉$_POST 也能读取multipart/form-data 中的数据)</p></blockquote><p>要读取那里面的数据只能用最原始的方法(同理json)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$data = file_get_contents(‘php://input’);</span><br><span class="line">$request-&gt;rawContent() // swoole</span><br></pre></td></tr></table></figure><p>notice:</p><blockquote><p>一般服务端语言如 php、python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。(我根据这个新增框架中json 数据的解析)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$getArr = static::$request-&gt;get;</span><br><span class="line">        $getArr = count($getArr) &gt; 0 ? $getArr : [];</span><br><span class="line"></span><br><span class="line">        $postArr = static::$request-&gt;post;</span><br><span class="line">        $postArr = count($postArr) &gt; 0 ? $postArr : []; //后面的覆盖前面的，所有post写在后面</span><br><span class="line"></span><br><span class="line">        if (isset(static::$request-&gt;header[&apos;content-type&apos;])) &#123;</span><br><span class="line">            if (static::$request-&gt;header[&apos;content-type&apos;] == &apos;application/json&apos;) &#123;</span><br><span class="line">                $rawContent = static::$request-&gt;rawContent() ?: &apos;&apos;;</span><br><span class="line">                $rawContent = json_decode($rawContent, true);</span><br><span class="line">                $postArr    = array_merge($postArr, $rawContent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return array_merge($getArr, $postArr);</span><br></pre></td></tr></table></figure><p>notice:</p><p>千万要注意：不能上来没有判断是json 就对rawContent 取到的内容进行切割，因为只有json 的时候切割才会符合我们预期，别的时候不会</p><p>上面就是post方式提交数据的几种情况，接下来我们说get方式（现在的restful api 还有delete put 等方式，我在各个文章上都没找到关于上面内容的解释，猜测一下，是不是delete put 本质上还是属于put 方式）</p><p>起因：之所以注意到get请求的这种方式，是因为再一次偶然的过程中发现get 请求的content-type 不存在，想了下确实合乎道理，get的参数都是拼接在url 上面 （file_get_contents(‘php://input’) 只能获取post请求中的输入）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4666915645624818122.png" alt="image.png"></p><p>注意就算是urlencode 加密，他们都是有字符编码的限制的，如果字符编码不一致，那么加密出来的结果将会不一样</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7052815645624820177.png" alt="image.png"></p><p>同理可以联想之前做的aes-128-ecb 加密，为什么有那么多可选项，也是这个原因</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8406415645624822588.png" alt="image.png"></p><p><a href="https://blog.csdn.net/andyzhaojianhui/article/details/5181902" target="_blank" rel="noopener">这篇文章对于编码的解释很透彻</a></p><p><a href="https://segmentfault.com/a/1190000015800019" target="_blank" rel="noopener">这篇文章和上面那篇文章都有简单描述urlencode是怎么实现的</a></p><p>(这篇文章中的很多坑我们写的时候没有碰到是因为很多默认配置的原因，比如php 字符集默认配置utf8,页面配置字符集 utf-8)</p><p>所以呢在通过get 方式传递参数的时候，我们一定要注意那些中文字符 urlencode 的时候（或者别的编码方式的时候设置的字符集是什么，是gbk 还是utf8,我们忽略这个问题是因为我们经常就默认都设置成utf8 导致很多时候这些细节会被忽略）</p><p>同理联想php中也有urlencode 函数，他的字符集是怎么设置的</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4356115645624825068.png" alt="image.png"></p><p>所以呢，当我们出现乱码的时候我们还可以这样考虑下：</p><ol><li>客户端传递过来的数据进行了怎么样的加密（字符集），get方式，post方式中的www-formedate-urlencode</li><li>服务端传递过来的数据进行了怎么样的解密（字符集）</li></ol><blockquote><p>在post方法里所要传送的数据也要URL encode，那么他是用什么编码方式的呢？<br>   在form所在的html文件里如果有段<meta http-equiv="Content-Type" content="text/html; charset=字符集（GBK，utf-8等）">，那么post就会用此处指定的编码方式编码。一般大家都认为这段代码是为了让浏览器知道用什么字符集来对网页解释，所以网站都会把它放在html代码的最前端，尽量不出现乱码，其实它还有个作用就是指定form表单的post方法提交数据的 URL encode编码方式。从这里可以看出对于get方法来说，浏览器对数据的URL encode的编码方式是有浏览器设置来决定(或者在请求之前，我们提前对非asii码进行编码设置，这样决定权就从浏览器变成我们开发者)，（可以用js做统一指定），而post方法，开发人员可以指定。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP属于一门高级语言，感觉就是那种语言里面偏向于应用层的语言，再加上lnmp架构还有框架的存在，对于http请求过程中的细节封装了太多层，导致我们实际在使用过程中得到的参数已经是面目全非的样子，记录下对其探索的历程&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="框架，HTTP" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6%EF%BC%8CHTTP/"/>
    
  </entry>
  
  <entry>
    <title>加密解密</title>
    <link href="http://yoursite.com/2019/02/21/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
    <id>http://yoursite.com/2019/02/21/加密解密/</id>
    <published>2019-02-21T03:50:59.000Z</published>
    <updated>2019-07-31T08:41:16.578Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个底层码农，其实加密解密平时是用不到的，毕竟平时写的就是cms 的curd, 但随着API的流行以及老大对代码质量的重视，还有和别的部门的交互，于是需要加解密啦。<a href="https://t.ti-node.com/thread/6497068236977209344" target="_blank" rel="noopener">原文</a></p><a id="more"></a><p>hash 和 加解密 </p><p>hash :  md5, sha1, hamc</p><p>加解密：base64, aes</p><p>用途：</p><p>hash ： 因为不能解密，所以一般用在签名过程中，怎么验证是否数据被用户修改了呢，用相同的密钥对于传递过来的数据重新加密一遍，和sign 比对，如果相等，那就没有人修改签名(注意这个密钥一定不能被知道，因为一旦被知道，劫持者可以根据密钥帮修改后的数据生成对应sign, 起不到保护的作用)</p><p><a href="https://blog.csdn.net/dengjiexian123/article/details/53313913" target="_blank" rel="noopener">这篇文章是关于上面3种hash的解释</a></p><p>md5: 经常用到，有时候我们需要固定长度的字符串，就可以用md5加密一下,md5 可以生成32位或者64位，依据不同的算法，js 好像经常出64位的，和php对接的时候要注意一下</p><p>sha1: 感觉和上面的md5类似（感觉就是两种不同的加密算法）</p><blockquote><p>其实跟前面的MD5同期的还有一个SHA1加密方式的，不过也是算法比较简单，所以这里就一笔带过吧。而这里即将要说到的<code>SHA256</code> 和 <code>SHA512</code>都是来自于SHA2家族的加密函数，看名字可能你就猜的出来了。</p></blockquote><p>hmac: hmac 其实就是用上面两种算法（hmac-sha256, hmac-md5），再加上一个密钥进行加密（这个密钥感觉又类似salt 的存在）</p><p>bcrypt : <a href="https://www.jianshu.com/p/2b131bfc2f10" target="_blank" rel="noopener">关于bcrypt 这里有个解释很清楚</a>， 感觉上其实就是另一种算法的hash</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712143357.png" alt=""></p><p>我之前很好奇这种hash, 怎么验证，也不能解密呀，当看到上面这张图片的时候，完全明白了，他的salt 存在了他加密后的字符串中，有了salt 就和以前的md5加解密一样了(注意上面各个字段的意思，10代表hash 10次)，php现在经常用的一种加密密码的方式也很好用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">md5(‘123456’) e10adc3949ba59abbe56e057f20f883e </span><br><span class="line">md5(‘123456’ . ($salt = ‘salt’)) 207acd61a3c1bd506d7e9a4535359f8a </span><br><span class="line">sha1(‘123456’) 40位密文 </span><br><span class="line">hash(‘sha256’, ‘123456’) 64位密文  // sha2</span><br><span class="line">hash(‘sha512’, ‘123456’) 128位密文 // sha2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$str = password_hash(123, PASSWORD_DEFAULT);  //默认 bcrypt， PASSWORD_DEFAULT 也代表了 PASSWORD_BCRYPT.二者都是1</span><br><span class="line">password_verify(123, $str); // 验证</span><br><span class="line"></span><br><span class="line">password_hash() – 对密码加密.</span><br><span class="line">password_verify() – 验证已经加密的密码，检验其hash字串是否一致. </span><br><span class="line">password_needs_rehash() – 给密码重新加密. // 其实感觉没啥必要，主要是因为感觉algo或者cost hash次数改变就会改变</span><br><span class="line">password_get_info() – 返回加密算法的名称和一些相关信息.</span><br></pre></td></tr></table></figure><p><a href="https://www.codecasts.com/blog/post/php-password-hash-in-the-right-way" target="_blank" rel="noopener">这篇文章php的password api说的挺好的</a></p><blockquote><h2 id="散列消息身份验证码-Hashed-Message-Authentication-Code-。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥-秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。"><a href="#散列消息身份验证码-Hashed-Message-Authentication-Code-。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥-秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。" class="headerlink" title="散列消息身份验证码 Hashed Message Authentication Code 。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥/秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。"></a>散列消息身份验证码 Hashed Message Authentication Code 。它不是散列函数，而是采用了将MD5或SHA1散列函数与共享机密秘钥（与公钥/秘钥对不同）一起使用的消息身份验证机制。消息与秘钥组合并运行散列函数（md5或sha1），然后运行结果与秘钥组合并再次运行散列函数。</h2><p>HMAC-SHA1简要来说，就是采用sha1算法，与HMAC机制相结合，制造出更加难以破解的加密串。</p><p>hash_hmac</p><p>在php中hash_hmac函数就能将HMAC和一部分哈希加密算法相结合起来实现HMAC-SHA1  HMAC-SHA256 HMAC-MD5等等算法。函数介绍如下：</p><p>string hash_hmac(string $algo, string $data, string $key, bool $raw_output = false)</p><p>algo：要使用的哈希算法名称，可以是上述提到的md5,sha1等</p><p>data：要进行哈希运算的消息，也就是需要加密的明文。</p><p>key：使用HMAC生成信息摘要是所使用的密钥。</p><p>raw_output：该参数为可选参数，默认为false，如果设为true，则返回原始二进制数据表示的信息摘要，否则返回16进制小写字符串格式表示的信息摘要（注意是16进制数，而非简单的字母加数字）。</p></blockquote><p>加解密：数据</p><p>base64:</p><p>base64_encode</p><p>base64_decode</p><p>(感觉url_encode 也不能算是加密，只能算是字符转换，因为那个转换之后得到的内容基本都能分辨出来)</p><p>这种最原始的方式，因为不需要密钥，感觉不能算上加解密，确实在各个网站上也是这么感觉的</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712150709.png" alt=""></p><p>首先的区分下加解密和hash 的不同，对于md5() 这样加密之后理论上就不能解密的方式，我们一般称之为hash,在我们以往的网站编程中，对于用户的密码保存一般都是通过hash这种方式，通过把用户的密码拼接一个字符串，然后md5下生成的值保存到数据库中，下次用户登陆的时候，再次把用户输入的密码做上次同样的操作，对比和数据库中值是否一致，如果一致说明密码正确，否则密码错误。</p><p>加密我们平时生活中遇到最多的应该就是https 解析过程，因为非对称加密太消耗性能，所以我们传输过程需要对称加密（对称加密就是加密密钥和解密密钥一致，非对称反之），而对于密钥的传输我们用的是非对称（非对称因为密钥的不同又有公钥和私钥之分：公钥加密，私钥解密，数据不会被获取；私钥加密，公钥解密，数据不会被篡改）。</p><p>对称加密算法一般有AES(itbasic 请求datrix 那边用的就是这种，ecb 没有$iv 偏移量，cbc 有偏移量 ),DES,3DES，非对称有RSA</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712235429.png" alt=""></p><p>上图中，123456 就是对称加密过程中的密钥</p><blockquote><p>最一开始的时候，我朝人民一般都是倾向于使用“天王盖地虎”，“宝塔镇河妖”这种加解密技术；然而，美帝用了一种叫做DES的技术进行对称加解密，这玩意一度成为业界通用的对称加解密技术，银行、五角大楼都爱用这玩意，可惜好景不长、世风日下、世态炎凉，这玩意的破解成本越来越低越来越低～～ 于是，为了续命，就又有一些白胡子老头给DES打补丁，缝缝补补搞出来一个玩意叫做3DES，继续用，又不是不能用…这个顾名思义就行了，别打我，真的：3DES就是用DES处理（注意是处理，我没说是加密）了三次的意思。就目前看来，3DES实际上用的可能也并不是十分广泛了，所以如果大家在选择对称加解密技术的时候，尽量避开DES和3DES就可以了。</p><p>呵呵，喜新厌旧的沙雕人类…虽然DES已经没人用了，但毕竟也是辉煌过，我觉得还是得动手表演一波儿。我们知道，<strong>在php7里，原来的mcrypt系列加解密已经被放弃掉了，官方建议我们使用openssl系列来进行加解密</strong>，所以确保你的PHP环境里安装了openssl标准扩展。</p></blockquote><p>上面是原文中对于DES 和 3DES 的描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 这个函数打印出来openssl支持的所有加密方法以及模式的组合</span><br><span class="line">$arr_ava_methods = openssl_get_cipher_methods(true);</span><br><span class="line">print_r( $arr_ava_methods );</span><br><span class="line">exit;</span><br><span class="line">// 返回值</span><br><span class="line">    [123] =&gt; aes-192-cfb8</span><br><span class="line">    [124] =&gt; aes-192-ctr</span><br><span class="line">    [125] =&gt; aes-192-ecb</span><br><span class="line">    [126] =&gt; aes-192-gcm</span><br><span class="line">    [127] =&gt; aes-192-ocb</span><br><span class="line">    [128] =&gt; aes-192-ofb</span><br><span class="line">    [129] =&gt; aes-256-cbc</span><br><span class="line">    [130] =&gt; aes-256-ccm</span><br><span class="line">    [131] =&gt; aes-256-cfb</span><br><span class="line">    [132] =&gt; aes-256-cfb1</span><br><span class="line">    [133] =&gt; aes-256-cfb8</span><br><span class="line">    [134] =&gt; aes-256-ctr</span><br></pre></td></tr></table></figure><blockquote><p>其中带有ede的，比如des-ede*这样的就表示是3DES</p></blockquote><p>其中des 有如下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">des-cbc</span><br><span class="line">des-cfb*（注意后面的通配符星号）</span><br><span class="line">des-ecb</span><br><span class="line">des-ofb</span><br></pre></td></tr></table></figure><p>下面是如何通过des-ecb 的方式加密</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 我们就选用des-ecb方法进行一次des加密</span><br><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">$my_method   = &apos;des-ecb&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123;</span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">$key  = &quot;123456&quot;;</span><br><span class="line">$data = &quot;helloMOTO&quot;;</span><br><span class="line">echo &quot;明文：&quot;.$data.PHP_EOL;</span><br><span class="line">$enc_data  = openssl_encrypt( $data, $my_method, $key );</span><br><span class="line">echo &quot;密文：&quot;.$enc_data.PHP_EOL;</span><br><span class="line">$dec_data  = openssl_decrypt( $enc_data, $my_method, $key );</span><br><span class="line">echo &quot;明文：&quot;.$dec_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">明文：helloMOTO</span><br><span class="line">密文：IbpWiZbAoNMiknX3jdeqmQ==</span><br><span class="line">明文：helloMOTO</span><br></pre></td></tr></table></figure><p>接下来我们说说aes 的加密方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">// 选用aes-128-ecb</span><br><span class="line">$my_method   = &apos;aes-128-ecb&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123; </span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">// 加密用的密码</span><br><span class="line">$key  = &quot;1234567812345678&quot;;</span><br><span class="line">// 加密的内容</span><br><span class="line">$data = &quot;12345678abcdxxoo12345678abcdxxoo&quot;;</span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA );</span><br><span class="line">$hex = bin2hex( $enc_data );</span><br><span class="line">echo $hex.&apos; : &apos;.strlen( $hex ).PHP_EOL;</span><br></pre></td></tr></table></figure><p>aes-128-ecb, 其中128代表密钥的长度，多余的长度会被直接街去掉(这个可以通过代码验证下，比如12345 用密钥1234567812345678和12345678123456789分别加密，看结果是否一样，最后再用不满128bit来加密123456781234567 )，128bit</p><p>128/8=16 位，aes-192-ecb, aes-256-ecb, 这其中的192 ，256，都是同样的意思。</p><blockquote><p>最后一个参数是OPENSSL_RAW_DATA，如果选用这个option的话，经过加密后的数据会是奇怪的二进制数据，无法直接通过文本方式查看，所以要看的话必须先使用bin2hex函数处理一下。</p></blockquote><p>上面这段话一定要注意理解，反正我第一次没有理解，导致第一次加密数据失败，网上的很多aes-128-ecb 这种加密代码的封装中都携带着自己的逻辑，所以会误导视野。上述opensssl_encrypt(),如果没有用最后一个参数，直接返回的结果是加密结果base64 的结果，如果有了，返回的是一段奇怪的二进制数据数据，这里我们可以理解成原始数据（加密数据最原始的样子），我们可以通过base64或者 bin2hex 转换城对应的base64格式或者16进制格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">明文：</span><br><span class="line">12345678abcdxxoo12345678abcdxxoo</span><br><span class="line">密文：c1391e34caf38f8c2a477cbda3772533c1391e34caf38f8c2a477cbda3772533d96aa42b59151a9e9b5925fc9d95adaf</span><br><span class="line">// 上面密文切分的结果</span><br><span class="line">c1391e34caf38f8c2a477cbda3772533 | c1391e34caf38f8c2a477cbda3772533 | d96aa42b59151a9e9b5925fc9d95adaf</span><br><span class="line"></span><br><span class="line">难道说明文“12345678abcdxxoo”被密钥“1234567812345678”加密后后的密文就是“c1391e34caf38f8c2a477cbda3772533”？</span><br><span class="line"></span><br><span class="line">DES和3DES会将明文以64bit（8字节）作为一个单元进行分组；</span><br><span class="line">AES则会将明文以128bit（16字节）作为一个单元进行分组；</span><br><span class="line">无论是AES还是DES，当最后一个分组的数据长度不满足分组标准长度的时候，会用某种填充方式进行填充；</span><br><span class="line">AES对一个16字节分组加密完毕后，分组大小依然为16字节；DES也一样</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712235458.png" alt=""></p><p>上面就是aes ecb 的处理过程</p><p>如果我们把加密的内容分组之后稍微修改下分组顺序再解密，可以得到原文分组顺序的不同</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712235511.png" alt=""></p><p>ecb太不靠谱了，竟然能修改，出现了cbc 模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ava_methods = openssl_get_cipher_methods();</span><br><span class="line">$my_method   = &apos;aes-128-cbc&apos;;</span><br><span class="line">if ( !in_array( $my_method, $ava_methods ) ) &#123;</span><br><span class="line">  exit( &apos;错误的加密方法&apos;.PHP_EOL );</span><br><span class="line">&#125;</span><br><span class="line">// 密钥 和 明文</span><br><span class="line">$key  = &quot;1234567812345678&quot;;</span><br><span class="line">$data = &quot;12345678abcdxxooxxooabcd12345678i&quot;;</span><br><span class="line">// 每种方法都有自己需要的iv向量的长度</span><br><span class="line">$iv_length = openssl_cipher_iv_length( $my_method );</span><br><span class="line">// 根据长度生成相应iv</span><br><span class="line">$iv        = openssl_random_pseudo_bytes( $iv_length, $cstrong ); // 我就是一直把这玩意当成一个随机的字符串看待的，他真的就是一个随机字符串</span><br><span class="line">echo &quot;明文：&quot;.$data.PHP_EOL;</span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA, $iv );</span><br><span class="line">$dec_data = openssl_decrypt( $enc_data, $my_method, $key, OPENSSL_RAW_DATA, $iv );</span><br><span class="line">echo &quot;解密：&quot;.$dec_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line">// 神器的代码</span><br><span class="line">test2(1,$c); // 这样竟让不会报错</span><br><span class="line">function test2 ($a, &amp;$b) &#123;</span><br><span class="line">        var_dump($a+$b, $b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><p>今天和我司员工对接cbc模式，~~不出意外，这条产品线的小伙伴也是在网上copy网上代码，结果直接没有给我iv向量，没有iv向量怎么可以解密呢，哈哈哈，其实之前我也不知道解密需要iv，我以为这个iv是包自带的，不需要我们管，但是当我在网上的在线平台使用的时候，发现cbc必须填写iv向量，最少还是16个字节，也就是16个英文字符（吐槽一下php自身生成的那个应该是二进制，需要转换一下，否则根本复制不下来，复制下来也不是16个字符长度），怎么办呢，这时候我逐渐意识到是不是加解密还需要iv,老李代码中反正有，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA, $iv ); // 加密</span><br><span class="line">$dec_data = openssl_decrypt( $enc_data, $my_method, $key, OPENSSL_RAW_DATA, $iv ); // 解密</span><br></pre></td></tr></table></figure><p>其实老李上面那段代码也写了注释，把iv当做一个随机的字符串，看来真的可能需要iv,这时候就开始翻他的go代码，但是他的go代码中没有传递iv变量这个值呀，看到了下面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blockMode := cipher.NewCBCEncrypter(block, key[:blockSize])</span><br></pre></td></tr></table></figure><p>~~对了，就是这个 这个key[:blocksS]，这个就是iv,怪不得他不用传递，原来是约定的,</p><blockquote><h2 id="初始化向量-IV"><a href="#初始化向量-IV" class="headerlink" title="初始化向量(IV)"></a><a href="http://blog.csdn.net/xiaohu50/article/details/51682849" target="_blank" rel="noopener">初始化向量(IV)</a></h2><p><a href="http://blog.csdn.net/xiaohu50/article/details/51682849" target="_blank" rel="noopener">http://blog.csdn.net/xiaohu50/article/details/51682849</a></p><p>初始化向量（IV，Initialization Vector）是许多工作模式中用于随机化加密的一块数据，因此可以由相同的明文，相同的密钥产生不同的密文，而无需重新产生密钥，避免了通常相当复杂的这一过程。</p><p>初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的；特别的，在许多实现中使用的产生IV的方法，例如SSL2.0使用的，即采用上一个消息的最后一块密文作为下一个消息的IV，是不安全的。</p><p>因为刚做了一个接口的用户信息加解密，加密至URL，然后那边后台解析，一开始IV不一致老是有一个参数解析不了，后来问同事是IV的问题，所以在这边做个记录，对这个还不是很了解。。。</p><p>如果加解密的IV不一致的话会导致数据不一致，所以解密失败，IV如果不变的话会导致不安全</p></blockquote><p>上面是我在百度go cbc 加解密的时候看到的， 起初还以为go的cbc加密iv有什么特殊化，看来是我多虑了，就像很多时候aes加密本身不需要base64，但很多时候网上代码都加上了，因为默认约定这样好看点，或者字符长度确定了便于存储</p><blockquote><p>这个传说中的iv向量终于他妈出现了！相对于ECB模式，CBC在加密之前多了一个XOR异或运算的环节，但是第一个明文分组和谁做异或呢？所以这个iv向量就是初始化后给第一个明文分组做XOR异或运算用的，第二个明文分组就与第一个密文分组做XOR异或运算，然后再加密得到第二个密文分组…依次重复下去。</p><p>xor 就是异或，相同的取0，不同的取1</p></blockquote><p>总结：</p><blockquote><p>AES和DES以及3DES这种加密方式被称为分组密码，分组密码每次只能加密固定长度的明文，所以如果明文很长的话，就需要轮流为每个分组明文进行加密，AES的分组长度是128bit，而DES的分组长度为64bit；如果一旦需要对多个分组进行轮流加密，加入明文被分成了三个明文分组，那么就需要对三个明文进行迭代加密（粗暴理解就是轮流加密），然而会有很多种不同的迭代方式，这种不同的迭代方式专业名词就叫“模式”，这些模式有：ECB、CBC、OFB、CFB、CTR… …</p><p>对明文进行分组的方式是固定的，唯一不同的就是分组长度不一样而已；模式是指对多个明文从第一个开始轮流加密到最后一个的这个过程，是怎么轮流执行的。</p></blockquote><p>非对称加解密就不copy了，以后用到的时候再看吧</p><p>自己的总结：</p><p>其实上面用到的也就怎么用php 进行aes-128-ecb加密，加密出来的数据让别的语言可以解析出来</p><p>这其中会遇到很多问题，比如之前曾经遇到过但是没有记录的和java通信过程中的padding 填充问题，以后遇到了再补充吧。</p><p>顺带补充一下：</p><p><a href="https://www.devglan.com/online-tools/aes-encryption-decryption" target="_blank" rel="noopener">https://www.devglan.com/online-tools/aes-encryption-decryption</a></p><p>这个网站以及下面的php代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$data = &apos;陈野&apos;;</span><br><span class="line">$key = &apos;1234567812345678&apos;;</span><br><span class="line"></span><br><span class="line">echo $key.PHP_EOL;</span><br><span class="line"></span><br><span class="line">$enc_data = openssl_encrypt( $data, $my_method, $key, OPENSSL_RAW_DATA);</span><br><span class="line">echo $enc_data.PHP_EOL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo base64_encode($enc_data).PHP_EOL;</span><br><span class="line"></span><br><span class="line">echo bin2hex( $enc_data );</span><br></pre></td></tr></table></figure><p>默认的填充方式</p><p>pkcs5padding or pkcs7padding (不确定)</p><p>字符集（utf8）</p><p><a href="http://tool.chacuo.net/cryptaes" target="_blank" rel="noopener">http://tool.chacuo.net/cryptaes</a></p><p>上面这个网站才是真正意义上详细的加密，参数可以选择</p><p>今天着重研究了下pkcs5padding 和 pkcs7padding , 网上说的 5p 是7 p的子集， 7p的填充 1 到255 字节都可以， 5p的填充只能 1 到 8字节 ，可是我发现aes 是16字节分组的（不管是 128 还是 256 算法，都是16字节分组），按理说5p只能填充 1到8 那如果只有1个字符的话，怎么填充呢，是填充7个字节还是15字节呢，反正，当我填充15的时候php的openssl nopading  出来的数据和 openssl  raw data 出来的数据是一样的，那么应该就是填充15了</p><p>网上看到7p和5p的区别大致上都是：5p是7p子集，5p只支持到8的block，7p可以支持到255，所以</p><p><a href="https://github.com/keel/aes-cross/blob/master/info-cn/README.md" target="_blank" rel="noopener">这篇文章上说的aes 5p和7p是一样的</a>， 感觉是错的，就是aes没有5p的padding</p><p>关于nopadding， 字面意思上就是不填充，对于aes，不填充的话，必须保证是16字节整数倍，否则会加密失败</p><p>关于zeropadding, php的 openssl 虽然有这个参数，但是要是不满16字节，仍然是会报错，既然这样，zeropadding 感觉和nopadding 就差不多了，实践了一下，果然zero_padding 就是base64了一下no_padding的结果</p><p>关于老版本的加密函数的转换，据说是老版本因为是zero_padding 导致数据出来和新版本不一样，zero_padding ,在末尾填充的是 chr(0), 代表0 这个ascii 对应的 字符，很多网上写的是 \0(很奇怪的是chr(\0)  能得到和 chr(0) 一样的字符，但是这个字符我们键盘是不能表示出来的，  chr(\1) 和 chr(1) 却不一样) ，当我们拼凑到16字节之后，再解密，只需要过滤掉\0这个特殊字符就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 这是php 的7padding ,</span><br><span class="line">function pad($data, $blocksize = 16)</span><br><span class="line">&#123;</span><br><span class="line">    $pad = $blocksize - (strlen($data) % $blocksize);</span><br><span class="line">    return $data . str_repeat(chr($pad), $pad);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为最后7padding 最后一个字符肯定是填充的自己长度，所以只需要截取未填充的部分就好</span><br><span class="line"> function unpad($text)</span><br><span class="line">&#123;</span><br><span class="line">    $pad = ord($text[strlen($text) - 1]); // 填充的字符</span><br><span class="line">  // var_dump($pad);</span><br><span class="line">                        </span><br><span class="line">    if ($pad &gt; strlen($text))</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">                            </span><br><span class="line">    if (strspn($text, chr($pad), strlen($text) - $pad) != $pad)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">                        </span><br><span class="line">    return substr($text, 0, -1 * $pad);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下填充时候的length, 我们计算的时候都是用的strlen, 并不是 中文字符的len</p><p>注意一下，我们没填充之前，已经是一个完整的string, 我们每次填充的内容，都是我们肉眼可以识别的字符，或者说是我们可以处理的字符，所以我们可以裁剪substr， 或者trim过滤掉我们添加的字符</p><p>总结：hash 和 加解密大致就是上面那些东西了，后面jwt 这些认证方式，其实就是 hash 和 加解密的实际运用，本质上并不是一个新的东西</p><p>现在重看， <a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">阮一峰</a> 老师的这篇jwt，讲解的真的好，jwt首先就可以看做一个token,自带token 相比较传统的cookie session,更便于扩展，由客户端自己维持登陆态。缺点token 签发了没法主动让他失效，除非到达失效时间，或者像我们一样添加额外逻辑，token 必须在redis中有对应内容，才能生效。</p><p>jwt token ,是由三个字符串base64加密而成,  因为base64解密不需要密钥，所以我们很容易根据base64解密出来</p><p>第一段是 alg + type. 算法 + 类型（JWT）</p><p>第二段是我们自定义的一个数组，当然可能有些属性是必须的，比如签发时间和过期时间</p><p>第三段是sign，为了防止第二段被别人修改，利用的加密算法是前面的alg (可能更确切的说是hash)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712225542.png" alt=""></p><p>综上：所以事先起来感觉很简单，前面两段都是base64, 就是最后一个用hash，之后再base64, 有个问题就是这块的base64不是普通的base64, base64之后再替换三个字符，我的感觉是怕用户把这个字段连接在url后面当做get请求发送，base64中的参数影响到这个url的正确性</p><p>当我们明白过程之后，我们就很容易自己实现一个jwt，就不需要用网上的加密包了，我们可以看看php的 firebase/php-jwt 包，蛮简单的，默认hsh256, php 的hash_hmac 很容易实现。</p><p>到此为止 ，我们就剩rs256 公钥和私钥没有去研究，以后遇到了再去研究这个firebase的包（从下面也可以看出，hash_hmac 用来hash的函数，openssl 一般是用来加密的函数）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190712234533.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个底层码农，其实加密解密平时是用不到的，毕竟平时写的就是cms 的curd, 但随着API的流行以及老大对代码质量的重视，还有和别的部门的交互，于是需要加解密啦。&lt;a href=&quot;https://t.ti-node.com/thread/6497068236977209344&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
      <category term="JWT" scheme="http://yoursite.com/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>PHP面试题</title>
    <link href="http://yoursite.com/2019/02/21/PHP%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2019/02/21/PHP面试题/</id>
    <published>2019-02-21T02:50:35.000Z</published>
    <updated>2019-08-08T10:21:19.508Z</updated>
    
    <content type="html"><![CDATA[<p>收集一些总是考的面试题</p><a id="more"></a><h1 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">怎么会导致跨域，为什么会出现跨域</span><br><span class="line">schema，或者ip地址，或者端口号 不同都会出现跨域，为了防止前端随意调用别人的后端接口</span><br><span class="line"></span><br><span class="line">怎么解决跨域</span><br><span class="line">jsonp(用的比较少,好像是通过拼凑返回内容,让前端主动调用某个申明好的js文件), cors(通过在返回头中添加header信息,比如允许的域名,允许的调用方法，允许的自定义参数)</span><br><span class="line"></span><br><span class="line">什么是简单请求，什么是非简单请求</span><br><span class="line">好像是除了get post 之外的跨域请求都属于非简单请求，除此之外携带额外的参数也属于非简单请求。在发送非简单请求之前都会发送一个options请求，options请求没有请求体内容，你只需要把预定的header信息返回就好了，如果返回的header请求信息做了跨域处理，那么后面浏览器就不会屏蔽掉返回内容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">get post 区别</span><br><span class="line">get 可以浏览器收藏，参数会被缓存，post 不可以 ，</span><br><span class="line">get 参数只能被url 编码， post 支持多种方式编码 （比如 application/x-www-form-urlencoded， 比如json 格式）</span><br><span class="line">get 长度一般由浏览器决定，比较短 ， post 比较长</span><br><span class="line">get 传递的参数一般直接显示在url 地址栏， 相比较的话，post会比较安全，get不要放敏感信息， get 参数放在url 中，post参数放在request body 中</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http请求过程</span><br><span class="line">浏览器开始在host文件中查找对应网址的ip地址，找不到的话再在本地浏览器缓存中查找，再找不到去dns解析中查找，找到服务器ip地址之后，一般会先去监听的web服务器上，比如nginx，nginx对于静态文件直接返回，对于php类似文件有转发作用，比如转发给9000端口的php-fpm, 或者swoole， 然后他们再交给单个的工作进程中的php处理</span><br><span class="line"></span><br><span class="line">为什么http请求需要三次握手4次挥手</span><br><span class="line">第一次握手，验证cli 可以发消息到 server， server确定cli 可以推送消息，</span><br><span class="line">第二次握手，server验证自己可以推送消息，cli知道自己能推送消息并能收到返回消息，此时已经可以发送消息</span><br><span class="line">第三次握手，server知道自己可以同送消息，也能接收到消息，于是握手结束</span><br><span class="line"></span><br><span class="line">第一次挥手，通知sever 我要关闭了</span><br><span class="line">第二次挥手，server 通知cli， 好的，你关闭吧</span><br><span class="line">第三次挥手，server通知cli</span><br><span class="line">第四次挥手，cli告知server， 收到</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https 和 http的区别</span><br><span class="line">https基于http， 有个ssl 包裹住用户信息</span><br><span class="line">https加密原理，服务端下发一份数据(感觉就是证书)，客户端上传一份数据，生成一个对称加密的密钥，然后利用这个密钥进行数据传输</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">什么是socket编程</span><br><span class="line">Socket 又称网络套接字，是一种操作系统提供的进程间通信机制。</span><br><span class="line"></span><br><span class="line">工作流程：</span><br><span class="line">1. 服务端先用 socket 函数来建立一个套接字，并调用 listen 函数，使服务端的这个端口和 IP 处于监听状态，等待客户端的连接</span><br><span class="line">2. 客户端用 socket 函数建立一个套接字，设定远程 IP 和端口，并调用 connect 函数</span><br><span class="line">3. 服务端用 accept 函数来接受远程计算机的连接，建立起与客户端之间的通信</span><br><span class="line">4. 完成通信以后，最后使用 close 函数关闭 socket 连接。</span><br><span class="line"></span><br><span class="line">感觉类似swoole, swoole 先开启监听，new 一个server</span><br><span class="line">然后写监听事件，用于cli的请求的接受</span><br><span class="line">请求处理完，关闭</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OAuth(Open Authorization) 协议为用户资源的授权提供了一个安全的、开放而又简易的标准，第三方无需使用用户的用户名与密码，就可以申请获得该用户资源的授权。</span><br><span class="line"></span><br><span class="line">运行流程：</span><br><span class="line"></span><br><span class="line">1. 用户打开客户端以后，客户端要求用户给予授权。</span><br><span class="line">2. 用户同意给予客户端授权</span><br><span class="line">3. 客户端使用上一步获得的授权，向认证服务器申请令牌。</span><br><span class="line">4. 认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</span><br><span class="line">5. 客户端使用令牌，向资源服务器申请获取资源。</span><br><span class="line">6. 资源服务器确认令牌无误，同意向客户端开放资源</span><br><span class="line"></span><br><span class="line">OAuth 2.0 定义了四种授权方式，授权码模式、简化模式、密码模式、客户端模式，具体的授权流程，请看阮一峰老师的文章理解OAuth 2.0。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">csrf 攻击</span><br><span class="line">防止因为浏览器请求本域名接口自动携带着cookie， 在第三方者在用户没有感知的情况下，调用api。解决办法是携带参数token</span><br><span class="line">xss 攻击</span><br><span class="line">用户输入信息没有做合理过滤，导致让前端页面调用非法的js等内容。用户信息过滤 </span><br><span class="line">sql 注入</span><br><span class="line">用户输入信息不合法, 导致sql执行用户命令。 用pdo，sql语句预处理功能，或者用户输入过滤。</span><br></pre></td></tr></table></figure><h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PHP 位运算符 </span><br><span class="line">| 或</span><br><span class="line">&amp; 且</span><br><span class="line">^ 异或</span><br><span class="line">~ 取反 （其实最常见的就是error_reporting(E_ALL ~E_NOTICE)）</span><br><span class="line">3 | 5 7</span><br><span class="line">3 &amp; 5 1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">常用string ,arr 函数</span><br><span class="line">array:</span><br><span class="line">array_merge</span><br><span class="line">array_slice</span><br><span class="line">array_values</span><br><span class="line">array_keys</span><br><span class="line">array_columns</span><br><span class="line">is_array</span><br><span class="line">array_key_exists</span><br><span class="line"></span><br><span class="line">string:</span><br><span class="line">explode</span><br><span class="line">substr</span><br><span class="line">strpos</span><br><span class="line">preg_split</span><br><span class="line">strstr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_merge 和 +  的区别</span><br><span class="line">+ 同key, 前面覆盖后面 （index 或者 关联）</span><br><span class="line">merge 关联后面覆盖前面，index 直接扩展开了</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">php7新特性</span><br><span class="line"></span><br><span class="line">1.错误也会报出异常，可以捕获</span><br><span class="line">2.太空舱运算符</span><br><span class="line">3.三目运算符的缩写</span><br><span class="line">4.define可以定义常量数组</span><br><span class="line">5.返回值也能严格要求返回类型</span><br><span class="line">6.传入参数类型声明的扩展，比如int</span><br><span class="line">7.命名空间合并</span><br><span class="line">8.closure call 替代bindTo 更加的方便</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php7为什么相较于php5性能有很大提升？</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php垃圾回收机制</span><br><span class="line">1、以php的引用计数机制为基础（php5.3以前只有该机制）（refcount 是1 的时候就删除， is_ref 是否是引用类型）</span><br><span class="line">2、同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题（php5.3开始引入该机制）（为了防止子变量中引用父变量，父变量unset 之后refcount 到不了0 一直得不到回收）</span><br><span class="line">其实最简单的防止那种慢性内存溢出的方式就是php-fpm 的连接重启(当然你要是一次性消耗了太多内存，还是会内存溢出的)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何解决php内存溢出问题（phpexcel中经常出现，第二个很管用）</span><br><span class="line">1. 增大 PHP 脚本的内存分配</span><br><span class="line">2. 变量引用之后及时销毁</span><br><span class="line">3. 将数据分批处理</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$z = 0.58;</span><br><span class="line">var_dump(intval($z * 100));</span><br></pre></td></tr></table></figure><p>答案是 57，所有语言对于小数的存取都是不精确的， 0.58其实是0.57999999，而且intval() 总是从遇到第一个不是数字开始截取，导致了0.57，比较通用的方法是转成别用intval, 或者用数学函数，bcmath扩展计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie 和 session 的 区别</span><br><span class="line">cookie 更像一个钥匙，因为没有加密，所以客户端可以查看和随意更改cookie的数据，cookie 对应的 session 才是服务端真正存储的序列化数据，</span><br><span class="line">php 中 cookie 默认名称是 phpsessid , 通过这个值，服务端php能识别客户端对应的用户</span><br><span class="line"></span><br><span class="line">什么是jwt， jwt 和 cookie, session 的区别</span><br><span class="line">jwt 是一种token 的实现方式，由base64 处理过，因为base64可以放解码，所以不要存储重要信息，存放一些基本的辨识用户的信息就好了。</span><br><span class="line">他是三段组成的，第一段是签名的加密算法，第二段是用户数据（载体）, 第三段是前面数据的签名，防止用户数据被修改。</span><br><span class="line">jwt相较于cookie 和session ,不需要服务端存储用户的基本信息，token下发到client ,完全由客户端保存, 可以防止csrf 攻击。但是jwt 下发之后除非做特殊处理比如服务端，否则不能失效，蛮尴尬的。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register和 _autoload 的区别</span><br><span class="line">现在的自动加载已经不用_autoload 了，这个只支持一个方法，现在一般用spl_autoload_register, 或者全部用composer， 但composer本质上还是spl_autload_register,他可以支持多个函数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">判断一个日期是否合法</span><br><span class="line">// 思路</span><br><span class="line">把一个日期转用strtotime 转换成时间戳再通过 date(), 转换成标准时间，和原先的日期比对是否相同，相同就合法，不同不合法</span><br><span class="line">// 注意：错误的时间date 也能转换，只是可能转换成1970 这样的时间</span><br><span class="line">// 字符串的比对比较耗时</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单引号，双引号区别</span><br><span class="line">单引号解析变量</span><br><span class="line">双引号不解析变量</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include require 区别</span><br><span class="line">include 包含文件不存在 warning</span><br><span class="line">require 错误</span><br><span class="line">required_once</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中文截取字符串</span><br><span class="line">mb_substr</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">平时开发用的设计模式</span><br><span class="line"></span><br><span class="line">单例  保证在整个应用程序的生命周期中，任何一个时刻，单例类的实例都只存在一个，同时这个类还必须提供一个访问该类的全局访问点。（getInstance）</span><br><span class="line"></span><br><span class="line">工厂 定义一个创建对象的接口，但是让子类去实例化具体类。工厂方法模式让类的实例化延迟到子类中。tp中对于config文件的不同处理，有三个驱动比如 ini,yaml, php, 当我们想读取ini文件的时候，factory 方法中传入的是ini,然后拼凑命名空间，交给 Ini 类处理，方便扩展</span><br><span class="line"></span><br><span class="line">注册树  用一个属性保存各个类的实例，需要的时候就从这个属性中取，容器用的就是这种思想</span><br><span class="line"></span><br><span class="line">门面  方便静态调用. 实际调用的是别的类（感觉主要是这些方法中不需要实例，所以可以静态调用）（如果是多进程，对于那些连接的操作，感觉通过门面不行，因为单个连接实例可能不能用了，得还连接池中别的实例）</span><br><span class="line"></span><br><span class="line">依赖注入 通过对类中需要以来的对象，直接以参数的形式传入（需要携带参数类型，也就是类名），让容器通过反射自己去实例化，解耦了各个类的依赖，下次以来的类修改的时候，不用我们修改生成依赖类的代码</span><br><span class="line"></span><br><span class="line">生产者消费者 异步任务或者花费时间多的任务放入队列中,让消费者消费</span><br><span class="line"></span><br><span class="line">订阅发布 主体对象状态发生改变,与之关联的观察者对象会收到通知，并进行相应操作</span><br><span class="line"></span><br><span class="line">装饰模式（laravel 的路由，核心 array_reduce）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">常用的魔术方法</span><br><span class="line">__construct  类初始化</span><br><span class="line">__destruct  对象销毁的时候</span><br><span class="line">__call  调用的方法不能访问 （redis 类封装的时候很好用）</span><br><span class="line">__callStatic  调用的静态方法不能访问</span><br><span class="line">__get  获取的属性不能访问</span><br><span class="line">__set  设置的属性不能访问</span><br><span class="line">__isset  isset empty 不能访问的属性</span><br><span class="line">__unset unset 不能访问的属性</span><br><span class="line">__sleep  序列化一个对象的时候</span><br><span class="line">__wakeup  反序列一个对象的时候</span><br><span class="line">__clone 对象（作为两个实体的存在)</span><br><span class="line">__invoke 调用类实例像调用方法那样自动触发，像closure类自带这个方法，php中所有的匿名函数默认都是closure的实例，所以我们执行保存匿名函数的变量自动执行了这个方法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php 错误信息控制</span><br><span class="line">error_reporting(E_ALL)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">trait Singleton &#123;&#125;</span><br><span class="line">多继承的实现</span><br><span class="line"></span><br><span class="line">class Db</span><br><span class="line">&#123;</span><br><span class="line">  use Singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">抽象类只能继承， extend ，接口可以实现多个，比如我想我这个类拥有foreach, 之类的功能， implement</span><br><span class="line"></span><br><span class="line">abstract 抽象类</span><br><span class="line">抽象类不能实例化</span><br><span class="line">抽象类中方法可以有方法体，没有方法体的只能定义abstract</span><br><span class="line"></span><br><span class="line">abstract 介于 class 和 interface 之间</span><br><span class="line"></span><br><span class="line">interface 接口</span><br><span class="line">interface 中不能用变量,但是可以有常量</span><br><span class="line">interface 中方法的访问权限只能是public, 不能是protected或者prviate</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">static ,延迟静态绑定，</span><br><span class="line">self, parent 调用的方法的时候都是以当前类为标准,</span><br><span class="line">static 根据实际调用对象，每当到了static 的 时候调用的上一个确定了调用类的对象方法 (parent self 都不能改变调用对象)（优先调用自己的，如果自己的不能调用，调用父类的）（注意延迟调用的一定要是静态的static）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function test()</span><br><span class="line">    &#123;</span><br><span class="line">        static::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A&#123;</span><br><span class="line">    protected static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::test(); // 调用不了， 在 a 中调用b的protected</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public static function foo()</span><br><span class="line">    &#123;</span><br><span class="line">        static::who();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public static function test()</span><br><span class="line">    &#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        parent::foo();</span><br><span class="line">        self::foo();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static function who()</span><br><span class="line">    &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B &#123;</span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();</span><br><span class="line"></span><br><span class="line">A C C</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">防止sql 注入</span><br><span class="line">sql 注入本质上就是害怕用户拼接sql, 在sql后面携带着用户传入的内容</span><br><span class="line"></span><br><span class="line">select name from user limit 10 offset . $offset;</span><br><span class="line"></span><br><span class="line">$offset = &apos; 0; select * from user&apos;;</span><br><span class="line"></span><br><span class="line">上述代码在pgsql 扩展中可以直接执行， 索然mysqli 中执行不了，</span><br><span class="line"></span><br><span class="line">handle:</span><br><span class="line">最好的方法就是利用预处理语句（那种 绑定??， 不能单纯的理解成嵌套变量进去，如果真的那样那还是防止不了sql注入）</span><br><span class="line"></span><br><span class="line">参数类型限定</span><br><span class="line">我们平时可以通过 转义 str_replace 之类的，但感觉这样很容易误伤，所以干脆还是用pdo的预处理语句吧</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">红包，我能想到比较简单的方法</span><br><span class="line">存在一定可能性死循环，就是后面数字的和已经不够一人一个了，已解决，每次计算剩余的最小值至少是每个1分，如果少于，则重新计算</span><br><span class="line">// mt_rand 只能产生随机整数，对于现实生活中的分，可以通过扩大100倍来解决</span><br><span class="line">// mt_getrandmx() 那个例子产生随机浮点数也是同样的道理</span><br><span class="line">// arr 是目前产生的数组</span><br><span class="line">// num 是剩余的值</span><br><span class="line">function productRand($arr, $num, $leave)</span><br><span class="line">&#123;</span><br><span class="line">    $tmp = mt_rand(0, $num);</span><br><span class="line">    $leveTotal = $num - $tmp; // 剩余的钱不能少于每个红包1分钱</span><br><span class="line">    if ($tmp == 0 || $tmp == $num || $leaveTotal &lt; $leave * 1) &#123;</span><br><span class="line">        return productRand($arr, $num);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $arr[] = $tmp;</span><br><span class="line">        $num -= $tmp;</span><br><span class="line">        return [$arr, $num];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// $total 代表总数量</span><br><span class="line">// $count 代表红包个数</span><br><span class="line">function hongbao($total, $count)</span><br><span class="line">&#123;</span><br><span class="line">    $num = $num * 100;</span><br><span class="line">    $arr = [];</span><br><span class="line">    $top = $num;</span><br><span class="line">    for ($i = 0; $i &lt; $cishu - 1; $i++) &#123;</span><br><span class="line">    $leave = $count - $i - 1; // 剩余红包个数</span><br><span class="line">        $res = productRand($arr, $top, $leave);</span><br><span class="line">        $arr = $res[0];</span><br><span class="line">        $top = $res[1]; </span><br><span class="line">    &#125;</span><br><span class="line">    $arr[] = $num - array_sum($arr);</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(hongbao(11, 4));</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同步，异步区别 阻塞非阻塞区别</span><br><span class="line">同步，异步主要是获取返回值内容的时候，同步如果一次性不能获取返回内容，需要不断的轮训获取返回内容，异步返回内容会主动通知（swoole task异步任务， php-fpm模式下同步代码）</span><br><span class="line">阻塞和非阻塞主要是进程方面，阻塞api所在进程会被系统直接挂起，直到完成（sleep， io比如redis mysqli pdo 等），非阻塞的时候所在进程不受影响，可以做别的事情（array, string 函数）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ab 测试</span><br><span class="line">-n  发送的请求总数</span><br><span class="line">-c  并发量</span><br><span class="line">ab -n 5000 -c 200 http://www.baidu.com/ (注意末尾的斜线)</span><br><span class="line">Requests per second  每秒钟完成的请求书</span><br><span class="line">Time per request  客户端等待时间</span><br><span class="line">Time per request 服务端等待时间</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yield  感觉就类似分页，有效减少内存的消耗（大数据量一次性读入内存吃不消），注意yield 的使用和数组还是有区别的.</span><br><span class="line">就相当于我们值读入部分数据到yield 中，我们还得forea yield 抛出的数据（iterator 实现了迭代器，所以可以循环），循环去插入 取出yield 中的数据</span><br><span class="line"></span><br><span class="line">function test() &#123;</span><br><span class="line">  for($i = 1; $i&lt;5; $i++) &#123;</span><br><span class="line">      yield $i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">$data = test();</span><br><span class="line">foreach ($data as $value) &#123;</span><br><span class="line">    var_dump($data-&gt;current(),$value);</span><br><span class="line">&#125; </span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">自带的接口</span><br><span class="line">iterator // 可以循环，下面的那些方法都是为了foreach能正确数据准备的</span><br><span class="line">class test implements Iterator</span><br><span class="line">&#123;</span><br><span class="line">    public $arr = [];</span><br><span class="line">    public $keyArr = [];</span><br><span class="line">    public $keyP = 0;</span><br><span class="line">    </span><br><span class="line">    public function __construct($arr)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;arr = $arr;</span><br><span class="line">        $this-&gt;keyArr = array_keys($arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function rewind()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement rewind() method.</span><br><span class="line">        reset($this-&gt;arr);</span><br><span class="line">        $this-&gt;keyP = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function current()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement current() method.</span><br><span class="line">        return pos($this-&gt;arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function next()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement next() method.</span><br><span class="line">        $this-&gt;keyP++;</span><br><span class="line">        return next($this-&gt;arr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function key()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement key() method.</span><br><span class="line">        return $this-&gt;keyArr[$this-&gt;keyP];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function valid()</span><br><span class="line">    &#123;</span><br><span class="line">        // TODO: Implement valid() method.</span><br><span class="line">        return isset($this-&gt;keyArr[$this-&gt;keyP]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php 进程间通信的方式</span><br><span class="line"></span><br><span class="line">第三方，比如redis</span><br><span class="line">消息队列， 也可以属于第三方</span><br><span class="line">共享内存， 不如swoole_table</span><br><span class="line">socket 文件</span><br><span class="line">管道 （应该类似 grep ）</span><br><span class="line">信号  字进程结束给父进程结束信号，请求回收</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">几个预定义接口 spl标准类库</span><br><span class="line">ArrayAccess , 让类可以类似数组方式访问</span><br><span class="line">Countab  , 让类可以被 count()</span><br><span class="line">iterator  让对象能循环，几个必须实现的方法（current, 当前key, key, 就是 key 的名称， next 往下走， rewind, 重置，valid 是否有效，本身php 的数组就包含上述的实现，$arr[$key], key,next, reset, isset）</span><br><span class="line">iteratorAggregate 感觉就是方便的创造一个迭代器比较方便（官网上直接调用spl 的一个标准库, ArrayIterator, 数组对象转成 Iterator 方便）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">php 多进程写入同一个文件</span><br><span class="line">file_put_contents() // 添加第三个参数ex_lock</span><br><span class="line"></span><br><span class="line">对文件加锁，并对锁设置超时时间（类似给redis 那种锁 sex 锁， setnx 不能同时设置锁的时间，不具有原子性，这里面的锁，其实就是一个key-value）</span><br><span class="line"></span><br><span class="line">$resource = fopen(&apos;./tmp.log&apos;);</span><br><span class="line">$try = 0;</span><br><span class="line">while(!flock($resource, LOCK_EX) &amp;&amp; $try != 100)</span><br><span class="line"> &#123;</span><br><span class="line">$try++;</span><br><span class="line">&#125; </span><br><span class="line">if ($try == 100) &#123;</span><br><span class="line">  return false; // 测试太多失败</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fwrite($res, &apos;ceshi&apos;);</span><br><span class="line">fclose($res); // 一般就能删除锁， 或者 flock($resource, UN_LOCK);</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">关于php这种锁，进程结束了就自动消失了，文档上说是脚本结束了，其实是一个意思（想一下我们用redis实现的锁，也是这样的，redis要是挂了，锁是不是没了）</span><br><span class="line">（当我用用了排它锁，我们再打开文件就是空的）</span><br><span class="line">(感觉写文件也不是直接往磁盘文件中写，而是写入一个缓存中，之后合并，因为当我用排它锁锁定一个文件的时候，fwrite 能立刻写入成功，虽然此时文件还没有修改)</span><br></pre></td></tr></table></figure><h1 id="Laravel"><a href="#Laravel" class="headerlink" title="Laravel"></a>Laravel</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">laravel 调优</span><br><span class="line">1. 开启Opcache</span><br><span class="line">   2.关闭debug</span><br><span class="line">   3.缓存配置 php artisan config:cache</span><br><span class="line">   4.缓存路由 php artisan router:cache</span><br><span class="line">   5.类映射加载优化 php artisan optimize</span><br><span class="line">   6.根据需要只加载必要的中间件</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel 生命周期</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loc ,facade, contract, 服务提供者是什么</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">laravel 和 其他框架的区别</span><br></pre></td></tr></table></figure><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql 性能优化</span><br><span class="line">1. 建立索引，优化索引</span><br><span class="line">2. 读写分离 （怎么保证一致性）</span><br><span class="line">3. 保证单表数据量，分库分表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql(1) 和 mysql(11)的区别</span><br><span class="line">都是占用 4个字节，1 和 11 代表显示长度，除非添加 zerofill 要不然没区别</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">varchar 和 char 区别</span><br><span class="line">varchar 会根据内容长度确定大小，最大长度是定义的长度 * 3,varchar 中会存储字符的长度</span><br><span class="line">char 是固定大小，</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hash索引和b+索引的区别</span><br><span class="line">hash 索引只能用来进行等值匹配, 也不能排序，b+索引能用来排序，可以范围取值</span><br><span class="line"></span><br><span class="line">什么是聚簇索引</span><br><span class="line">索引本质上是树，聚簇索引的叶子结点是用户记录</span><br><span class="line">普通索引</span><br><span class="line">普通索引的叶子结点是主键(id), 索引字段， 主键主要是为了回表，通过id 去 聚簇索引中查找用户记录</span><br><span class="line">覆盖索引</span><br><span class="line">因为回表属于不连续的io， 比较耗时，如果不用回表，索引字段包含select 的内容，那就会很快，这种索引就叫覆盖索引</span><br><span class="line">联合索引</span><br><span class="line">给多个字段建立索引，联合索引是最左原则，得在前面的字段是等值的情况下，后面的字段才能符合要求（比如前面的字段是范围索引，那么取出来的数据是无序的，在无序的情况下，联合索引第二个字段是起不到排序的作用的）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innodb 和 myisam 存储引擎的区别</span><br><span class="line">innodb 是行锁，myisam表锁</span><br><span class="line">innodb 支持事务，myisam不支持</span><br><span class="line">innodb 数据和索引存储文件一样，myisam是分开的</span><br><span class="line">innodb 中的聚簇索引的叶子结点就是数据记录或者主键，myisam中叶子结点只是数据的存储位置，所以肯定需要回表</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么样的字段适合建立索引 （索引建立的标准）</span><br><span class="line">区分度大的字段，查找起来更容易确定具体的记录，减少回表的内容</span><br><span class="line">对于字符串，需要先确定首部字符串，才能匹配类似字符串</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">常见的索引</span><br><span class="line">主键， 唯一索引，复合索引，普通索引</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql 中的事务有什么作用，请列举事务的隔离级别</span><br><span class="line">我好像只用到了 事务的原子性（一起执行或者不执行）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql_fetch_row, mysql_fetch_assoc, mysql_fetch_array 区别</span><br><span class="line">row 好像是数组，assoc 关联数组， array 是前面二者的结合体</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">limit, left join ,order by ,group by, where , select , from ,having </span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">left join</span><br><span class="line">where </span><br><span class="line">group by </span><br><span class="line">having</span><br><span class="line">order by</span><br><span class="line">limit</span><br><span class="line"></span><br><span class="line">执行顺序： 先连接，再筛选，再分组，再having, 再select, 最后order by</span><br><span class="line">FROM</span><br><span class="line">ON</span><br><span class="line">JOIN</span><br><span class="line">WHERE</span><br><span class="line">GROUP BY</span><br><span class="line">WITH CUBE 或 WITH ROLLUP</span><br><span class="line">HAVING</span><br><span class="line">SELECT</span><br><span class="line">DISTINCT</span><br><span class="line">ORDER BY</span><br><span class="line">TOP</span><br></pre></td></tr></table></figure><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190718195208.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">404   最长匹配原则，但是只能匹配到 a</span><br><span class="line">500   ~* 不区分大小写， 权重比 / 高</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nginx 负载均衡（属于反向代理）upstream prox_pass关键字</span><br><span class="line">轮询（默认）</span><br><span class="line">权重</span><br><span class="line">ip_hash</span><br><span class="line">url_hash</span><br><span class="line"></span><br><span class="line">upstream  test&#123;</span><br><span class="line">   server 127.0.0.1:8081 weight=1;</span><br><span class="line">   server  127.0.0.1:8082 weight=2;</span><br><span class="line">&#125;</span><br><span class="line">prox_pass http://test # 还可以配置back 备胎机器</span><br></pre></td></tr></table></figure><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 和 memecached的区别</span><br><span class="line">1. 更丰富的数据结构，除了缓存，更多的使用场景</span><br><span class="line">2. 单进程，只能利用单核</span><br><span class="line">3. redis 可以持久化</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis 怎么持久化</span><br><span class="line">AOF 记录每条命令，后面重新执行一遍</span><br><span class="line">RDB 类似快照，把缓存中数据都存储下来（利用back，防止始终阻塞）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 的常用数据类型</span><br><span class="line">string  key value 形式</span><br><span class="line">hash  数组，关联数组，索引数组</span><br><span class="line">list  队列，</span><br><span class="line">set  集合</span><br><span class="line">sort set  有序集合</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 的使用场景</span><br><span class="line">点赞，利用 incr</span><br><span class="line">排行榜，有序集合，分数sorce 作为排序标准</span><br><span class="line">api 限流（sort set 滑动窗口）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">linux 常用命令</span><br><span class="line">cd  进入</span><br><span class="line">ls -la  展示</span><br><span class="line">tar 解压缩</span><br><span class="line">mkdir -p 新建文件夹</span><br><span class="line">touch 新建文件</span><br><span class="line">rm -rf  删除文件夹</span><br><span class="line">vim 编辑文件</span><br><span class="line">tail -f  动态查看文件变化</span><br><span class="line">netstat -antp 查看tcp 连接</span><br><span class="line">ps -ef  查看进程</span><br><span class="line">free 查看系统资源</span><br><span class="line">top  查看系统进程消耗资源</span><br><span class="line">df -h 查看系统盘</span><br><span class="line">alias -p 查看取别名</span><br><span class="line">find / -name 查找</span><br><span class="line">locate  查找</span><br><span class="line">chmod  修改权限</span><br><span class="line">chown  修改用户组用户</span><br><span class="line">wc -l 统计行数</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rebase 变基，比如把当前分支的分叉点移动到主分支最新节点，为的就是log日志中不产生分支</span><br><span class="line">git push origin master:master  推送本地master分支到远程master分支</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk 的使用</span><br><span class="line">awk -F &apos; &apos; &#123;&apos;print $1&apos;&#125; ./access.log |sort|uniq|wc -l   uniq只能合并相邻的不同的，所以要先排序</span><br></pre></td></tr></table></figure><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">4种排序</span><br><span class="line">从小到大</span><br><span class="line">1. 冒泡 (核心：每次一个数据到达最终位置，第一次确定最大的数字)</span><br><span class="line">   $arr = [20, 19, 88, 76, 43, 1];</span><br><span class="line"></span><br><span class="line">function maopao($arr) &#123;</span><br><span class="line">    $count = count($arr); </span><br><span class="line">    for($i=0; $i &lt; $count -1; $i++) &#123; // 最后一个数不用变动，位置自动确定</span><br><span class="line">        for ($j= 0; $j &lt; $count - 1 - $i; $j++) &#123; // 每次上浮的数字都要和没有确定的比较</span><br><span class="line">            if ($arr[$j] &gt; $arr[$j+1]) &#123;</span><br><span class="line">                list($arr[$j+1], $arr[$j]) = [$arr[$j], $arr[$j+1]];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.选择排序 (和冒泡的区别，这个每次选出一个最小的数，和冒泡一样，但是不移动数据，只是最终和确定的数组比较，如果不一致，才会移动)</span><br><span class="line">function xuanze1($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    for($i= 0; $i &lt; $count - 1; $i++) &#123;</span><br><span class="line">        $p = $i;</span><br><span class="line">        for ($j = $i; $j &lt; $count; $j++) &#123;</span><br><span class="line">            if ($arr[$j] &lt; $arr[$p]) &#123;</span><br><span class="line">                $p = $j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ($i != $p) &#123;</span><br><span class="line">            list($arr[$i], $arr[$p]) = [$arr[$p], $arr[$i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">3.插入排序 (核心，前面排好序的字段不断扩展，用来容纳新插入的数据)</span><br><span class="line">function charu($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $count = count($arr);</span><br><span class="line">    for ($i=1; $i &lt; $count; $i++) &#123;</span><br><span class="line">       </span><br><span class="line">        if ($arr[$i-1] &gt; $arr[$i]) &#123;</span><br><span class="line">            $tmp = $arr[$i];</span><br><span class="line">            for($j=$i-1; $j&gt;=0 &amp;&amp; $arr[$j] &gt; $tmp;$j--) &#123;</span><br><span class="line">                $arr[$j+1] = $arr[$j];</span><br><span class="line">            &#125;</span><br><span class="line">            $arr[$j+1] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">       // var_dump($arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">1. 快排：以一个数为基准，分原数组成两列，递归调用</span><br><span class="line">   function quick($arr)</span><br><span class="line">   &#123;</span><br><span class="line">    if (!$arr) &#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $tmp = $arr[0];</span><br><span class="line">    $left = $right = [];</span><br><span class="line">    $count = count($arr);</span><br><span class="line"></span><br><span class="line">    if ($count &gt; 1) &#123;</span><br><span class="line">        for ($i = 1; $i &lt; $count; $i++) &#123;</span><br><span class="line">            if ($arr[$i] &lt;= $tmp) &#123;</span><br><span class="line">                $left[] = $arr[$i];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $right[] = $arr[$i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array_merge(quick($left), [$tmp], quick($right));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return $arr;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">查找 （注意查找的算法都是在排好序的基础上）</span><br><span class="line">1.二分查找</span><br><span class="line">function search1($arr, $num, $min, $max) &#123;</span><br><span class="line"></span><br><span class="line">    if ($min == $max &amp;&amp; $num != $arr[$min]) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    $tmp = ceil(($min + $max) / 2);</span><br><span class="line">    if ($num == $arr[$tmp]) &#123;</span><br><span class="line">        return $tmp;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if ($num &lt; $arr[$tmp]) &#123;</span><br><span class="line">            $max = $tmp-1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $min = $tmp + 1;</span><br><span class="line">        &#125;</span><br><span class="line">       return search1($arr, $num, $min, $max);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1000000个数字的整数， 大小是0 到 999999， 找出其中重复的数字.</span><br><span class="line"></span><br><span class="line">1. 最简单的。先排序，排序玩比较相邻数字是否相同，相同就添加进结果集。（二分 nlogn）</span><br><span class="line">2. 利用hash, 时间复杂度n, 空间复杂度n. 我们知道php 的数组就是一个hash, 我们可以遍历这个大的原始数据，然后把其中的数字都往一个预先的hash 里面塞，如果之前有值就代表重复.</span><br><span class="line">3. 因为大小是0 到 99999， 所以我们可以foreach ,然后把对应数据换算到我们要的位置上来，如果最后没有调回来，代表这个数字重复</span><br><span class="line"></span><br><span class="line">$arr = [2,3,1,0,2,5,3];</span><br><span class="line">// 转变过程</span><br><span class="line">// [1,3,2,0,2,5,3]</span><br><span class="line">// [3,1,2,0,2,5,3]</span><br><span class="line">// [0,1,2,3,2,5,3]</span><br><span class="line">// 2, 3 入结果集</span><br><span class="line">// foreach 的时候，如果 &amp;value,可以改变这次遍历的内容，单单$arr[$key] 只能改变下次遍历时候的$arr</span><br><span class="line"> function chongfu($arr)</span><br><span class="line">&#123;</span><br><span class="line">    $chongfu = [];</span><br><span class="line">    foreach ($arr as $key =&gt; &amp;$value) &#123;</span><br><span class="line">        if ($value == $key) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            jiaohuan($arr, $chongfu, $key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return $chongfu;</span><br><span class="line">&#125;</span><br><span class="line">function jiaohuan(&amp;$arr, &amp;$chongfu, $key)</span><br><span class="line">&#123;</span><br><span class="line">    if ($key != $arr[$key]) &#123;</span><br><span class="line">       // var_dump($key, $arr[$key]);</span><br><span class="line">        $value = $arr[$key];</span><br><span class="line">        if ($value == $arr[$value]) &#123;</span><br><span class="line">            $chongfu[] = $value;//var_dump($chongfu, $key, $value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            list($arr[$key], $arr[$value]) = [$arr[$value], $arr[$key]];</span><br><span class="line">            //var_dump($arr, $key);</span><br><span class="line">            jiaohuan($arr, $chongfu, $key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(chongfu($arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">订单系统</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100件商品高并发，先到先得</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">30w 的ip地址,类似如下</span><br><span class="line">10.23.25.0  10.23.25.255    湖南省 长沙市</span><br><span class="line">请设计出一个实现方式,可以给某个IP找到对应的省和市。要求效率尽可能的高。</span><br><span class="line"></span><br><span class="line">利用redis的zset, 把ip地址变成数字作为score 存储，然后把各个省市的最大ip和最小ip村春，利用 zset 的范围，取到第一个最大的城市就是该城市</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.请设计一个投票系统,满足如下要求</span><br><span class="line">a.一个用户10分钟内对一个投票只能成功完成一次。</span><br><span class="line">b.一个用户每个自然日最多只能成功完成50个不同的投票。</span><br><span class="line"></span><br><span class="line">每次投票成功， 就往set 里面塞入一个投票类型，每次投片前都检测下，有没有超过50</span><br><span class="line">利用redis, userid_投的票  =&gt; 时间，如果 时间 + 10 分钟 &gt;= 现在时间就给投票</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">.用php写一个函数，获取一个文本文件最后$n行内容，要求尽可能效率更高，并可以跨平台使用</span><br><span class="line"></span><br><span class="line">利用exec 执行 tail -f , 主要就是tail -f 没有停止，会持续获取，但也没关系，手动停了就好了，注意的是这块没停止的话，进程一直阻塞着，不能去往下执行，打印 exec 执行后的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$filename = &apos;/opt/httpd/logs/access_log&apos;;</span><br><span class="line">$xie = &apos;./xie.log&apos;;</span><br><span class="line"></span><br><span class="line">function kan($line, $file, $xie)</span><br><span class="line">&#123;</span><br><span class="line">    $line = $line -1;</span><br><span class="line">    $x = fopen($xie, &apos;a+&apos;);</span><br><span class="line">    $res = fopen($file, &apos;a+&apos;);</span><br><span class="line">    $postion = -2;</span><br><span class="line">   </span><br><span class="line">    $str = fgets($res);</span><br><span class="line">   </span><br><span class="line">    while ($line) &#123;</span><br><span class="line">        fseek($res, $postion, SEEK_END);</span><br><span class="line">        $tmp = fgetc($res);</span><br><span class="line">        $postion -= 1;</span><br><span class="line">       </span><br><span class="line">        if ($tmp == PHP_EOL) &#123;</span><br><span class="line">            </span><br><span class="line">            $str .= fgets($res);</span><br><span class="line">            $line -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var_dump($str);exit;</span><br><span class="line">    fwrite($x, $str);</span><br><span class="line">&#125;</span><br><span class="line">kan( 5, $filename, $xie);</span><br><span class="line"></span><br><span class="line">exit;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">有两个文本文件 A.txt B.txt</span><br><span class="line">A.txt 3000万行，userid唯一，userid和username以空格分隔，如下所示：</span><br><span class="line">userid  username</span><br><span class="line">1       yi</span><br><span class="line">2       er</span><br><span class="line">3       san</span><br><span class="line">...     ...</span><br><span class="line">B.txt 3000万行，userid唯一，userid和realname以空格分隔，如下所示：</span><br><span class="line">userid  realname</span><br><span class="line">1       一</span><br><span class="line">2       二</span><br><span class="line">3       三</span><br><span class="line"></span><br><span class="line">感觉可以把 a读入一个数组中，然后遍历 b ，往b中写入相应数据 。 a可以看做一个hash，所以查找一个数据就是1， 然后遍历 b文件，n， 所以总的复杂度是 n.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集一些总是考的面试题&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="interview" scheme="http://yoursite.com/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>laravel 核心技术读书笔记</title>
    <link href="http://yoursite.com/2019/01/03/laravel-%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/03/laravel-核心技术读书笔记/</id>
    <published>2019-01-03T15:31:06.000Z</published>
    <updated>2019-07-31T08:41:07.184Z</updated>
    
    <content type="html"><![CDATA[<p>关于laravel 框架核心技术一书的阅读感受<br><a id="more"></a></p><p>###1.关于命名空间<br>我理解的命名空间是文件中的namespace 可以定义成任意的值，但是composer 的自动加载因为符合psr4 ，所以要求命名空间和文件路径一致，文件名和类名保持一样。当我们不适用composer的自动加载的时候，就可以随便指定文件中的namespace是多少了，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace test;</span><br><span class="line">class test</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以保存在任意位置任意名称的文件中，但是不能写在composer autoload 驱动的框架中，除非改成别的方式加载，比如map<br>还记得我们在控制器中引用别的类吗，通过use,然后就能直接使用new classname()了，但是我们在脚本中使用的时候，我们一定要用到include 先去包含这个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace test;</span><br><span class="line"></span><br><span class="line">include &apos;test2.php&apos;;</span><br><span class="line"></span><br><span class="line">use test2\test5;</span><br><span class="line"></span><br><span class="line">class test </span><br><span class="line">&#123;</span><br><span class="line">  public function test2()</span><br><span class="line">  &#123;</span><br><span class="line">      test1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$a = new test();</span><br><span class="line">$a-&gt;test2();</span><br><span class="line"></span><br><span class="line">$b = new test5();</span><br><span class="line">$b-&gt;test3();</span><br></pre></td></tr></table></figure></p><p>可能你在想，既然我们都include 了，那为啥还要使用use，use在这个地方的作用是什么，当你使用 use test2\test5的时候，你在使用 new test5(), 它实际new 的是 test2\test5(), 如果没有 new test5(), 当前命名空间下的test5类，所以你明白了use 并不是导入包含文件，只是引入一个类的前缀，想不适用前缀，那就 new \test5() ，绝对路径吧，如果想使用当前命名空间下的 test5(),那就把外来引入的换个名称吧，比如 as。现在想想，其实我们平时同一个文件夹下面命名空间一样，本质上是写在一个文件中的，只是我们为了方便好看，才把分到多个文件中，但是我们互相引用的时候，同一个命名空间下面，不用use，因为默认就在当前文件夹下面找。</p><p>当我接触use 的时候，书中还有一句话，use只能引用类，并不能引用常量，函数··！！难道还可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace test;</span><br><span class="line"></span><br><span class="line">//include &apos;test2.php&apos;;</span><br><span class="line"></span><br><span class="line">use test2\test5;</span><br><span class="line"></span><br><span class="line">class test </span><br><span class="line">&#123;</span><br><span class="line">  public function test2()</span><br><span class="line">  &#123;</span><br><span class="line">      test1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* class test5</span><br><span class="line">&#123;</span><br><span class="line">    public function test3()</span><br><span class="line">    &#123;</span><br><span class="line">        echo 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; */</span><br><span class="line"></span><br><span class="line">function test1()</span><br><span class="line">&#123;</span><br><span class="line">    echo 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function autoload($class) &#123;</span><br><span class="line">    echo $class;</span><br><span class="line">    include &apos;./test2.php&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(&apos;test\autoload&apos;);</span><br><span class="line"></span><br><span class="line">$a = new test();</span><br><span class="line">$a-&gt;test2();</span><br><span class="line"></span><br><span class="line">$b = new test5();</span><br><span class="line">$b-&gt;test3();</span><br></pre></td></tr></table></figure></p><p>对，你没看错，class 的外面还能定义function, 然后我们当前命名空间中可以直接使用，如果是不同的命名空间，需要加前缀</p><p>###2.spl_autoload<em>register 和 __autoload<br>\</em>_autoload已经被废弃了，在7.2 中。__autoload 如果在一个库中出现多次，会出错的，虽然是魔术方法，但可以不在类中定义，spl_autolad_register ，可以绑定多个自动加载，还可以删除，composer的自动加载机制中就用到了删除。他是类似一种方法的执行，可以写在任意地方，可以直接是方法名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register(&apos;test\autoload&apos;);</span><br></pre></td></tr></table></figure></p><p>可以是面向对象的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register([$this, &apos;autoload&apos;], true, true);</span><br></pre></td></tr></table></figure></p><p>第二个参数true 代表异常可以捕获，__autoload 就不行，第三个参数说实话不知道咋用，队列头部和队列尾部，就是先加载哪个自动加载函数的意思呗？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于laravel 框架核心技术一书的阅读感受&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>LBS 和 redis mongodb</title>
    <link href="http://yoursite.com/2018/12/24/LBS-%E5%92%8C-redis-mongodb/"/>
    <id>http://yoursite.com/2018/12/24/LBS-和-redis-mongodb/</id>
    <published>2018-12-24T14:00:01.000Z</published>
    <updated>2019-07-31T08:41:08.013Z</updated>
    
    <content type="html"><![CDATA[<p>LBS,刚听起来挺高大上的，其实简单理解就是附近的人。其实这个需求蛮常见的，比如大众点评中搜索摸某一个店铺按照离我当前位置距离进行排序，又或者某些社交软件中的附近的人，实现的方式有很多，php + mysql ， php + redis ， php+ mongodb， 其中mysql 的话，就是把所有的点的坐标保存下来，然后通过编写sql语句，直接通过sql去查询每个点离我们的距离，然后排序返回，但数据量大的时候，可能不太好，所以就有了后面的nosql ， redis 和 mongodb 的相关应用，其中 mongodb 在这方面应该是我听得最多的，当初想试这个功能也是因为想教一下前端朋友mongodb的相关功能，方便他面试，但后来发现其实还是redis 实现比较方便，因为php的mongodb扩展 mongo(php5） 和 mongodb(php7) 接口一点都不一样，而且中文文档比较少啦。其实通过es 也是可以实现的，方法很多.<br><a href="https://zhuanlan.zhihu.com/p/31380780" target="_blank" rel="noopener">详细见这篇文章</a><br><a id="more"></a></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>(<a href="https://yq.aliyun.com/articles/62844" target="_blank" rel="noopener">参考</a>)redis 自从3.2就有了对于经纬度的处理，但注意并不是新增了一个一个数据结构，这个经纬度是在 有序集合zset 的基础上发展而来的，所以我们对于zset 的操作都能对经纬度使用，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrange key 0 10 #  把key 中所有的member 都取出来 zrange cy1 0 10</span><br><span class="line">zcard key   # key 中有多少个member, zcard cy1</span><br><span class="line">zsore  key member #  key 中具体的member 的score，对于经纬度这个取出来看不懂</span><br></pre></td></tr></table></figure></p><p>穿插一句：刚开始使用redis 的时候，虽然他的api很简单，便于理解，但是和sql编程还是不同的，为什么我们一个对象有了member 这个名称还需要key 呢，你想啊，我么需要从一个集合中获取离这个点比较近的点，这个集合的名称就是 key,这个是事先我们往集合中塞就定好的，后面我们可能变化的是member 的名称，需要我们从外边传入。<br>关于php使用redis, 大致分成两种方法，有通过编译c扩展，还有就是通过composer 安装predis,这是两种方法，我们不要混淆了，平时我们大部分用的是c扩展额，然后自己封装其中基本的方法和连接方式，需要注意的是关于重连啊，或者单例模式是的使用啊之类的，还有就是其中__call方法的使用，如果有那些我们没有封装的方法，但是自己还使用了，默认就会调用这个方法。一般很多时候调用方法正确的放回是0和1，所以我们不能根据0和1来判定方法是否执行成功，很多时候他代表着影响的行数，比如新增返回1，修改返回0。还有c扩展方式安装的，比如 geoRadiusByMember, 不知道这个方法的参数都是啥，也不知道在哪能找到，只能凭着redis的使用去猜测，比如最后一个option 应该传数组，但其实如果传错的话，也有提示，感谢扩展报错信息的详细<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3280215645624671911.png" alt="image.png"></p><p>geoadd: 增加地理位置的坐标。<br>geodist: 获取两个地理位置的距离。<br>geohash: 获取地理位置的GeoHash值。<br>geopos: 获取地理位置的坐标。<br>georadius: 根据给定经纬度坐标获取指定范围内的地理位置集合。<br>georadiusbymember: 根据给定地理位置获取指定范围内的地理位置集合。</p><p>georadius 和 georadiusbymember 的参数</p><p>WITHDIST: 同时返回地理位置与给定位置的距离<br>WITHCOORD: 同时返回地理位置的经纬度坐标<br>WITHHASH: 同时返回Redis内部的GeoHash值（非标准算法值），一般用于debug<br>ASC|DESC：结果按距离升降序排序<br>STORE|STOREDIST: 结果存到新的有序集合中，前者以GeoHash值做score，后者以与指定位置的距离作score，该选项与WITH[DIST|COORD|HASH]选项冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public function addLocation()</span><br><span class="line">    &#123;</span><br><span class="line">        $redis = new Redis();</span><br><span class="line"></span><br><span class="line">        //var_dump($redis-&gt;geodist(&apos;cy1&apos;, &apos;a&apos;, &apos;b&apos;));exit;</span><br><span class="line"></span><br><span class="line">        $lnt = Request::instance()-&gt;post(&apos;lnt&apos;);</span><br><span class="line">        $lat = Request::instance()-&gt;post(&apos;lat&apos;);</span><br><span class="line">        $name = Request::instance()-&gt;post(&apos;name&apos;);</span><br><span class="line">      // 1 成功 新增</span><br><span class="line">        // 0 也可能是成功  修改</span><br><span class="line"></span><br><span class="line">        $res = $redis-&gt;geoadd(&apos;cy1&apos;, $lnt ,$lat, $name); // 相同的名称就直接替换了</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function dist()</span><br><span class="line">    &#123;</span><br><span class="line">        $member1 = Request::instance()-&gt;post(&apos;member1&apos;);</span><br><span class="line">        $member2 = Request::instance()-&gt;post(&apos;member2&apos;);</span><br><span class="line"></span><br><span class="line">        $redis = new Redis();</span><br><span class="line">        var_dump($redis-&gt;geodist(&apos;cy1&apos;, $member1, $member2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function fujin()</span><br><span class="line">    &#123;</span><br><span class="line">        $radius = Request::instance()-&gt;post(&apos;radius&apos;); // 多少半径</span><br><span class="line">        $member = Request::instance()-&gt;post(&apos;member&apos;); // 点的名称</span><br><span class="line">        $unit = Request::instance()-&gt;post(&apos;unit&apos;); // 单位</span><br><span class="line"></span><br><span class="line">        $option = [&apos;withdist&apos;, &apos;withcoord&apos;];</span><br><span class="line"></span><br><span class="line">        $redis = new Redis();</span><br><span class="line">        var_dump($redis-&gt;georadiusbymember(&apos;cy1&apos;, $member, $radius, $unit, $option</span><br><span class="line"></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>验证方法，通过求得两个点的距离之后按照多少米之内半径调整圆的大小，来观察另一点是否在圆圈内来验证.</p><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><p>关于mongodb的安装就看菜鸟教程吧，也是解压完就能用，类似redis,然后服务端启动是 mongod, 客户端shell是 mongo(然后据说是js shell，不知道需不需要node的支持，反正我的服务器上node 是必须的，因为vue 啊 或者 hexo 啊 都需要node), 启动的时候要设置 dbpath 和 log path,直接写到配置文件中就可以 mongod启动了。</p><p>小插曲：因为这个mongo启动的时候输了一堆的信息，然后又看不懂，所以就像通过检查端口号来看是否启动成功，这又到了用ps 和 netstat 的时候了。先通过ps -ef|grep 27017 没有，是不是这个命令本来就不输出端口号呢？ps -ef |grep nginx,果然没有端口号，于是netstat -antp|grep 27017,看到了，害怕这个应用层服务不是基于tcp (也许是多虑吧)，我把t 去掉了，查到了。完事之后自己思考了下，ps 主要是用来检查进程的，netstat 是用来检查网络连接的，拿nginx 来举例，他可能有一个manage 进程，然后有个master 子进程，然后每个master还有worker进程，然后他监听了 80 ，443 等端口，所以ps 查出来的只能是进程相关，netstat 查出来的才是各种提供的服务和端口号。</p><p>mongodb 和 redis 同属于nosql，拿现在比较流行的话说，他也是对标mysql的产品，很多教程拿他和mysql做对比，确实也更容易理解<br><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9864415645624675608.png" alt="image.png"></p><p>我们刚开始进入shell :<br>show dbs   显示有哪些数据库，默认 local 和 admin<br>可是默认我们在test 下面，为什么test 没有显示，因为test 中没有内容呀，但凡我们插入数据，就可以有了</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>use test 切换数据库，如果没有就新建</p><p>db 显示当前数据库</p><p>db.dropdatabase  删除当前数据库</p><h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>db.runoob.drop 删除当前表/collection</p><p>show tables   显示当前数据库中有哪些表 </p><p>show collections  同上</p><p>db.createCollection(‘test’)   创建表</p><p>db.createCollection(“mycol”, { capped : true, autoIndexId : true, size :<br>   6142800, max : 10000 } ) 创建表</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>db.runoob.insert({“name”:”菜鸟教程”})  插入数据 ，这个runoob 是表的名字，在mongodb 中是文档的意思，然后mongo 中table 中 field 不需要统一</p><p>db.col.insert({title: ‘MongoDB 教程’,<br>    description: ‘MongoDB 是一个 Nosql 数据库’,<br>    by: ‘菜鸟教程’,<br>    url: ‘<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>‘,<br>    tags: [‘mongodb’, ‘database’, ‘NoSQL’],<br>    likes: 100<br>})   // 往col 表里面插入数据</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>db.col.find({title:’cy’, sex:’boy’})   //查找col 表里面数据,and 条件<br>db.col.find().pretty() 更好的显示出来</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/8883215645624677668.png" alt="image.png"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>db.col.update({‘title’:’MongoDB 教程’},{$set:{‘title’:’MongoDB’}})</p><blockquote><p>db.col.save({<br>    “_id” : ObjectId(“56064f89ade2f21f36b03136”),<br>    “title” : “MongoDB”,<br>    “description” : “MongoDB 是一个 Nosql 数据库”,<br>    “by” : “Runoob”,<br>    “url” : “<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“,<br>    “tags” : [<br>            “mongodb”,<br>            “NoSQL”<br>    ],<br>    “likes” : 110<br>})</p></blockquote><p>save 的话，保存id 就是更新，没有id 的话就是新增</p><p>默认的话只能更新一条，如下可以更新多条，因为第二个布尔值代表多条的意思</p><p>db.col.update( { “count” : { $gt : 3 } } , { $set : { “test2” : “OK”} },false,true );</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>db.col.remove({‘title’:’MongoDB 教程’})<br>db.col.remove({‘title’:’MongoDB 教程’}， 1)  // 只想删除一个，just one 参数设置为1</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>db.col.find({likes : {$lt :200, $gt : 100}})</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>db.col.find({“title” : {$type : 2}})</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>db.COLLECTION_NAME.find().limit(NUMBER).skip(NUMBER)</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>db.COLLECTION_NAME.find().sort({KEY:1})</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>db.col.createIndex({“title”:1})<br>db.values.createIndex({open: 1, close: 1}, {background: true})，第二个是参数，前面的1是升序，-1是降序</p><p>未完待续····（坑爹的php 的 mongodb扩展，感觉不知道咋用呀）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LBS,刚听起来挺高大上的，其实简单理解就是附近的人。其实这个需求蛮常见的，比如大众点评中搜索摸某一个店铺按照离我当前位置距离进行排序，又或者某些社交软件中的附近的人，实现的方式有很多，php + mysql ， php + redis ， php+ mongodb， 其中mysql 的话，就是把所有的点的坐标保存下来，然后通过编写sql语句，直接通过sql去查询每个点离我们的距离，然后排序返回，但数据量大的时候，可能不太好，所以就有了后面的nosql ， redis 和 mongodb 的相关应用，其中 mongodb 在这方面应该是我听得最多的，当初想试这个功能也是因为想教一下前端朋友mongodb的相关功能，方便他面试，但后来发现其实还是redis 实现比较方便，因为php的mongodb扩展 mongo(php5） 和 mongodb(php7) 接口一点都不一样，而且中文文档比较少啦。其实通过es 也是可以实现的，方法很多.&lt;br&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/31380780&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详细见这篇文章&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="redis" scheme="http://yoursite.com/tags/redis/"/>
    
      <category term="mongodb" scheme="http://yoursite.com/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>常用的接口(-)</title>
    <link href="http://yoursite.com/2018/12/07/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/12/07/常用的接口/</id>
    <published>2018-12-06T16:34:57.000Z</published>
    <updated>2019-07-31T08:41:18.041Z</updated>
    
    <content type="html"><![CDATA[<p>关于登陆，现在的网站有第三方登陆（qq,微信，微博）， 手机号登陆，用户名密码登陆，sso登陆，找回密码，注销 感觉其实都差不多<br><a id="more"></a></p><p><strong>第三方登陆</strong><br>其实国内的大多数第三方登陆都是基于oauth 2.0的变种，同理还有微信上消息more按钮点击能跳转到公司网站同样实现登陆都是基于这个，那什么是oauth2.0呢，阮老师这篇文章讲解的很清楚<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">oauth2.0</a>，而我们用的更多的又是其中的授权码模式，大致逻辑如下</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/9459615645624774616." alt=""></p><p>其中比较重要的两点就是用户授权code和access_token, code作用代表用户同意登陆了，access_token 代表这个用户资源（有时候像之前的小程序，是拿着用户同意之后返回的code 去换回openid, 这个openid 类似这个access_token, 他在每个应用中是唯一的，代表了一个用户，如果我们想把不同app上同一个微信用户绑在一起，需要我们去微信联合平台绑定需要处理的app，然后下次请求的时候会返回一个unit id ，这个对于同一个微信用户在不同的app内部是唯一的）</p><p>for example 微信消息跳转itbasic网站<br>1.引导用户点击授权链接，微信给的授权链接上会有参数绑定回调地址和state参数，当用户点击的时候，微信会重定向（注意不是回调）填写的会掉地址，并携带参数state,还有code ,也就是用户授权码，下面是我们的重定向地址代码<br>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public function dologin($req)</span><br><span class="line">    &#123;</span><br><span class="line">        $code = $req-&gt;param(&apos;code&apos;);  # 用户授权码</span><br><span class="line">        $state = $req-&gt;param(&apos;state&apos;);  # 自己定义的参数，比如这次登陆来自微信，或者登陆之后需要跳转的地址</span><br><span class="line">        $accesstoken = $this-&gt;getAccessToken(); # 微信这块的access_token不需要用户的授权即可获取，但后面获取用户信息还是需要授权码，所以原理和上面是一样的</span><br><span class="line">         </span><br><span class="line">        $url = &apos;https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=&apos;.$accesstoken.&apos;&amp;code=&apos;.$code;  </span><br><span class="line"></span><br><span class="line">        $res =$this-&gt;http($url); #获取用户信息</span><br><span class="line"></span><br><span class="line">        if (!array_key_exists(&apos;UserId&apos;, $res[&apos;result&apos;])) &#123;</span><br><span class="line">             // 记录错误信息（微信）到日志,获取用户信息出错</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">           // 根据实际业务处理，我这块是登陆</span><br><span class="line">          // 你可以根据返回的用户名称，判断是新用户，还是老用户，新用户的话会往数据库插入数据</span><br><span class="line">            $user_model = Box::getObject(&apos;user&apos;, model);</span><br><span class="line">            $res = $user_model-&gt;search($res[&apos;name&apos;]);</span><br><span class="line"></span><br><span class="line">            if (!$res) &#123;</span><br><span class="line">                // 记录错误信息（itbaisc） 到日志，查找用户失败</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            $userinfo = $res;</span><br><span class="line">            $userinfo = [&apos;userid&apos; =&gt; $userinfo[&apos;id&apos;], &apos;username&apos; =&gt; $userinfo[&apos;username&apos;], &apos;status&apos; =&gt; $userinfo[&apos;status&apos;], &apos;deptsid&apos; =&gt; $userinfo[&apos;deptsid&apos;], &apos;postsid&apos; =&gt; $userinfo[&apos;postsid&apos;], &apos;role&apos; =&gt; $userinfo[&apos;role&apos;], &apos;long&apos; =&gt; true];</span><br><span class="line">            Session::set(&apos;userinfo&apos;, $userinfo);  //实现登陆</span><br><span class="line">        </span><br><span class="line">        $state = urldecode($state);  // 之前我们自己绑定的参数，因为url在http参数中需要加密，防止多余的http这些参数</span><br><span class="line">        header( &quot;Location: $state&quot; );exit;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><strong>手机号登陆</strong><br>首先生成验证码,存入缓存中，手机号=》验证码（过期时间，离开当前页面让其失效，只能使用一次），然后调用第三方接口发送给手机上这个验证码，用户收到验证码之后调用新的接口进行验证，我们在缓存中寻找手机号验证码是否匹配，如果匹配代表成功，后面是登陆啊，还是绑定啊看自己的业务需求</p><p><strong>sso登陆</strong><br>一处登陆处处登陆，一处注销，处处注销<br>(itbasic的原理类似oauth2。首先用户验证是否在的登陆中心登陆，如果没有，先登录，登陆中心成功后返回一个access_token,重定向到你来时候那个地址，相当于帮你发出请求，你拿着这个access_token获取用户信息，干啥都是你自己的事情。下次用户再来的时候，验证中心已经登陆上了，直接返回access_token然后重定向)<br>（注销，我们在每次去验证中心验证的时候，都记住有哪些来的网站，注销的时候都请求他们注销的地址就好了，这个时候可以直接请求，不用重定向，因为不用种cookie,直接销毁服务端数据就好了）</p><p><strong>找回密码</strong><br>通过邮箱。首先填写用户名和邮箱（为了防止别人恶意找回用户），确保用户名和邮箱和登陆的时候绑定一致，才发送修改密码的邮件，邮件内容是</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/633115645624777185.png" alt="image.png"></p><p>这样其实就足够了，这个token 是我们之前发送邮件时候生成的，我们只需要保证 用户名 =&gt;token,当用户请求这个接口的时候（注意一定是get请求，因为是点击），我们通过这个token,知道是哪个用户就好了，然后返回一个界面让用户修改密码就可以了.</p><p>熟悉了几个函数的使用</p><p>http_query_build ,拼接http请求参数（这个对url 好像还会进行urlencode加密）</p><p>parse_str, 把上面的拼接内容分开</p><p>当然上面各个案例的解决方案很多，比如找回密码用手机而不是用邮箱，只是简单记录下常用的方式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于登陆，现在的网站有第三方登陆（qq,微信，微博）， 手机号登陆，用户名密码登陆，sso登陆，找回密码，注销 感觉其实都差不多&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="API" scheme="http://yoursite.com/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>日志 awk sed</title>
    <link href="http://yoursite.com/2018/11/28/%E6%97%A5%E5%BF%97-awd-sed/"/>
    <id>http://yoursite.com/2018/11/28/日志-awd-sed/</id>
    <published>2018-11-28T10:32:20.000Z</published>
    <updated>2019-07-31T08:41:20.830Z</updated>
    
    <content type="html"><![CDATA[<p>日志很重要</p><blockquote><p>日志可以进行数据挖掘，分析用户的喜好，比如什么资源被用户频繁访问（对应面试题：取出访问量前20的网址）  –来自百度某朋友</p><p>你线上要是有错误怎么办，你们平时是不是都不看日志，只有错误了才解决，··balabal （一顿嘲讽）  –来自平安好房某专家表哥</p><p>为啥本地开发的时候，错误信息能输出在页面，线上环境直接就是个500页面，好奇怪，好奇怪     –来自17年的me</p></blockquote><a id="more"></a><p>###了解日志<br>我们itbasic用的其实是lamp, 通过apache的模块处理php, php的错误日志可以在虚拟域名里面进行配置<br>lnmp,nginx 起到静态文件处理的作用，php 转给php-fpm 进行处理，虽然网上说nginx 记录不了错误日志，但其实当我在虚拟站点里面配置error-log的时候，也是有记录的，和php-fpm中是一样的。<br>php-fpm 中开启日志需要修改php.fpm 的配置文件（还可以添加慢查询日志，<a href="https://juejin.im/post/5b9394a0e51d450e686747e3" target="_blank" rel="noopener">据说很重要</a>，有空的话可以把itbasic改成lnmp,有空的话看看php-fpm 中各个参数的作用，）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/5401815645624805999.png" alt="image.png"><br>特别是这块，php_flag和php_value 的作用是一致的，不知道为什么要搞两个一样的，还有就是他们的使用是这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php_flag[error_reporting] = 0</span><br></pre></td></tr></table></figure></p><p>来覆盖代码中的error_reporting ,····原先以为还有什么作用呢</p><p>###分析日志</p><p>我不会告诉你最开始接触sed和awk 是因为面试题，很多时候，当我们分析一个大日志文件的时候，我们甚至都打不开这个文件，因为太大了， 但是我们可以通过这些文本处理工具对数据加以筛选。</p><p>awk（参照<a href="http://www.ruanyifeng.com/blog/2018/11/awk.html" target="_blank" rel="noopener">阮一峰</a>老师，很可惜，没有出sed 入门）</p><p><strong>基本用法</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 格式</span><br><span class="line">$ awk 动作 文件名</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">$ awk &apos;&#123;print $0&#125;&apos; demo.txt</span><br><span class="line"></span><br><span class="line">$ echo &apos;this is a test&apos; | awk &apos;&#123;print $0&#125;&apos;</span><br><span class="line">this is a test</span><br></pre></td></tr></table></figure></p><p>print 和 echo 都是标准输出，stdin ,这个东西最近经常看到，感觉就是输出在控制台上，比如php cli 模式下，普通php 脚本中 echo,  print,  var_dump都可以打印在控制台上（但好像记得之前子进程中输出好像只有父进程中才能看到，不记得是return 还是 输出了），这种标准输出好像都可以通过管道进行连接然后进行处理<br>上面的分割， \$1 代表第一个元素，$0 代表整体元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 练习（test.log）：</span><br><span class="line">root:x:0:0:root:/root:/usr/bin/zsh</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line"></span><br><span class="line"># 想输出第一个字符的话</span><br><span class="line">cat test.log|awk -F &apos;:&apos; &apos;&#123;print $1&#125;&apos;</span><br></pre></td></tr></table></figure></p><p> 想一下，我们通过cat ,是不是能把文件默认输出在页面上，然后我们通过awk去处理，设置分隔符号 ‘:’,默认的分隔符符号是 ‘ ‘.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 练习：提取nginx 500 日志，并统计总数</span><br><span class="line"># 78.181.37.209 - - [28/Nov/2018:15:01:56 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36&quot;</span><br><span class="line">cat access.log|awk -F &apos; &apos; &apos;if ($9 == 500) print $0&apos; | wc -l</span><br></pre></td></tr></table></figure><p>注意这个分隔符号是空格，即使双引号里面有空格，也会把切割开， wc -l 可以统计行数</p><p><strong>变量</strong><br>内置一些变量，比如行数NR，这一行有多少个字段NF(这两个应该是最常用)，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILENAME：当前文件名</span><br><span class="line">FS：字段分隔符，默认是空格和制表符。</span><br><span class="line">RS：行分隔符，用于分割每一行，默认是换行符。</span><br><span class="line">OFS：输出字段的分隔符，用于打印时分隔字段，默认为空格。</span><br><span class="line">ORS：输出记录的分隔符，用于打印时分隔记录，默认为换行符。</span><br><span class="line">OFMT：数字输出的格式，默认为％.6g。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">练习：</span><br><span class="line">      2 345</span><br><span class="line">      2 123</span><br><span class="line">      1 789</span><br><span class="line">      1 1234</span><br><span class="line"></span><br><span class="line">awk &apos;&#123;print NR&quot; &quot; $2&#125;&apos; log  # 行数  第二个字段中间用空格连接</span><br><span class="line">awk &apos;&#123;print NR&quot; &quot; $(NF)&#125;&apos; # 行数 最后一个字段中间用空格连接，运行的时候中间的值会被替换</span><br></pre></td></tr></table></figure><p><strong>函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tolower()：字符转为小写。</span><br><span class="line">length()：返回字符串长度。</span><br><span class="line">substr()：返回子字符串。</span><br><span class="line">sin()：正弦。</span><br><span class="line">cos()：余弦。</span><br><span class="line">sqrt()：平方根。</span><br><span class="line">rand()：随机数。</span><br></pre></td></tr></table></figure></p><p><strong>条件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;条件 动作&apos; 文件名</span><br><span class="line">awk &apos;条件 动作&apos; 文件名awk -F &apos;:&apos; &apos;/usr/ &#123;print $1&#125;&apos; demo.txt</span><br><span class="line">awk -F &apos;:&apos; &apos;NR % 2 == 0 &#123;print $0&#125;&apos; demo.text #输出偶数行</span><br><span class="line">awk -F &apos;:&apos; &apos;&#123;if (NR % 2 == 0) print $0; else print &quot;error&quot; &apos;&#125;&apos; demo.text</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">练习</span><br><span class="line">[例]：有如下文件test,请统计每个网址出现次数，用一句shell实现。</span><br><span class="line">a [www.baidu.com]  20:00</span><br><span class="line">b [www.qq.com]  14:00</span><br><span class="line">d [www.baidu.com] 23:00</span><br><span class="line">e [www.qq.com]  20:30</span><br><span class="line">f [www.360.com] 20:30</span><br><span class="line"></span><br><span class="line"> cat url.txt|awk &apos;&#123;print $2&#125;&apos;|sort|uniq -c|sort -rn</span><br><span class="line"># cat 查看文件内容， 输出第二行的内容，排序，因为 uniq 只能把连接在一起的文件重复文件合并，然后再倒序</span><br></pre></td></tr></table></figure><p>uniq -c  把重复的行数显示在前，但是只能合并连续的<br>sort 排序， -rn   r是倒序，n是按照数字处理<br>head -n 5  取出前五行，这也是查询的时候经常要用到的</p><p>补充一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 取出cpu 或者内存占用前五，top 查看占用</span><br><span class="line">ps -aux|sort -k3rn|head -n 5</span><br><span class="line"># sort 自带切割，</span><br><span class="line"># ps -aux 可以查看所有进程， 比如之前我想查看我的一个脚本 server.php,可以通过 ps -aux|grep server.php, 相比较netstat -antp|grep 9000,查看端口占用情况， ps -aux 查看更加清楚，比如swoole 的进程，1个 master ,1个manage,剩下的work ，所有的进程都能查看到，但是netstat 只能查看到一个</span><br></pre></td></tr></table></figure></p><p>统计某接口的调用次数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log| grep &apos;GET /app/kevinContent&apos; | wc -l</span><br></pre></td></tr></table></figure><p>统计报错接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat access.log| awk &apos;&#123;if ($9 == 500) print $0&#125;&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日志很重要&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;日志可以进行数据挖掘，分析用户的喜好，比如什么资源被用户频繁访问（对应面试题：取出访问量前20的网址）  –来自百度某朋友&lt;/p&gt;
&lt;p&gt;你线上要是有错误怎么办，你们平时是不是都不看日志，只有错误了才解决，··balabal （一顿嘲讽）  –来自平安好房某专家表哥&lt;/p&gt;
&lt;p&gt;为啥本地开发的时候，错误信息能输出在页面，线上环境直接就是个500页面，好奇怪，好奇怪     –来自17年的me&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP常用工具</title>
    <link href="http://yoursite.com/2018/11/23/PHP%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/23/PHP常用工具/</id>
    <published>2018-11-23T15:26:05.000Z</published>
    <updated>2019-07-31T08:41:10.529Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
