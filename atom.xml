<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-21T12:50:38.628Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构算法 面试题总结</title>
    <link href="http://yoursite.com/2021/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/20/数据结构-面试题总结/</id>
    <published>2021-03-20T14:21:45.000Z</published>
    <updated>2021-03-21T12:50:38.628Z</updated>
    
    <content type="html"><![CDATA[<p>关于数据结构面试题的记录</p><a id="more"></a><p>go 夜读 <a href="https://reading.hidevops.io/interview/interview-data-structure/" target="_blank" rel="noopener">https://reading.hidevops.io/interview/interview-data-structure/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.什么是跳跃表?</span><br><span class="line"></span><br><span class="line">跳跃表是基于有序链表的一种扩展, 有序链表查数据还是得遍历，o(n) 复杂度，如果构建索引， 抛硬币50% 的那种，o(logn) 复杂度</span><br><span class="line"></span><br><span class="line">2. 介绍下 RESTFull API 方式下, 怎么做到快速路由?</span><br><span class="line">在计算机科学中，基数树，或称Patricia trie/tree，或crit bit tree，压缩前缀树，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210320223227.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.如何在一个给定有序数组中找两个和为某个定值的数，要求时间复杂度为O(n), 比如给｛1，2，4，5，8，11，15｝和15？</span><br><span class="line"></span><br><span class="line">很巧妙的算法，最大 + 最小， 大了 最大减少，小了 最小增大， 想了下还是 o(n) 复杂度</span><br><span class="line"></span><br><span class="line">2.给定一个数组代表股票每天的价格，请问只能买卖一次的情况下，最大化利润是多少？日期不重叠的情况下，可以买卖多次呢？输入：&#123;100,80,120,130,70,60,100,125&#125;，只能买一次：65(60买进，125卖出)；可以买卖多次：115(80买进，130卖出；60买进，125卖出)？</span><br><span class="line">（波底买，波峰卖）</span><br><span class="line"></span><br><span class="line">3.给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？</span><br><span class="line"></span><br><span class="line">bitmap  40 亿 /8 = 5亿， 50000 0000 = 500m</span><br><span class="line"></span><br><span class="line">磁盘排序，其实就是 树。</span><br></pre></td></tr></table></figure><p>github  <a href="https://github.com/lifei6671/interview-go" target="_blank" rel="noopener">https://github.com/lifei6671/interview-go</a></p><p>排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</span><br><span class="line"></span><br><span class="line">作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/bubbleSort.b7d216a5.gif" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">arr := []int&#123;12,3,28,11,0,4&#125;</span><br><span class="line"></span><br><span class="line">count := len(arr)</span><br><span class="line">for i:=0; i &lt;= count-1-1; i++ &#123; // 多少个元素需要确定位置</span><br><span class="line">for j:= 0; j &lt;= count -1 -1- i; j++ &#123; //  每个元素要比较的次数，因为是和 j+1 比较，所以要 再减去 1</span><br><span class="line">if arr[j] &gt; arr [j+1] &#123;</span><br><span class="line">arr[j+1], arr[j] = arr[j], arr[j+1]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210321140858.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">两个算法其实本质差不多，只是这个不需要频繁的交换元素</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">arr := []int&#123;12,3,28,11,0,4&#125;</span><br><span class="line"></span><br><span class="line">count := len(arr)</span><br><span class="line">for i:=0; i &lt;= count-1-1; i++ &#123; // 需要确定的元素个数</span><br><span class="line">max := arr[0]</span><br><span class="line">index := 0</span><br><span class="line">for j:= 1; j &lt;= count -1-i; j++ &#123; // 需要比较的元素</span><br><span class="line">if arr[j] &gt; max &#123;</span><br><span class="line">index = j</span><br><span class="line">max = arr[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[count-1-i], arr[index] = arr[index], arr[count-1-i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">快速排序算法通过多次比较和交换来实现排序，其排序流程如下： [2] </span><br><span class="line">(1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 [2] </span><br><span class="line">(2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 [2] </span><br><span class="line">(3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 [2] </span><br><span class="line">(4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。 [2]</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">arr := []int&#123;12, 3, 28, 11, 0, 4, 15&#125;</span><br><span class="line"></span><br><span class="line">arr = quick(arr)</span><br><span class="line"></span><br><span class="line">fmt.Println(arr, &quot;===&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func quick(arr []int) []int &#123;</span><br><span class="line">count := len(arr)</span><br><span class="line">if count &lt;= 1 &#123;</span><br><span class="line">fmt.Println(arr, &quot;return single&quot;)</span><br><span class="line">return arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">minIndex := 1</span><br><span class="line">mid := arr[0]</span><br><span class="line">min := arr[minIndex]</span><br><span class="line">maxIndex := count - 1</span><br><span class="line"></span><br><span class="line">if minIndex == maxIndex &#123;</span><br><span class="line">if min &gt; mid &#123;</span><br><span class="line">return []int&#123;mid, min&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return  []int&#123;min, mid&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">fmt.Println(mid, min, minIndex, maxIndex, arr)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line"></span><br><span class="line">if arr[minIndex] &gt; mid &#123;</span><br><span class="line">for &#123;</span><br><span class="line">if arr[maxIndex] &lt; mid &#123;</span><br><span class="line">arr[minIndex],arr[maxIndex] = arr[maxIndex], arr[minIndex]</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">if minIndex == maxIndex &#123;</span><br><span class="line">fmt.Println(arr[1:minIndex], arr[minIndex:count], mid, &quot;tree111&quot;)</span><br><span class="line"></span><br><span class="line">new1 := make([]int, minIndex-1)</span><br><span class="line">new2 := make([]int, count-minIndex)</span><br><span class="line">copy(new1, arr[1:minIndex])</span><br><span class="line">copy(new2, arr[minIndex:count])</span><br><span class="line"></span><br><span class="line">left := quick(new1)</span><br><span class="line">right := quick(new2)</span><br><span class="line">tmp1 := append(left, mid)</span><br><span class="line">tmp2 := append(tmp1, right...)</span><br><span class="line">fmt.Println(tmp2, &quot;==return111==&quot;)</span><br><span class="line">return tmp2</span><br><span class="line">&#125;</span><br><span class="line">maxIndex--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">minIndex++</span><br><span class="line">// 相等返回</span><br><span class="line">if minIndex == maxIndex &#123;</span><br><span class="line">fmt.Println(arr[1:minIndex], arr[maxIndex:count], mid, &quot;tree&quot;)</span><br><span class="line">new1 := make([]int, minIndex-1)</span><br><span class="line">new2 := make([]int, count-maxIndex)</span><br><span class="line">copy(new1, arr[1:minIndex])</span><br><span class="line">copy(new2, arr[maxIndex:count])</span><br><span class="line">left  := quick(new1)</span><br><span class="line">right := quick(new2)</span><br><span class="line">tmp1 := append(left, mid)</span><br><span class="line">tmp2 := append(tmp1, right...)</span><br><span class="line">fmt.Println(left,right,tmp1, tmp2, maxIndex, minIndex, &quot;==return==&quot;)</span><br><span class="line">return tmp2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">二分查找</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">arr := []int&#123;1,3,5,8,12,34,98, 100&#125;</span><br><span class="line">fmt.Println(search(12, arr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func search(n int, arr []int) int &#123;</span><br><span class="line">// 二分查找 12</span><br><span class="line">min := 0</span><br><span class="line">max := len(arr) - 1</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">mid := (max + min) / 2</span><br><span class="line">fmt.Println(arr[min], arr[max], arr[mid], min, max, mid)</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line"></span><br><span class="line">if arr[mid] == n &#123;</span><br><span class="line">return mid</span><br><span class="line">&#125; else if arr[mid] &gt; n &#123;</span><br><span class="line">max = mid</span><br><span class="line">&#125; else &#123;</span><br><span class="line">min = mid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if max == min &amp;&amp; arr[max] != n &#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">01、实现 strStr() leetcode 基础题 （循环遍历）</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func str1(haystack string, str string) int &#123;</span><br><span class="line">if len(str) == 0 &#123;</span><br><span class="line">return  0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := []rune(haystack)</span><br><span class="line">arr1 := []rune(str)</span><br><span class="line"></span><br><span class="line">for k, v := range arr &#123;</span><br><span class="line">if v == arr1[0] &#123;</span><br><span class="line">left := len(arr) - k</span><br><span class="line">if left &lt; len(arr1) &#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">if string(arr[k:k+len(arr1)]) == str &#123;</span><br><span class="line">return k</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return  -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">haystack := &quot;Here is a little Hao&quot;</span><br><span class="line">str := &quot;little&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(str1(haystack, str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反转字符串 leetcode 基础题 (这种前后递减的方式今天用到两次，一次是在二分查找，一次是在快排)</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func swap(str string) string &#123;</span><br><span class="line">if len(str) == 0 &#123;</span><br><span class="line">return &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">minIndex := 0</span><br><span class="line">maxIndex := len(str) - 1</span><br><span class="line"></span><br><span class="line">arr := []rune(str)</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">if minIndex == maxIndex || minIndex &gt; maxIndex &#123;</span><br><span class="line">return  string(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr[minIndex], arr[maxIndex] = arr[maxIndex], arr[minIndex]</span><br><span class="line"></span><br><span class="line">minIndex++</span><br><span class="line">maxIndex--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">str := &quot;hello0&quot;</span><br><span class="line">fmt.Println(swap(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">字符串中的第一个唯一字符  leetcode基础题 （核心就是去重，去重就想到了map）</span><br><span class="line"></span><br><span class="line">给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1 。 案例:</span><br><span class="line"></span><br><span class="line">s = &quot;leetcode&quot; 返回 0.</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;, 返回 2.</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func repeat(str string) int &#123;</span><br><span class="line">m1 := make(map[string]int)</span><br><span class="line"></span><br><span class="line">arr := []rune(str)</span><br><span class="line"></span><br><span class="line">for k, v := range arr &#123;</span><br><span class="line">if tmp, ok := m1[string(v)]; ok &#123;</span><br><span class="line">return tmp</span><br><span class="line">&#125; else &#123;</span><br><span class="line">m1[string(v)] = k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return  -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">str := &quot;loveleetcode&quot;</span><br><span class="line">fmt.Println(repeat(str))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 leetcode 基础题 （这题的核心在我看来也是前后往中间算，这种题目需要注意的就是 min &gt;= max 的时候我们就要break了 不要， 也就是min 一定小于 max, 我们才能 min++ 和max --）</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">// A 65 ~ 90</span><br><span class="line">// a  97 ~ 122</span><br><span class="line"></span><br><span class="line">func huiwen(s string) bool &#123;</span><br><span class="line">if len(s) == 0 &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := make([]string, 0)</span><br><span class="line">for _, v := range s &#123;</span><br><span class="line">if v &gt;= 65 &amp;&amp; v &lt;= 90 &#123;</span><br><span class="line">arr = append(arr, string(v+32))</span><br><span class="line">&#125;</span><br><span class="line">if v &gt;= 97 &amp;&amp; v &lt;= 122 &#123;</span><br><span class="line">arr = append(arr, string(v))</span><br><span class="line">&#125;</span><br><span class="line">if v &gt;= 48 &amp;&amp; v &lt;=57 &#123;</span><br><span class="line">arr = append(arr, string(v))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if len(arr) == 0 &#123;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">minIndex := 0</span><br><span class="line">maxIndex := len(arr) -1</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">if arr[minIndex] == arr[maxIndex] &#123;</span><br><span class="line">if minIndex &gt;= maxIndex &#123;</span><br><span class="line">break</span><br><span class="line">&#125; else &#123;</span><br><span class="line">minIndex++</span><br><span class="line">maxIndex--</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return  true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">fmt.Println(huiwen(&quot;0P&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">给定两个数组，编写一个函数来计算它们的交集。leetcode 基础题 （之前没做出来，这次竟然做出来了，我的做法很简单，就是遍历）</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func intersect(nums1 []int, nums2 []int) []int &#123;</span><br><span class="line"></span><br><span class="line">res := make([]int, 0 )</span><br><span class="line">if len(nums1) == 0 || len(nums2) == 0 &#123;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for _, v := range nums1 &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">for k1, v1 := range nums2 &#123;</span><br><span class="line">if v == v1 &#123;</span><br><span class="line">res = append(res, v)</span><br><span class="line">nums2 = append(nums2[0:k1], nums2[k1+1:]...)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">arr1 := []int&#123;1,2,2,1&#125;</span><br><span class="line">arr2 := []int&#123;2,2&#125;</span><br><span class="line"></span><br><span class="line">/*arr1 = []int&#123;4,9,5&#125;</span><br><span class="line">arr2 = []int&#123;9,4,9,8,4&#125;*/</span><br><span class="line"></span><br><span class="line">fmt.Println(intersect(arr1, arr2))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于数据结构面试题的记录&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql 面试题总结</title>
    <link href="http://yoursite.com/2021/03/20/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/20/数据库-面试题总结/</id>
    <published>2021-03-20T13:50:10.000Z</published>
    <updated>2021-03-20T13:50:10.409Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库 面试题总结</title>
    <link href="http://yoursite.com/2021/03/20/mysql-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/20/mysql-面试题总结/</id>
    <published>2021-03-20T13:50:10.000Z</published>
    <updated>2021-03-21T13:46:21.927Z</updated>
    
    <content type="html"><![CDATA[<p>关于数据库 的面试</p><a id="more"></a><p>mysql</p><p>go 夜读  <a href="https://reading.hidevops.io/interview/interview-database/" target="_blank" rel="noopener">https://reading.hidevops.io/interview/interview-database/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">1.Mysql事物的隔离级别?</span><br><span class="line"></span><br><span class="line">2.Innodb和Myisam的区别？</span><br><span class="line">Innodb支持事务，而Myisam不支持事务</span><br><span class="line">Innodb支持行级锁，而Myisam支持表级锁</span><br><span class="line">innodb 对于count 的支持得全表扫，myisam 是单个元素支持</span><br><span class="line">Innodb支持外键，而Myisam不支持</span><br><span class="line">Innodb不支持全文索引，而Myisam支持</span><br><span class="line">Innodb是索引组织表， Myisam是堆表</span><br><span class="line"></span><br><span class="line">3.Mysql慢响应默认时间?</span><br><span class="line">10s</span><br><span class="line"></span><br><span class="line">4.Explain的含义?</span><br><span class="line">explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助 选择更好的索引和写出更优化的查询语句。</span><br><span class="line"></span><br><span class="line">6.Redis的过期失效机制？</span><br><span class="line">scan扫描+给每个key存储过期时间戳</span><br><span class="line"></span><br><span class="line">7. Redis持久化方案aof的默认fsync时间是多长？</span><br><span class="line">1s</span><br><span class="line"></span><br><span class="line">8.Redis持久化方案rdb和aof的区别？</span><br><span class="line">rdb 文件快照</span><br><span class="line">aof 指令，log 日志</span><br><span class="line"></span><br><span class="line">9. Redis的集群怎么搭建？</span><br><span class="line">redis cluster在设计的时候，就考虑到了去中心化、去中间件，也就是说，集群中的每个节点都是平等关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</span><br><span class="line">Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做哈希槽 (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个 slot，当我们 set 一个 key 时，会用CRC16算法来取模得到所属的 slot，然后将这个 key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到 set 和 get 的时候，直接跳转到了7000端口的节点。（感觉这种固定的槽数量也不太灵活）</span><br><span class="line">Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的 salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个 master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。</span><br><span class="line">需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.简单介绍下什么是缓存击穿, 缓存穿透, 缓存雪崩? 能否介绍些应对办法?</span><br><span class="line">https://blog.csdn.net/zeb_perfect/article/details/54135506 ，缓存穿透用布隆过滤器的一个问题就是布隆过滤器没发删数据。</span><br><span class="line">缓存雪崩，遇到的很少。可能数量级还没上去，流量比较平稳。其实说的单进程读写数据库其实就是消息队列限流啦，基本不可能用这种方式。而且我们还有连接池。</span><br><span class="line">缓存击穿，go 那边有个包就是如果一个请求没有返回，在这期间都不会把数据打到db层，只会放一条数据通行。要是我做的话就是提供一个分布式锁，没拿到这个锁不允许执行后面的内容，都给我阻塞住。当我cache设置好了，才可以执行。</span><br><span class="line"></span><br><span class="line">11.</span><br></pre></td></tr></table></figure><p>github : <a href="https://github.com/lifei6671/interview-go/blob/master/mysql/mysql-interview.md" target="_blank" rel="noopener">https://github.com/lifei6671/interview-go/blob/master/mysql/mysql-interview.md</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">1 索引哪些情况会失效</span><br><span class="line"></span><br><span class="line">查询条件包含or，可能导致索引失效  （因为可能筛选or 后面的一些数据）</span><br><span class="line">如何字段类型是字符串，where时一定用引号括起来，否则索引失效</span><br><span class="line">like通配符可能导致索引失效。 （字符串一般是hash 存储，比对会从第一个字符比对）</span><br><span class="line">联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。 （最左前缀）</span><br><span class="line">在索引列上使用mysql的内置函数，索引失效。</span><br><span class="line">对索引列运算（如，+、-、*、/），索引失效。</span><br><span class="line">索引字段上使用（！= 或者 &lt; &gt;，not in）时，可能会导致索引失效。</span><br><span class="line">索引字段上使用is null， is not null，可能导致索引失效。 （我们不用null， 除非统计）</span><br><span class="line">左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</span><br><span class="line">mysql估计使用全表扫描要比使用索引快,则不使用索引。</span><br><span class="line"></span><br><span class="line">2.索引不适合哪些场景</span><br><span class="line">数据量少的不适合加索引 （全表扫可能效率更高）</span><br><span class="line">更新比较频繁的也不适合加索引</span><br><span class="line">区分度低的字段不适合加索引（如性别）</span><br><span class="line"></span><br><span class="line">3. 索引的一些潜规则</span><br><span class="line">覆盖索引 （不要用select *）</span><br><span class="line">回表</span><br><span class="line">索引数据结构（B+树）</span><br><span class="line">最左前缀原则</span><br><span class="line">索引下推  https://juejin.cn/post/6844904110072791048, 感觉就是先merge， 再回表</span><br><span class="line"></span><br><span class="line">4.日常工作中你是怎么优化SQL的</span><br><span class="line"></span><br><span class="line">加索引</span><br><span class="line">拆分join</span><br><span class="line">避免返回不必要的数据</span><br><span class="line">适当分批量进行</span><br><span class="line">优化sql结构</span><br><span class="line">分库分表</span><br><span class="line">读写分离</span><br><span class="line"></span><br><span class="line">5. 说说分库与分表的设计</span><br><span class="line"></span><br><span class="line">水平拆分 就是 记录分表</span><br><span class="line">垂直拆分 就是业务拆表，这个我们很少</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.分库分表可能遇到的问题</span><br><span class="line">事务问题：需要用分布式事务啦 （这个我们一般用mq 去解决）</span><br><span class="line">跨节点Join的问题：解决这一问题可以分两次查询实现</span><br><span class="line">跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在应用程序端进行合并。</span><br><span class="line">数据迁移，容量规划，扩容等问题</span><br><span class="line">ID问题：数据库被切分后，不能再依赖数据库自身的主键生成机制啦，最简单可以考虑UUID，雪花算法，redis，基于 1000 基础上</span><br><span class="line"></span><br><span class="line">7. InnoDB与MyISAM的区别</span><br><span class="line">InnoDB支持事务，MyISAM不支持事务</span><br><span class="line">InnoDB支持外键，MyISAM不支持外键</span><br><span class="line">InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持</span><br><span class="line">select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。</span><br><span class="line"></span><br><span class="line">InnoDB支持表、行级锁，而MyISAM支持表级锁。</span><br><span class="line">InnoDB表必须有主键，而MyISAM可以没有主键</span><br><span class="line">Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。</span><br><span class="line">Innodb按主键大小有序插入，物理存储一定有有序，MyISAM记录插入顺序是，按记录插入顺序保存。</span><br><span class="line">InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引</span><br><span class="line">InnoDB 属于索引组织表，使用共享表空间和多表空间储存数据。MyISAM用.frm、.MYD、.MTI来储存表定义，数据和索引。（在服务器上的存储文件结构）</span><br><span class="line"></span><br><span class="line">8.为什么MySQL使用B+树做索引？ 平衡二叉树相较于 二叉树，避免 o(n) 的复杂度查询，b树相较于平衡二叉树减少树的高度， b+树相较于 b树让节点存储更多的 索引信息，页大小固定，能让索引树更高效</span><br><span class="line"></span><br><span class="line">9.聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针. 为什么我们select 的时候避免 *， 为的就是非聚簇索引的回表操作。</span><br><span class="line"></span><br><span class="line">10  limit 1000000 加载很慢的话，你是怎么解决的呢？</span><br><span class="line">我一般都是通过 id 大小 去 scan</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于数据库 的面试&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>操作系统 面试题总结</title>
    <link href="http://yoursite.com/2021/03/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/20/操作系统-面试题总结/</id>
    <published>2021-03-20T12:19:36.000Z</published>
    <updated>2021-03-20T12:19:36.421Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang 基础面试题总结</title>
    <link href="http://yoursite.com/2021/03/20/golang-%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/20/golang-基础面试题总结/</id>
    <published>2021-03-20T05:30:44.000Z</published>
    <updated>2021-03-20T12:19:14.050Z</updated>
    
    <content type="html"><![CDATA[<p>golang 面试中涉及到自己的知识盲区, 记录下, 为了以后更好的编程</p><a id="more"></a><p>极客兔兔的面试题 :<a href="https://geektutu.com/post/qa-golang-1.html" target="_blank" rel="noopener">https://geektutu.com/post/qa-golang-1.html</a></p><p>基础语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Q1 = 和 := 的区别？</span><br><span class="line"></span><br><span class="line">:= 声明加赋值，而且 := 只能在函数内部使用，外部只能用 var</span><br><span class="line"></span><br><span class="line">Q2 指针的作用？</span><br><span class="line"></span><br><span class="line">Q3 Go 允许多个返回值吗？</span><br><span class="line"></span><br><span class="line">Q4 Go 有异常类型吗？</span><br><span class="line"></span><br><span class="line">Q5 什么是协程（Goroutine）</span><br><span class="line"></span><br><span class="line">相比较进程 线程，更轻量，占用资源更少，所以堆共同资源锁等待的时间就更少，每个大概只占用 2Kb</span><br><span class="line"></span><br><span class="line">Q6 如何高效地拼接字符串</span><br><span class="line"></span><br><span class="line">string.Builder 出现之前，用的 byte.Buffe,  string.Builder 效率更高是因为 指针的转换 unsafe 包，虽然go 明确说了 指针不能转换和 运算，但是这个unsafe 包可以，底层用的slice</span><br><span class="line"></span><br><span class="line">Q7 什么是 rune 类型 </span><br><span class="line"></span><br><span class="line">ascii 本身128 ，只需要7个字节，由于utf8 大一统的出现，一个字符最多4个字节，so int32 4个字节（utf8 , 中文三个字节）</span><br><span class="line">字节英文怎么拼的 bytedance， 字节跳动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q8 如何判断 map 中是否包含某个 key ？</span><br><span class="line"></span><br><span class="line">Q9 Go 支持默认参数或可选参数吗？</span><br><span class="line"></span><br><span class="line">Q10 defer 的执行顺序</span><br><span class="line"></span><br><span class="line">这个题目考得太多了，主要核心就是</span><br><span class="line"></span><br><span class="line">0. defer 的执行 栈</span><br><span class="line"></span><br><span class="line">1.返回值在defer 执行前面</span><br><span class="line"></span><br><span class="line">2.如果我们定义了返回值（返回值有名字），我们就不需要申请新的变量，反之我们需要申请临时变量来储存这个值。在defer 之前，我们有个赋值的动作。</span><br><span class="line"></span><br><span class="line">3.return 执行完了，执行defer。 defer 中的变量如果不是传进去的，会是一个全局变量，相互影响，甚至会影响到 func 定义的return， 整个func 是一个作用域</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q11 如何交换 2 个变量的值？</span><br><span class="line"></span><br><span class="line">Q12 Go 语言 tag 的用处？</span><br><span class="line"></span><br><span class="line">反射的几个函数研究。 之前看的一篇文章介绍的很好， valueof 包装一个反射值，然后用这个包装后的值调用反射的对应方法，可以写篇博客记录下。</span><br><span class="line"></span><br><span class="line">Q13 如何判断 2 个字符串切片（slice) 是相等的？</span><br><span class="line"></span><br><span class="line">reflect.DeepEqual(a, b)， 这个我倒是没想到。</span><br><span class="line"></span><br><span class="line">Q14 字符串打印时，%v 和 %+v 的区别</span><br><span class="line"></span><br><span class="line">Q15 Go 语言中如何表示枚举值(enums)</span><br><span class="line"></span><br><span class="line">Q16 空 struct&#123;&#125; 的用途</span><br><span class="line"></span><br><span class="line">使用空结构体 struct&#123;&#125; 可以节省内存，一般作为占位符使用，表明这里并不需要一个值。但感觉应该稍微也占点内存空间吧。</span><br></pre></td></tr></table></figure><p>实现原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">Q1 init() 函数是什么时候执行的？</span><br><span class="line"></span><br><span class="line">init() 函数是 Go 程序初始化的一部分。Go 程序初始化先于 main 函数，由 runtime 初始化每个导入的包，初始化顺序不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</span><br><span class="line"></span><br><span class="line">每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的 init() 函数。同一个包，甚至是同一个源文件可以有多个 init() 函数。init() 函数没有入参和返回值，不能被其他函数调用，同一个包内多个 init() 函数的执行顺序不作保证。</span><br><span class="line"></span><br><span class="line">一句话总结： import –&gt; const –&gt; var –&gt; init() –&gt; main()</span><br><span class="line"></span><br><span class="line">同一个文件竟然能包含多个init 函数，竟然不会出现重复定义的问题，也是蛮神奇的，但是没有顺序性，也是蛮蛋疼的事。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q2 Go 语言的局部变量分配在栈上还是堆上？</span><br><span class="line"></span><br><span class="line">由编译器决定。Go 语言编译器会自动决定把一个变量放在栈还是放在堆，编译器会做逃逸分析(escape analysis)，当发现变量的作用域没有超出函数范围，就可以在栈上，反之则必须分配在堆上。</span><br><span class="line"></span><br><span class="line">func foo() *int &#123;</span><br><span class="line">v := 11</span><br><span class="line">return &amp;v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m := foo()</span><br><span class="line">println(*m) // 11</span><br><span class="line">&#125;</span><br><span class="line">foo() 函数中，如果 v 分配在栈上，foo 函数返回时，&amp;v 就不存在了，但是这段函数是能够正常运行的。Go 编译器发现 v 的引用脱离了 foo 的作用域，会将其分配在堆上。因此，main 函数中仍能够正常访问该值。</span><br><span class="line">这个解释真的很棒。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q3 2 个 interface 可以比较吗？</span><br><span class="line"></span><br><span class="line">Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 == 或 != 比较。2 个 interface 相等有以下 2 种情况</span><br><span class="line"></span><br><span class="line">两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</span><br><span class="line">2）类型 V 相同，且对应的值 V 相等。</span><br><span class="line">看下面的例子：</span><br><span class="line">type Stu struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type StuInt interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var stu1, stu2 StuInt = &amp;Stu&#123;&quot;Tom&quot;&#125;, &amp;Stu&#123;&quot;Tom&quot;&#125;</span><br><span class="line">var stu3, stu4 StuInt = Stu&#123;&quot;Tom&quot;&#125;, Stu&#123;&quot;Tom&quot;&#125;</span><br><span class="line">fmt.Println(stu1 == stu2) // false</span><br><span class="line">fmt.Println(stu3 == stu4) // true</span><br><span class="line">&#125;</span><br><span class="line">stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。</span><br><span class="line">stu3 和 stu3 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true。 （如何比较结构体）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q4 两个 nil 可能不相等吗？ （更深刻的讲解 interface 的存在）</span><br><span class="line"></span><br><span class="line">可能。</span><br><span class="line"></span><br><span class="line">接口(interface) 是对非接口值(例如指针，struct等)的封装，内部实现包含 2 个字段，类型 T 和 值 V。一个接口等于 nil，当且仅当 T 和 V 处于 unset 状态（T=nil，V is unset）。</span><br><span class="line"></span><br><span class="line">两个接口值比较时，会先比较 T，再比较 V。</span><br><span class="line">接口值与非接口值比较时，会先将非接口值尝试转换为接口值，再比较。</span><br><span class="line">func main() &#123;</span><br><span class="line">var p *int = nil</span><br><span class="line">var i interface&#123;&#125; = p</span><br><span class="line">fmt.Println(i == p) // true</span><br><span class="line">fmt.Println(p == nil) // true</span><br><span class="line">fmt.Println(i == nil) // false</span><br><span class="line">&#125;</span><br><span class="line">上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为(T=*int, V=nil)，i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，p 与 nil 比较，直接比较值，所以 p == nil。</span><br><span class="line"></span><br><span class="line">但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q5 简述 Go 语言GC(垃圾回收)的工作原理</span><br><span class="line"></span><br><span class="line">最常见的垃圾回收算法有标记清除(Mark-Sweep) 和引用计数(Reference Count，php 用的就是这种方式)，Go 语言采用的是标记清除算法。并在此基础上使用了三色标记法和写屏障技术，提高了效率。</span><br><span class="line"></span><br><span class="line">中间还有详细的步骤</span><br><span class="line"></span><br><span class="line">1）标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)</span><br><span class="line">2）使用三色标记法标记（Marking, 并发）</span><br><span class="line">3）标记结束(Mark Termination，需 STW)，关闭写屏障。</span><br><span class="line">4）清理(Sweeping, 并发)</span><br><span class="line"></span><br><span class="line">感觉这个就类似es 的遍历，做了一个快照，只是他没有写屏障这一个步骤。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Q6 函数返回局部变量的指针是否安全？ （讲的真好）</span><br><span class="line"></span><br><span class="line">这在 Go 中是安全的，Go 编译器将会对每个局部变量进行逃逸分析。如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上</span><br><span class="line"></span><br><span class="line">一个T类型的值可以调用为*T类型声明的方法，但是仅当此T的值是可寻址(addressable) 的情况下。编译器在调用指针属主方法前，会自动取此T值的地址。因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型*T声明的方法。</span><br><span class="line">反过来，一个*T类型的值可以调用为类型T声明的方法，这是因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，编译器都会为类型*T自动隐式声明一个同名和同签名的方法。</span><br><span class="line">哪些值是不可寻址的呢？</span><br><span class="line"></span><br><span class="line">字符串中的字节；</span><br><span class="line">map 对象中的元素（slice 对象中的元素是可寻址的，slice的底层是数组）；（这个会扩容，会重新hash，渐进式hash 等）</span><br><span class="line">常量；</span><br><span class="line">包级别的函数等。</span><br><span class="line">举一个例子，定义类型 T，并为类型 *T 声明一个方法 hello()，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。</span><br><span class="line"></span><br><span class="line">type T string</span><br><span class="line"></span><br><span class="line">func (t *T) hello() &#123;</span><br><span class="line">fmt.Println(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var t1 T = &quot;ABC&quot;</span><br><span class="line">t1.hello() // hello</span><br><span class="line">const t2 T = &quot;ABC&quot;</span><br><span class="line">t2.hello() // error: cannot call pointer method on t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并发问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Q1 无缓冲的 channel 和 有缓冲的 channel 的区别？</span><br><span class="line"></span><br><span class="line">Q2 什么是协程泄露(Goroutine Leak)？</span><br><span class="line"></span><br><span class="line">看了下解释，核心就是阻塞</span><br><span class="line"></span><br><span class="line">Q3 Go 可以限制运行时操作系统线程的数量吗？ （注意事线程数）</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.很经典的const 输出问题</span><br><span class="line">func main() &#123;</span><br><span class="line">const (</span><br><span class="line">a, b = &quot;golang&quot;, 100</span><br><span class="line">d, e</span><br><span class="line">f bool = true</span><br><span class="line">g</span><br><span class="line">)</span><br><span class="line">fmt.Println(d, e, g)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 严格类型</span><br><span class="line">func main() &#123;</span><br><span class="line">const N = 100</span><br><span class="line">var x int = N</span><br><span class="line"></span><br><span class="line">const M int32 = 100</span><br><span class="line">var y int = M</span><br><span class="line">fmt.Println(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 竟然不报错， defer 可以只有一行，recover 才是必须在func 中</span><br><span class="line">n := 1</span><br><span class="line">if n == 1 &#123;</span><br><span class="line">defer fmt.Println(n)</span><br><span class="line">n += 100</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(n)</span><br></pre></td></tr></table></figure><p>go 夜读 <a href="https://reading.hidevops.io/interview/interview-golang-language/" target="_blank" rel="noopener">https://reading.hidevops.io/interview/interview-golang-language/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.select是随机的还是顺序的？</span><br><span class="line"></span><br><span class="line">2.2.Go语言局部变量分配在栈还是堆？</span><br><span class="line"></span><br><span class="line">3.3.简述一下你对Go垃圾回收机制的理解？</span><br><span class="line"></span><br><span class="line">4.简述一下golang的协程调度原理?</span><br><span class="line"></span><br><span class="line">M(machine): 代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。</span><br><span class="line">P(processor): 表示逻辑processor，是线程M的执行的上下文。</span><br><span class="line">G(goroutine): 调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。</span><br><span class="line"></span><br><span class="line">5.介绍下 golang 的 runtime 机制?</span><br><span class="line"></span><br><span class="line">6.如何获取 go 程序运行时的协程数量, gc 时间, 对象数, 堆栈信息?</span><br><span class="line"></span><br><span class="line">7.介绍下你平时都是怎么调试 golang 的 bug 以及性能问题的?</span><br><span class="line">panic 调用栈</span><br><span class="line">pprof</span><br><span class="line">火焰图(配合压测)</span><br><span class="line">使用go run -race 或者 go build -race 来进行竞争检测</span><br><span class="line">查看系统 磁盘IO/网络IO/内存占用/CPU 占用(配合压测)</span><br><span class="line"></span><br><span class="line">8.简单介绍下 golang 中 make 和 new 的区别</span><br><span class="line"></span><br><span class="line">我一般new 用的都是 返回struct 的指针，make 一般是用来 slice ，map channel 类型的初始化、</span><br></pre></td></tr></table></figure><p>面试题一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">1. defer 执行顺序， panic 执行顺序</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    defer_call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func defer_call() &#123;</span><br><span class="line">    defer func() &#123; fmt.Println(&quot;打印前&quot;) &#125;()</span><br><span class="line">    defer func() &#123; fmt.Println(&quot;打印中&quot;) &#125;()</span><br><span class="line">    defer func() &#123; fmt.Println(&quot;打印后&quot;) &#125;()</span><br><span class="line">    panic(&quot;触发异常&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">panic 最后执行</span><br><span class="line"></span><br><span class="line">2. for 循环的时候， 循环变量是副本</span><br><span class="line">type student struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age  int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pase_student() &#123;</span><br><span class="line">    m := make(map[string]*student)</span><br><span class="line">    stus := []student&#123;</span><br><span class="line">        &#123;Name: &quot;zhou&quot;, Age: 24&#125;,</span><br><span class="line">        &#123;Name: &quot;li&quot;, Age: 23&#125;,</span><br><span class="line">        &#123;Name: &quot;wang&quot;, Age: 22&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    for _, stu := range stus &#123;</span><br><span class="line">        m[stu.Name] = &amp;stu</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">虽然map 中value 不能寻址，但是可以储存变量类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 协程执行的不确定性，还有对于匿名函数执行时候运行态的保存</span><br><span class="line">func main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(1)</span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">    wg.Add(20)</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func() &#123;</span><br><span class="line">            fmt.Println(&quot;A: &quot;, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">        go func(i int) &#123;</span><br><span class="line">            fmt.Println(&quot;B: &quot;, i)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.组合</span><br><span class="line">type People struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (p *People) ShowA() &#123;</span><br><span class="line">    fmt.Println(&quot;showA&quot;)</span><br><span class="line">    p.ShowB()</span><br><span class="line">&#125;</span><br><span class="line">func (p *People) ShowB() &#123;</span><br><span class="line">    fmt.Println(&quot;showB&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Teacher struct &#123;</span><br><span class="line">    People</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (t *Teacher) ShowB() &#123;</span><br><span class="line">    fmt.Println(&quot;teacher showB&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    t := Teacher&#123;&#125;</span><br><span class="line">    t.ShowA()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. select 的随机性</span><br><span class="line">func main() &#123;</span><br><span class="line">    runtime.GOMAXPROCS(1)</span><br><span class="line">    int_chan := make(chan int, 1)</span><br><span class="line">    string_chan := make(chan string, 1)</span><br><span class="line">    int_chan &lt;- 1</span><br><span class="line">    string_chan &lt;- &quot;hello&quot;</span><br><span class="line">    select &#123;</span><br><span class="line">    case value := &lt;-int_chan:</span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    case value := &lt;-string_chan:</span><br><span class="line">        panic(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. defer 的参数在执行到这个地方就执行</span><br><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">    ret := a + b</span><br><span class="line">    fmt.Println(index, a, b, ret)</span><br><span class="line">    return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    a := 1</span><br><span class="line">    b := 2</span><br><span class="line">    defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))</span><br><span class="line">    a = 0</span><br><span class="line">    defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))</span><br><span class="line">    b = 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7. 这个make 没有给len， 给了len 的话，默认就会填充 int 默认值 0</span><br><span class="line">func main() &#123;</span><br><span class="line">    s := make([]int, 0)</span><br><span class="line">    s = append(s, 1, 2, 3)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8.  map 锁，不仅我们修改的时候要加锁，读取的时候也要加锁</span><br><span class="line">type UserAges struct &#123;</span><br><span class="line">ages map[string]int</span><br><span class="line">sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ua *UserAges) Add(name string, age int) &#123;</span><br><span class="line">ua.Lock()</span><br><span class="line">defer ua.Unlock()</span><br><span class="line">ua.ages[name] = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ua *UserAges) Get(name string) int &#123;</span><br><span class="line">if age, ok := ua.ages[name]; ok &#123;</span><br><span class="line">return age</span><br><span class="line">&#125;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">9. 不太明白考察啥</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10. 这个竟然编译不通过，虽然 student 能够调用 speak， 但本质上还是寻址调用，所以student不属于 people</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People interface &#123;</span><br><span class="line">Speak(string) string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Stduent struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (stu *Stduent) Speak(think string) (talk string) &#123;</span><br><span class="line">if think == &quot;bitch&quot; &#123;</span><br><span class="line">talk = &quot;You are a good boy&quot;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">talk = &quot;hi&quot;</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var peo People = Stduent&#123;&#125;</span><br><span class="line">think := &quot;bitch&quot;</span><br><span class="line">fmt.Println(peo.Speak(think))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">11. interface&#123;&#125; 和 nil</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type People interface &#123;</span><br><span class="line">Show()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (stu *Student) Show() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func live() People &#123;</span><br><span class="line">var stu *Student</span><br><span class="line">return stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">if live() == nil &#123;</span><br><span class="line">fmt.Println(&quot;AAAAAAA&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;BBBBBBB&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面试题二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">1. 因为type只能使用在interface</span><br><span class="line">func main() &#123;</span><br><span class="line">i := GetValue()</span><br><span class="line"></span><br><span class="line">switch i.(type) &#123;</span><br><span class="line">case int:</span><br><span class="line">println(&quot;int&quot;)</span><br><span class="line">case string:</span><br><span class="line">println(&quot;string&quot;)</span><br><span class="line">case interface&#123;&#125;:</span><br><span class="line">println(&quot;interface&quot;)</span><br><span class="line">default:</span><br><span class="line">println(&quot;unknown&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetValue() int &#123;</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.  函数返回值命名 在函数有多个返回值时，只要有一个返回值有指定命名，其他的也必须有命名。 如果返回值有有多个返回值必须加上括号； 如果只有一个返回值并且有命名也需要加上括号； 此处函数第一个返回值有sum名称，第二个为命名，所以错误。这种感觉编辑器会提示，自己没必要做</span><br><span class="line">func funcMui(x,y int)(sum int,error)&#123;</span><br><span class="line">    return x+y,nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. defer 的执行</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">println(DeferFunc1(1))</span><br><span class="line">println(DeferFunc2(1))</span><br><span class="line">println(DeferFunc3(1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc1(i int) (t int) &#123;</span><br><span class="line">t = i</span><br><span class="line">defer func() &#123;</span><br><span class="line">t += 3</span><br><span class="line">&#125;()</span><br><span class="line">return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc2(i int) int &#123;</span><br><span class="line">t := i</span><br><span class="line">defer func() &#123;</span><br><span class="line">t += 3</span><br><span class="line">&#125;()</span><br><span class="line">return t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func DeferFunc3(i int) (t int) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">t += i</span><br><span class="line">&#125;()</span><br><span class="line">return 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 没这么用过，这种都用make</span><br><span class="line">func main() &#123;</span><br><span class="line">list := new([]int)</span><br><span class="line">list = append(list, 1)</span><br><span class="line">fmt.Println(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5.  ...解析来使用</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s1 := []int&#123;1, 2, 3&#125;</span><br><span class="line">s2 := []int&#123;4, 5&#125;</span><br><span class="line">s1 = append(s1, s2)</span><br><span class="line">fmt.Println(s1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6.  结构体比较大小，所有元素都必须比较大小</span><br><span class="line"></span><br><span class="line">而且顺序还得保持一致。 map 不能比较大小，除非用deep equal</span><br><span class="line">func main() &#123;</span><br><span class="line">sn1 := struct &#123;</span><br><span class="line">age  int</span><br><span class="line">name string</span><br><span class="line">&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line">sn2 := struct &#123;</span><br><span class="line">age  int</span><br><span class="line">name string</span><br><span class="line">&#125;&#123;age: 11, name: &quot;qq&quot;&#125;</span><br><span class="line"></span><br><span class="line">if sn1 == sn2 &#123;</span><br><span class="line">fmt.Println(&quot;sn1 == sn2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sm1 := struct &#123;</span><br><span class="line">age int</span><br><span class="line">m   map[string]string</span><br><span class="line">&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line">sm2 := struct &#123;</span><br><span class="line">age int</span><br><span class="line">m   map[string]string</span><br><span class="line">&#125;&#123;age: 11, m: map[string]string&#123;&quot;a&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">if sm1 == sm2 &#123;</span><br><span class="line">fmt.Println(&quot;sm1 == sm2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">7. interface&#123;&#125; 和 nil</span><br><span class="line"></span><br><span class="line">func Foo(x interface&#123;&#125;) &#123;</span><br><span class="line">if x == nil &#123;</span><br><span class="line">fmt.Println(&quot;empty interface&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;non-empty interface&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">var x *int = nil</span><br><span class="line">Foo(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8.  string 和 nil 真的没意思··</span><br><span class="line">func GetValue(m map[int]string, id int) (string, bool) &#123;</span><br><span class="line">if _, exist := m[id]; exist &#123;</span><br><span class="line">return &quot;存在数据&quot;, true</span><br><span class="line">&#125;</span><br><span class="line">return nil, false</span><br><span class="line">&#125;</span><br><span class="line">func main()  &#123;</span><br><span class="line">intmap:=map[int]string&#123;</span><br><span class="line">1:&quot;a&quot;,</span><br><span class="line">2:&quot;bb&quot;,</span><br><span class="line">3:&quot;ccc&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v,err:=GetValue(intmap,3)</span><br><span class="line">fmt.Println(v,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9. 0 1 zz zz 4  这个iota 。 这题还真的要注意下</span><br><span class="line">const (</span><br><span class="line">x = iota</span><br><span class="line">y</span><br><span class="line">z = &quot;zz&quot;</span><br><span class="line">k  </span><br><span class="line">p = iota</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">fmt.Println(x,y,z,k,p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang 面试题三</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">1. := 在函数外部使用，感觉好沙雕的问题</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">var(</span><br><span class="line">    size :=1024</span><br><span class="line">    max_size = size*2</span><br><span class="line">)</span><br><span class="line">func main()  &#123;</span><br><span class="line">    println(size,max_size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. const 不可以寻址</span><br><span class="line">package main</span><br><span class="line">const cl  = 100</span><br><span class="line"></span><br><span class="line">var bl    = 123</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    println(&amp;bl,bl)</span><br><span class="line">    println(&amp;cl,cl)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. goto不能跳转到其他函数或者内层代码</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line"></span><br><span class="line">    for i:=0;i&lt;10 ;i++  &#123;</span><br><span class="line">    loop:</span><br><span class="line">        println(i)</span><br><span class="line">    &#125;</span><br><span class="line">    goto loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 类型别名和相等。我们有的时候定义别名是为了在另一个包中封装更多的方法，否则你想用int， 只能在int 包中封装对应的方法。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    type MyInt1 int</span><br><span class="line">    type MyInt2 = int</span><br><span class="line">    var i int =9</span><br><span class="line">    var i1 MyInt1 = i</span><br><span class="line">    var i2 MyInt2 = i</span><br><span class="line">    fmt.Println(i1,i2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5. *Go 1.9 新特性 Type Alias **</span><br><span class="line">因为MyUser2完全等价于User，所以具有其所有的方法，并且其中一个新增了方法，另外一个也会有。 但是</span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type User struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">type MyUser1 User</span><br><span class="line">type MyUser2 = User</span><br><span class="line">func (i MyUser1) m1()&#123;</span><br><span class="line">    fmt.Println(&quot;MyUser1.m1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func (i User) m2()&#123;</span><br><span class="line">    fmt.Println(&quot;User.m2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i1 MyUser1</span><br><span class="line">    var i2 MyUser2</span><br><span class="line">    i1.m1()</span><br><span class="line">    i2.m2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.  ambiguous selector my.m1</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type T1 struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (t T1) m1()&#123;</span><br><span class="line">    fmt.Println(&quot;T1.m1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">type T2 = T1</span><br><span class="line">type MyStruct struct &#123;</span><br><span class="line">    T1</span><br><span class="line">    T2</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    my:=MyStruct&#123;&#125;</span><br><span class="line">    my.m1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">7.  作用域 ， result, err := tryTheThing() 这行代码，我也被坑过。 重新定义了变量</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var ErrDidNotWork = errors.New(&quot;did not work&quot;)</span><br><span class="line"></span><br><span class="line">func DoTheThing(reallyDoIt bool) (err error) &#123;</span><br><span class="line">    if reallyDoIt &#123;</span><br><span class="line">        result, err := tryTheThing()</span><br><span class="line">        if err != nil || result != &quot;it worked&quot; &#123;</span><br><span class="line">            err = ErrDidNotWork</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func tryTheThing() (string,error)  &#123;</span><br><span class="line">    return &quot;&quot;,ErrDidNotWork</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    fmt.Println(DoTheThing(true))</span><br><span class="line">    fmt.Println(DoTheThing(false))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.  这道题目很牛逼，匿名函数延迟执行</span><br><span class="line"></span><br><span class="line">而且用两种test 让我知道了 for 循环的时候 value 重复赋值的问题，那个value 是真一个变量，但是循环内部 每次 := , 这是两个变量</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func test() []func()  &#123;</span><br><span class="line">    var funs []func()</span><br><span class="line">    for i:=0;i&lt;2 ;i++  &#123;</span><br><span class="line">        funs = append(funs, func() &#123;</span><br><span class="line">            println(&amp;i,i)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return funs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    funs:=test()</span><br><span class="line">    for _,f:=range funs&#123;</span><br><span class="line">        f()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func test() []func()  &#123;</span><br><span class="line">    var funs []func()</span><br><span class="line">    for i:=0;i&lt;2 ;i++  &#123;</span><br><span class="line">        x:=i</span><br><span class="line">        funs = append(funs, func() &#123;</span><br><span class="line">            println(&amp;x,x)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    return funs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">9. 这个问题又要颠覆我的认知了。闭包的变量竟然共享。只有传进去才是自己的吗，感觉闭包只有传值进去才不会发生奇怪的事情，要不然感觉都是地址类型</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">func test(x int) (func(),func())  &#123;</span><br><span class="line">    return func() &#123;</span><br><span class="line">        println(x)</span><br><span class="line">        x+=10</span><br><span class="line">    &#125;, func() &#123;</span><br><span class="line">        println(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    a,b:=test(100)</span><br><span class="line">    a()</span><br><span class="line">    b()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10. 很基础的defer 层层传递，func 如果直接赋值的话是一个 地址类型，如果直接定义的func 不可寻址。</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main1()  &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">       if err:=recover();err!=nil&#123;</span><br><span class="line">           fmt.Println(err)</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           fmt.Println(&quot;fatal&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        panic(&quot;defer panic&quot;)</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;panic&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        if err:=recover();err!=nil&#123;</span><br><span class="line">            fmt.Println(&quot;++++&quot;)</span><br><span class="line">            f:=err.(func()string)</span><br><span class="line">            fmt.Println(err,f(),reflect.TypeOf(err).Kind().String())</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            fmt.Println(&quot;fatal&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    defer func() &#123;</span><br><span class="line">        panic(func() string &#123;</span><br><span class="line">            return  &quot;defer panic&quot;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;()</span><br><span class="line">    panic(&quot;panic&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>golang 面试题四</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">1.在utf8字符串判断是否包含指定字符串，并返回下标。 “北京天安门最美丽” , “天安门” 结果：2</span><br><span class="line"></span><br><span class="line">我的想法是转换成 []rune, 再去判断。</span><br><span class="line"></span><br><span class="line">2.实现一个单例</span><br><span class="line"></span><br><span class="line">3.  panic: send on closed channel</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int, 1000)</span><br><span class="line">go func() &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">a, ok := &lt;-ch</span><br><span class="line">if !ok &#123;</span><br><span class="line">fmt.Println(&quot;close&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;a: &quot;, a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">close(ch)</span><br><span class="line">fmt.Println(&quot;ok&quot;)</span><br><span class="line">time.Sleep(time.Second * 100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. 如果类型实现String()，％v和％v格式将使用String()的值。因此，对该类型的String()函数内的类型使用％v会导致无限递归。 编译报错：</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type ConfigOne struct &#123;</span><br><span class="line">Daemon string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *ConfigOne) String() string &#123;</span><br><span class="line">return fmt.Sprintf(&quot;print: %v&quot;, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">c := &amp;ConfigOne&#123;&#125;</span><br><span class="line">c.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.反转整数 反转一个整数，例如：</span><br><span class="line"></span><br><span class="line">例子1: x = 123, return 321</span><br><span class="line">例子2: x = -123, return -321</span><br><span class="line"></span><br><span class="line">输入的整数要求是一个 32bit 有符号数，如果反转后溢出，则输出 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.</span><br><span class="line">合并重叠区间 给定一组 区间，合并所有重叠的 区间。</span><br><span class="line"></span><br><span class="line">例如： 给定：[1,3],[2,6],[8,10],[15,18] 返回：[1,6],[8,10],[15,18]</span><br><span class="line"></span><br><span class="line">7. 输出 9</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(len(&quot;你好bj!&quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8. 编程报错cannot assign to struct field list[&quot;name&quot;].Name in map。 因为list[“name”]不是一个普通的指针值，map的value本身是不可寻址的，因为map中的值会在内存中移动，并且旧的指针地址在map改变时会变得无效。 定义的是var list map[string]Test，注意哦Test不是指针，而且map我们都知道是可以自动扩容的，那么原来的存储name的Test可能在地址A，但是如果map扩容了地址A就不是原来的Test了，所以go就不允许我们写数据。你改为var list map[string]*Test试试看。所以通过name 我们不能直接取到变量，得整体赋值</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Test struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var list map[string]Test</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">list = make(map[string]Test)</span><br><span class="line">name := Test&#123;&quot;xiaoming&quot;&#125;</span><br><span class="line">list[&quot;name&quot;] = name</span><br><span class="line">list[&quot;name&quot;].Name = &quot;Hello&quot;</span><br><span class="line">fmt.Println(list[&quot;name&quot;])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">9、</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10.</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">//&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const N = 10</span><br><span class="line"></span><br><span class="line">var wg = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; N; i++ &#123;</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">println(i)</span><br><span class="line">defer wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang 面试中涉及到自己的知识盲区, 记录下, 为了以后更好的编程&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://yoursite.com/2021/03/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2021/03/18/数据结构/</id>
    <published>2021-03-18T02:09:23.000Z</published>
    <updated>2021-03-18T03:11:49.230Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看数据结构, 学到的蛮多的。之前总以为数据结构没有意义，平时工作也用到的没有，其实最主要是平时的工作太简单了，涉及不到复杂的逻辑，或者是大数据，高并发，偶尔遇到一些比如 ip 确定省份的问题，直接调用的第三方包，根本不需要自身去做，导致之前的眼界太窄。记录一下学习到的内容。</p><a id="more"></a><p>1.内存结构</p><p>数组： 连续的地址块</p><p>链表： 非连续的地址块，用指针连接</p><p>2.线性结构</p><h3 id="队列-：头部出数据，尾部进数据。"><a href="#队列-：头部出数据，尾部进数据。" class="headerlink" title="队列 ：头部出数据，尾部进数据。"></a>队列 ：头部出数据，尾部进数据。</h3><p>应用范围：</p><p>可以用数组实现，进数据 o(1), 出数据 o(n), 因为其后的所有数据都要向前移动，还涉及到扩容等机制。</p><p>可以用链表实现，</p><p>单链表， 表头head有指针 , 进数据 o(1), 出数据 o(n), 因为要遍历到链表尾部</p><p>双链表，包含头部尾部指针，金数据 o(1), 出数据 o(1).</p><p>包含的方法:</p><p>1.入队列</p><p>2.出队列  （链表删除元素需要注意下操作）</p><p>3.队列是否是空</p><p>4.获取队列长度</p><p>5.获取队列头部元素</p><p>循环队列</p><p>用数组做的队列很容易造成假溢出现象，比如头部元素的删除，尾部元素的加入，会导致内存地址一直向后移动，于是有了循环队列这个东西，比如我们申请了 长度为10 的数组长度，当我们index &gt;9 的时候，我们不申请新的空间 当 0号没有元素的时候，而是直接填充0.</p><p>我们需要两个指针，head （指向头结点）和 tail （指向当前节点的下个位置），为啥不是当前位置，想象一下 没有元素和 有一个元素怎么去区分。</p><p>head == tail， 空队列</p><p>tail + 1 == head  ,满队列，如果不希望浪费一个空间，需要添加一个元素，替代head == tail 到底是空队列还是满队列 。这种添加元素来完成功能很常见，比如 string 的长度，添加一个size， 链表的长度，添加一个size， myisam 数据库引擎中对于数据量的获取，直接有个元素，所以 count 特别快</p><h3 id="栈-：栈顶进数据，栈顶出数据"><a href="#栈-：栈顶进数据，栈顶出数据" class="headerlink" title="栈 ：栈顶进数据，栈顶出数据"></a>栈 ：栈顶进数据，栈顶出数据</h3><p>应用范围：很广泛，比如括号匹配，我们平时程序的调用栈</p><p>可以用数组实现，队列尾部进数据，o(1) 队列尾部出数据 o(1)</p><p>可以用链表实现，链表头进数据 o(1). 链表头出数据 o(1)</p><p>包含的方法:</p><p>1.入栈</p><p>2.出栈  （链表删除元素需要注意下操作）</p><p>3.栈是否是空</p><p>4.获取栈长度</p><p>5.获取栈头部元素</p><p>3.非线性结构</p><h3 id="二叉树-：左右孩子节点"><a href="#二叉树-：左右孩子节点" class="headerlink" title="二叉树 ：左右孩子节点"></a>二叉树 ：左右孩子节点</h3><p>遍历方式</p><p>1.先序遍历 （使用递归）</p><p>2.中序遍历</p><p>3.后序遍历</p><h3 id="堆：首先是个完全二叉树，再者孩子节点一定要小于父节点"><a href="#堆：首先是个完全二叉树，再者孩子节点一定要小于父节点" class="headerlink" title="堆：首先是个完全二叉树，再者孩子节点一定要小于父节点"></a>堆：首先是个完全二叉树，再者孩子节点一定要小于父节点</h3><p>大端堆：堆头元素最大</p><p>小端堆：堆头元素最小</p><p>应用范围： 获取 top 10 元素</p><p>堆排序 ：挨个删除堆头元素。</p><p>1.添加元素进堆。（我们先把元素加到叶子节点上，让其满足完全二叉树，再通过元素比较，比较层数就是树的高度）</p><p>2.元素出堆 （只有从堆头删除元素，才能保证有序，出堆的元素检查是否有左右节点，如果有，就进行元素变动）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看数据结构, 学到的蛮多的。之前总以为数据结构没有意义，平时工作也用到的没有，其实最主要是平时的工作太简单了，涉及不到复杂的逻辑，或者是大数据，高并发，偶尔遇到一些比如 ip 确定省份的问题，直接调用的第三方包，根本不需要自身去做，导致之前的眼界太窄。记录一下学习到的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>网络面试题总结</title>
    <link href="http://yoursite.com/2021/03/08/%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/08/网络面试题总结/</id>
    <published>2021-03-08T12:35:17.000Z</published>
    <updated>2021-03-20T15:03:34.097Z</updated>
    
    <content type="html"><![CDATA[<p>网络方面关于 一些面试题的总结，蛮多涉及到自己的知识盲区，所以总结记录下</p><a id="more"></a><p>计算机网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.应用层  http</span><br><span class="line">2.传输层 tcp/udp</span><br><span class="line">3.网络层  ip</span><br><span class="line">4.数据链路层</span><br><span class="line">5.物理层</span><br></pre></td></tr></table></figure><p>udp 的特点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. UDP 是无连接的，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延。 正因为是无连接的，所以不存在 全双工的探讨（全双工 半双工针对的是连接）。udp 无连接， UDP 支持一对一、一对多、多对一和多对多的交互通信。</span><br><span class="line">2. UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表</span><br><span class="line">3. UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。 （关于字节流 和 报文的区别就是，报文是一个个打包好的数据，自己流需要tcp 自己去打包，也就是数据边界，为什么这样设计 https://blog.csdn.net/peanutwzk/article/details/79999936， 讲的很好，tcp 有自己唯一的传输连接，不需要打包，也能好给数据流切片。）</span><br><span class="line">4. UDP 没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。（tcp 滑动窗口 应答）</span><br><span class="line">5.UDP 的首部开销小，只有8个字节，比 TCP 的20个字节的首部要短 （校验，序列号）</span><br></pre></td></tr></table></figure><p>tcp 的特点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.TCP 是面向连接的运输层协议。应用程序在使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接</span><br><span class="line">2. 每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的(一对一)， 4元组确定一条tcp 连接</span><br><span class="line">3. TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错 （头部有校验字段）、不丢失（每个包都有ack 包）、不重复 （重复确认会丢弃），并且按序到达 （有序列号）</span><br><span class="line">4. TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接受缓存，用来临时存放双向通信的数据</span><br><span class="line">5. 面向字节流。TCP 中的“流”指的是流入到进程或从进程流出的字节序列</span><br></pre></td></tr></table></figure><p>简述三次握手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 服务器进程先创建传输控制块 TCB，并处于监听状态，等待客户端的连接请求 （listen, socket 文件绑定 设备ip + 端口号 port）</span><br><span class="line">2. 客户端创建传输控制块 TCB，并向服务器发出连接请求报文段 (syn_send)</span><br><span class="line">3.服务器收到连接请求报文段后，如同意建立连接，则发送确认报文段 (syn_recv)</span><br><span class="line"> 4.客户端进程收到服务器的确认报文段后，立即回复确认报文段，并进入已建立连接状态 (establish)</span><br><span class="line">5. 服务器收到确认报文段之后，也进入已建立连接状态 (establish)</span><br><span class="line"></span><br><span class="line">为什么是3次不是4次</span><br><span class="line">ack 包中包含了 一次建立连接的请求 syn</span><br><span class="line"></span><br><span class="line">为什么是3次</span><br><span class="line">1，客户端到服务端建立连接请求</span><br><span class="line">2.ack  服务端到客户端连接请求</span><br><span class="line">3. ack</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210320224455.png" alt=""></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210320224632.png" alt=""></p><p>注意 syn 和 ack 是标志位，不要和 seq 和 ack 弄混淆了。</p><p>tcp 释放 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4次挥手</span><br><span class="line"></span><br><span class="line">1. 客户端应用进程发出连接释放报文段，并停止再发送数据，进入 FIN-WAIT-1(终止等待1)状态，等待服务器确认</span><br><span class="line">2. 服务器收到连接释放报文段后即发出确认，进入 CLOSE-WAIT(关闭等待)状态，服务器若发送数据，客户端扔要接收</span><br><span class="line">3. 客户端收到来自服务器的确认后，进入 FIN-WAIT-2(终止等待2)状态，等待服务器发出连接释放报文段</span><br><span class="line">4. 服务器没有要发送的数据，发出连接释放报文段，进入 LAST-ACK(最后确认)状态，等待客户端确认</span><br><span class="line">客户端收到连接释放报文段后，发出确认，进入 TIME-WAIT(时间等待)状态，经过时间等待计时器设置的时间 2MSL 后，进入 CLOSED(关闭) 状态</span><br><span class="line">5. 服务器收到客户端报文段后，进入 CLOSED 状态</span><br></pre></td></tr></table></figure><p>time-wait 是什么，为什么是2mls</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是客户端接收到服务端的信号后等待时间才会释放连接。</span><br><span class="line"></span><br><span class="line">2mls 是数据包在网络上存在的最长时间。我们知道4元组确定一个唯一的tcp 连接，万一发送包之后我们连接断了，这个包按理说不应该到达，而是在网络上有游荡走向毁灭，可是却到了这个新建的tcp连接中，那就完蛋了。</span><br></pre></td></tr></table></figure><p>大量出现time-wait的原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果在2mls 我们大量的断开连接，就会出现大量的time-wait</span><br><span class="line"></span><br><span class="line">怎么避免</span><br><span class="line">1.我们用更多的4元组生成更多的tcp连接</span><br><span class="line">2. 调整参数，直接回收</span><br><span class="line">3.调整参数，直接发送一个rst包，不等待</span><br></pre></td></tr></table></figure><p>tcp粘包问题的出现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp 面向的字节流。</span><br></pre></td></tr></table></figure><p>socket 建立步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建 socket 文件 （我的理解 进程 ）</span><br><span class="line">2. 绑定 socket 到指定地址和端口</span><br><span class="line">3. 开始监听连接 （listen）</span><br><span class="line">4. 读取客户端输入 (传输数据)</span><br><span class="line">5. 关闭 socket</span><br></pre></td></tr></table></figure><p>http状态码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">200 success</span><br><span class="line">304 not modified</span><br><span class="line">400 bad request</span><br><span class="line">401 not auth</span><br><span class="line">403 forbidden</span><br><span class="line">404 not found</span><br><span class="line">499 limit rate</span><br><span class="line">500 服务端错误</span><br><span class="line">502 php-fpm 挂了 代理转发</span><br><span class="line">504 超时</span><br></pre></td></tr></table></figure><p>什么是长连接 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。 其实我感觉短连接也能发送多个数据包，比如php 里面的短连接也是可以复用的，主要感觉就是需要keep alive 保活。也就是心跳检测。</span><br></pre></td></tr></table></figure><p>https 都干了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对称加密传输，https.</span><br><span class="line">秘钥 ？ 公钥加密，私钥解密。保证不被窃听。客户端的公钥怎么发送，通过办法ca证书。ca 私钥加密，公钥解密，保证不被修改，我们得到确定的hash值 和 公钥， 我们把 公钥 hash 后和hash 值对比，类似jwt 那种，观察是否被修改了。</span><br></pre></td></tr></table></figure><p>go 夜读 :  <a href="https://reading.hidevops.io/interview/interview-os/" target="_blank" rel="noopener">https://reading.hidevops.io/interview/interview-os/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">1.Select，Poll，Epoll的区别？</span><br><span class="line"></span><br><span class="line">1. select每次调用select都需要重新想内核传递监听的描述符，浪费了一些开销。 而epoll模型对每个描述符只需要利用epoll_ctl做一次处理，之后epoll_wait阻塞监听时不再需要向内核空间传递要监听哪一些描述符</span><br><span class="line">2. epoll模型并非向select模型那样使用整型数组来表示监听的描述符集，因而能够监听的文件描述符较大</span><br><span class="line">poll模型在实现原理上和select模型差不多，只是在对监听描述符集的描述上有所差异。</span><br><span class="line">poll模型使用struct pollfd结构体描述要监听的描述符集。</span><br><span class="line"></span><br><span class="line">epoll 重要的三个函数</span><br><span class="line">epoll_create用于创建一个额外的文件描述符，该描述符用语标识服务器要监听的事件在内核中对应的事件表。</span><br><span class="line">epoll_ctl 用于操作参数epfd（由之前的epoll_create函数生成）对应的内核事件表，如向事件表中注册、修改、删除事件。</span><br><span class="line">epoll_wait是epoll模型的主要函数，它用于（在超时时间timeout内）阻塞监听是否有我们关注（注册）的事件发生。</span><br><span class="line"></span><br><span class="line">3. select模型在阻塞监听时需要轮询每个监听的文件描述符，而epoll只需要判断就绪队列是否为空。相比之下，在没有监听的事件发生时，epoll能更早地让出系统资源，让CPU调度运行其他进程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.什么叫虚拟内存？</span><br><span class="line">虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的 可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内 存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</span><br><span class="line"></span><br><span class="line">4.Linux什么命令可以查看cpu和内存？怎么查看每个核的cpu呢？</span><br><span class="line">top命令</span><br><span class="line">在top查看界面按数字1即可查看每个核的数据</span><br><span class="line"></span><br><span class="line">6.怎么查看一个端口的TCP连接情况？</span><br><span class="line"></span><br><span class="line">netstat， 很少用了，···现在一般都交给运维做了</span><br><span class="line"></span><br><span class="line">8.介绍一下Tcpdump？</span><br><span class="line">用的少，以前用他分析过redis 数据传输，看pipeline 到底怎么传输数据的</span><br><span class="line"></span><br><span class="line">9.什么叫大端和小端？</span><br><span class="line"></span><br><span class="line">https://www.ruanyifeng.com/blog/2016/11/byte-order.html</span><br><span class="line">一般操作系统都是小端的，而通信协议是大端的 ，电脑是小端的，人接触的是大端的</span><br><span class="line"></span><br><span class="line">11.介绍些僵尸进程和孤儿进程的区别, 怎么产生的, 怎么避免?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 12.CPU 使用率和 CPU 负载有什么区别?</span><br><span class="line"></span><br><span class="line">使用率代表cpu 一直在用，比如4核 400%了，已经不能加任务了，跑不动了，cpu 负载代表任务数量。</span><br><span class="line"></span><br><span class="line">13.客户端在建立异常中发现很多connect reset by peer,你觉得问题出在哪？</span><br><span class="line">三次握手维护的半连接队列或者全连接队列溢出导致</span><br><span class="line"></span><br><span class="line">14.https建立连接的过程?</span><br><span class="line"></span><br><span class="line">15.http，tcp，ip分别处于OSI哪一层？</span><br><span class="line"></span><br><span class="line">传输层协议：TCP、UDP、SCTP</span><br><span class="line">网络层协议：IP、ARP、RARP、ICMP、IGMP、OSPF</span><br><span class="line">应用层协议：http，FTP、SMTP、RIP、DNS</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210320230108.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络方面关于 一些面试题的总结，蛮多涉及到自己的知识盲区，所以总结记录下&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一些思考</title>
    <link href="http://yoursite.com/2021/02/08/%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2021/02/08/一些思考/</id>
    <published>2021-02-08T06:31:58.000Z</published>
    <updated>2021-02-08T09:43:57.267Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了一篇专栏，记录下里面一些问题的思考，好怕像未曾遇到过。</p><a id="more"></a><ul><li><p>乐观锁和悲观锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>讲一讲对Redis 的了解，项目中是如何使用的，在哪个地方使用的，为什么要使用？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工作中其实用到redis 的地方很多，比如 string，我们经常把配置json 化之后存储一份，list 不太重要的任务发送到redis list， 然后用消费者取。hash， 设备的信息存储，比如想获取这个设备最近的访问时间，直接获取这个field。set 集合 sort set 排行榜。比较少的有布隆过滤器，我们双十一有个场景，简化一下就是，我们接了淘宝的红包广告，产品的需求就是用户点击过，这条广告就变灰了。其实客户端做这个很方便，但他们不想做，于是后端做。我们不可能针对每个用户去做个缓存，虽然我们这边机器够，但这也太浪费了，于是我们用布隆过滤器，用设备号做hash， 点过之后，对应字段设置成1。数据量大的时候可能存在没点击过的用户也是灰色图片，但是我们下发的没点击过的图片一定是正确的的。</span><br></pre></td></tr></table></figure></li><li><p>如何保证 Kafka 消息的顺序性，如何解决重复消费问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kafka 只能保证单partition 里面有顺序，所以为了生产的消息有顺序 （单个partition 对应一个consumer，所以消费者获取到消息也是有顺序的），我们只能用单个partition。而且我们的consumer 不能用异步（比如如果我启动了10个goroutine, 就没法保证这10个的顺序性）。但kafka 就是为了分布式而存在，比如他的批量拉取，我们可以在业务层做这个事情，比如我们只要求同一个id 顺序，我们可以把同一个id 提交给同一个partition。</span><br><span class="line">重复消费这是所有消费者应该考虑的问题，不管是rabbit 还是kafka， 比如推送，我们可以针对message id做一个布隆过滤器,每个推送过的用户我们写成1，只有0 的情况才会推送，但这样会不会造成热点key ，又是一个问题？？？？？</span><br></pre></td></tr></table></figure></li><li><p>你能否写一个Rpc框架，什么时候序列化/反序列化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>ES搜索引擎，你在项目哪些功能使用过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">商品详情页的口碑，对于标签字段的聚合。</span><br></pre></td></tr></table></figure></li><li><p>介绍一下自己最近做的一个典型的项目，项目中遇到了哪些问题，自己是如何解决的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>系统支撑的用户量是多少，假如用户量提升10倍，系统会出现什么样的问题，如何优化系统 or 重新设计系统。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如何存放数据到 Redis 集群，介绍一下这个过程，如何处理热点数据问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们这边接触到的热点数据主要是配置项，</span><br><span class="line">1、我们可以做本地缓存，（有一定的延迟）</span><br><span class="line">2、我们把 key 备份多个，打散到redis 多个分片中，分散压力</span><br></pre></td></tr></table></figure></li><li><p>分库分表使用什么算法拆分，简述一下一致性Hash算法原理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一致性hash （围成一个圆，取范围内的数据，造成最小的影响）</span><br><span class="line">2.range </span><br><span class="line">1. 时间片</span><br></pre></td></tr></table></figure></li><li><p>MySQL事务隔离级别和MVCC，事务的底层实现原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>说说 Redis 常用几种类型，各自底层是怎么实现的，项目中如何使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://juejin.cn/post/6844903936520880135#heading-9， 这篇文章对redis 的底层数据结构讲解的很到位</span><br><span class="line">1. sds 动态字符串，redis 中但凡用到字符串的地方，数据结构， len  alloc []buffer, 相比较c （一样的\0 结尾，为了用c的一些函数）。但是用了特殊的编码，所以不担心 \0 会错误的结束</span><br><span class="line">2.链表。 双向链表 list + listNode</span><br><span class="line">3.字典，hash table， 如果 hash 冲突， 单个节点对应list 这样。rehash 是渐进式。</span><br><span class="line">4.跳跃表， 相比较 平衡二叉树，不需要添加数据之后重新平衡，多层索引 logn 的查找效率（有序）。imooc wiki 上的图文很清楚 https://www.imooc.com/wiki/Redis6/chapter32.html。</span><br><span class="line">5.整数集合， int 组成的集合</span><br><span class="line">6.压缩列表，比如 hash 和 list 可能是 ziplist 和 字典组成， ziplist 和 list 组成。和数据量大小有关。</span><br></pre></td></tr></table></figure></li><li><p>Redis 有哪两种备份方式，两种备份方式有何区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.rdb  备份所有数据，会出现时间窗口没备份</span><br><span class="line">2.aof 备份说有的指令</span><br></pre></td></tr></table></figure></li><li><p>数据库和缓存双写一致性问题：先更新数据库再更新缓存，若更新完数据库了，还没有更新缓存，此时有请求过来了，访问到了缓存中的数据，怎么办？（提示：<strong>延时双删策略</strong>）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>说说你对索引的理解，组合索引，索引的最佳实践，你是怎么给你的表设置索引的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>写生产者消费者问题，考虑高并发的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>设计一个发号器，考虑集群和高并发的情况，要求发号器生成的id是递增趋势，通过id可以区分出来是今天生成的id还是昨天生成的id，但是生成的id中不能直接带有日期，要具有一定的混淆功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>讲项目中的难点、挑战，你是如何解决的？画项目架构图，画一个用户从发起请求到接收到响应，中间经过哪些服务。</p></li><li><p>遍历二叉树，不使用递归方法。</p></li><li><p>手写冒泡排序（Bubble Sort）</p></li><li><p>项目中系统监控怎么做的？（可以了解下美团开源的CAT系统，还是很出色的）</p></li></ul><ul><li>MySQL索引底层实现为什么不用B-Tree，红黑树，为什么不用hash。</li></ul><ul><li><p>MySQL默认的事务隔离级别，MVCC、RR怎么实现的？</p></li><li><p>MySQL间隙锁/死锁，写一段会造成死锁的SQL语句，死锁发生了如何解决，如何解决死锁。</p></li><li><p>如何保证Kafka 消息的顺序性，如何解决重复消费问题。</p></li><li><p>项目中如何保证接口的幂等操作，用什么方法。</p></li><li><p>Redis底层数据结构原理？</p></li><li><p>Redis如何实现分布式锁？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  notexiset, exist time</span><br></pre></td></tr></table></figure></li><li><p>说一个你了解最多的中间件框架。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p></li><li><p>如何理解分布式事务，为什么会出现这个问题，如何去解决，了解哪些分布式事务中间件？</p></li><li><p>Redis是单线程的还是多线程的，Redis为什么这么快?</p></li><li><p>Redis Hash中某个key过大，变为String类型的大key，怎么处理，使用中如何避免出现这种问题?</p></li><li><p>Kafka 如何保证消息顺序消费、在consumer group 中新增一个consumer 会提高消费消息的速度吗、那如果我想提高消息消费的速度，我要怎么办？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新增一个consumer 不行，得新增一个partition ，而且还得重新负载均衡。</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li>MySQL事务隔离级别，幻读，脏读，项目中用什么事务隔离级别，为什么？</li><li>对分库分表、读写分离的了解，项目中怎么分的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了一篇专栏，记录下里面一些问题的思考，好怕像未曾遇到过。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>新的起点</title>
    <link href="http://yoursite.com/2021/02/06/%E6%96%B0%E7%9A%84%E8%B5%B7%E7%82%B9/"/>
    <id>http://yoursite.com/2021/02/06/新的起点/</id>
    <published>2021-02-06T02:41:06.000Z</published>
    <updated>2021-02-06T09:06:41.602Z</updated>
    
    <content type="html"><![CDATA[<p>不知道还能在虎扑呆多久, 又要开始漂泊的生活</p><a id="more"></a><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><ul><li>常用的数据结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string : 配置项，json 之后的存储</span><br><span class="line"></span><br><span class="line">hash  :对于对象的存储，比如设备，不需要一次性取出所有的字段内容</span><br><span class="line"></span><br><span class="line">set : 去重</span><br><span class="line"></span><br><span class="line">sortSet :  排行榜</span><br><span class="line"></span><br><span class="line">list  : 队列任务</span><br></pre></td></tr></table></figure><ul><li>lua 的使用</li></ul><ul><li>分布式锁</li></ul><ul><li><p>数据持久化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">RDB 和 aof</span><br><span class="line"></span><br><span class="line">简单说rdb 就是备份数据，aof 是备份指令。</span><br><span class="line"></span><br><span class="line">RDB（Redis DataBase）详解：</span><br><span class="line">RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个 dump.rdb 文件。Redis 重启会通过加载 dump.rdb 文件恢复数据。</span><br><span class="line"></span><br><span class="line">Redis 提供了 SAVE 和 BGSAVE 两个命令来生成 RDB 文件，区别是前者是阻塞的，后者是后台 fork 子进程进行，不会阻塞主进程处理命令请求。载入 RDB 文件不需要手工运行，而是 server 端自动进行，只要启动时检测到 RDB 文件存在 server 端便会载入 RDB 文件重建数据集。当然上面简介中已经提到，如果同时存在 AOF 的话会优先使用 AOF 重建数据集，因为其保存的数据更完整。</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">适合大规模的数据恢复，如果业务对数据完整性和一致性要求不高，RDB 的启动速度更快，是很好的选择。</span><br><span class="line">RDB 文件简洁，它保存了某个时间点的 Redis 数据集，适合用于做备份。你可以设定一个时间点对 RDB 文件进行归档，如果 1s 间隔保存一次快照，这样就能在需要的时候很轻易地把数据恢复到不同的版本。</span><br><span class="line">考虑到磁盘硬件故障问题，RDB 文件很适合用于灾备，因为单文件可以很方便地传输到另外的数据中心。</span><br><span class="line">RDB 的性能很好，需要进行持久化时，主进程会 fork 一个子进程出来，然后把持久化的工作交给子进程，自己不会有相关的 I/O 操作。</span><br><span class="line">缺点：</span><br><span class="line">1、数据的完整性和一致性不高，因为 SAVE 命令执行是有时间间隔的，比如 5min 备份一次，RDB 可能在最后一次备份时宕机，这 5min 的时间窗数据可能丢失。</span><br><span class="line"></span><br><span class="line">2、备份时占用内存，因为 Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件。所以 Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> AOF（Append Only File），Redis 默认不开启。它的出现是为了弥补 RDB 的不足（RDB 可能丢失一个时间窗口的数据），所以它采用日志的形式来记录每个写操作，生成一个 appendonly.aof 文件，并将日志追加到文件末尾。Redis 重启的会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。有点类似 Mysql 的 binlog。</span><br><span class="line"></span><br><span class="line">  优点：</span><br><span class="line"></span><br><span class="line">  AOF 策略最大限度地保证数据不丢失，数据的完整性和一致性更高。</span><br><span class="line"></span><br><span class="line">  缺点：</span><br><span class="line"></span><br><span class="line">  AOF 备份产生的 appendonly.aof 文件较大，数据恢复的时候，也会比较慢，Redis 针对 AOF 文件大的问题，提供重写的瘦身机制。</span><br><span class="line"></span><br><span class="line">  面试官：OK（这不是简单概括了，至于具体配置参数就不问了，这一块用的不多。）</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>redis 为什么快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.单线程不代表一定就慢，单线程有一个最大好处就是节省线程切换的开销，更不用考虑并发读写带来的复杂操作场景，这就大大节省了线程间切换的时间了。</span><br><span class="line"></span><br><span class="line">2.Reids 是基于内存的读写操作，内存肯定比传统磁盘IO数据库快</span><br><span class="line"></span><br><span class="line">3.Reids 核心是基于非阻塞的IO多路复用机制</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>redis 底层数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  string 还是蛮简单的</span><br><span class="line"></span><br><span class="line">  /*  </span><br><span class="line">- 保存字符串对象的结构  </span><br><span class="line">     */  </span><br><span class="line">    struct sdshdr &#123;  </span><br><span class="line">   // buf 中已占用空间的长度  </span><br><span class="line">   int len;  </span><br><span class="line">      </span><br><span class="line">   // buf 中剩余可用空间的长度  </span><br><span class="line">   int free;  </span><br><span class="line">      </span><br><span class="line">   // 数据空间  </span><br><span class="line">   char buf[];  </span><br><span class="line">    &#125;;</span><br><span class="line">    len 变量，用于记录buf 中已经使用的空间长度。</span><br><span class="line">    free 变量，用于记录buf 中还空余的空间，初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现，这样做是为了杜绝C语言中缓冲区溢出的可能性，当我们需要对一个SDS进行修改的时候，Redis 会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS的空间，然后再执行拼接操作。</span><br><span class="line">    buf 字符数组，用于记录我们的字符串（记录Redis）。</span><br><span class="line"></span><br><span class="line">  list 双端链表</span><br><span class="line"></span><br><span class="line">  链表还是常规的普通双端链表，可以支持反向查找和遍历，更方便操作，通过增删节点来灵活地调整链表的长度，双端链表在Redis内部也是被多次使用：</span><br><span class="line"></span><br><span class="line">  事务模块使用双端链表依序保存输入的命令。</span><br><span class="line"></span><br><span class="line">  服务器模块使用双端链表来保存多个客户端。</span><br><span class="line"></span><br><span class="line">  订阅/发送模块使用双端链表来保存订阅模式的多个客户端。</span><br><span class="line"></span><br><span class="line">  事件模块使用双端链表来保存时间事件（time event）。</span><br><span class="line"></span><br><span class="line">  sortSet</span><br><span class="line"></span><br><span class="line">  链表还是常规的普通双端链表，可以支持反向查找和遍历，更方便操作，通过增删节点来灵活地调整链表的长度，双端链表在Redis内部也是被多次使用：</span><br><span class="line"></span><br><span class="line">  事务模块使用双端链表依序保存输入的命令。</span><br><span class="line"></span><br><span class="line">  服务器模块使用双端链表来保存多个客户端。</span><br><span class="line"></span><br><span class="line">  订阅/发送模块使用双端链表来保存订阅模式的多个客户端。</span><br><span class="line"></span><br><span class="line">  事件模块使用双端链表来保存时间事件（time event）。</span><br><span class="line"></span><br><span class="line">  (红黑树和跳跃表分别是什么)</span><br><span class="line"></span><br><span class="line">  红黑树：红黑树的查找效率很高，但是在进行重新平衡时，会涉及到大量节点的变化，因此实现和操作起来都比较复杂。</span><br><span class="line"></span><br><span class="line">  跳跃表：通过简单的多层索引结构，实现简单，且能达到近似于红黑树的查找效率，插入节点（多层插入）不需要像红黑树那样有额外操作。而且跳跃表还能实现范围查找及输出，而红黑树只支持单个元素查找，对于范围查找效率低。</span><br></pre></td></tr></table></figure><p>​</p></li></ul><ul><li><p>缓存策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>FIFO（First In First Out）： 先进先出算法，即先放入缓存的先被移除。</p><p>LRU（Least Recently Used）： 最近最少使用算法，使用时间距离现在最久的那个被移除。</p><p>LFU（Least Frequently Used）： 最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">* redis 集群</span><br><span class="line"></span><br><span class="line">    ![](https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210206122055.png)</span><br></pre></td></tr></table></figure></li></ul><p>master 读  slave 写</p><p>利用raft 算法进行选举</p><p>利用一致性hash 算法进行数据分片</p><p>三机房部署，每个机房有一主一从，即一个 Master 对应一个 Slave ，但是你会发现，机房 1 中的 Master 1 连接的 Slave 在机房 2，机房 2 中的 Master 2 连接的 Slave 在机房 3，机房 3 中的 Master 3 连接的 Slave 在机房 1，这样构成一个环，为什么要这样设计？</p><p>三机房部署（其中一主一从构成一个分片，之间通过异步复制同步数据，一旦某个机房掉线，则分片上位于另一个机房的 slave 会被提升为 master 从而可以继续提供服务） ；每个 master 负责一部分 slot，数目尽量均摊；客户端对于某个 Key 操作先通过公式计算（计算方法见下文）出所映射到的 slot，然后直连某个分片，写请求一律走 master，读请求根据路由规则选择连接的分片节点，</p><p>假设机房 1 的全部机器断电了，1 机房数据都不能访问了吗？这显然是我们不希望的。前面已经说了 Master 负责写，Master 会自动同步到 Slava，如果 Master 写服务宕机，Slave 读服务会被提升为 master ，也就是说机房 1 的数据在机房 2 的 Slava2 上还有备份，数据还在，在宕机的 master 没有恢复前 Slave 要同时承担读写服务，虽然累一点，但是系统仍然能提供服务。</p><p>但是你会发现，单个机房如果距离很远， Master 1 的数据同步到 Slave2 上是跨机房，跨机房同步肯定不如同机房块，这样一来 Slave2 负责的读就会有延迟，Master1 要更新的数据还没有同步到他在另一个机房的备份前，读操作就是不一致的，这样设计牺牲掉一致性（C）。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* redis 雪崩，穿透，击穿</span><br></pre></td></tr></table></figure><p>  雪崩就是指缓存中大批量热点数据过期后系统涌入大量查询请求，因为大部分数据在Redis层已经失效，请求渗透到数据库层，大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p><p>  resolve:</p><p>  1.将缓存失效时间分散开，比如每个key的过期时间是随机，防止同一时间大量数据过期现象发生，这样不会出现同一时间全部请求都落在数据库层，如果缓存数据库是分布式部署，将热点数据均匀分布在不同Redis和数据库中，有效分担压力，别一个人扛。</p><ol><li><p>简单粗暴，让Redis数据永不过期（如果业务准许，比如不用更新的名单类）。当然，如果业务数据准许的情况下可以，比如中奖名单用户，每期用户开奖后，名单不可能会变了，无需更新。</p><p>穿透是指绕过Reids，调用者发起的请求参数（key）在缓存和数据库中都不存在，通过不存在的key，成功穿透到系统底层，大规模不断发起不存在的key检索请求导致系统压力过大最后故障。</p><p>(这个遇到还是蛮常见的，比如我们详情页回去这个商品的口碑数据，因为有的商品就是没有符合规则的口碑，会一直击穿redis 调用es， 压测的时候es扛不住)</p><p>resolve:</p><p>1.分布式布隆过滤器：布隆是BloomFilter音译过来的，Redis 自身支持BloomFilter。</p><p>2.返回空值：遇到数据库和Redis都查询不到的值，在Redis里set一个null value，过期时间很短，目的在于同一个key再次请求时直接返回null，避免穿透。</p><p>击穿 (就是一个key 大量的访问，golang 的 sync包可以解决这个问题，单个请求没返回，剩下的请求都会被阻塞，而不是直接查询db)</p><p>击穿和穿透概念类似，一般是指一个key被穿透，这个key是热点key，同一个key会被有成千上万次请求，比如微博热点排行榜，key是小时时间戳，value是个list的榜单。每个小时产生一个key，这个key会有百万QPS，如果这个key失效了，就像保险丝熔断，百万QPS直接压垮数据库。</p><p>解决办法：</p><p>业界比较常用的做法，是使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。类似下面的代码：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 布隆过滤器</span><br></pre></td></tr></table></figure><p>   BloomFilter：即布隆过滤器。可以用于检索一个元素是否在一个集合中。</p><p>  特点：</p><p>  BloomFilter检索一个元素是否在一个集合中有一定的错误率（很低），但不会漏判。</p><p>  如果判断一个key不在集合中，那一定不在。</p><p>  如果判断一个key存在，那不一定真的在。</p><p>  本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>  相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p>  1.布隆过滤器的特点就是不能删除</p><p>  2.某个内容返回存在不一定存在（hash 碰撞），但是返回不存在就一定不存在。</p><p>  （识货的使用场景，双十一两个广告红包，用户点击之后红包变灰，如果这个小功能对所有用户，比如每天200w的用户，太浪费了，以天为单位做布隆过滤器，用户点击之后把对应位数置为1，用户下次请求，如果返回是0必然没点过，都是白图，如果是1，有概率没点过（hash碰撞，别人点的），但概率不大）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* redis 热点数据</span><br></pre></td></tr></table></figure><p> 关于热点数据问题我有话要说，这个问题我早在刚刚学习使用 Redis 时就从已经意识到了，所以在使用时会刻意避免，坚决不会给自己挖坑，热点数据最大的问题会造成 Reids 集群负载不均衡（也就是数据倾斜）导致的故障，这些问题对于 Redis 集群都是致命打击</p><p>  识货的热点数据：信息流里面标签的展示依赖一个配置项，信息流本身的qps 就比较高，而且信息流在app中的场景也比较多。</p><p>  resolve:</p><p>  1.识货的场景就是多生成几个一样的配置，每次过来随机读取</p><p>  2.对于数据一致性不是那么高的业务，可以将热点 key 缓存到业务机器的本地缓存中，因为是业务端的本地内存中，省去了一次远程的 IO 调用。但是当数据更新时，可能会造成业务和 Redis 数据不一致。(本地缓存也是很好用的)。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"></span><br><span class="line">* redis 大key 问题</span><br></pre></td></tr></table></figure><p> 大的标准</p><ol><li>大：string 类型 value &gt; 10K，set、list、hash、zset 等集合数据类型中的元素个数 &gt; 1000。</li><li><p>超大： string 类型 value &gt; 100K，set、list、hash、zset 等集合数据类型中的元素个数 &gt; 10000。</p><p>识货的金刚位配置，很大。</p><p>拆分，比如20个金刚位，按照顺序拆分成2个配置。</p><p>先说说造成 Reids 集群负载不均衡故障的主要原因：</p></li><li><p>高访问量的 Key，也就是热 key，根据过去的维护经验一个 key 访问的 QPS 超过 1000 就要高度关注了，比如热门商品，热门话题等。</p></li><li>大 Value，有些 key 访问 QPS 虽然不高，但是由于 value 很大，造成网卡负载较大，网卡流量被打满，单台机器可能出现千兆 / 秒，IO 故障。</li><li><p>热点 Key + 大 Value 同时存在，服务器杀手。</p><p>那么热点 key 或大 Value 会造成哪些故障呢：</p></li><li><p>数据倾斜问题：大 Value 会导致集群不同节点数据分布不均匀，造成数据倾斜问题，大量读写比例非常高的请求都会落到同一个 redis server 上，该 redis 的负载就会严重升高，容易打挂。</p></li><li>QPS 倾斜：分片上的 QPS 不均。</li><li>大 Value 会导致 Redis 服务器缓冲区不足，造成 get 超时。</li><li>由于 Value 过大，导致机房网卡流量不足。</li><li>Redis 缓存失效导致数据库层被击穿的连锁反应。</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* redis 热点数据怎么定位（说实话，这个都是dba 在搞的）</span><br></pre></td></tr></table></figure><p>提前获知法：</p><p>  根据业务，人肉统计 or 系统统计可能会成为热点的数据，如，促销活动商品，热门话题，节假日话题，纪念日活动等。</p><p>  2.Redis 客户端收集法：</p><p>  调用端通过计数的方式统计 key 的请求次数，但是无法预知 key 的个数，代码侵入性强。</p><p>  3.Redis 集群代理层统计：</p><p>  像 Twemproxy，codis 这些基于代理的 Redis 分布式架构，统一的入口，可以在 Proxy 层做收集上报，但是缺点很明显，并非所有的 Redis 集群架构都有 proxy。</p><p>  4.Redis 服务端收集：</p><p>  监控 Redis 单个分片的 QPS，发现 QPS 倾斜到一定程度的节点进行 monitor，获取热点 key， Redis 提供了 monitor 命令，可以统计出一段时间内的某 Redis 节点上的所有命令，分析热点 key，在高并发条件下，会存在内存暴涨和 Redis 性能的隐患，所以此种方法适合在短时间内使用；同样只能统计一个 Redis 节点的热点 key，对于集群需要汇总统计，业务角度讲稍微麻烦一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### MQ</span><br><span class="line"></span><br><span class="line">* 用过的mq</span><br></pre></td></tr></table></figure><ol><li>RabbitMQ：Rabbit 科技有限公司开发，使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。(这个是真的方便，消费者随便添加，相比较consumer 对应 partion 的kafka 是真的更加方便， 但是容易堆积)</li><li>RocketMQ：阿里巴巴自主开发，是淘宝内部的交易系统使用了淘宝自主研发的 Notify 消息中间件，使用 MySQL 作为消息存储媒介，可完全水平扩容。（没用过）</li><li><p>Kafka：最初是由领英开发，并随后于 2011 年初开源，并于 2012 年 10 月 23 日由 Apache Incubator 孵化出站。（目前在用，主要是觉得堆积多了没啥影响，具体的问一下运维到底解决了什么痛点）(kafka 可以批量拉数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* 你用过的mq 比较多的场景，为什么用mq</span><br></pre></td></tr></table></figure><p>识货口碑的产生<br>识货是个导流网站，他的所有商品下面绑定了各个出站的渠道，用户可以自行选择任意的出站渠道。我们需要对商品渠道的评价进行爬取， 所以<br>1.第一步就是渠道组会把商品和渠道链接的绑定关系发送给我们，包括渠道下架（口碑下架）和 口碑上架。通过kafka, 为什么不直接通过http呢，因为渠道的变动时间很可能是不均匀的，我们对实时性要求没有那么高，我们没必要在不均匀的时间内对产生的口碑渠道都进行处理。<br>2.拿到消息（渠道url 也就是淘宝店铺地址）之后我们就进行数据爬取。拿回来的数据我们需要进行打标签和打分，之前我们是同步的调用算法接口，但由于算法接口返回过慢导致我们脚本消费速度上不去，导致kafka消息堆积，但其实我们也没法处理，所以也改成异步，我们把消息推送给算法（1 topic），算法处理完再推送给我们(2 topic), 这样我们互相不干扰了，出了问题也好判断是哪方的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 了解一下识货日志的收集</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* mq 的好处</span><br></pre></td></tr></table></figure><p>1.异步，解耦<br>2.发布订阅 （一条消息，可以广播给任意个收听方，Producer 只负责发送消息 Message，Consumer 可随意订阅 Message。就像广播一样，是系统之间跨机房跨机器通讯的主要手段。）<br>3.流量削峰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 消息队列的这些问题怎么解决</span><br></pre></td></tr></table></figure><p>1.消息丢失问题： 任何系统不能保证万无一失，比如 Producer 发出了 10000 条消息，Consumer 只收到了 9999 个消息，万有 1 失，Consumer 能否接受丢一条？如果是订单成功短信可以接受丢一条，就是有一个顾客没有通知到已经发货，但货还是发出去了，如果是支付系统，用户已经付款却因为消息丢失没有通知到订单或物流系统，那恐怕顾客要找你麻烦了。</p><p>2.消息重复问题：如 Producer 发出了 10000 条消息，Consumer 只收到了 10001 条消息，有一条是重复的，业务能否接受一条重复的消息，这个是作为系统设计者要考虑的问题。<br>消息的顺序问题：如 Producer 发送顺序是 123，Consumer 收到的消息是 132，要考虑消费端是否对顺序敏感。(识货需要做的。这个为了避免只能做接口的幂等，比如我们推送业务，每次推送的内容都有一个id， 我们利用 这个id + 推送给的人 作为唯一id ，就不会导致重复推送了)</p><p>3.一致性问题： 如消息丢失问题真的发生且无法找回，会造成两个系统的数据最终不一致，如果消息延迟，会造成短暂不一致。</p><p>4.消息顺序问题，单partition 单 consumer， 发挥不了kafka 的优势。我们可以通过业务去解决顺序问题。比如我们只要求相同id 下的顺序问题，我们可以把某个id 进去取余，发送到唯一的partition 下面。（发送kafak 可以通过 topic messageKey partition 去确定唯一的partition）（比如砍价发送的推送，必然不能染后面的降价通知在前面到达）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* kafka 基础知识</span><br></pre></td></tr></table></figure><p>producer : 生产者<br>consumer ：消费者<br>topic ： 可以理解队列<br>partition: 分区，一个topic 的数据可以在多个partition 上<br>broker： 可以理解成一个服务器的节点，集群包含一个或多个服务器，这种服务器被称为 broker。对应用来说，生产者把消费发出去了，就不管了。消费者慢条斯理地按照自己的速率来消费。这段时间可能有大量消息产生，消费者压力还是在一定范围内。做生产者和消费者之间解耦的就是一个缓存服务 broker。kafka 发出去的消息是存储在服务器上的，通过控制offset 来消费最新的消息，如果offset 提前到 0，就能消费最老的数据了（到底存储多久就看运维设置的多久了）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* kafka 为什么效率高</span><br></pre></td></tr></table></figure><p>1.利用了磁盘连续读写性能远远高于随机读写的特点，内部采用消息的批量处理，zero-copy 机制，数据的存储和获取是本地磁盘顺序批量操作，具有 O (1) 的复杂度，消息处理的效率很高。（用户态-&gt;内核态-&gt;硬盘， 因为数据其实在硬盘上移动就好了，不需要移动到用户态和内核态）</p><p>2.并发，将一个 topic 拆分多个 partition， kafka 读写的单位是 partition，因此，将一个 topic 拆分为多个 partition 可以提高吞吐量。但是，这里有个前提，就是不同 partition 需要位于不同的磁盘（可以在同一个机器）。如果多个 partition 位于同一个磁盘，那么意味着有多个进程同时对一个磁盘的多个文件进行读写，使得操作系统会对磁盘读写进行频繁调度，也就是破坏了磁盘读写的连续性。<br>(kafka 每个partition 对应 consumer， 消息在单个partition 上有序)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ​</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Mysql</span><br><span class="line"></span><br><span class="line">单表数据1000w的时候就要重新考虑规划了。虽然我们的设备表之前看6kw 数据，活的依旧好好的，用的阿里云的rds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 垂直切分，水平切分</span><br></pre></td></tr></table></figure></li></ol><p>垂直切分: 业务切分，比如把设备相关的表都拿到一个单独的库中<br>水平切分： 单表太大，拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 分库分表的好处</span><br></pre></td></tr></table></figure><p>  分库： 提高架构可用性，减少单点故障，有效分担一个库的压力，只分库不分表，常用于读写分离场景，一主多从，主库负责写，从库用于读，从库从主库同步更新数据，保持数据一致，适用于写入少读取多的场景。(这个很常见，我现在还真的对任何人的库都不放心，所以不希望任何人的表在我的库里面)<br>  分表： 把数据分片拆分，多个表数据减少，insert 插入速度提高，读取速度也得以提高。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 什么策略分库分表</span><br></pre></td></tr></table></figure></p><p>  1.对key取模法： 项目中我主要是用的这个方法给user表做的分表。<br>  如采用第三种即分库又分表方法为例，根据userId把3000w最终分6张表，n = 6，userId = 10001 取模（10001% 6 = 5）这条数据落在db_2 第user_4分片上，10002 % 6 = 0，落在db_0 第user_0个分片上，以此类推，（注意：分片数从0计数），可以哈希后再取模，Hash（userId）% n ，此种方法数据分布较均匀。（一致性hash ，<a href="https://juejin.cn/post/6844903750860013576" target="_blank" rel="noopener">https://juejin.cn/post/6844903750860013576</a> 这篇文章讲的好）（提前做好规划，就不会出现需要额外扩建的问题）</p><p>  2.RANGE分区：(这个应该最简单)</p><p>  这个是我额外了解的方法，userId 从0 - 500w一张表，5000001 - 1000w一张表，依此类推。目前没有在项目中使用过此方法，我觉得这个方法在增量表场景中会造成数据分布不均匀，没道理是用此方法。</p><p>  3.时间分区：<br>  这个方法很实用，适用于订单数据拆分，如按天分表，按月分表，按年分表，时间越久的数据被查询的概率就会越低，类似冷热数据分离，比如我用ES给订单数据做归档，就是使用的按月索引。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 分库分表需要考虑的问题 （因为我们用的阿里的drds 服务，所以这些也没有考虑）</span><br></pre></td></tr></table></figure></p><p>  分库分表会带来哪些挑战<br>  分布式ID问题：<br>  在分库分表后，我们不能再使用MySQL的自增主键。因为在插入记录的时候，不同的库生成的记录的自增ID会出现冲突。因此需要有一个全局的ID生成器。系统需要额外的可靠分布式ID生成器服务。</p><p>  分布式事务问题：<br>  分布式事务是分库分表绕不过去的一个坎，因为涉及到了同时更新多个数据库，如何保证要么同时成功，要么同时失败。关于分布式事务，MySQL支持XA事务，但是效率较低。柔性事务是目前比较主流的方案，柔性事务包括：最大努力通知型、可靠消息最终一致性方案以及TCC两阶段提交。但是无论XA事务还是柔性事务，实现起来都是非常复杂的。</p><p>  最低代价动态扩容问题：<br>  记得一次面试中，上家单位是我第一次使用分库分表，也是用户表，我采用的是取模法将1亿用户分8个表，面试官问我，如果你的用户变成2亿3亿甚至更多，8张表远不够，要分成16张表，这是时候你要重新将几亿数据重新刷盘，你觉得这样合理吗？还有没有什么更好的办法？<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* uuid 和 雪花算法 ？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### ES</span><br><span class="line"></span><br><span class="line">* 倒排序，这篇文章讲的挺好 https://www.zhihu.com/question/23202010， 一般我们是通过文档定位关键字，而他是关键字定位文档。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* index 对应库 type 对应表  document 对应记录，现在type 基本没用了</span><br><span class="line">* 使用场景是商品口碑，我们给客户端的接口需要通过标签进行聚合，运营需要通过接口该口碑的商家进行聚合，给商家做画像。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知道还能在虎扑呆多久, 又要开始漂泊的生活&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>es的简单总结</title>
    <link href="http://yoursite.com/2020/12/17/es%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/12/17/es的简单总结/</id>
    <published>2020-12-17T06:07:42.000Z</published>
    <updated>2021-03-28T12:57:50.458Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做商品评论的相关内容，因为数据量比较大，而且后台需要根据内容进行评论匹配的功能，显然用mysql 的 like 不太合适了，我们用的是elasticsearch。</p><a id="more"></a><p>需要注意的几个点:</p><ol><li>es 每条记录都有 id , 这个id 不等同于我们结构体中的id， 需要我们手动指定，如果我们不指定，es 会默认生成一个字符充当id， 当我们用get 请求的时候拼接的id 也是 此id （如果id 重复后插入的会覆盖之前的）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;_index&quot;: &quot;shihuo_other_comment_dgscore_v1&quot;,</span><br><span class="line">        &quot;_type&quot;: &quot;other_comment_dgscore&quot;,</span><br><span class="line">        &quot;_id&quot;: &quot;25135190&quot;,</span><br><span class="line">        &quot;_score&quot;: null,</span><br><span class="line">        &quot;_source&quot;: &#123;</span><br><span class="line">          &quot;id&quot;: &quot;25135190&quot;,</span><br><span class="line">          &quot;channelType&quot;: 23,</span><br><span class="line">          &quot;createTime&quot;: &quot;2020-12-14 16:38:01&quot;,</span><br><span class="line">          &quot;goodsId&quot;: &quot;50021&quot;,</span><br><span class="line">          &quot;mixId&quot;: &quot;o_39007587&quot;,</span><br><span class="line">          &quot;commentDisplay&quot;: &quot;2&quot;,</span><br><span class="line">          &quot;dgScore&quot;: &quot;0.00&quot;,</span><br><span class="line">          &quot;isPhoto&quot;: 0,</span><br><span class="line">          &quot;mixType&quot;: &quot;o&quot;,</span><br><span class="line">          &quot;praise&quot;: &quot;0&quot;,</span><br><span class="line">          &quot;tagIds&quot;: [],</span><br><span class="line">          &quot;innerScore&quot;: &quot;0.00&quot;,</span><br><span class="line">          &quot;content&quot;: &quot;好看，喜欢。&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot;: [</span><br><span class="line">          25135190</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">// 比如我们常用的go包（github.com/olivere/elastic）</span><br><span class="line">中通过 Id 去指定这条记录的id</span><br></pre></td></tr></table></figure><p>2.当我们想获取es 的版本号的时候我们可以发送 get  / 请求，能获取到版本号</p><p>3.es 7 好像废弃了 type 的存在，之前我们可以理解 index 数据库，type 表</p><p>4.es 的那些搜索条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">sort 和 query 是同一个级别的 </span><br><span class="line"></span><br><span class="line">sort 也可以传入多个条件</span><br><span class="line">&#123;</span><br><span class="line">    &quot;sort&quot;:[</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;f1&quot;:&#123;</span><br><span class="line">                &quot;order&quot;:&quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;f2&quot;:&#123;</span><br><span class="line">                &quot;order&quot;:&quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">go 代码：</span><br><span class="line">res1, err := client.Search(indexName).Query(bo).Sort(&quot;innerScore&quot;, false).Sort(&quot;id&quot;, false).Do(context.TODO())</span><br><span class="line">或者：</span><br><span class="line">sortQuery1 := elastic.NewFieldSort(&quot;name&quot;)</span><br><span class="line">sortQuery2 := elastic.NewFieldSort(&quot;age&quot;).Desc()</span><br><span class="line"></span><br><span class="line">searchService := client.Search().</span><br><span class="line">Index(&quot;students&quot;).</span><br><span class="line">SortBy(sortQuery1, sortQuery2)</span><br><span class="line"></span><br><span class="line">// 几种方法的对应 </span><br><span class="line">/id   -&gt; Get().Index()</span><br><span class="line">/_search -&gt; Search().Index()</span><br><span class="line">/_mapping -&gt; Index().Index() , 这个index方法和后面的index方法 不一样的结构体的方法</span><br><span class="line">/_delete -&gt; Delete().Index()</span><br><span class="line">/_deleteByQuery()  传入query 就可以了</span><br><span class="line">/_updatedByQuery() </span><br><span class="line">这个相比较之前的就是和query 级别多了个参数 script， lang 用的painless。 然后如果我们更新的级别比较频繁，建议用</span><br><span class="line">source 代表更新的field 比如 ctx._source.&#123;$k&#125;=params.&#123;$k&#125;;</span><br><span class="line">我们传入一个map 赋值给一个params ，然后循环params用来构成source 字符串 </span><br><span class="line">POST /shihuo_other_comment_dgscore/other_comment_dgscore/25117494/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;filter&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;term&quot;:&#123;</span><br><span class="line">                        &quot;goodsId&quot;:&quot;397&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;script&quot;:&#123;</span><br><span class="line">        &quot;source&quot;:&quot;ctx._source.commentDisplay=params.test;ctx._source.commentDisplay=params.display&quot;,</span><br><span class="line">        &quot;lang&quot;:&quot;painless&quot;,</span><br><span class="line">        &quot;params&quot;: &#123;</span><br><span class="line">               &quot;test&quot;: 11</span><br><span class="line">               &quot;display&quot;: &quot;display&quot;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 大批量更新的时候一定要用params ， 否则会报错。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/_update -&gt; id 更新最简单的方式就是</span><br><span class="line">POST /shihuo_other_comment_dgscore/other_comment_dgscore/25117494/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;: &#123;</span><br><span class="line">    &quot;innerScore&quot;: &quot;0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bulk , bulk 我们提交的数据批量插入，但这个某个失败不会导致我们整体bulk的失败</span><br><span class="line">go 里面大致流程 ：</span><br><span class="line">1.构造一个 bulk client （感觉就是 bulk url）</span><br><span class="line">2. 构造一个 插入的request 数组</span><br><span class="line">3. bulk 多次 add 这个 request ，完事 do 请求一下</span><br></pre></td></tr></table></figure><p>5.我们在构造query 参数中需要注意的几个点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query 第一层无可厚非</span><br><span class="line">bool 第二层，我平时就没用用过非bool 的</span><br><span class="line">第三层有两个 filter 和 must，怎么区分呢，filter 一般用来过滤条件，比如 id = ，terms in， term 这种完全匹配 。filter效率比较高，因为他不会根据sort 去排分，must 一般用在 内容匹配上，一般我会搭配match_parse ,感觉这样更精确。然后 must 和 filter 里面装的是数组，剩下的都是 obj， 这点一定要注意。还有个should 是同一级别的，should [] 中是 or 的关系，但是should 自身和must 还是and 关系,</span><br><span class="line">exists 和 missing 匹配 类似sql 中 is_null.</span><br><span class="line"></span><br><span class="line">go 中怎么使用呢，new boolquery， 然后把这些条件都加进去。</span><br></pre></td></tr></table></figure><p>6.我们在用es 更新的时候不一定马上能刷新，比如删除，比如修改，我们可以用refresh = wait_for, 这个就相当于是同步的，默认是false 是异步的，如果用true 所有的都这样会影响性能。</p><p><a href="https://blog.csdn.net/u011228889/article/details/80855431" target="_blank" rel="noopener">关于刷新</a>, 这篇文章讲的挺好的，其实wait_for 也不是马上刷新，只是加了wait for 之后那个接口会在等待刷新完成之后才返回结果。</p><p>7.es 的聚合功能，我们在口碑中有使用到<a href="https://www.cnblogs.com/leeSmall/p/9215909.html" target="_blank" rel="noopener">这篇文章用法讲的很仔细</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">// 必备的属性，不能缺少</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123; // 属性</span><br><span class="line">    &quot;test&quot;: &#123; // 聚合名称 </span><br><span class="line">      &quot;terms&quot;: &#123;  // 聚合类型 </span><br><span class="line">        &quot;field&quot;: &quot;innerTagIds&quot;, // 字段</span><br><span class="line">        &quot;size&quot; : 2 // 数量</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">  &quot;_key&quot;: &quot;asc&quot;  // 按照key 排序</span><br><span class="line">&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 聚合当中的filter 属性很重要，可以减少我们聚合的次数，比如我们口碑后台就可以两次聚合成一次，减少复杂度。</span><br><span class="line"></span><br><span class="line">go 中 指标聚合的 https://www.tizi365.com/archives/868.html，蛮好用的</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">做口碑后台统计的时候用到的功能，用下面这个举例</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 0,  // 这个地方生产模式可以改成 0， 因为其实我们不需要这部分查询出来的数据</span><br><span class="line">  </span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;term_no_quality&quot;: &#123;  // 分组的名称 </span><br><span class="line">      &quot;terms&quot;: &#123;  // 聚合的模式，其实还有 avg， max， value_count 等多种 </span><br><span class="line">        &quot;field&quot;: &quot;shopId&quot;,</span><br><span class="line">        &quot;size&quot;: 10 , // 限制聚合的桶的个数，因为可能会比较多，我们没必要</span><br><span class="line">         &quot;collect_mode&quot;:&quot;breadth_first&quot; // 这个地方代表聚合的模式， 之前是广度优先，我们可以用深度优先</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &quot;term_shopId&quot;: &#123;  //另一个分组 </span><br><span class="line">      &quot;filter&quot;: &#123;  // 我们可以加上分组的条件，比如我们口碑统计的时候，一次计算需要一个条件，另一次计算不需要这个条件，我们就可以加上这个选项，但加上这个选项之后我们就不能马上加用桶聚合，还是得加上 aggs 的key ，再继续往下写</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;problem&quot;: 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, </span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;term_level&quot;: &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;shopId&quot;,</span><br><span class="line">             &quot;size&quot;: 10</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;aggs&quot;: &#123;</span><br><span class="line">            &quot;term_level_level&quot;: &#123;</span><br><span class="line">              &quot;terms&quot;: &#123;</span><br><span class="line">                &quot;field&quot;: &quot;level&quot;</span><br><span class="line">               </span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8.es 搜索到的内容json转换成我们需要的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if searchResult.TotalHits() &gt; 0 &#123;</span><br><span class="line">// 查询结果不为空，则遍历结果</span><br><span class="line">var b1 Article</span><br><span class="line">// 通过Each方法，将es结果的json结构转换成struct对象</span><br><span class="line">for _, item := range searchResult.Each(reflect.TypeOf(b1)) &#123;</span><br><span class="line">// 转换成Article对象</span><br><span class="line">if t, ok := item.(Article); ok &#123;</span><br><span class="line">fmt.Println(t.Title)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">之前代码中遇到totalhits &gt; 0 ,拿到数据却是0， 主要就是这个each 方法执行失败的 err我不知道怎么抛出来，需要自己打印下，一般是结构体转换失败。</span><br></pre></td></tr></table></figure><p>9.es 中经常遇到的mapping 问题 <a href="https://www.cnblogs.com/Neeo/articles/10585035.html#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%88dynamic%EF%BC%9Astrict%EF%BC%89" target="_blank" rel="noopener">一般都是字段名字写错了</a>, 而且 es 的mapping 设定好修改包括字段类型，就不方便修改了</p><p>10.es 中查询值不存在，试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;bool&quot;:&#123;</span><br><span class="line">            &quot;must_not&quot;:[</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;exists&quot;:&#123;</span><br><span class="line">                        &quot;field&quot;:&quot;innerScore&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11.es 的遍历 。类似redis 的遍历， <a href="https://www.cnblogs.com/WalkOnMars/p/12377313.html，" target="_blank" rel="noopener">https://www.cnblogs.com/WalkOnMars/p/12377313.html，</a> 注意不要用search_type=scan， 直接用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?scroll=1m  // 这个1m 代表1min， 我再次请求中间的时间间隔，快照只会保留着在 1min</span><br><span class="line">&#123;</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &quot;_doc&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>search_type 这种方式早就下线了，上面的scroll 方式效率也很高，因为不排序。</p><p>12.es 想获取分片信息，直接  /shihuo_other_comment_dgscore?pretty， 能获取index 的详细信息，比如6个shard</p><p>13.桶聚合的数据其实是不准确的</p><p>原理看下这篇文章 ：<a href="https://segmentfault.com/a/1190000022025890，" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022025890，</a> 为了让更加准确，用一个shard 显然不合适，所以调大聚合的数据，比如 聚合的时候，termes 里面的size 我使用的是200， 让聚合更加准确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这两个很重要的指标</span><br><span class="line">doc_count_error_upper_bound：表示没有在这次聚合中返回，但是可能存在的潜在聚合结果。（和上面链接中的 d 元素对应下）</span><br><span class="line">sum_other_doc_count：表示这次聚合中没有统计到的文档数。这个好理解，因为ES统计的时候默认只会根据count显示排名前十的分桶。如果分类（这里是目的地）比较多，自然会有文档没有被统计到。</span><br></pre></td></tr></table></figure><p>14.关于es 的更新操作，好久之前在写php 的时候就发现 create 和 update 功能一样，这次特地查了下，es 其实还是分不分更新和整体更新</p><p>部分更新 ：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/partial-updates.html，" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/partial-updates.html，</a> _update 方法，如果没有查询到这个doc( 不同于update_by_query 用的id 索引)， 就更新失败。</p><p>整体更新：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/update-doc.html#update-doc，" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/update-doc.html#update-doc，</a> 这种更新是那种如果不存在就插入，其实还蛮好用的。</p><p>注意上面两种方法参数有一些不一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做商品评论的相关内容，因为数据量比较大，而且后台需要根据内容进行评论匹配的功能，显然用mysql 的 like 不太合适了，我们用的是elasticsearch。&lt;/p&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="http://yoursite.com/categories/elasticsearch/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="es" scheme="http://yoursite.com/tags/es/"/>
    
  </entry>
  
  <entry>
    <title>破解</title>
    <link href="http://yoursite.com/2020/12/11/%E7%A0%B4%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/12/11/破解/</id>
    <published>2020-12-11T03:10:47.000Z</published>
    <updated>2020-12-11T03:13:17.262Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些破解有用的文章</p><h3 id="Navicate"><a href="#Navicate" class="headerlink" title="Navicate"></a>Navicate</h3><p><a href="https://www.jianshu.com/p/e43cfe3fe832" target="_blank" rel="noopener">我用的12</a>, 直接打开那个百度云盘，把对应文件copy到对应安装目录下就好了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一些破解有用的文章&lt;/p&gt;
&lt;h3 id=&quot;Navicate&quot;&gt;&lt;a href=&quot;#Navicate&quot; class=&quot;headerlink&quot; title=&quot;Navicate&quot;&gt;&lt;/a&gt;Navicate&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.jiansh
      
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="破解" scheme="http://yoursite.com/tags/%E7%A0%B4%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>速查笔记</title>
    <link href="http://yoursite.com/2020/07/17/%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/17/速查笔记/</id>
    <published>2020-07-17T03:01:39.000Z</published>
    <updated>2021-01-05T02:57:32.160Z</updated>
    
    <content type="html"><![CDATA[<p>工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-X/--request [GET|POST|PUT|DELETE|…]  指定请求的 HTTP 方法</span><br><span class="line">-H/--header                           指定请求的 HTTP Header</span><br><span class="line">-d/--data                             指定请求的 HTTP 消息体（Body）</span><br><span class="line">-v/--verbose                          输出详细的返回信息</span><br><span class="line">-u/--user                             指定账号、密码</span><br><span class="line">-b/--cookie                           读取 cookie  </span><br><span class="line"></span><br><span class="line">例子:curl -v -XPOST -H &quot;Content-Type: application/json&quot; http://127.0.0.1:8080/user -d&apos;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin1234&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>w10 修改环境变量</p><p>set name=cy</p><p>echo %name% (golang 这些编辑器中想生效，就得重启编辑器)</p><p>公司网络最近谷歌不能访问了，只能 用 www.google.com.hk， 修改默认的搜索引擎</p><p><a href="https://www.jianshu.com/p/94a145564254" target="_blank" rel="noopener">https://www.jianshu.com/p/94a145564254</a></p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20201123170141.png" alt=""></p><p>我们不能修改默认的搜索引擎，比如谷歌，想修改的话只能新建，然后添加默认，下面那些乱七八糟的都能删除了</p><h1 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h1><p>其实一直有个痛点，我们用charles 抓的包之前我不知道咋修改参数，导致我每次想改变请求的时候，我都是copy 到 postman上修改成我想要的请求，这样又有一个痛点就是返回的结果没有直接在手机上展示，不够直观，···可是还能忍</p><p>直到我们现在go 本地开发，客户端的请求是 <a href="http://sh-gateway.xxx.xxx/xxxxx" target="_blank" rel="noopener">http://sh-gateway.xxx.xxx/xxxxx</a>, 而我本地接口是 <a href="http://127.0.0.1:4040/xxxx" target="_blank" rel="noopener">http://127.0.0.1:4040/xxxx</a>, 这个其实前端经常遇到，他们的解决办法是用proxy， 之前我做vue 的时候还不知道这个插件的作用，猜测一下，其实就是类似这个proxy 接收到以后该上线的请求，构造一个新的curl ，发送到新的地址（所以这个proxy 是node 写的~~）</p><p>其实charles 也自带这个功能，我们可以用他的rewrite功能</p><p>tools —&gt; rewrite </p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210105104642.png" alt=""></p><p>上面那个是要匹配的原始url， 如下</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210105104714.png" alt=""></p><p>下面那个是要修改的请求</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20210105104854.png" alt=""></p><p>可以修改 path url， body 等，</p><p>服务端对于客户端请求的ip怎么获取 ？ 还记得以前 看tp源码时候吗，通过x-word-for 之类的header 参数，所以这里我们只要添加对应header 参数就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>gin 的那点事</title>
    <link href="http://yoursite.com/2020/07/17/gin-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2020/07/17/gin-的那点事/</id>
    <published>2020-07-17T02:45:57.000Z</published>
    <updated>2020-07-17T03:01:16.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事</p><a id="more"></a><p>abort ，next 方法</p><p>gin 的中间件和别的中间件还不一样，gin 的中间件没有next 也能正常执行，next 只是控制自己的代码和中间件的代码执行顺序。中间件中用return 不能停止中间件的执行，只能用abort 方法才能停止后面程序的执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>go 小知识点</title>
    <link href="http://yoursite.com/2020/07/14/go-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2020/07/14/go-小知识点/</id>
    <published>2020-07-14T09:57:32.000Z</published>
    <updated>2021-03-28T09:59:26.013Z</updated>
    
    <content type="html"><![CDATA[<p>读源码学到的新的语法，补充自己对go的更多了解</p><a id="more"></a><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>今天在看别人代码的时候发现了一个 interface.([]int) 新用法，以前不知道，这个其实就是断言 assert， 其实php 中也经常用到</p><p>1.go 中目前我接触到断言,取map值的时候 ，a, ok :=  map[“name”],  虽然没有这个ok 也是能正确运行的，比如 a := map[“name”]</p><p>2.interface 断言， interface.([]int), 转换成[]int类型</p><p>3.断言失败会取断言类型的默认值，如果断言失败还是不知道原因可以用reflect.TypeOf获取断言的真正类型。断言失败的时候经常就是胯类型断言，比如你知道一个类型[]map[string]string, 但你收到这个值的时候不能直接断言interface.([]map[string]string), 而是应该 interface.([]interface{}),  for range 每个值断言map[string]string.<strong> 所以能用结构体就用结构体接受吧，要不然每层断言很辛苦  ，曾经断言60行的代码，用结构体 不到10行 就接受了，还不用处理一堆的断言错误</strong>。</p><p>4.关于类型 interface{} 兼容 string， 但不代表 []interface{} 兼容 []string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Can I convert a []T to an []interface&#123;&#125;? ¶</span><br><span class="line">Not directly. It is disallowed by the language specification because the two types do not have the same representation in memory. It is necessary to copy the elements individually to the destination slice. This example converts a slice of int to a slice of interface&#123;&#125;:</span><br><span class="line"></span><br><span class="line">t := []int&#123;1, 2, 3, 4&#125;</span><br><span class="line">s := make([]interface&#123;&#125;, len(t))</span><br><span class="line">for i, v := range t &#123;</span><br><span class="line">    s[i] = v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">还有另一种方式实现转换</span><br><span class="line"></span><br><span class="line">[]interface&#123;&#125;&#123;&quot;11&quot;, &quot;112&quot;&#125;</span><br><span class="line"></span><br><span class="line">notice : []interface&#123;&#125;&#123;v...&#125; , 这样不行的，这样转换的interface slice， 数量总是 1</span><br></pre></td></tr></table></figure><p>5.今个写代码遇到件事， 对于  int 1, 我用 string(int 1) —–&gt; 想直接得到结果，这样是不行的，还是老老实的用 strconv.Itoa,  string 应该直接用在字符类型，比如 rune  []byte 这类 </p><h1 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h1><p>奇怪的现象</p><p>1.最近用slice 总容易写一个bug， 就是make 的时候给定大小，然后append slice， 这样会导致一直往后面插入slice ，而不是从0 开始修改slice 的值。原因就是 make 的时候 len 和 cap 都是 给定的值，每个位置都有自己的默认值，append 的元素已经没地方放了，只会动态扩容 slice 来容纳给更多的内容。</p><p>2.slice 和 map 虽然是地址类型，但是我们 for range 的时候改变值并不会修改自身，原因就是因为for range 的时候是copy 。copy 之后dst 和src 指向的底层 array 不一样，导致指向 dst 和  src 的slice 随意修改都不影响对方。</p><p>3.copy 也有需要注意的地方，就是 src 的len &gt; dst 的len ，并不会copy 全，也就是copy的时候并不会动态扩容</p><p>4.切片的传递属于引用传递，我们日常使用切片也是引用。所以我们在用切片相互赋值的时候，修改某一个可能会影响两一个。原因就是slice 底层指向了同一个数组</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/Image.png" alt=""></p><p>5.我们在什么情况下使用切片不会影响到之前赋值的切片呢，就是在切片动态扩容，改变切片地址指向的时候，比如 append 的时候。因为我们一般切片创建用的 make，make slice  len == cap ，当我们append 的时候必然扩容。</p><p>6.切片是由3个属性决定， 指针 ，len， cap 一般情况下我们 len 和 cap 都一样， 所以会导致我们觉得 指针改变，切片就变化，指针不变，切片就不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func m(modify[]int) []int&#123;</span><br><span class="line">fmt.Printf(&quot;\n %p&quot;, modify)</span><br><span class="line">modify = append(modify, 13)</span><br><span class="line">fmt.Printf(&quot;\n %p \n&quot;, modify)</span><br><span class="line">fmt.Println(len(modify), cap(modify), modify)</span><br><span class="line">return  modify</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">a4 := make([]int, 2,10)</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%p \n&quot;, a4)</span><br><span class="line">m(a4)</span><br><span class="line">fmt.Printf(&quot;%p&quot;, a4)</span><br><span class="line">fmt.Println(a4, len(a4), cap(a4))</span><br><span class="line">&#125;</span><br><span class="line">// 这个例子a4 没有变化，虽然 没有扩容 ，指针没变，一般情况下如果m 方法中我们 m[0] = 12, 这样a4 必然改变、</span><br><span class="line">// 这个例子中 ，虽然没有扩容，但是 cap 和 len 没有通过函数返回，导致即使 a4在 m 方法中没有扩容，指针没改变，m 方法中 append 13 也没有影响 a4 。 仅在m 方法中a4 被影响了一小会,因为受影响的 len 没有返回，所以退出m方法， a4又还原了。这也是 append 必须有接受值的原因才能改变slice</span><br></pre></td></tr></table></figure><p>6.我们var 定义 []int 的时候，[]int 是nil， 所以我们不能给他赋值。但是我们make 的时候，虽然此时没有开辟内存空间，但是point 是有值的。！！！所以如果用var 定义的变量赋值会报address 不存在错误，如果用make 就不会。</p><p>7.for range 的时候只循环len 的内容，不循环cap 的内容</p><h1 id="channel定义"><a href="#channel定义" class="headerlink" title="channel定义"></a>channel定义</h1><p>之前看过对channel 的定义最好不要在全局，之前不知道为啥原因，当时因为想做缓冲channel， 而以为var 没法做，所以一直没用全局channel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var channel = make([]chan task, 10)</span><br><span class="line">// 10 个的缓冲， 然后是 task 组成的chan 的slice</span><br><span class="line"></span><br><span class="line">slice 用make 和 自身 定义的区别</span><br><span class="line">make([]int, 10)  [0 0 0 ..]</span><br><span class="line">[]int&#123;&#125;  就是nil</span><br></pre></td></tr></table></figure><h1 id="goroutine的意义"><a href="#goroutine的意义" class="headerlink" title="goroutine的意义"></a>goroutine的意义</h1><p>把一个任务分成很多部分，每个任务完成的周期很短。多个任务中我们可以通过channel 进行通信。如果我们通过单个channel ，在进行io的时候会阻塞的， 所以我们需要多个channel 来配合多个goroutine。多个goroutine消耗多个channel, 取数据的时候，可以把channel 传入goroutine当中，来消耗特定的channel。投递数据的时候咋办？当往特定的channel 中投递任务，因为go不像php 那样可以拼变量名，我们可以先把多个channel 放在一个数组中，然后通过数组index 去取特定的channel。</p><p>go  slice 结构， （指向array 的指针，len, cap）</p><p>（go 中slice 的改动会及时没有用 &amp; 也会影响自身）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func handle(a []string)  &#123;</span><br><span class="line">a[0] = &quot;bb&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">b := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line"></span><br><span class="line">c := make([]string, len(b))</span><br><span class="line">copy(c, b) // copy 的话就不会影响,注意copy 的时候一定要len 一样，否则会copy不全</span><br><span class="line"></span><br><span class="line">// 这种直接赋值的话， c 的改动会直接影响b</span><br><span class="line">// c := b</span><br><span class="line"></span><br><span class="line">handle(c)</span><br><span class="line">fmt.Println(b, c)</span><br><span class="line"></span><br><span class="line">a := []string&#123;&quot;name&quot;, &quot;str&quot;, &quot;aa&quot;&#125;</span><br><span class="line">sort.Strings(a)</span><br><span class="line"></span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(copy 方便数组的拷贝，不影响原始数组的变动)</p><p>（arr := […]int{1,2,3,4}, arr[1:2:3], start 1 end 2  len 3, 索引的位置）</p><p>// go 中的引用类型</p><p>引用类型和原始的基本类型恰恰相反，它的修改可以影响到任何引用到它的变量。在Go语言中，引用类型有切片、map、接口、函数类型以及<code>chan</code>。</p><p>引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。</p><p>//  go 中经常这样，类型别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Duration int64</span><br></pre></td></tr></table></figure><p>// go 可变参数</p><p>可以变参数，可以是任意多个。我们自己也可以定义可以变参数，可变参数的定义，在类型前加上省略号…即可。</p><p>// 组合类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">name string</span><br><span class="line">email string</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type admin struct &#123;</span><br><span class="line">user</span><br><span class="line">level string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ad:=admin&#123;user&#123;&quot;张三&quot;,&quot;zhangsan@flysnow.org&quot;&#125;,&quot;管理员&quot;&#125;</span><br><span class="line">fmt.Println(&quot;可以直接调用,名字为：&quot;,ad.name) // 能运行</span><br><span class="line">fmt.Println(&quot;也可以通过内部类型调用,名字为：&quot;,ad.user.name) // 能运行</span><br><span class="line">fmt.Println(&quot;但是新增加的属性只能直接调用，级别为：&quot;,ad.level)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 访问权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type user struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Admin struct &#123;</span><br><span class="line">user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user 无法被导出，因为 小写，类似严格访问类型</span><br></pre></td></tr></table></figure><p>// race 检测对共享变量的修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go build -race 10.go</span><br><span class="line"></span><br><span class="line">10.exe</span><br></pre></td></tr></table></figure><p>// sync 包真的是解决并发问题的一个优点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">count int32</span><br><span class="line">wg    sync.WaitGroup</span><br><span class="line">mutex sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg.Add(2) // 计数器</span><br><span class="line">go incCount()</span><br><span class="line">go incCount()</span><br><span class="line">wg.Wait() // 如果信号量不到0 main 进程就一直堵塞</span><br><span class="line">fmt.Println(count)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func incCount() &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">for i := 0; i &lt; 2; i++ &#123;</span><br><span class="line">mutex.Lock() // 只能有一个goroutine 进来</span><br><span class="line">value := count</span><br><span class="line">runtime.Gosched()</span><br><span class="line">value++</span><br><span class="line">count = value</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 很经典的一个关于获取三个url 最快速的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func mirroredQuery() string &#123;</span><br><span class="line">    responses := make(chan string, 3)</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;asia.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;europe.gopl.io&quot;) &#125;()</span><br><span class="line">    go func() &#123; responses &lt;- request(&quot;americas.gopl.io&quot;) &#125;()</span><br><span class="line">    return &lt;-responses // return the quickest response</span><br><span class="line">&#125;</span><br><span class="line">func request(hostname string) (response string) &#123; /* ... */ &#125;</span><br></pre></td></tr></table></figure><h1 id="json-序列化的小问题"><a href="#json-序列化的小问题" class="headerlink" title="json 序列化的小问题"></a>json 序列化的小问题</h1><p>json 协议没有int 类型，只有 number 类型。int 都会被解析成 float64， 注意！！</p><p>上面的描述有bug ，今天一个str  json 反序列化的时候很成功，啥时候会出现上面问题，通过 interface{} 断言的时候。</p><p>json  序列化的时候如果没有这个值，就不给客户端 （比如我们更倾向于返回空对象，而不是一个完整对象，然后值都是空的），可以使用json tag 中的 omitempty </p><p>json 序列化的时候如果不想要这个，可以直接 - （比如密码这类我们不想暴露给客户端，我们只是我们后端struct 使用，并不需要给客户端）</p><p>json 我们也可以用 int 接受 string 类型 （需要注意的是 我们再次 json序列化的时候 还是 string ）</p><p>今天遇到一个很好用json 方法，<a href="https://medium.com/@xfstart07/go-json-%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81-e689522a1f1f" target="_blank" rel="noopener">就当做json 序列化和 反序列化前的操作</a></p><h1 id="url处理"><a href="#url处理" class="headerlink" title="url处理"></a>url处理</h1><p>最近有一个很恶性的需求，就是解析别人填入的url， 再添加一些想要的参数，组成新的url 返回，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">u, err := url.Parse(href)  // 解析成一个url 对象，这个url 对象有个 string() 方法，可以直接输出这个 href</span><br><span class="line">// 获取 query</span><br><span class="line">query := u.RawQuery  </span><br><span class="line">// 解析query</span><br><span class="line">queryMap, err := url.ParseQuery(query) // 返回一个values 对象，是一个 map[string][]string</span><br><span class="line">// go 中一个参数默认对应一个slice， 如果是单个参数，就是slice 的第一位啦</span><br><span class="line">// 这个values 有很多方法，如果想改参数试试 set， 注意参数是[]string, 否则会整体覆盖哦</span><br><span class="line">// 注意map 赋值是不会被修改的，所以还是调用他的方法吧</span><br><span class="line">queryMap.Encode()</span><br><span class="line">u.RawQuery = queryMap.Encode()</span><br><span class="line">// 组成新的query 参数,再赋值下就能得到新的url</span><br></pre></td></tr></table></figure><h1 id="http-请求"><a href="#http-请求" class="headerlink" title="http 请求"></a>http 请求</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>golang 发送http 请求没有 php 那么直接，其实php 也没有那么直接，毕竟curl 那么一大串，只是php 的curl 面向过程，看起来是那么自然，从上而下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">resp, err := http.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line">//</span><br><span class="line">上面的方法编程平时应该用不到，因为我们的请求至少需要一个超时时间吧</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &quot;net/http&quot;</span><br><span class="line">...</span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">resp, err := clt.Get(&quot;http://wwww.baidu.com&quot;)</span><br><span class="line"></span><br><span class="line">// 不是那么丝滑，需要用客户端发送请求，但又是那么的符合生活，像我们平时请求就应该有个客户端</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 本质</span><br><span class="line">req, err := http.NewRequest(&quot;GET&quot;, &quot;http://www.baidu.com&quot;, nil)</span><br><span class="line"></span><br><span class="line">//然后http.client 结构体的 Do 方法</span><br><span class="line">//http.DefaultClient可以换为另外一个http.client</span><br><span class="line">resp, err := http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure><p>评论 ：Go的get请求面上有好几种请求方式，实则只有一种：</p><p>1、使用<code>http.NewRequest</code>函数获得<code>request</code>实体</p><p>2、利用<code>http.client</code>结构体的<code>Do</code>方法，将<code>request</code>实体传入<code>Do</code>方法中。</p><h2 id="post"><a href="#post" class="headerlink" title="post"></a>post</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line">resp, err := http.Post(&quot;xxxxxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">注意这个body 是个io.reader. 通过这个strings.NewReader 转变来，显然，这个方法的参数是 strings</span><br><span class="line">// 当我们的content-type 是 application/ json, 我们这块就不能用 data.Encode 了而是应该用 json .Marc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">var r http.Request</span><br><span class="line">r.ParseForm()</span><br><span class="line">r.Form.Add(&quot;xxx&quot;, &quot;xxx&quot;)</span><br><span class="line">body := strings.NewReader(r.Form.Encode())</span><br><span class="line">http.Post(&quot;xxxx&quot;, &quot;application/x-www-form-urlencoded&quot;, body)</span><br><span class="line"></span><br><span class="line">// 这种form 请求之前在js 里面用的很经常，简单哇</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">http.PostForm(&quot;xxxx&quot;, data)</span><br><span class="line"></span><br><span class="line">// golang 封装的postForm</span><br></pre></td></tr></table></figure><p>当然上面的方法本质上也是用client 发出来的</p><p>然后client 本质也是依靠 newRequest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">data := url.Values&#123;&quot;start&quot;:&#123;&quot;0&quot;&#125;, &quot;offset&quot;:&#123;&quot;xxxx&quot;&#125;&#125;</span><br><span class="line">body := strings.NewReader(data.Encode())</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">req.Header.Set(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure><p>!!!notice</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">添加request header</span><br><span class="line">net/http包没有封装直接使用请求带header的get或者post方法，所以，要想请求中带header，只能使用NewRequest方法。</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">req, err := http.NewRequest(&quot;POST&quot;, &quot;xxxxx&quot;, body)</span><br><span class="line">//此处还可以写req.Header.Set(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line">req.Header.Add(&quot;User-Agent&quot;, &quot;myClient&quot;)</span><br><span class="line"></span><br><span class="line">clt := http.Client&#123;&#125;</span><br><span class="line">clt.Do(req)</span><br></pre></td></tr></table></figure><p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。</p><p>有一点需要注意：在添加header操作的时候，<code>req.Header.Add</code>和<code>req.Header.Set</code>都可以，但是在修改操作的时候，只能使用<code>req.Header.Set</code>。<br>这俩方法是有区别的，Golang底层Header的实现是一个<code>map[string][]string</code>，<code>req.Header.Set</code>方法如果原来Header中没有值，那么是没问题的，如果又值，会将原来的值替换掉。而<code>req.Header.Add</code>的话，是在原来值的基础上，再<code>append</code>一个值，例如，原来header的值是“s”，我后<code>req.Header.Add</code>一个”a”的话，变成了<code>[s a]</code>。但是，获取header值的方法<code>req.Header.Get</code>确只取第一个，所以，如果原来有值，重新<code>req.Header.Add</code>一个新值的话，<code>req.Header.Get</code>得到的值不变。</p><p>其实不止是header 会这样，query 参数也会这样。</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">&quot;io/ioutil&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br><span class="line">content, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">respBody := string(content)</span><br></pre></td></tr></table></figure><p>获取返回值</p><h2 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h2><p>go sort 已经有人封装好包了，相比较自己写快排，冒泡的好处就是，这个包会根据效率自动选择合适的排序方式，我们需要做的就是实现sort 中的接口 （<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）" target="_blank" rel="noopener">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter03/03.1.html）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Len()  获取要排序的slice 的len</span><br><span class="line">Less() return s[i] &lt; s[j]  默认倒序</span><br><span class="line">Swap(i, j int) 交换  // s[i], s[j] = s[j],s[i]</span><br><span class="line"></span><br><span class="line">sort.Sort([]object)</span><br></pre></td></tr></table></figure><p>对于倒序，很简单的实践方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.Sort(sort.Reverse([]object)) // 帮我们少写了好多代码</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面的用法得写一堆东西，还有简单的方式</span><br><span class="line"></span><br><span class="line">直接调用  sort.Slice() 方法</span><br></pre></td></tr></table></figure><h2 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a>runtime.Caller</h2><p>在调用公司组件的时候，发现log 输出信息有问题，错误行号和文件是上一层函数调用，而不是我想输出的地方的调用。问题就出在，runtime.Caller(skip), 这个参数，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">for i:=0; i&lt;=4; i++ &#123;</span><br><span class="line">_, file, line, _ := runtime.Caller(i)</span><br><span class="line">fmt.Println(file,line,&quot;=====&quot;,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果 caller(i)  i 是 0 的时候，就是当前文件的输出，因为这个方法被封装了，所以，不管我在项目  // 中哪个地方调用，每次输出内容都是一样的。</span><br><span class="line">//   试试不调用组件，在单独文件中 runtime.Caller(i) 输出试试，就会发现当i = 0 时候这个方法的真  // 正含义。</span><br><span class="line"></span><br><span class="line">// 看看beego 中获取行号和文件名的方法</span><br><span class="line"></span><br><span class="line">func FILE() string &#123;</span><br><span class="line"></span><br><span class="line">    _, file, _, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return file</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// __LINE__ returns the line number at which the function was invoked</span><br><span class="line"></span><br><span class="line">func LINE() int &#123;</span><br><span class="line"></span><br><span class="line">    _, _, line, _ := runtime.Caller(1)</span><br><span class="line"></span><br><span class="line">    return line</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skip 1 ,仅仅跳出当前方法所在的文件，因为他仅仅封装了一层</span><br></pre></td></tr></table></figure><p><a href="https://studygolang.com/articles/3116" target="_blank" rel="noopener">https://studygolang.com/articles/3116</a>, 这篇文章对 call 和 calls 方法讲解的比较细致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pc := make([]uintptr, 1024)</span><br><span class="line">for skip := 0; ; skip++ &#123;</span><br><span class="line">    n := runtime.Callers(skip, pc)</span><br><span class="line">    if n &lt;= 0 &#123;</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(&quot;skip = %v, pc = %v\n&quot;, skip, pc[:n])</span><br><span class="line">&#125;</span><br><span class="line">// 当我们调用 callers 方法的时候，pc 这个array 的容量一定要足够大，否则 n 一直不会渠道数据</span><br><span class="line">// runtime.FuncForPC(pc[skip]).FileLine(pc[skip]) , 这个方法比较好玩，从上面calles 获取   //到的指针连获取对应方法的方法名和 函数</span><br></pre></td></tr></table></figure><p><a href="https://colobu.com/2018/11/03/get-function-name-in-go/" target="_blank" rel="noopener">https://colobu.com/2018/11/03/get-function-name-in-go/</a>, 这篇文章也对上面两个方法做了详细的解释</p><h2 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h2><p>429  ，限流了</p><p>499 ， 服务端返回的时间超出客户端设置的超时时间，到这客户端提前关闭</p><h2 id="fmt问题"><a href="#fmt问题" class="headerlink" title="fmt问题"></a>fmt问题</h2><p>平时为了打印结构体我们就用 fmt.printf(“%+v”), 但当我们用[]<em>struct 的时候，这个打印就不好使了，会直接打印内存地址（我们为啥要用</em>struct， 因为遍历的时候 struct 不能修改值）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type Stu struct &#123;</span><br><span class="line">Name string `json:&quot;name&quot;`</span><br><span class="line">Age string `json:&quot;age&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*func (t *Stu)String()  string&#123;</span><br><span class="line">return &quot;11&quot;</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">str := `</span><br><span class="line">[&#123;&quot;name&quot;:&quot;12&quot;&#125;]</span><br><span class="line">`</span><br><span class="line">var students []Stu</span><br><span class="line"></span><br><span class="line">err := json.Unmarshal([]byte(str), &amp;students)</span><br><span class="line"></span><br><span class="line">for _, v := range students &#123;</span><br><span class="line">v.Name = &quot;xiugia111&quot;</span><br><span class="line">v.Age = &quot;1111&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(&quot;%+v &quot;, students[0], err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 为了让修改生效，我们必须让 students []*Stu</span><br><span class="line">// 但这样之后我们打印 []*Stud 就是内存地址，我们需要哥 *Stu 定义 string() 方法，这样就能 fmt // 直接打印了</span><br></pre></td></tr></table></figure><h1 id="Kafka使用"><a href="#Kafka使用" class="headerlink" title="Kafka使用"></a>Kafka使用</h1><h1 id="Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）"><a href="#Es使用-（olivere-elastic-v6，我们的es-是6-x-版本，所用的v6）" class="headerlink" title="Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）"></a>Es使用 （olivere/elastic.v6，我们的es 是6.x 版本，所用的v6）</h1><p>今天在使用es 的时候，想起了之前使用redis 的时候有not found 的判定，找了下 果然这个es 包中也有。只是这个es 包判定not found 用的是方法，原理是 http 请求的code，相比较redis， 感觉这个更靠谱些。</p><h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><p>time 很实用的一个方法， time.Since 可以获取时间差</p><p><a href="https://www.jianshu.com/p/f809b06144f7" target="_blank" rel="noopener">https://www.jianshu.com/p/f809b06144f7</a>, 时间的很好的一个文章</p><p>timer :  延迟触发，只触发一次。 可以重置</p><p>ticker : 多次执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// timer</span><br><span class="line">        d := time.Duration(time.Second*2)</span><br><span class="line"></span><br><span class="line">        t := time.NewTimer(d)</span><br><span class="line">        defer t.Stop()</span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line">                &lt;- t.C</span><br><span class="line"></span><br><span class="line">                fmt.Println(&quot;timeout...&quot;)</span><br><span class="line">// need reset</span><br><span class="line">t.Reset(time.Second*2), // 如果没有这个reset 就deadlock了</span><br><span class="line">        &#125;</span><br><span class="line"> // ticker , 这个随便获取</span><br><span class="line">  t := time.NewTicker(3*time.Second)</span><br><span class="line">        defer t.Stop()</span><br><span class="line"></span><br><span class="line">        fmt.Println(time.Now())</span><br><span class="line">        time.Sleep(4*time.Second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for &#123;</span><br><span class="line"></span><br><span class="line">                select &#123;</span><br><span class="line"></span><br><span class="line">                case &lt;-t.C:</span><br><span class="line"></span><br><span class="line">                        fmt.Println(time.Now())</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h1><p>go 中 error 的处理还是没有总结出什么好的办法，目前想到的就是公用的方法，统一内部自己处理异常，当然也会抛出去，外层就可以不用处理了。</p><p>几种error 可以不处理的场景:</p><p>1.断言失败，有默认值的</p><p>2.调用方法，失败了error有返回，对于int float 这些都有默认的返回值。但对于一些结构体，还是要给默认值的，否则可能会是nil</p><p>3.思考一下我在项目中error 的处理方式。一般有问题，都在最底层的服务统一处理，因为一层层的往上抛，感觉日志记录可能重复，详见我的third 包调用 第三方的处理方式。但是我的service中， error 一般都没处理，一般是抛给了 controller 处理，因为我的service 虽然按道理也是公共的，但是调用方其实很少，当时考虑的也不太周到，所以都是交给controller 处理。</p><p>error 几种常见需要解决的问题</p><p>1.wrap ，我经常要 对错误信息添加，比如对发生错误时候的参数进行记录。</p><p>2.判断两个error 是否相等。我们需要注意的是 error 是地址类型 （可以通过 reflect 获取 ），所以两个error 完全相等必须是同一个变量，而不只是 new 里面的内容相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var UserSexNil = errors.New(&quot;未查到该用户信息！&quot;)</span><br><span class="line"></span><br><span class="line">// 然后我们通过 err == UserSexNil 判断</span><br></pre></td></tr></table></figure><p>go 1.13 之后又很完美的方式解决我上面的蛋疼问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fmt.Error(&quot;%w xxx&quot;, errors.New(&quot;old error&quot;)) // 这个新生成的error 就是old error + 自定义的xx信息， 但此时我们要判断是否是old error 生成，需要调用特殊的方法</span><br><span class="line"></span><br><span class="line">errors.Is(newError, oldError)</span><br><span class="line"></span><br><span class="line">当我们要断言某种错误的时候， 这个我其实用的很少，可以通过 errors.As() 来断言获取到对应的内容，因为要赋值</span><br></pre></td></tr></table></figure><p><a href="https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html" target="_blank" rel="noopener">这篇文章讲的很好</a></p><p>引申: 看了这个想到了怎么对interface 类型执行，可以</p><h1 id="静态文件引入"><a href="#静态文件引入" class="headerlink" title="静态文件引入"></a>静态文件引入</h1><p>php 中对于静态文件引入很容易，定义个相对路径就好了，但是我们go 微服务不可以（不是所有的都不可以）， 我们go 的执行方式是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec /app/&quot;$@&quot; -conf /app/config.yaml</span><br><span class="line"></span><br><span class="line">// 这个 @是个二进制文件（也就是build之后生成的文件），我们在go 中获取到的执行路径就是 当前路径，所以一旦修改了这个二进制文件地址，这个相对路径就不生效了， 所以这块有两种方式</span><br><span class="line">1. 相对路径改成绝对路径，我们把我们的文件也copy到文件中某个位置，然后用绝对路径</span><br><span class="line">2. go build 只会对go 结尾文件生效，我们利用第三方包把我们的静态文件也打包成go 文件，这样我们就能取到这个文件了</span><br><span class="line"></span><br><span class="line">// 对于静态文件打包成go 文件可以试一下这个包</span><br><span class="line">go-bindata， 我其实就用到他的压缩，然后获取内容用的 Asset方法， 可以看一下生成的</span><br></pre></td></tr></table></figure><h1 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h1><p>indirect , 可能是我平时直接 go get 获取的，项目中用不到</p><p>go.sum  <a href="https://studygolang.com/articles/25658" target="_blank" rel="noopener">https://studygolang.com/articles/25658</a>, 这篇文章讲的很好。 go.mod 中只是我们直接import 的文件，go.sum 中存在依赖的依赖。 那串hash 主要用来校验，防止别人修改代码。go 中发布是可以删除tag 修改代码再发布的，这样就会导致你之前依赖的代码可能被别人修改过，而你不知道，这时候go.sum 就会发挥用处。</p><p>go.sum 也是个文件，可能存在conflict， 而且他还是类似 log 日志的那种存在。如果冲突，我们可以都保留，或者保留最新的，反正只是个验证作用。</p><p>如果实在通不过，难道真的是包作者删除 tag，再重新打包？ ~~</p><h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><p>1.一些公共变量在框架init 的时候初始化，但这个变量应该放在哪？我开始是放在main 文件中，但有个很坑爹的时候，service 对于main 中变量引入不了，一来是因为循环依赖（比如 a 依赖b， b反过来也引入a），我们可以开一个单独的包，定义这个公共变量，并且 包含 自身init 函数</p><p>2.今天听大佬分享 公共pool 中对象被耗尽的问题，如何解决？ （最近接的案例就是我们的redis pool 被耗尽了）。1.池子里面对象尽可能给多，2.池子里面对象取出来尽快还回去。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读源码学到的新的语法，补充自己对go的更多了解&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go 包的学习</title>
    <link href="http://yoursite.com/2020/07/03/go-%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/03/go-包的学习/</id>
    <published>2020-07-03T06:41:03.000Z</published>
    <updated>2020-07-03T06:47:03.682Z</updated>
    
    <content type="html"><![CDATA[<p>go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们</p><a id="more"></a><p>math/rand</p><p>随机数我们经常用到，php 中rand(), 就能生成一个随机数，但是go中不行，详见 <a href="https://blog.sqrtthree.com/articles/random-number-in-golang/" target="_blank" rel="noopener">https://blog.sqrtthree.com/articles/random-number-in-golang/</a></p><p>这篇文章的解释。php 中也有seed 的概念，不太清楚php中默认seed 是什么，因为一直改变，导致rand() 产生的随机数一直在变，我们可以通过函数设置seed 固定，这样rand 产生的随机数就不变了</p><p>ps: seed 并不是 rand 产生随机数从上限的概念，应该是随机数算法中用到的。还有go rand产生的随机数好像都是从1 开始的，比如我们想从5 开始，可以给产生的随机数都 + 5， 就能满足需求了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-并发</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/07/02/go-并发/</id>
    <published>2020-07-02T13:56:22.000Z</published>
    <updated>2021-01-11T09:10:04.013Z</updated>
    
    <content type="html"><![CDATA[<p>这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较php 的多进程 （process）和 java的多线程（thread）更轻量。</p><a id="more"></a><p>我们在我们项目代码中可以随意的通过 go func（）{} （） 生成一个goroutine， 不同的goroutine 可以执行不同的逻辑，我们的主进程也可以看成一个goroutine，他会不等待 其他的goroutine, 如果main 执行完了，其他的goroutine 会自动结束，不管有没有执行完， 所以我们经常在代码的尾部，sleep ，等待其他goroutine执行完。但这只是demo，真正工作中无法知道一个goroutine 要执行的时间，比如 curl的返回，多种方法可以解决上述的问题，等待goroutine 执行完。</p><ul><li>我们可以通过go 的sync 包，同步阻塞，等待所有的goroutine 执行完。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决goroutine 一起完成我们引入了</span><br><span class="line">w sync.WaitGroup</span><br><span class="line"></span><br><span class="line">// 添加4个goroutine</span><br><span class="line">w.add(4)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">  defer w.Done()</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">// 完成</span><br><span class="line">w.Wait()</span><br></pre></td></tr></table></figure><p>sync.waitGroup 只是让goroutine 在没有channel 的执行下也阻塞住了，等待goroutine的执行，但并没有解决线程安全的问题。线程安全解决方式</p><p>1.互斥锁。但比如 web， 读多写少，互斥锁并不是很友好。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决读写不一致问题</span><br><span class="line">// 互斥锁</span><br><span class="line">r sync.Mutex</span><br><span class="line"></span><br><span class="line">r.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.Unlock()</span><br><span class="line"></span><br><span class="line">// 注意这个锁是针对代码的，而不是针对资源的，同一时刻只能有一个goroutine能执行</span><br><span class="line">// 我们不能随便用 defer r.Unlock() , 当锁不存在的时候会报错</span><br><span class="line">// 互斥锁有时候太严格，比如两个读操作，并不需要等待</span><br></pre></td></tr></table></figure><p>2.读写锁。相比较互斥锁，只是读写互斥，读读不互斥，更友好点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决上述问题，出现了读写锁</span><br><span class="line">r Sync.RWMutex</span><br><span class="line"></span><br><span class="line">// 读锁</span><br><span class="line">r.Rlock()</span><br><span class="line">r.RUnlock()</span><br><span class="line"></span><br><span class="line">// 写锁</span><br><span class="line">r.Lock()</span><br><span class="line">r.Unlock()</span><br><span class="line"></span><br><span class="line">// 相比于普通锁 (读写锁性能更高，因为两个读锁之间不会互斥)</span><br><span class="line">r Sync.Mutex </span><br><span class="line"></span><br><span class="line">r.Lock()</span><br><span class="line">r.Unlock()</span><br></pre></td></tr></table></figure><p>3.并发安全的map。</p><p>4.data++ 这种操作原来也会出现线程不安全问题 。除了锁之外，还可以通过原子性操作解决并发问题</p><ul><li>通过channel ，我们在channel 的使用过程中经常会发生死锁问题，这恰恰是我们可以通过channel 等待goroutine 执行的关键所在。</li></ul><p><a href="https://studygolang.com/articles/18800" target="_blank" rel="noopener">https://studygolang.com/articles/18800</a></p><p>这篇文章很好的解释了channel 造成死锁的几个原因。</p><p><a href="https://juejin.im/post/5d216f07e51d4550bf1ae8e0" target="_blank" rel="noopener">https://juejin.im/post/5d216f07e51d4550bf1ae8e0</a></p><p>掘金的这篇文章比较简单，但也说明了channel的几个使用场景。</p><p>关于并发：</p><p>首先想说一下关于并发的场景，其实并发在生活中很常见，只要用户量足够多，同一时刻很可能有两个人在做同样的事情，但这不是高并发，高并发常见的场景就是秒杀的时候，很多用户在某一个时刻被召集起来争抢有限的资源。总结：就是某一时刻某个api 被大量请求，这就是我们压测的原因， 在高并发的情况下我们的服务是否稳定。</p><p>其实很多时候我们的接口在高并发下其实没啥影响，比如幂等的接口（获取某个后台配置），只要我们的服务器撑得住，多少的并发量不是问题，这不是目前我想表达的并发，想说的是非幂等性接口在高并发下的危险性，比如秒杀情况下的超卖。为什么会出现超卖，就是我们在获取数据的同时并不是立马就能处理逻辑，比如在我们减少库存的途中，另一个请求先完成了，导致库存数已经为0了，这时候虽然我们之前的库存1 ，减少为0 合情合理，但其实我们在减少库存1的时候库存数量已经是0了，我们并不知道，所以实际库存已经是 -1了，这就是超卖。</p><p>这个库存可以类比到我们代码中就是公共变量，在lnmp的架构中，因为我们的webserver其实是 fpm提供的，fpm 会有多个进程，每个进程中有php，我们的业务代码存在于每个进程中，每当请求结束，这个进程中的变量生命周期就结束了，这种同步模式不存在公共变量读写不一致问题，唯一可能的就是我们从第三方中间件比如redis 比如 mysql中数据读写不一致问题，一般是redis ，所以就有了 redis + lua 的 原子性操作。</p><p>而在go 中，当我们用go 的 net/http 包做webserver 的时候，对于全局变量，不同的goroutine会存在读写不一致问题， 这时候我们就会引入sync 包</p><p>模拟并发的出现也是个技术活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样正常情况下不会发生超卖，因为间隔时间太短</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">     time.Sleep(5 * time.Second)  // 睡个5s ，必然出现</span><br><span class="line">     </span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go 对于并发问题的解决，经常用到goroutine,我们用goroutine 经常会造成 死锁，我们来分析一下这些原因</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">result:=make(chan int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">sum:=0</span><br><span class="line">for i:=0;i&lt;10;i++&#123;</span><br><span class="line">sum=sum+i</span><br><span class="line">&#125;</span><br><span class="line">result&lt;-sum</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Print(&lt;-result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不会造成死锁，以上示例使用一个单独的goroutine求和，当得到结果时，存放在result这个chan里，然后供main goroutine读取出来。当result没有被存储值的时候，读取result是阻塞的，所以会等到结果返回，协同工作，通过chan通信。</span><br><span class="line"></span><br><span class="line">// 如果这个 &lt;- result 是写在go func 上面，就会造成，因为一直阻塞在读取 chan 处，并不会执行到协程处，就会造成死锁</span><br><span class="line"></span><br><span class="line">// 死锁发生的原因就是 主协程被阻塞住，然后也没有办法解决这种状态</span><br><span class="line">// 不管是主协程还是从协程，但凡从channel 读取数据，读取不到都会被阻塞住，之所以 从协程堵塞住不会死锁是因为不会影响主协程的执行。当主协程塞数据进去的时候从协程就能执行了。</span><br><span class="line">// 上面的特性又引入了另一个不通过 sync包而让主协程等待其他协程全都执行完了再往下执行的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logicCount := 5</span><br><span class="line">finishChannel = make(chan bool, logicCount)</span><br><span class="line"></span><br><span class="line">for i:=0;i&lt;logicCount; i++ &#123;</span><br><span class="line">  go func() &#123;</span><br><span class="line">    finishChannel &lt;- true</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for i:=0; i&lt; logicCount; i++ &#123;</span><br><span class="line">  &lt;-finishChannel</span><br><span class="line">&#125;</span><br><span class="line">读取logicCount 之后就不堵塞了</span><br></pre></td></tr></table></figure><ul><li><p>我们平时工作中用到 协程的场景 (这篇文章的核心！！！！)</p><p>1.一个api接口中聚合了不同的逻辑，相互不干扰。比如我们的home/info, 我会启动5个goroutine，去处理不同的业务。我会启动两个channel， 一个代表finishChannel  (chan bool),主要用来阻塞主协程的执行，一个resChannel, 用来读取数据。之所以不用resChannel 来阻塞主协程，是因为我在判断所有业务是否都执行完的时候并不想把这些数据都取出来（现在想想也可）。resChannel 中的消息体一般长这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Message struct &#123;</span><br><span class="line">  Flag string</span><br><span class="line">  Msg interface&#123;&#125;</span><br><span class="line">  Err err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flag 代表不同的逻辑，下面一个switch 接入，进行不同的逻辑处理。msg 因为不同逻辑返回内容不一样，我们取出来之后要断言一次。err 就是错误信息。</p><p>2.同一个接口循环去做通样的事。比如没有群发消息，我们不能bulk，只能单个循环。我们可以利用goroutine。</p></li></ul><p>多进程下面读写安全的map(其实很简单，读取的时候加读锁，写的时候加写锁) (可以读一下cache2go 来了解一下本地缓存， 核心也是一个安全的map， 本地缓存相比较分布式缓存有一个缺点是如果容器重启了，缓存就消失了，如果没有redis 这种落地数据的操作)</p><p>上面我的home/Info 还可以有个方式去解决 并发等待问题就是 errGroup， 类似于waitgroup，把常用的几个功能进行了分装 （add  wait done）, 主要作用如下</p><ul><li>errgroup 可以捕获和记录子协程的错误(只能记录最先出错的协程的错误)</li><li>errgroup 可以控制协程并发顺序。确保子协程执行完成后再执行主协程 （waitgroup 的wait）</li><li>errgroup 可以使用 context 实现协程撤销。或者超时撤销。子协程中使用 ctx.Done()来获取撤销信号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// demo</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line"></span><br><span class="line">    &quot;golang.org/x/sync/errgroup&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    group, ctx := errgroup.WithContext(context.Background())</span><br><span class="line">    for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">        index := i</span><br><span class="line">        group.Go(func() error &#123;</span><br><span class="line">            fmt.Printf(&quot;start to execute the %d gorouting\n&quot;, index)</span><br><span class="line">            time.Sleep(time.Duration(index) * time.Second)</span><br><span class="line">            if index%2 == 0 &#123;</span><br><span class="line">                return fmt.Errorf(&quot;something has failed on grouting:%d&quot;, index)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Printf(&quot;gorouting:%d end\n&quot;, index)</span><br><span class="line">            </span><br><span class="line">            select &#123;</span><br><span class="line">            case: err &lt;- ctx.Done():</span><br><span class="line">   // 获取其他协程或者主协程的终止信号，来进行相对应的处理</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return nil</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    if err := group.Wait(); err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析一下errGroup 的源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Group struct &#123;</span><br><span class="line">  cancel  func()             //context cancel()</span><br><span class="line">    wg      sync.WaitGroup         </span><br><span class="line">    errOnce sync.Once          //只会传递第一个出现错的协程的 error</span><br><span class="line">    err     error              //传递子协程错误</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 虽然我们没法主动调用cancel， 但是我们可以通过返回的ctx 接收到 cancel 信号</span><br><span class="line">func WithContext(ctx context.Context) (*Group, context.Context) &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    return &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 就是go 方法挺蛋疼，不能传参数进去</span><br><span class="line">func (g *Group) Go(f func() error) &#123;</span><br><span class="line">    g.wg.Add(1)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer g.wg.Done()</span><br><span class="line">        if err := f(); err != nil &#123;</span><br><span class="line">            g.errOnce.Do(func() &#123;       </span><br><span class="line">                g.err = err             //记录子协程中的错误</span><br><span class="line">                if g.cancel != nil &#123;</span><br><span class="line">                    g.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>errGroup 虽然好，但是仅仅解决了我们 waitgroup 的工作 和 goroutine 中 err传递的工作，对于结果集的传递，感觉还是得造一个channel 用来传递</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package common</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line">//安全的Map</span><br><span class="line">type SynchronizedMap struct &#123;</span><br><span class="line">rw *sync.RWMutex</span><br><span class="line">data map[interface&#123;&#125;]interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">//存储操作</span><br><span class="line">func (sm *SynchronizedMap) Put(k,v interface&#123;&#125;)&#123;</span><br><span class="line">sm.rw.Lock()</span><br><span class="line">defer sm.rw.Unlock()</span><br><span class="line"></span><br><span class="line">sm.data[k]=v</span><br><span class="line">&#125;</span><br><span class="line">//获取操作</span><br><span class="line">func (sm *SynchronizedMap) Get(k interface&#123;&#125;) interface&#123;&#125;&#123;</span><br><span class="line">sm.rw.RLock()</span><br><span class="line">defer sm.rw.RUnlock()</span><br><span class="line"></span><br><span class="line">return sm.data[k]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除操作</span><br><span class="line">func (sm *SynchronizedMap) Delete(k interface&#123;&#125;) &#123;</span><br><span class="line">sm.rw.Lock()</span><br><span class="line">defer sm.rw.Unlock()</span><br><span class="line"></span><br><span class="line">delete(sm.data,k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历Map，并且把遍历的值给回调函数，可以让调用者控制做任何事情</span><br><span class="line">func (sm *SynchronizedMap) Each(cb func (interface&#123;&#125;,interface&#123;&#125;))&#123;</span><br><span class="line">sm.rw.RLock()</span><br><span class="line">defer sm.rw.RUnlock()</span><br><span class="line"></span><br><span class="line">for k, v := range sm.data &#123;</span><br><span class="line">cb(k,v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//生成初始化一个SynchronizedMap</span><br><span class="line">func NewSynchronizedMap() *SynchronizedMap&#123;</span><br><span class="line">return &amp;SynchronizedMap&#123;</span><br><span class="line">rw:new(sync.RWMutex),</span><br><span class="line">data:make(map[interface&#123;&#125;]interface&#123;&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 之前模拟过一个例子</span><br><span class="line">// 利用500 个goroutine 对 普通map 进行增加，会发现运行结束，count 的值不是500</span><br><span class="line">// 对上面的 安全map 修改，count 的值也不正确</span><br><span class="line">// 因为上面的值只有get ， get完 +1 put， 这不是原子性，所以只有 incr 方法才能让最终的值是500</span><br></pre></td></tr></table></figure><p>关于 context ,很重要的一个知识点，对于并发，我们之前一直通过 waitgroup . add 去添加信号量，但是对于 树状的goroutine， 这样会越来越复杂，完美的方式还是通过 context 上下文的传递。 我们设置一个可以随时取消的上下文，当上下文被cancel 的时候，这个请求自然就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 本质上这些 控制并发用的都是 channel</span><br><span class="line">// channel 也经常用于 代码的阻塞</span><br><span class="line">// 下面的代码中如果 一直select 不到数据，会一直default， 但我不知道select 这个频率是多少</span><br><span class="line">// select 只会被调用一次，这是我们需要知道的</span><br><span class="line">// select 下面的case 都满足，会随机公平的选择一个</span><br><span class="line">// 当default 和 case 都满足的时候 ，会优先case</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">stop := make(chan bool)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">select &#123;</span><br><span class="line">case &lt;-stop:</span><br><span class="line">fmt.Println(&quot;监控退出，停止了...&quot;)</span><br><span class="line">return</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;goroutine监控中...&quot;)</span><br><span class="line">time.Sleep(2 * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(10 * time.Second)</span><br><span class="line">fmt.Println(&quot;可以了，通知监控停止&quot;)</span><br><span class="line">stop&lt;- true</span><br><span class="line">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span><br><span class="line">time.Sleep(5 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">// 关于 context 需要认知的几个东西</span><br><span class="line"></span><br><span class="line">// 首先是context 的 struct</span><br><span class="line">type Context interface &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok bool) // 方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</span><br><span class="line"></span><br><span class="line">Done() &lt;-chan struct&#123;&#125; // 这个done 方法我们经常用，就是select 获取到值就说明超时了</span><br><span class="line"></span><br><span class="line">Err() error  //方法返回取消的错误原因，因为什么Context被取消。</span><br><span class="line"></span><br><span class="line">Value(key interface&#123;&#125;) interface&#123;&#125; // 这个value 方法在我们项目中用到的就是中间件解析内容，让后放到context里面</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 经典用法</span><br><span class="line">func Stream(ctx context.Context, out chan&lt;- Value) error &#123;</span><br><span class="line">  for &#123;</span><br><span class="line">  v, err := DoSomething(ctx)</span><br><span class="line">  if err != nil &#123;</span><br><span class="line">  return err</span><br><span class="line">  &#125;</span><br><span class="line">  select &#123;</span><br><span class="line">  case &lt;-ctx.Done():</span><br><span class="line">  return ctx.Err()</span><br><span class="line">  case out &lt;- v:</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">// 平时经常用的两个context </span><br><span class="line">var (</span><br><span class="line">background = new(emptyCtx)</span><br><span class="line">todo       = new(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Background() Context &#123;</span><br><span class="line">return background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TODO() Context &#123;</span><br><span class="line">return todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>context 的衍生</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</span><br><span class="line">func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context</span><br><span class="line"></span><br><span class="line">这四个With函数，接收的都有一个partent参数，就是父Context，我们要基于这个父Context创建出子Context的意思，这种方式可以理解为子Context对父Context的继承，也可以理解为基于父Context的衍生。</span><br><span class="line"></span><br><span class="line">通过这些函数，就创建了一颗Context树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。</span><br><span class="line"></span><br><span class="line">WithCancel函数，传递一个父Context作为参数，返回子Context，以及一个取消函数用来取消Context。</span><br><span class="line">// 通过主动调用这个cancel 方法，可以结束当前函数的执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WithDeadline函数，和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。</span><br><span class="line">// 理解 成截止日期。当然我们也可以手动调用，结束函数的执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。</span><br><span class="line">// 这个是duration，上面的是time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">withxxx  返回的 cancel 我们可以主动调用， 完了就可以取消这个context ， 这时候 done() 方法就能获取到内容了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于 withValue 赋值</span><br><span class="line">//</span><br><span class="line">我们可以使用context.WithValue方法附加一对K-V的键值对，这里Key必须是等价性的，也就是具有可比性；Value值要是线程安全的。</span><br><span class="line"></span><br><span class="line">这样我们就生成了一个新的Context，这个新的Context带有这个键值对，在使用的时候，可以通过Value方法读取ctx.Value(key)。</span><br><span class="line"></span><br><span class="line">记住，使用WithValue传值，一般是必须的值，不要什么值都传递。</span><br><span class="line">// 就是 k v 形式</span><br></pre></td></tr></table></figure><p>上下文真是个好东西, 方便我们 协程隔离</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">之前写代码的过程中，发现大佬们在中间件解析用户uid 的时候都通过 constant.withValue 存储到上下文中，当时很不理解，为啥不直接 全局变量存储，后来想通了，go 中 包内变量多goroutine共享，很容易相互污染。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较php 的多进程 （process）和 java的多线程（thread）更轻量。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>go-反射</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/07/02/go-反射/</id>
    <published>2020-07-02T08:13:01.000Z</published>
    <updated>2020-07-02T08:38:33.837Z</updated>
    
    <content type="html"><![CDATA[<p>反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。</p><a id="more"></a><p>go中反射的使用当然包含上述依赖注入的场景，目前我接触到的场景就是struct 中tag 的使用，比如struct 在json string 中 对于json属性名的自动转小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Name struct&#123;</span><br><span class="line">   name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := Name&#123;&quot;111&quot;&#125;</span><br><span class="line"></span><br><span class="line">r := reflect.TypeOf(a)  // 返回一个type 类型</span><br><span class="line">r.NumField()  // 返回属性的个数</span><br><span class="line">r.Field(i) // 返回第i 个属性</span><br><span class="line">r.Name() // 获取属性的名称</span><br><span class="line">r.Kind() // 获取属性的类别 ，比如自定义结构体叫myStruct, kind 返回 struct, name 返回myStruct</span><br><span class="line"></span><br><span class="line">// 对于地址类型</span><br><span class="line">r := reflect.TypeOf(a).Elem() // 返回一个type类型，我们就能愉快的使用接下来的那些方法了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(a)  // 返回一个value 类型 ，（把类型和值分开了，虽然感觉很奇怪）</span><br><span class="line">v.Field(i) 这个返回的类型和上面type 的类型还不一样，上面的那个可以获取tag等属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 还有个很重要的就是函数的反射</span><br><span class="line"></span><br><span class="line">func Sum(a int, b int) int &#123;</span><br><span class="line">   return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := reflect.ValueOf(Sum)</span><br><span class="line"></span><br><span class="line">// 注意call 调用的时候必须是[]value, 然后单个value 可以用ValueOf 来返回</span><br><span class="line">p.Call(reflect.Value&#123;reflect.ValueOf(10), reflect.ValueOf(20)&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>go-加密</title>
    <link href="http://yoursite.com/2020/06/17/go-%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2020/06/17/go-加密/</id>
    <published>2020-06-17T07:23:40.000Z</published>
    <updated>2020-06-17T07:27:06.817Z</updated>
    
    <content type="html"><![CDATA[<p>加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>go 数据库原生操作</title>
    <link href="http://yoursite.com/2020/06/09/go-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%94%9F%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/06/09/go-数据库原生操作/</id>
    <published>2020-06-09T12:28:16.000Z</published>
    <updated>2020-06-09T12:52:51.286Z</updated>
    
    <content type="html"><![CDATA[<p>go web 开发，操作mysql 是基础啦</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;database/sql&quot;</span><br><span class="line">   _ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line">首先是包的引入，很常见吧，下面那个驱动引入，却未使用可能是只希望使用这个包的 init()方法</span><br></pre></td></tr></table></figure><blockquote><p>通常来说, 不应该直接使用驱动所提供的方法, 而是应该使用 sql.DB, 因此在导入 mysql 驱动时, 这里使用了匿名导入的方式(在包路径前添加 _), 当导入了一个数据库驱动后, 此驱动会自行初始化并注册自己到Golang的database/sql上下文中, 因此我们就可以通过 database/sql 包提供的方法访问数据库了.</p><p>可能这就是interface 的作用吧</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type DbWorker struct &#123;</span><br><span class="line">    //mysql data source name</span><br><span class="line">    Dsn string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    dbw := DbWorker&#123;</span><br><span class="line">        Dsn: &quot;user:password@tcp(127.0.0.1:3306)/test&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    db, err := sql.Open(&quot;mysql&quot;,</span><br><span class="line">        dbw.Dsn) // 返回一个sql.DB 的指针</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>sql.Open并不会立即建立一个数据库的网络连接, 也不会对数据库链接参数的合法性做检验, 它仅仅是初始化一个sql.DB对象. 当真正进行第一次数据库查询操作时, 此时才会真正建立网络连接;</li><li>sql.DB表示操作数据库的抽象接口的对象，但不是所谓的数据库连接对象，sql.DB对象只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法;</li><li>sql.Open返回的sql.DB对象是协程并发安全的.</li><li>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</li></ol><p>所以我们平时用的都是长连接，在池子里面可以复用的啦。平时我们在 prepare ，query(查询)， exec(插入，修改) 之后都要及时 close</p><p>MySQL 5.5 之前， UTF8 编码只支持1-3个字节,从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，utf8mb4兼容utf8，所以能支持更多的字符集;关于emoji表情的话mysql的utf8是不支持，需要修改设置为utf8mb4，才能支持。</p><p>(4 字节的utf8 我们应该一直在用啦)</p></blockquote><p>插入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;insert tasks (content, user, create_at, update_at, deleted) values (?, ?, ?, ?, ?)&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">now, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2016-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">update := time.Now().Format(&quot;2006-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">result, err := stmt.Exec(&quot;测试&quot;, &quot;cy&quot;, now, update, 0)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(result.LastInsertId())</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;update tasks set content = ? where id = ?&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">stmt.Exec(&quot;ceshi11111&quot;, 2)</span><br></pre></td></tr></table></figure><p>查询代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:wyqnkxk2012_CY@tcp(118.184.219.156)/cy&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">err = db.Ping()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//update(db)</span><br><span class="line">//return</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(&quot;select * from tasks where id = ?&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(stmt)</span><br><span class="line">&#125;</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">rows, err := stmt.Query(3)</span><br><span class="line"></span><br><span class="line">defer rows.Close()</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := []*task&#123;&#125;</span><br><span class="line"></span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">tmp := &amp;task&#123;&#125;</span><br><span class="line">rows.Scan(&amp;tmp.id, &amp;tmp.content, &amp;tmp.user, &amp;tmp.create_at, &amp;tmp.update_at, &amp;tmp.deleted)</span><br><span class="line">arr = append(arr, tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go web 开发，操作mysql 是基础啦&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go time</title>
    <link href="http://yoursite.com/2020/06/09/go-time/"/>
    <id>http://yoursite.com/2020/06/09/go-time/</id>
    <published>2020-06-09T11:47:50.000Z</published>
    <updated>2020-07-03T08:50:54.958Z</updated>
    
    <content type="html"><![CDATA[<p>go 中时间包的使用</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">time.Now() // time 包的 Time 类型</span><br><span class="line"></span><br><span class="line">// Time</span><br><span class="line">// 2018-05-31 09:22:19 +0800 CST Time 类型打印出来长这样</span><br><span class="line">time.Now() // 获取当前时间的Time 类型</span><br><span class="line">time.Now().Unix()  Time 类型装 int64</span><br><span class="line">time.Now().Unix()Formate(&quot;2006-01-02 15:04:05&quot;) // 格式化</span><br><span class="line">time.Now().in(a)  // 使用某个时区，返回的是Time 类型，所以可以用</span><br><span class="line"></span><br><span class="line">// location</span><br><span class="line">time.Location() // 返回时区信息</span><br><span class="line">a,_ := time.LoadLocation(&quot;UTC&quot;)  // time 包的 location,如果想用时区，就得用这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数字转Time</span><br><span class="line">time.Unix(11111)</span><br><span class="line"></span><br><span class="line">// 字符串转Time</span><br><span class="line">time.Parse() 和 Time.Format() 是互逆的两个函数</span><br><span class="line">time.Parse() 解析字符串成Time 的时候需要时区信息，我们可以用Loadlocation获取时区信息，然后作为第三个参数传进去</span><br><span class="line"></span><br><span class="line">// Duration </span><br><span class="line">这个在sleep 的时候经常用到</span><br><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond          = 1000 * Nanosecond</span><br><span class="line">    Millisecond          = 1000 * Microsecond</span><br><span class="line">    Second               = 1000 * Millisecond</span><br><span class="line">    Minute               = 60 * Second</span><br><span class="line">    Hour                 = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>今天遇到一个问题，比如sleep() ,这个参数需要是 time.duration, 但是我需要可控的 整数， 6 <em> time.Second， 这样执行不了，需要把 6转换成 time.Duration(6) </em> time.Second, 这样就能运算了。</p><p>这个其实并不是包的特殊性，还是golang语法自身问题自己了解的不足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type c int</span><br><span class="line"></span><br><span class="line">var cparam int</span><br><span class="line">cparam = 1</span><br><span class="line"></span><br><span class="line">o := 1</span><br><span class="line"></span><br><span class="line">fmt.Println(cparam == o)  // 必然报错，虽然是别名，但还是不同类型</span><br><span class="line"></span><br><span class="line">time.Sleep(6 * time.Second) // 这是因为 6可以当做 time.Duration 类型</span><br><span class="line"></span><br><span class="line">可是</span><br><span class="line">r := rand.Int() // int</span><br><span class="line"></span><br><span class="line">time.Sleep(r * time.Second) // 不同的数据类型不能相乘</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天还发现 time 包的一个很牛逼的方法，涉及channl， 所以只有 goroutine 的时候用得到。 time.After() 是一个channl 在规定时间后可以读取一个数据，利用select 机制，可以控制超时问题。</span><br></pre></td></tr></table></figure><p>今天 发现go 去修改时间也很方便，比如</p><p>time.Add() 比如 + 1天， -1 天，</p><p>Sub() 计算两天的差值（不是用来算负数天的哦）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 中时间包的使用&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
  </entry>
  
</feed>
