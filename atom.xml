<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-21T07:58:39.475Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>外接广告</title>
    <link href="http://yoursite.com/2020/04/21/%E5%A4%96%E6%8E%A5%E5%B9%BF%E5%91%8A/"/>
    <id>http://yoursite.com/2020/04/21/外接广告/</id>
    <published>2020-04-21T03:36:04.000Z</published>
    <updated>2020-04-21T07:58:39.475Z</updated>
    
    <content type="html"><![CDATA[<p>最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。</p><a id="more"></a><p>首先介绍一下前置知识吧，对于ios 和 android 手机的标识。ios手机现在一般用idfa， 但是用户可以关闭广告追踪，那我们获取到的就是一堆 0000-000··这样乱七八糟的东西，毫无价值，为了实验效果，我们一定要开启ios手机的广告追踪。（怎么快速获取当前手机的idfa，可以在appstore中下载一个myidfa,可以快速获取到，注意字母都是大写）。所以要是苹果手机用户关闭了广告跟踪，那么我们就完全追踪不到点击广告的用户信息了，广告的转化率我们必然</p><p>android 手机五花八门，之前一般都是用的imei ，然后有的手机可能还有多个，目前没有考虑很多的情况，都是取的默认的第一个。但现在imei好像逐渐开始也获取不到了，国内的手机一般用的都建议用oaid，据说覆盖量已经 80%以上（但是oaid是国内手机联盟定的东西，像海外的安卓机器是没有的，而且现在识货android客户端也是不支持回传oaid的）</p><p>主要流程：当我们app（识货）在头条（或者朋友圈）上面投放广告的时候，当用户点击我们投放的广告，会给我们的web server发送一条请求，这个请求包括用户的基本信息，比如ios 的idfa 或者android 的imei,还有个call_back,类似标识这个用户信息是头条回传给我们的，我们拿到这个信息存储下来，当用户启动我们app的时候，我们可以把这个用户的信息（imei 或者 idfa）和 头条回传给我们的信息作比对，如果对应上，然后时间间隔在我们希望之内（比如两天），就可以当做这个用户是头条带来的。</p><h1 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h1><p>头条应该是接入的几个广告主中最简单的。头条是没有账号区分的（接口中让我们传入sign，但其实可以不用传），所以当我门投放部使用多账户进行广告投放，在我们代码中是没有影响的，我门只需要调用头条的上传用户行为的接口，传入设备信息和call_back 就好了。</p><p>坑点：</p><p>1.首先我们要区分开发者和广告主两个角色，开发者角色在这次广告对接中基本没啥用处，就是用来看开发者文档的。广告主角色很重要，因为我们配置好监控链接，联调上传行为的时候需要用广告主角色登陆后台管理界面，进行联调（填写头条用户id，然后刷新头条信息流，出现联调广告，点击，观察头条发起调用我们的url，我们可以直接拿这条url测试我们的监控接口是否正常，然后取出callback 和 idfa或者imei，作为参数调用头条的上传用户行为,这就是整个步骤啦，注意imei属于隐私数据，所以会用md5加密）</p><p>2.在我们联调的时候需要填写很多信息，比如下载链接，ios就是App Store我们应用的连接，android 需要我们上传apk到头条或者自己上传一个到七牛云，说白了，用户点击广告需要下载，我们给他们提供一个下载地址（好像不能用应用宝地址，因为腾讯？）</p><p>3.主要就是上面两个，剩下的就是代码设计方面，首先是对于表的设计，因为头条那边我们回传用户行为不需要去重，所以我们之前的代码中自己检测到属于头条带来的新用户直接就上报了，自己没做任何处理，比如记录日志，比如存表。这样带来一个坏处就是万一逻辑哪里出错了，不好排查，比如我们和bi那边做数据差异对比，完全拿不出证据证明这个用户在我们逻辑中属于新用户，为什么bi那边不算新用户，所以可以把用户的上报行为时间也存下来。</p><h1 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h1><p>快手和头条内容基本一致，就是快手不支持去重，只能我们这边自己去重，所以我们终究要保存下我们上传的用户信息，再次触发上报条件的时候，需要检测之前是否上报过。</p><p>（为什么我们会触发多次激活的上报条件？按理说不正常，但历史原因是识货这边在获取用户启动信息的list里面可能第一次没有获取到imei 或者idfa，这样用户虽然激活了，但是没法匹配到头条那边的点击广告信息，只能在第二次用户启动app的时候去激活）</p><p>快手比价坑的就是他的callback往往很长，··长的你不能想象，所以我们要注意数据库是否会自动截断。</p><h1 id="广点通"><a href="#广点通" class="headerlink" title="广点通"></a>广点通</h1><p>广点通相比较上面二者更加复杂，首先就是多账户系统和开发者。</p><p>1.开发者需要把多账户（多个广告主）接通流程，首先开发者需要自己建立一个应用（这个应用不用区分ios 和 android ，目的就是获取一个appkey 和 appsecret, 这个信息在我们上传用户行为的时候需要，头条那边之前以为也需要，但是他那个sign 可以不传，所以这个应用可以不建立）</p><p>2.建立好应用之后就需要我们通过腾讯系老一套的oauth2.0 ，把广告主账户挂载在这个应用下面，因为应用需要获取我们的广告主信息，所以需要通过模拟第三方登陆，让我们应用获取到广告主的信息（比如accesstoken）,这个accesstoken 很重要，上传用户行为就靠他了。ps:这个accesstoken 有时间限制的，为了让他一直有效，我们需要通过refreshtoken 一直刷新accesstoken 的时间（感觉上就是类似redis 的set， 不断的刷新有效期，可以写个定时任务）</p><p>3.获取到accesstoken ，我们再建立用户行为，（但是激活和次留可以用一个行为id），然后把accesstoken ，行为id，事件回传就可以了</p><p>综上，其实各家广告厂商套路其实都差不多，我们提供给他们的广告连接都是可以加上我们自己的参数的，类似微信登陆我们在回调的时候对于scene字段传入我们自定义的值。我们可以利用这个值作为不同的投放计划名称，方便我们不同计划的统计，虽然头条他们本身也能传给我们计划名称。</p><p>各家公司对于ios 和 android 需要建立不同的计划，但是我们的检测链接可不需要，因为我们可以从他们回传的内容中获取到os,判断是android 还是 ios，而且毕竟是mysql，关系型数据库，我们只需要把它们返回的内容都保存就好了，有个例外就是快手不行，因为他们的回传内容中获取不到os，我们无法判断是android还是ios，（android 和 ios 匹配头条用户信息的逻辑不一样，所以要区分）难道通过idfa或者imei去判断，显然不保险，不如填写两条不同的检测链接，标识哪个是ios ，哪个是android。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="广告" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-validate验证器</title>
    <link href="http://yoursite.com/2019/12/16/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-validate%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/16/tp源码分析-validate验证器/</id>
    <published>2019-12-15T16:12:26.000Z</published>
    <updated>2019-12-15T17:06:37.418Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。</p><p>曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。</p><a id="more"></a><p>首先说下php 的验证库可以做哪些事吧，还是蛮丰富的。</p><ol><li>首先是验证器，在我看来验证器就是单独抽象了一个层出来，我们在controller里面只需要调用，让controller更加简洁，而且也能复用，验证器类都继承于think\validate。</li><li>其次controller 里面的validate 方法可以直接调用，本质上和前面一样都是调用tp的验证器库。</li><li>最后我们如果想单独使用验证器，就当做普通方法那样也是可以的，毕竟有时候我们除了对于传入参数的验证，业务代码中也有一些内容需要验证的。</li></ol><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>属性：</p><p>static type : 这个主要是我们第三种方法独立验证器用到的。rule 规则都存在这里面，当我们使用独立验证器的时候，想扩展验证规则，extend 方法修改的就是这个属性，因为是static， 所以在本次请求的下次使用中，也能调用上次extend 的验证规则</p><p>alias： 就是我们rule 中可以用  &gt;: 5, 当做 gt: 5 来使用</p><p>rule: 验证规则，我们在写验证器的时候，重写的就是这个属性</p><p>message: 提示信息的重写。包含5个占位符，:attribute, :rule, :1, :2, :3</p><p>field: 字段的描述，主要作用用在message中message 中的占位符 :attribute 会被这个内容替代</p><p>typeMsg: 提示信息呗，这块是英文的，最终会通过 lang\zh-cn.php 转换成中文</p><p>currentScene: 当前验证的场景，这个感觉就是为了验证器准备的（场景），其实也蛮实用的，方便验证器中规则的自由组合。</p><p>filter: 主要是利用php filter_var函数的验证</p><p>regex: 主要是用到正则的验证, ctype 也是php 很好用的一个扩展，方便一些特殊字符的验证</p><p>scene: 场景</p><p>error: 错误信息，只有控制器中错误才能抛出异常</p><p>batch: 当前参数验证错误，还能轮到下一个参数</p><p>only: 场景中哪些参数被验证</p><p>remove: 场景中移除</p><p>append: 场景中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">看源码写的一点总结</span><br><span class="line">// remove 不可能移除所有，除非append 中是空</span><br><span class="line">// remove 连续移除是通过 |</span><br><span class="line">// remove append 的最佳实践是二者不要存在顺序关系，因为程序不会鉴别</span><br></pre></td></tr></table></figure><p>方法：</p><p>__construct:  </p><p>rule 验证规则， message 提醒， field 字段描述 :attribute 占位符实际内容</p><p>make:</p><p>new self 生成一个验证器</p><p>rule:</p><p>独立验证修改rule 和 field 属性，供后面check 使用。方便直接传入 rule 和 message </p><p>extend:</p><p>独立验证器中的方法扩展</p><p>setTypeMsg:</p><p>独立验证器中使用</p><p>message:</p><p>提示信息</p><p>scene:</p><p>修改当前验证场景</p><p>hasScene:</p><p>scene 优先考虑 sceneEdit 方法，再考虑 scene -&gt; [‘edit’ =&gt; []] 属性</p><p>batch:</p><p>批量验证</p><p>only:</p><p>场景的使用验证哪些字段</p><p>remove:</p><p>场景移除验证规则</p><p>append:</p><p>场景添加沿正规则: 上线 remove 和 append的调用的时候没有先后顺序 ！！！</p><p>check:</p><p>验证器核心，这时候传入的内容会覆盖掉初始化的内容。</p><p>getScene:</p><p>根据传入的scene 和 current scene 修改 only  remove add 内容</p><p>getDataValue: </p><p>根据传入的data 数组和 可以， 获取对应的内容</p><p>checkItem:</p><p>实际的验证，通过 call_user_func 去调用对应的验证内容</p><p>checkRule:</p><p>官网上这么说，</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191216005751.png" alt=""></p><p>感觉意义不大，毕竟静态方法make 创造的更好用点</p><p>getRuleMsg: </p><p>获取错误信息，可以好好看看，挺好的，调用了lang 类。因为自定义的closure ，如果 不是 === true， 就当做error， 结果就当做errorMsg，和调用类方法还是有点区别的。</p><p>getValidateType:</p><p>像一些 is，比如 isEmail, isIp 都走的is 方法</p><p>后面就是一些验证方法了，以后写代码都可以借鉴下</p><h3 id="ValidateRule"><a href="#ValidateRule" class="headerlink" title="ValidateRule"></a>ValidateRule</h3><p>这个类的主要用途就是通过rule 类的形式去调用对应的验证规则</p><p>属性：</p><p>title  :attribute</p><p>rule 规则</p><p>message 提示信息</p><p>方法：</p><p>addItem ：</p><p>为 is 方法统一添加rule，message 属性</p><p>getRule  getTile  getMesage 获取对应属性</p><p>title 设定title</p><p>——call  </p><p>——callStatic </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。&lt;/p&gt;
&lt;p&gt;曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPhP" scheme="http://yoursite.com/tags/ThinkPhP/"/>
    
      <category term="validate" scheme="http://yoursite.com/tags/validate/"/>
    
  </entry>
  
  <entry>
    <title>持久化</title>
    <link href="http://yoursite.com/2019/12/03/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/12/03/持久化/</id>
    <published>2019-12-03T11:59:55.000Z</published>
    <updated>2019-12-06T14:17:20.110Z</updated>
    
    <content type="html"><![CDATA[<p>我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。</p><a id="more"></a><p>举个例子吧，之前接手的一个任务毒和nike关联出价，当前台下发撤单任务的时候，因为牵扯到很多curl 请求，不能同步实现，1.感觉可以通过把请求内容放到mq当中，然后利用daemon 化的task始终监听这个mq，如果有内容，则触发任务，往后执行，否则停歇1min 继续监听。2.那个前作者是通过把内容放到redis中，通过daemon化的task监听这个redis，如果检测到这个redis这个key，就执行相应任务。</p><p>总结一下吧，其实上面两个方式php的daemon话都是通过while true，那么supervisor 的作用是啥呢，当php的这个脚本挂掉了，supervisor可以重新拉起这个脚本。同理pm2也可以，而且不一定是脚本挂掉，脚本执行完了，也可以重新拉起，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo date(&apos;Y-m-d H:i:s&apos;)</span><br><span class="line">echo &apos;end&apos;;</span><br><span class="line">// 利用上面两个进程管理工具之后，可以一直输出</span><br></pre></td></tr></table></figure><p>上面的例子还有个很重要的技术点就是定时触发。相比较crontab 的task，上面的task 触发任务时间不一致，触发时间靠前台控制，所以我们这时候就通过始终运行一个后台任务，然后靠前台触发一个开关，后端始终运行的task始终监测这个开关，如果是开就运行，虽然可能存在一定时间的误差，但大体上还是能完成任务的。</p><p>再比如之前接手的一个安卓灰度更新的任务，当某个渠道开启灰度之后，我们需要每隔30min发送一条钉钉消息，我们同样可以检测表中渠道是否有开启灰度的状态，如果有，则发一条消息，并记录通知时间，下次的循环任务检测是否灰度还在开启，如果还在开启，检测时间通知是否超过30min，如果超过了，再发送消息，并更新通知时间。</p><p>上面的任务看似已经解决，但还是会涉及一个多进程问题，再举个例子，比如erp系统，需要爬取商户的店铺信息，这个task 要一直执行，如果我们有100个商户，就得运行100个task，启动100个脚本。我们上面灰度通知的好解决，一种办法就是检测运行的渠道，循环运行的渠道列表，然后发送消息通知，另一种就是一次性检测，把渠道更新信息包含在一条短消息中发出去，之所以这么做是因为后续的任务（发送钉钉通知）可以在很短时间内完成，如果像erp的那种爬虫任务，只能通过启动多个脚本了。</p><p>关于php的多进程扩展pnctl 这里暂时不做讨论，说一下pm2 和 supervisor 的简单使用。</p><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p><a href="https://juejin.im/post/5b823506e51d4538d517662f" target="_blank" rel="noopener">这篇文章关于pm2讲解的很好</a></p><p>我比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br><span class="line">pm2 app.js --name wx_spider --watch   // name 名称，方便理解， watch 文件变动，方便重启，类似nodemon</span><br><span class="line">pm2 delete all</span><br><span class="line">pm2 delete (:id)</span><br><span class="line">pm2 restart app</span><br><span class="line">pm2 logs (:name)</span><br></pre></td></tr></table></figure><p>pm2 配置简单，非常好用，echo 的内容之间在log中能看到，除了node， php也是能管理的</p><p>（PM2 的安装需要通过node 和 npm， node 的安装很简单，但我们一定要注意npm 安装的module 位置，如果是linux 下，一定要配置好node_path ,否则 npm -g 安装的内容可能不能使用， npm config  get prefix  可以查看node -g 包安装的位置 。同理node的安装位置最好也是/usr/local/ 下面，方便直接访问）</p><p>今天在使用pm2 管理我的一个task的时候遇到一个问题，就是普通的脚本pm2 start app.js 或者 pm2 start test.php, 但是我现在的命令是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php symfony trade:UpdateCommentDgTags updateUserPublishment  --split=4</span><br></pre></td></tr></table></figure><p>之前的那个命令是肯定不可以的，需要使用配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; //统计报表更新</span><br><span class="line">  &quot;name&quot;: &quot;up4&quot;, // 随便取</span><br><span class="line">  &quot;args&quot;: &quot;trade:UpdateCommentDgTags updateUserPublishment  --split=4&quot;, // 这些都属于参数</span><br><span class="line">  &quot;script&quot;: &quot;symfony&quot;, // 这个地方一定要注意，symfony 其实是脚本，只是没有 .php 的后缀</span><br><span class="line">  &quot;exec_interpreter&quot;: &quot;php&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;Cluster&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;fork&quot;,</span><br><span class="line">  &quot;max_memory_restart&quot;: &quot;100M&quot;,</span><br><span class="line">  &quot;cwd&quot;： &quot;../&quot;  // 上一级目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要注意，这个地方symonfy 是脚本，怪不得之前我在执行task 命令的时候忘记输入symfony ,他说找不到脚本。 后面的那一长串都会统一看成参数，只是参数解析的形式不一样，比如 trade:UpdateCommentDgTags, 解析成方法名称，–split = 4 解析成参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps:   php test.php --goods_id=12 uo22</span><br><span class="line"></span><br><span class="line">test.php</span><br><span class="line">&lt;?php</span><br><span class="line">var_dump($argv)</span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; test.php</span><br><span class="line">    [1] =&gt; uo22</span><br><span class="line">    [2] =&gt; --goods_id=12</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>pm2 log日志的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error log path    │ /home/username/.pm2/logs/app-error-0.log</span><br><span class="line">out log path      │ /home/username/.pm2/logs/app-out-0.log</span><br></pre></td></tr></table></figure><p>需要注意的是这个error 应该是pm2 自身的error, 一般我们程序抛出的都是在out 日志里面</p><p>！！~notice: pm2 虽然香，但也不能乱用，比如之前我在预发布机器上跑的一个task 脚本，因为跑完了，脚本 die， 不断的被pm2重启，导致cpu 很快被耗尽，所以很多脚本停止的时候 都会有个sleep 操作，过一段时间再重启。当然如果你是那种常驻内存，比如node 做的webserver 肯定不用，因为一般不会崩溃，唯一一种就是你的代码有问题，不断的报错，导致服务不断的被唤醒。</p><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p><a href="https://learnku.com/laravel/t/2126/supervisor-installation-configuration-use" target="_blank" rel="noopener">使用和安装可以大致看看这个文章，但这篇文章的配置文件有问题</a></p><p>配置文件里面一定要有[supervisord]和[supervisorctl] 部分，否则会报错。<a href="https://juejin.im/post/5c66be44f265da2de52d784d" target="_blank" rel="noopener">这篇文章应该还可以</a> 需要注意的就是监听端口从 127.0.0.1:9001 改成 0.0.0.0:9001 ,方便外网访问，贴个图</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191203210626.png" alt=""></p><p>基本就能用啦 （比如我那几百万的任务task就能通过这两个处理，不用我一直看着了，跑完了看看 log就好了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="daemon" scheme="http://yoursite.com/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>复盘一下代码的提交流程</title>
    <link href="http://yoursite.com/2019/11/28/%E5%A4%8D%E7%9B%98%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/28/复盘一下代码的提交流程/</id>
    <published>2019-11-28T06:20:02.000Z</published>
    <updated>2019-11-28T10:36:20.370Z</updated>
    
    <content type="html"><![CDATA[<p>昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。</p><a id="more"></a><p>首先我们开发一个功能需要从master上面下拉代码</p><ol><li><p>注意是远程的master，本地的master没啥屌用，因为一般为了提交方便和方便记忆，本地分支和远程分支保持同名，如果你用master 的话，总不能推送到远程master上吧，似乎没人有这个权限。</p></li><li><p>提交代码前是否要合并master ？ 血的例子，别吧。如果你往master上面提交代码没冲突，那就别合并了，对吧，为啥要合并呢 ？只要你的代码正常上线，dont care anything ，因为要是你真的在这个时候合并了远程master，然后远程master 0.01%的可能是个脏master，这时候你的开发分支也就脏了，意味着你合并master 之后改的东西，在领导发现master 脏了之后，都是要被回滚的，回滚的终结点不一定，凭他们的感觉吧，其实感觉就是那个人把release 合并到master 上的点。那问题来了，如果，万一你真的合并了脏master，咋办，其实也好办，你git reset 到合并master之前的那个commit，重新提交给master，看是否能合并，不能合并，再去解决冲突（后面会介绍冲突解决办法），所以感觉在merge 别的分支的时候一定要做好commit message （最好不要改merge 的info，比如当时我修改改成conflict resolve 我都不知道我要回退到哪个版本，其实只要回退到merge 之前的版本就好了）， 有时候真的会帮大忙，方便你的开发分支剔除掉别的合并的内容</p></li><li><p>开发feature中是否要合并master ？ 还是血的例子，别吧。万一你开发分支合并了错误的master，万一你不知道，接着在错误分支上开发，当开发很多的时候，当master 需要回滚的时候会很艰难，毕竟开发了那么多。这时候只能继续相信master， 不断的合并master，其实没啥屌用，你的开发分支已经领先master了，如果你没回滚，你合并的时候只会在人家前面，你会多提交很多内容，这些内容在你给领导要求pr merge 的时候被看到肯定会打回来，~~~不知道咋解决</p></li><li><p>我的流程总结。开发的时候下拉master成为一个开发分支，比如chenye/feature/gray_test, 开发完了，提交dev。万一和dev冲突，下来dev到本地，merge gray_test,看冲突是啥，万一是自己的文件，直接解决。解决完了，推送到远程，给dev提交pr，合并之后，自己的gray_test 就能合并到dev了。注意，在解决冲突的时候一定不要修改自己的开发分支，也就是gray_test, 万一在release 或者 master合并的时候修改了自己的开发分支，一定要dev， release ，master 按顺序重新提交一遍！！！！！否则，别人拉代码的时候一定会冲突。</p></li><li><p>当发现别人的代码冲突的时候咋办，最好的办法就是告诉别人，因为你不知道以哪个为标准。</p><p>你觉得是以master为标准，毕竟线上跑着呢，万一人家当初并不想把代码提交到master上，被另一个同学误操作了，也就是你clone的master是错误代码，这时候以master会覆盖调用dev的正确代码。</p><p>你说以dev标准，毕竟dev是最新的代码 ？还是不对，可能别人着急，直接提交了master，也就是说master代码比dev新，这样dev就会覆盖掉master上的新代码。</p><p>所以遇到这种情况，直接告知吧，任何一种自己修改别人冲突的方法都是不负责任的行为。</p></li></ol><p>顺带提一下最近遇到的win 和 linux 下空格遇到的问题，我们都知道代码是跑在linux下的，所以我们的换行一定要</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160209.png" alt=""></p><p>用这个LF, win下是</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160245.png" alt=""></p><p>我们既然改变不了win，可以通过phpstorm自带的功能，去编辑文件，模拟在linux下的编辑。</p><p>（ps:我是怎么发现这个问题的，在用php的heredoc 换行的时候就能发现）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="虎扑" scheme="http://yoursite.com/tags/%E8%99%8E%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-数据库操作</title>
    <link href="http://yoursite.com/2019/11/17/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/11/17/tp源码分析-数据库操作/</id>
    <published>2019-11-17T07:45:09.000Z</published>
    <updated>2019-11-17T07:53:51.947Z</updated>
    
    <content type="html"><![CDATA[<p>tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo</p><p>的api 去操作数据就好了。</p><a id="more"></a><p>我们先来看看常用的pdo api</p><p>首先是关于pdo的安装部分，我们要安装统一的pdo扩展，然后在这个扩展的基础上安装 pdo mysql ,或者 pdo postgresql，类似针对不同的数据库的驱动的感觉。</p><p>预定义常量：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo&lt;/p&gt;
&lt;p&gt;的api 去操作数据就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go 学习笔记</title>
    <link href="http://yoursite.com/2019/11/17/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/go-学习笔记/</id>
    <published>2019-11-17T07:44:14.000Z</published>
    <updated>2020-01-17T13:42:35.926Z</updated>
    
    <content type="html"><![CDATA[<p>php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能</p><a id="more"></a><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>和php 的安装基本没啥区别，找篇文章就能解决。需要注意的是</p><ol><li>go 1.13 以上加了 goproxy 的功能，我的理解就是类似composer 中国镜像， github 上有个goproxy-cn, 修改一下就好了。</li><li>然后go 运行脚本是 go run  xxx.go, 需要这个脚本 package 是main, 执行的当前方法是 main (go build 那些以后用到再补充)</li><li>gopath 那些概念在1.13以上好像都淡化了，以后用到再补充</li></ol><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量申明多种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var num int  // 没给初始值，默认 0</span><br><span class="line">num := 1  // 这样更简洁更方便， 函数外不给使用</span><br><span class="line"></span><br><span class="line">int, float64, bool 这都是和别的语言一样的，array , slice, map</span><br><span class="line"></span><br><span class="line">arr1 := [...]int&#123;1,2&#125;  // 因为不能扩展，用的比较少</span><br><span class="line">slice1 := []int&#123;1,2&#125;  // 关联数组</span><br><span class="line">map1 := map1[string]string&#123;&#125; // 索引数组</span><br><span class="line"></span><br><span class="line">// 换一种看法看go， 下面两种都代表数组，只是填充的对象是byte 或者是rune</span><br><span class="line">[]byte&#123;&#125;</span><br><span class="line">[]rune&#123;&#125;</span><br><span class="line">(不管是byte 还是 rune，对应的字符序列都是 十进制，要想转换成 十六进制需要通过 hex.encodetostring ,或者 printf , 第一个只能对 slice 处理，第二个可以对数组)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结构体，类似</span><br><span class="line">type cy struct &#123;</span><br><span class="line">name string `json:Name` // json 的时候生成key 的名称</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cy1 := new(cy)</span><br><span class="line">cy1.name = &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(cy1.name)</span><br><span class="line">//cy 类似类名，所以我们还需要变量名</span><br><span class="line"></span><br><span class="line">// 别名</span><br><span class="line">type</span><br><span class="line"></span><br><span class="line">// map value 定义成某个字段太局限了，可以 map[string]interface&#123;&#125; 这样，更灵活</span><br><span class="line">// :=  map[string]interface&#123;&#125;&#123;&#125; ,一定要给初始值</span><br><span class="line"></span><br><span class="line">// go 中 printf %v  struct 这种不够，因为 名称打印不出来，需要 %+v 打印</span><br></pre></td></tr></table></figure><p>一次性给多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1, arr2 := []int&#123;1,2&#125;, []int&#123;2,3&#125;</span><br></pre></td></tr></table></figure><p>因为go 中的异常机制和php还是有点区别的，很多函数在使用之后会有error 的返回，我们根据 error != nil ,就能知道是否错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if _,error := test(x , y ); error != nil &#123;</span><br><span class="line">  错误处理</span><br><span class="line">&#125; </span><br><span class="line">:=  ,只有多个变量中有一个是新的，:= 不会报错</span><br><span class="line"></span><br><span class="line">真实因为go 的这种语言机制，导致 if 才能这样用，最多有两个表达式，第二个 值的内容是布尔 （上面 _ 属于匿名）</span><br><span class="line"></span><br><span class="line">还有go 中和 js let 一样，都有块状作用域，比如那个 if 里面赋值的变量，只能在 &#123;&#125; 中使用</span><br></pre></td></tr></table></figure><p>var 和 const 一次性声明多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">test1 int</span><br><span class="line">test2 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 枚举，内部可以用iota</span><br><span class="line">const (</span><br><span class="line">test2 iota</span><br><span class="line">test3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>go 中 if 和 for 都是不用括号包裹的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>node 学习笔记</title>
    <link href="http://yoursite.com/2019/11/17/node-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/node-学习笔记/</id>
    <published>2019-11-17T07:44:05.000Z</published>
    <updated>2019-11-17T07:44:05.685Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>虎扑这几天的git流程总结</title>
    <link href="http://yoursite.com/2019/11/12/%E8%99%8E%E6%89%91%E8%BF%99%E5%87%A0%E5%A4%A9%E7%9A%84git%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/12/虎扑这几天的git流程总结/</id>
    <published>2019-11-12T08:04:56.000Z</published>
    <updated>2019-12-06T14:21:16.049Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下虎扑的代码开发流程（包括提交，发布流程不太明白，对金啃死了解太少）。公司给每个人分了台虚拟机(类似云主机)，</p><p>我原先的想法是通过在虚拟机上clone 代码，然后通过phpstorm 的远程连接主机的功能，实现在本地开发，然后映射到虚拟机上代码改变。可是这样有一个问题就是虚拟机linux上clone的代码的换行和我本地win上的换行不一样，虽然开发的时候没有影响，但是要是在win上提交代码就会出现很多没有修改的代码也会有modifyed（其实git 本身做了兼容，在clone的时候，但主要是我现在把linux代码拉取到本地，所以才会这样）。而且我也不可能在linux上提交，毕竟提交的时候需要通过一些工具观察文件的改变，所以改成了第二种方式</p><p>通过在本地和远程都clone 代码，然后通过sftp实现两个文件夹的关联，本地代码的修改也能直接映射到虚拟机，而且可以在windows上提交代码，因为是在win上clone迁出远程仓库的代码，所以提交的时候不会出现换行(crlf)的问题。</p><a id="more"></a><p>首先是开发分支的命名。 </p><p>姓名/feature(bugfix) 特征/ 自定义名称 （这样切割之后，在一些git 工具上可以发现是以文件夹方式显示的）</p><p>开发完了，推送到远程</p><p> git push origin chenye/feature/dgtag(本地分支):chenye/feature/dgtag(远程分支)</p><p>然后给develop 提交一个pr，再合并（最好不要直接给develop提交，就算提交也是通过git fetch origin develop(远程分支):deve1 去提交, 千万不要把自己的分支推到远程的develop分支上了，防止覆盖）</p><p>当我们提交的时候出现conflect 的时候，我们可以 git fetch origin develop:dev1, 然后在dev 上merge 我们的分支 chenye/feature/dgtag, 合并完了，再推送到远程新建分支，再把这个分支和dev分支合并。</p><p>当我们merge本地分支的时候肯定会出冲突，这个冲突的来源有两种可能，一种自己的，这个很好办，把head 到 ==== 中间删除，替换成自己最新的。</p><p>还有种可能是别人的，要是别人的呢，也好办，最暴力的方法就是用dev替换自己分支上最新的，这样自己的分支和dev合并就没有冲突了，但这个只适用于dev哈，如果是release 和 master ，一定要问一下出现conflect文件的那个人！！！</p><p>远程仓库更新完了，我们需要更新服务器上的代码，这和itbasic 一样，直接去28机器上git clone 就好了</p><p>唯一有区别的就是release， 我们这边release 的发布类似以前，每次发布之后都会在服务器上产生一个新的文件夹，通过改变软链接指向的文件夹，保证每次发布成新的代码（而不是通过代码覆盖，感觉这样是不是发布更快速，如果是clone的话，有时候需要很久才能全部完成）</p><p>进入release 环境，我们第一个选2， 第二个选项是不同的php， 7.1 和 7.2，7.2的count() 真的很坑呀，要注意，其中3环境我们每次执行完脚本要及时删除 文件夹下的cache， 否则脚本执行不了 （很奇怪~~）。</p><p>有时候我们在release 环境修改文件会发现没生效，这可能是因为有人发布代码了，所以你后面再次进入修改的文件，可能对应的文件夹已经不是之前你修改的那个了。</p><p>这几天git常用的几个命令</p><p>git pull origin master:master1 </p><p>注意这个和 git pull origin master 不一样，后者会下拉master 并和 当前分支合并，前者即使当前在master1 分支上，也是用master 强制覆盖master1 ，类似push 。</p><p>git fetch origin master:master1 </p><p>下拉远程master 在本地新建master 1</p><p>git reset   commitId  回退本地 commit 的内容到工作区（并不是删除）</p><p>(如果没有 –hard， 内容会再次回到工作区，需要 git checkout . 抛弃， 默认是 git reset –soft)</p><p>git checkout  .  删除工作区的内容</p><p>git clean  删除添加的文件，或者直接 rm  删除文件</p><p>git branch –delete  分支名 删除本地分支</p><p>git  push origin  –delete 分支名 删除远程分支</p><p>git merge  ing 的时候如果想放弃，也可以通过删除merge的文件，这样是不是能少记一个命令呢，哈哈哈</p><p>我们在解决冲突的时候，千万不要把develop，或者release 上面的代码合并到自己的开发分支上， 因为自己的开发分支最终是要合并到master上的，所以我们对这两个分支解决冲突只能通过新拉分支来解决，解决完也不要推送到自己的开发分支上，可以推送到远程的临时分支上，与dev和release合并</p><ul><li>今天在给一个新项目做远程sftp配置的时候（本地clone，远程也是clone）,始终配置不上server， </li></ul><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191112232234.png" alt=""></p><p>options 这块总是显示mapping 不对，打开 configuration</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191112232326.png" alt=""></p><p>注意那个地方一定要有个 / !!!!</p><ul><li>今天用sftp 发现，为了删除文件，只能在phpstorm上面删除，如果自己打开文件夹删除，是更新不到服务器上的</li></ul><ul><li>今天用git 的时候，想给部署多个仓库</li></ul><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191205161629.png" alt=""></p><p>小垃圾们看一下，~是不是对origin 有更深刻的理解了 ，地址<a href="https://segmentfault.com/q/1010000008366409" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008366409</a></p><ul><li>今天在推送本地分支到远程的时候推送错了，导致远程分支提前自己的开发分支，所以只能强推，当然只有自己的分支能这么坐哈，~公共分支千万别，因为感觉强推就是覆盖</li></ul><p>git push origin dev -f</p><ul><li>今天在提交代码的时候，发现想删除某个提交，其实这个情况蛮常见的，比如之前某个大佬把release合并到master上，我们只需要</li></ul><p>git rebase -i  还是蛮重要的，目前我就用在删除当前分支的某次提交。变基的时候如果没有修改同一个文件的话，没有冲突的话，改起来话挺快的，可以快速删除某个不想要的提交，比如：<a href="https://www.36nu.com/post/275" target="_blank" rel="noopener">https://www.36nu.com/post/275</a>，</p><p>但是如果改了同一个文件的话，可能存在某种冲突，所以变基操作会每个commit 慢慢操作，只需要 git rebase –continue 这样就行了</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191206114054.png" alt=""></p><ul><li>git reset 的后遗症蛮严重的，特别是自己开发分支修复不当，所以我们每次提交一定要严格执行合并dev， release，master 流程，一旦开发分支修改过，都要重走一遍。今天有人合并分支出现冲突，强推了merge，导致我的代码被覆盖，但归根结底都是之前提交代码不规范，~一定要引以为戒</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说一下虎扑的代码开发流程（包括提交，发布流程不太明白，对金啃死了解太少）。公司给每个人分了台虚拟机(类似云主机)，&lt;/p&gt;
&lt;p&gt;我原先的想法是通过在虚拟机上clone 代码，然后通过phpstorm 的远程连接主机的功能，实现在本地开发，然后映射到虚拟机上代码改变。可是这样有一个问题就是虚拟机linux上clone的代码的换行和我本地win上的换行不一样，虽然开发的时候没有影响，但是要是在win上提交代码就会出现很多没有修改的代码也会有modifyed（其实git 本身做了兼容，在clone的时候，但主要是我现在把linux代码拉取到本地，所以才会这样）。而且我也不可能在linux上提交，毕竟提交的时候需要通过一些工具观察文件的改变，所以改成了第二种方式&lt;/p&gt;
&lt;p&gt;通过在本地和远程都clone 代码，然后通过sftp实现两个文件夹的关联，本地代码的修改也能直接映射到虚拟机，而且可以在windows上提交代码，因为是在win上clone迁出远程仓库的代码，所以提交的时候不会出现换行(crlf)的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-数据库和模型</title>
    <link href="http://yoursite.com/2019/10/25/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/10/25/tp源码分析-数据库和模型/</id>
    <published>2019-10-25T07:05:40.000Z</published>
    <updated>2019-10-25T07:05:40.160Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tp源码分析-Cache</title>
    <link href="http://yoursite.com/2019/10/22/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cache/"/>
    <id>http://yoursite.com/2019/10/22/tp源码分析-Cache/</id>
    <published>2019-10-22T01:45:16.000Z</published>
    <updated>2019-10-25T06:45:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>需要改变的观点是</p><ol><li><p>这个cache 并不能完全替代redis， 这个cache 只提供一些缓存比如redis,memcache，file 方法的聚合，比如set 设置缓存，如果配置的是redis， 走的是redis string的get 方法，如果配置的是file， 则对文件名进行hash， 然后存储在对应文件下面 （redis 键的过期不用我们代码中主动考虑，当我们使用redis 的set 命令的时候自动帮我们实现（redis有自己的键过期策略），但是file 没法设置过期时间，只有在get的时候拿着文件的mktime 加上 存储的expire time 和当前时间进行对比，如果超过了就返回null，并删除文件，当然我们在调用的时候不用考虑，单纯的通过 Cache::set() 就行了，上面的操作都是 cache的driver 之一 file 帮我们封装好了）</p></li><li><p>介绍一下 cache 库的基本结构</p><p>首先 \Cache -&gt; facade Cache -&gt; think Cache,  所以上述三个类都能调用cache，前面两个类等同，都只能通过 静态方式调用方法 ！！！，走的是我们的默认配置。think\Cache 属于实际类，他没有 _call_static 方法，所以我们不能用这个类静态的调用方法，需要先实例化，然后去调用。</p><p>这个库包含三个基本文件</p><ol><li><p>cache.php ,这个类是入口，实例化的时候走的是他的_construct, 生成handel实际处理句柄，干啥的？ 对于set， get 操作，实际发起者就是他。然后就就是一些config 的配置，具体的操作并不涉及。</p></li><li><p>cache 文件夹下的 driver.php .是一个abstract class （abstract 相比较interface ，首先abstract 是类，类只能单继承，interface 是接口，可以多实现。再者abstract 中可以包含 方法实体，但是interface 中的方法都不能包含实体。这个driver.php 应该用abstract，因为他包含一些公共方法，比如 pull -&gt;取出缓存中的一个数据并删除，可以直接通过各个cache driver 的 get 和rm 方法的组合，并不需要每个  cache driver 各自定义，所以他的pull 方法可以直接包含方法体）。</p></li></ol></li></ol><a id="more"></a><p>首先来看一下 think\Config</p><p>instance</p><p>容器类，装着一个个 options 的驱动类，这些驱动的名字默认是配置项（options）序列化，保证同样的配置不会生成多个实例</p><p>config </p><p>配置属性，用来选择使用哪个驱动，file ? redis or memcache</p><p>handler</p><p> 注意这个和driver 下面的驱动类的handle 区分开，那个handle 是实现具体操作的句柄，比如 驱动是 redis， 那个handle 是 new \Redis （c 实现的php扩展）， 而Cache 中的handle 是驱动类， think\cache\Redis</p><p>__construct()</p><p>初始化方法，config 属性的赋值，然后调用init() 方法</p><p>connect()</p><p>根据配置生成实际的cache 文件夹的实体类，存储在instance 属性中 （可以有多个cache配置），名字用配置项的序列化生成的字符串。返回的内容是实体类</p><p>init()</p><p>返回内容也是实体类，但操作的是 handle，handle属于instance 中的一个，是当前调用Cache 时候某个config 生成的实体类，不多于一个。因为这个条件的限制，所以只有第二个参数force 在 true 的时候，或者当前handle 是null（比如file），才能实现 cache 加载类的切换。</p><p>getConfig()</p><p>获取options, 操作的属性名叫config （不叫options）</p><p>setConfig()</p><p>设置options,操作的属性名叫config</p><p>store()</p><p>上面也说了init 方法不太方便切换当前操作的cache， 这个store很方便，通过传入不同配置项的名称，实现cache 加载的config 的切换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return [</span><br><span class="line">    // 使用复合缓存类型</span><br><span class="line">    &apos;type&apos;  =&gt;  &apos;complex&apos;,</span><br><span class="line">    // 默认使用的缓存</span><br><span class="line">    &apos;default&apos;   =&gt;  [</span><br><span class="line">        // 驱动方式</span><br><span class="line">        &apos;type&apos;   =&gt; &apos;file&apos;,</span><br><span class="line">        // 缓存保存目录</span><br><span class="line">        &apos;path&apos;   =&gt; &apos;../runtime/default&apos;,</span><br><span class="line">    ],</span><br><span class="line">    // 文件缓存</span><br><span class="line">    &apos;file&apos;   =&gt;  [</span><br><span class="line">        // 驱动方式</span><br><span class="line">        &apos;type&apos;   =&gt; &apos;file&apos;,</span><br><span class="line">        // 设置不同的缓存保存目录</span><br><span class="line">        &apos;path&apos;   =&gt; &apos;../runtime/file/&apos;,</span><br><span class="line">    ],  </span><br><span class="line">    // redis缓存</span><br><span class="line">    &apos;redis&apos;   =&gt;  [</span><br><span class="line">        // 驱动方式</span><br><span class="line">        &apos;type&apos;   =&gt; &apos;redis&apos;,</span><br><span class="line">        // 服务器地址</span><br><span class="line">        &apos;host&apos;       =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">    ],     </span><br><span class="line">]</span><br><span class="line">复合cache， 通过传入redis， file ，还可以定义更多的</span><br></pre></td></tr></table></figure><p>再看一下cache 文件夹下的Driver.php</p><p>handle</p><p>实体类操作句柄，类似 redis 的 new Redis, pdo 的 new Pdo</p><p>readTimes  </p><p>读取次数，自身用的比较少 （每次读取都会增加）</p><p>writeTimes</p><p>写入次数，用的比较少 （每次写入都会增加）</p><p>options</p><p>tag</p><p>给缓存加标签，比较方便的就是 clear 的时候会清除掉tag 绑定的缓存，而不是整个redis 库的flushDB</p><p>serialize </p><p> 一个数组，其中的四个参数分别代表，序列化方法，反序列化方法，缓存前缀，缓存前缀的字符数量</p><p>abstract  has</p><p>是否有这个缓存</p><p>abstract get</p><p>读取这个缓存</p><p>abstract set 设置这个缓存</p><p>abstract inc 新增步长</p><p>abstract dec 减少步长</p><p>abstract rm 删除缓存</p><p>abstract clear  删除缓存</p><p>getExpireTime</p><p>这个方法太傻比了，不知道咋用，传入的参数是个时间，返回的还是时间，没啥用</p><p>getCacheKey </p><p>正如名字上写的，获取缓存的名字，比如redis 的key值，file 通过这个返回的内容加上自身逻辑，生成对应文件名（其实就是options 中的prefix 拼接上 key）</p><p>pull</p><p>get 和 rm 的组合</p><p>remember</p><p>不存在则写入，类似redis 的分布式锁，5s 中内每隔 0.2 s 执行一次 看是否能设置成功。 5s 中后直接操作，不管有没有锁 （按理说锁的存在时间不应该这么久，所以直接覆盖了之前的锁）</p><p>tag</p><p>给当前类设置属性tag.</p><p>如果传入额外的key, 则把传入的key 存入该tag 名下，这个tag 和key的对应关系如下 ： tag 名根据定义关系生成key,  把对应的key 连接成字符串当做value， 做成 key -&gt; value 映射 （整个cache 库的映射关系都是 key value 形式，没有别的数据结构）</p><p>setTagItem</p><p>给当前tag 加入新的 key</p><p>getTagItem</p><p>获取当前tag 对应的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected function getTagItem($tag)</span><br><span class="line">    &#123;</span><br><span class="line">        $key   = &apos;tag_&apos; . md5($tag);</span><br><span class="line">        $value = $this-&gt;get($key);</span><br><span class="line"></span><br><span class="line">        if ($value) &#123;</span><br><span class="line">            return array_filter(explode(&apos;,&apos;, $value)); </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 发现上面的array_filter 方法用的蛮多的，用来过滤 数组中的 false， 蛮好用的</span><br></pre></td></tr></table></figure><p>serialize </p><p>获取的上面 serialize 属性参数1对应的序列化方法序列化</p><p>unserialize</p><p>获取的是上面serialize 属性参数2对应的序列化方法反学历恶化</p><p>registerSerialize</p><p>修改serialize 属性</p><p>handler()</p><p>获取句柄</p><p>getReadTimes</p><p>获取读取次数</p><p>getWriteTimes</p><p>获取写入次数</p><p>下面是cache 文件中的驱动，随便选一个，比如 redis.php 分析 (看了这个类很容易自己封装一个 redis 操作库)</p><p>（为啥还需要自己封装redis 操作库，因为这个cache 类只是简单的使用redis 的string 类型，更多的操作类型并没有）</p><p>（封装redis lib 其实蛮简单的，把这个redis 连接抄一下，然后加入一个_call 方法就好了，最简单的redis lib）</p><p>(其他的lib 比如es lib 也可以这么考虑，重要的就是一个tcp 连接)</p><p>options  </p><p>redis连接的参数</p><p>_construct</p><p>建立redis 连接 （支持 php 扩展 redis （phpredis） 和 predis (单纯用php 实现的redis 客户端)）</p><p>has</p><p>调用redis 的 exists 方法</p><p>get</p><p>调用redis 的get 方法</p><p>set</p><p>调用redis 的set 方法，其实 setex 可以直接用set 实现</p><p>inc</p><p>redis incrby 方法</p><p>dec</p><p>redis decrby 方法</p><p>rm </p><p>redis delete 方法</p><p>clear</p><p>redis delete 或者 flushDB !!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要改变的观点是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这个cache 并不能完全替代redis， 这个cache 只提供一些缓存比如redis,memcache，file 方法的聚合，比如set 设置缓存，如果配置的是redis， 走的是redis string的get 方法，如果配置的是file， 则对文件名进行hash， 然后存储在对应文件下面 （redis 键的过期不用我们代码中主动考虑，当我们使用redis 的set 命令的时候自动帮我们实现（redis有自己的键过期策略），但是file 没法设置过期时间，只有在get的时候拿着文件的mktime 加上 存储的expire time 和当前时间进行对比，如果超过了就返回null，并删除文件，当然我们在调用的时候不用考虑，单纯的通过 Cache::set() 就行了，上面的操作都是 cache的driver 之一 file 帮我们封装好了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍一下 cache 库的基本结构&lt;/p&gt;
&lt;p&gt;首先 \Cache -&amp;gt; facade Cache -&amp;gt; think Cache,  所以上述三个类都能调用cache，前面两个类等同，都只能通过 静态方式调用方法 ！！！，走的是我们的默认配置。think\Cache 属于实际类，他没有 _call_static 方法，所以我们不能用这个类静态的调用方法，需要先实例化，然后去调用。&lt;/p&gt;
&lt;p&gt;这个库包含三个基本文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;cache.php ,这个类是入口，实例化的时候走的是他的_construct, 生成handel实际处理句柄，干啥的？ 对于set， get 操作，实际发起者就是他。然后就就是一些config 的配置，具体的操作并不涉及。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cache 文件夹下的 driver.php .是一个abstract class （abstract 相比较interface ，首先abstract 是类，类只能单继承，interface 是接口，可以多实现。再者abstract 中可以包含 方法实体，但是interface 中的方法都不能包含实体。这个driver.php 应该用abstract，因为他包含一些公共方法，比如 pull -&amp;gt;取出缓存中的一个数据并删除，可以直接通过各个cache driver 的 get 和rm 方法的组合，并不需要每个  cache driver 各自定义，所以他的pull 方法可以直接包含方法体）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>三个星期的PHP面试</title>
    <link href="http://yoursite.com/2019/10/01/%E4%B8%89%E4%B8%AA%E6%98%9F%E6%9C%9F%E7%9A%84PHP%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/10/01/三个星期的PHP面试/</id>
    <published>2019-10-01T13:36:20.000Z</published>
    <updated>2019-10-01T15:51:38.926Z</updated>
    
    <content type="html"><![CDATA[<p>故事发生背景：男，94年，工作经验2.5年，普通一本，软件工程，裸辞，8月9日裸辞！！！然后在上海和家呆了一星期，去云南玩了一星期，后来回上海写简历，租临时住所一星期，9月1日正式开启我的找工作之旅。</p><a id="more"></a><h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><p>简历真的很重要，因为很多hr真的会把你的简历筛掉 </p><p> <img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2e55660f533d8ada1971e2ead31f030.jpgg" width="300"></p><p>所以啦，不能怪他们，只能怪我们自己没有写的好，怎么写好PHP面试的建立？老李的文章写得很详细，这里我就大致说一下我自己的看法：</p><p>首先是对于基础的掌握程度，比如各种框架的生命周期，composer加载原理，facade，ioc，各种设计模式，比如单例，工厂，装饰器。又比如网络层面的基础，比如tcp三次握手4次挥手，https原理，tcp 编程，php-fpm fastcgi swoole。再者就是各种更深层次的原理，比如php7 的优化，redis 数据结构，索引b+ 树最左前缀。</p><p>写完基础，就要看项目经验了，是否有电商的项目经验，redis的应用场景，mysql 的分库分表，最高并发和最多数据量的表是多少，是否有服务拆分，微服务相关经验。是否有app 开发的相关经验，代码发布流程。</p><p>很大程度上面试官都会依据着你写的简历问你相关的问题，哪方面比较擅长就多写点呗，很多时候面试官都会给你机会让你在你擅长的领域上发挥，我们不用管我们擅长的是项目还是PHP本身，把你最好的表现出来就好了，一定不要因为你觉得更熟悉框架对请求的加载流程相较于有高并发经验比较低级，硬往上面靠，到头来不仅没有因为你擅长的东西得到面试官的青睐，还会因为表达不清楚或者说瞎编被抛弃（深有感触，在sty面试之后有感）</p><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p>首先想说一下关于裸辞这件事。</p><p>本身我是很赞成裸辞的，毕竟觉得找工作单纯靠着上班时间请假很难完成，而且觉得自己有能力，辞职之后还可以专心准备找工作。但是经历了这三个星期之后，我的想法产生了极大的变化，可能以后我还会裸辞，但是我想告诉大家一些事情，当你裸辞之后你要做好长时间找不到工作，又或者是下家比上家还差的打算。下面是我大致的新路历程：</p><h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><p>因为2年多从来没面试过，很仿徨，觉得redis 数据结构不懂，php 源码不会，总感觉自己没准备好，而且为了练手，我在拉钩上只投了很小的几个企业，大致规模是 150人以下，收到了4个面试邀约（很少了，其实如果裸辞的话，一周感觉10个吧，然后筛选一下到7个，也不会很累）。</p><p>第一家是做线上培训的。公司很小(一层楼都没有)，大概类似传统行业的格子间 。首先是做面试题嘛，他家的面试题很杂，大概就是网上找的那些html+css+js+mysql+php, 其实这些都是web开发应该会的，但是他家的题很恶性，类似那种mysql 改密码一共有多少种方式，以下哪个js 语法有错误，mysql事务的4个特征属性是什么，唯一一道有参考价值的应该是末尾的用php写一个广度优先。后面就是面试官，balabal，问了一个场景，同时4w人考试的系统怎么设计(全国范围内)。在后面是 ceo 宣传了1个小时他家的产品，给的很低，而且试用期打折，pass。</p><p>第二家是做的一个类似实体店铺的导购，完全没有面试官，就是ceo 宣传（！真的敢这么招人，仿佛来了就要），没有学到一点面试经验，所以呢，以后小伙伴们投递的时候对于50 人左右的公司， 或者是ceo直接在拉钩上招人的公司，慎重投递，没啥意义。</p><p>第三家，sty (二面很惨)。 这应该是这一周唯一一次有价值的面试了，公司蛮大的，研发也挺多，环境高大上，hr 挺好看，就是有点冷漠 （不要水的话，他们不会给你倒的哦）。做题。一面，说一下地址栏输入地址之后的过程。这个我擅长呀，先hosts 文件，浏览器缓存，dns解析，域名转ip 地址，然后和服务器建立连接，nginx 传php-fpm , 给php ，我顺便补充了一下tp框架执行流程。 那你用过composer吗，用过，然后我直接给他说了composer 源码加载原理。用过redis吗， 说一下场景 （我这个级别，很多时候就考这个，redis 命令一定要记熟悉！！！比如怎么获取zsort 中元素数量），还问了redis 集群，raft算法 (不会啦，redis 真的很重要) ，git 怎么回退 （！！！啧啧啧，真的很少用 git reset），说一下array 经常用的方法。本来以为很简单的过了，和朋友都发了短信，二面面试官来了。真的很厉害，tcp 三次握手建立连接除了syn ack包还有那些 ？pdo 是长连接还是短连接 ？连接池有什么作用 ？到底用长连接还是短连接比较好 ？为什么主键需要连续 ？索引怎么查找的 ？事务没提交出现大量close_wait 错误是出在哪里，php 还是mysql ？</p><p>第四家，rt 。第四家在soho 的地下室，其实面的感觉还不错，但是没要，不知道是不是像我朋友说的那样套路创意，因为之前他面的ios， 聊得很不错，后来就没消息了。面试题很不错，总共4道题，第一眼看上去可能一道都不会，第一道是对msyql 表的设计，给了一个场景。第二道是对laravel 的collection 一个方法的实现。第三道是写一个sql。第四道是关于mysql 可重复读时候修改数据阻塞的考察，问的内容大致就是一些简单项目，还有一点点es。</p><h3 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h3><p>因为第一周面试之后给我的阴影蛮大的(最主要sty的二面让我真的认识到自己的不足)，周六和周日投的基本是b轮以上的公司或者是150人以上的，可竟然周一一个面试机会都没有！！！</p><p>我慌了！！！</p><p>周一晚上疯狂的海投（但是类似lb，bd，tx，fl，hp，yw，bz 这些大厂还没有投，想留在第三周），终于约了4个面试。</p><p>第一家，yhxc。大概两个小时的车程，主要到了那边下地铁之后坐不到公交车，对的，你没有听错，在上海竟然等不到公交车（ps，可能之前都住在比较靠近市里的地方，公交车基本10分钟以内一班），打车去的软件园。公司挺大，一层楼，很高档，相比sty 的 ins风，这边更加温馨，但可以看得出来，不缺钱。笔试，拿走了手机。面试，面试官对着我两个for 写的冒泡看了半天，说不对，··我讲了半天我自己都怀疑了，然后他拿来的dell 笔记本，我写了一下，运行正确，他又看了5分钟····二面，一个不喜欢我用DateTime 去写时间的人，说实话，我挺反感的，主要是他直接定义我date 用的不熟，于是我直接用date 实现了一遍，他还是不服气，因为他的题是 2018-9-7，~~不同人的看法不一样，这tm 和 2018-09-07 的考察点的区别真的很大吗。后面就是hr面，背调了2个小时，真的！！！本来想着凑合着他过吧，出现了另一家拯救我的公司，yx。</p><p>第二家，yx的面试是下午5点钟，因为中午回去不了，我找了家星巴克（肉疼）。没有笔试题，一面面试官来自百姓网，穿个大裤衩，北方人，看上去就很放荡不羁，一直擦着鼻涕，但真的很厉害好嘛~~~我们之间的面试很短暂，可能是我了解的知识正好是他get的点，而且聊到情深处，他自问自答，当他对我说索引 b+树查找原理之后，我顺便拿着这个回答了二面面试官。真的蛮想去他那，可是呢，996，对不起了，如果以后有机会的话，真的想认识一下。二面面试官也很厉害，他更注重项目经验，眼光狠毒辣，仿佛我的两年半工作经历都被他看穿了，不管我怎么掩饰。tinyint 占用几个字节，能表示的数多大，你们代码发布流程？没有app的开发经验。然后是hr面</p><p>上面两家公司的offer 让我很是头疼，是去一个类似国企的公司还是去一个技术更占优势但是996的公司，我失眠了。</p><p>第三家，xyk。要是xyk 给的钱多的话，可能就没有后续了。笔试题， 8 % -2 多少？ 0！！！，他们那的一个对我影响蛮深的面试题就是 setcookie, var_dump($_COOKIE); 答案是 null。一面面试官就对着面试题询问，我们大概聊了1个小时，他和我工作经验差不多，然后人很好，很热情，对于面试题上出现的没达到他想要的内容都会耐心引导，一度让我以为他很闲（哈哈哈，真的，小哥人真的超级好）。二面面试官，首先不说他技术咋样，反正蛮反感的，就是类似比如觉得你restful 说的不全面，但自己也不说哪不对，滚混去查~~~。hr面，钱给的少，pass。技术还行，不加班，介于上面二者之间，氛围不错</p><p>第四家，ydkd。是一家在青浦的快递公司，真的PHP的兄弟们！！！不要去，真的。首先面试距离远不说，去了要做一份智力题，不过不给面试，那些题目真的恶心到家了。而且公司里面员工都穿着快递服装，进门就是一股浓浓的网吧味道（塑料胶门）。因为那边的环境，逻辑题8分钟糊弄完，没过，滚回家了。</p><h3 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h3><p>第一家，sm。┭┮﹏┭┮，sm真的不是司马的意思，但去知乎上面搜一下，这个公司的负面新闻真的蛮多的，这也是我面试以来第一次没通过一面的公司。比较难的点 php 源码，zend 引擎， docker 和 k8s。不管你答得好不好，他反正没有反馈，真的很sm 那。唯一一点好处就是，以前一直没关注abstract 和 interface 的区别，这次回来自己弄明白了。面完之后朋友说半小时内你可能会受到一个面试反馈，这家公司应该是hr在刷kpi，果真这也是我第一次收到面试反馈···</p><p>第二家，lb。lb 那三道万年不变的面试题。但和面试官沟通之后，学会了几个技巧，比如有序数组，就要想到二分查找，原先的结果反转，就可能得到组合的效果。lb里面人的反馈蛮差的，本身觉得他和pdd有什么关系，但实际上好像并没有，面了两轮技术，一轮hr， 最后一轮hr没面到。</p><p>第三家，fl。笔试题好像很不错，好像错了一道，直接过了。然后是两轮技术。fl不是一个技术驱动的公司，他们那更多的在乎是业务。fl的前台真的巨好看，好想再去面一次。fl的面试中午提供午餐，真的很好吃。26号入职，fl也给你交社保。fl的hr 真的超级贴心。对不起，fl。</p><p>第四家hp。 面试官，我要给你奉献我的心脏。</p><p>第五家bd。真的sb bd， 周三约电话面试，我推掉了所有的事情，你tm值面了我10分钟，让周五去现场面试。周五我推掉了所有的面试，你tm周五早上对我说面试官有事情，只能下周一，我之前就清楚的说了我下周一就要入职了。你的股价跌也是有原因的。</p><p>第六家，lyg。lyg和hp的评价在看准网上都挺低的，我一度不想去lyg面试了，可真当我可lyg的面试官交流后，我发现他是面试以来最和蔼的人top3。二面，可能没get到他的点，他也没问我啥。（lyg在宜山路一栋楼，好像饮料也都是免费的，如果能进去应该不错，在做类似比心的陪玩)。二面面试官类似lb面试官跑去和hr商量了一下，回来说hr不在。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是这次大致的面试经历，其中第三周还省略了好几家，比如一家上机面试（hr夸我厉害，说很少有人能做出来，后来给的很多，而且6险2金）,一家洗涤公司（希望我做过二次开发，为啥？因为这样读别人的烂代码就有经验了），收到了蛮多offer的，相比前两周的失意，第三周仿佛开了挂一般，虽然大公司不多。所以想告知小伙伴们，如果裸辞了，一定要做好打持久战的准备，而且可能这个城市没机会了，只能换一个城市，（中国也就上海 北京了吧，php的话），所以呢为了保险起见，还是不要裸辞了，安安心心做事，踏踏实实学本领，总会变得有钱的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事发生背景：男，94年，工作经验2.5年，普通一本，软件工程，裸辞，8月9日裸辞！！！然后在上海和家呆了一星期，去云南玩了一星期，后来回上海写简历，租临时住所一星期，9月1日正式开启我的找工作之旅。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于ob函数</title>
    <link href="http://yoursite.com/2019/09/30/%E5%85%B3%E4%BA%8Eob%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/30/关于ob函数/</id>
    <published>2019-09-30T11:40:50.000Z</published>
    <updated>2019-09-30T11:52:09.020Z</updated>
    
    <content type="html"><![CDATA[<p>在看源代码的时候还有phpexcel 的时候经常都会看到ob 函数，ob函数主要是用于处理php 的缓存的，默认cli 下ob 是关闭的，需要我们手动打开</p><p><a href="http://www.laruence.com/2010/04/15/1414.html" target="_blank" rel="noopener">ob_flush和flush</a></p><p><a href="http://www.laruence.com/2010/12/17/1833.html" target="_blank" rel="noopener">echo</a></p><p><a href="http://www.laruence.com/2011/02/13/1870.html" target="_blank" rel="noopener">加速echo</a></p><p>(之前看到的fastcgi-finish-request 和上面的缓存也是有一点关系的哦), 每当php 返回数据的时候，我们可以这么看待传输过程，首先是php把数据给webserver， webserver 再把数据给cli ，webserver 在传输给cli 的过程中php的处理进程并没有结束，所以这之间的传输效率也会影响php进程的存活时间，当这之中传输过慢的时候，就会导致大量的php进程存在（php维护的的数据库单例连接也就存在），有时候我们想尽快的结束这个php进程，可以让php 传输给webserver 的时候开启一个缓冲池，当缓冲池满的时候一次性推给webserver，然后fastcgi_finish_request ,这之后就和php进程没关系了，php就可以接受下一个请求或者断开都可以</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看源代码的时候还有phpexcel 的时候经常都会看到ob 函数，ob函数主要是用于处理php 的缓存的，默认cli 下ob 是关闭的，需要我们手动打开&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2010/04/15/1414.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ob_flush和flush&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2010/12/17/1833.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;echo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2011/02/13/1870.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;加速echo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(之前看到的fastcgi-finish-request 和上面的缓存也是有一点关系的哦), 每当php 返回数据的时候，我们可以这么看待传输过程，首先是php把数据给webserver， webserver 再把数据给cli ，webserver 在传输给cli 的过程中php的处理进程并没有结束，所以这之间的传输效率也会影响php进程的存活时间，当这之中传输过慢的时候，就会导致大量的php进程存在（php维护的的数据库单例连接也就存在），有时候我们想尽快的结束这个php进程，可以让php 传输给webserver 的时候开启一个缓冲池，当缓冲池满的时候一次性推给webserver，然后fastcgi_finish_request ,这之后就和php进程没关系了，php就可以接受下一个请求或者断开都可以&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-Response</title>
    <link href="http://yoursite.com/2019/09/30/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Response/"/>
    <id>http://yoursite.com/2019/09/30/tp源码分析-Response/</id>
    <published>2019-09-30T09:36:34.000Z</published>
    <updated>2019-12-29T14:52:57.237Z</updated>
    
    <content type="html"><![CDATA[<p>框架可能让你对PHP 怎么给webserver 返回内容产生了误解 ！！！</p><a id="more"></a><p>PHP 是怎么把数据返回给前端的？通过response 对象？因为我们一直在用框架，框架中对于这些返回都是包裹成了response 对象，然后我们想要改变返回的内容，直接修改这个response对象就好了，比如在itbasic上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/[:controller]/[:func]&apos;, function ($request, $response) &#123;</span><br><span class="line">    $res  = $obj-&gt;$func($request, $response);</span><br><span class="line"></span><br><span class="line">    //$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;);</span><br><span class="line">    $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line"></span><br><span class="line">    $response-&gt;json($res);</span><br><span class="line">    // return json_encode($res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面就是一种很常见的route 组件的使用，很多时候我们可能以为代码就在这结束了，殊不知，这块只是我们定义个的一个callback， 框架代码在执行了这段之后只是完成了response 对象的封装，之后他们还会处理response 对象，比如调用php原生header 处理response的header 属性，echo response 对象的data 属性。</p><p>又或者下面这种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/[:controller]&apos;, function ($request, $response, $service) &#123;</span><br><span class="line">    return $obj-&gt;$func($request, $response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>直接返回数据，并没有返回response 对象，那后面程序就可以根绝默认的配置比如content-type html, 然后echo  返回的string。</p><p>上面两种方式大概就是一般路由的使用方法，下面我们来看看tp 中到底是怎么处理的。我们查看一下入口文件index.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 执行应用并响应</span><br><span class="line">Container::get(&apos;app&apos;)-&gt;run()-&gt;send();</span><br><span class="line">从容器中获取 App.php 的实例，执行run 方法</span><br></pre></td></tr></table></figure><p>run 方法很长，我们筛选这次用的几个重要点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 初始化应用</span><br><span class="line">            $this-&gt;initialize(); // 这个里面会帮我们加载自定义的路由中间件到 middleware 的queue 属性中</span><br><span class="line"></span><br><span class="line">····</span><br><span class="line">        $this-&gt;middleware-&gt;add(function (Request $request, $next) use ($dispatch, $data) &#123;</span><br><span class="line">            // var_dump(&apos;ppp&apos;);</span><br><span class="line">           // var_dump($data);</span><br><span class="line">            // 没错误，直接走的run 方法</span><br><span class="line">            // 这个地方因为 next 用不到了，所以</span><br><span class="line">            return is_null($data) ? $dispatch-&gt;run() : $data;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 这个地方往middleware 的queue 属性中加入一个callback， 如果之前有路由中间件，这块就是前面需要需要的参数 $next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $response = $this-&gt;middleware-&gt;dispatch($this-&gt;request); // 中间件的执行，包括控制器的执行都在这里面</span><br><span class="line"></span><br><span class="line">        // 监听app_end</span><br><span class="line">        $this-&gt;hook-&gt;listen(&apos;app_end&apos;, $response); // 钩子 app end 执行</span><br><span class="line"></span><br><span class="line">        return $response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>所以呢，通过上面的代码可以看出来在tp 中路由中间件和控制器其实是同一个层面的，他们的核心就是返回一个response， 比如中间件过滤失败 ，我们也需要返回一个response，万万不可以在路由中间件里面返回false， 因为后面的send() 方法需要response 类来调用，控制器中之所以可以直接返回数据是上面那个回调函数写的好，\$dispatch-&gt;run() 中有对控制器返回内容的自适应，如果控制器返回的是一个response，那就直接让他调用send 方法，否则会根据配置文件包装一个response 方法返回。 </p><p>但凡我们想停止路由中间件的执行，我们可以不执行 $next() 方法，直接返回response， 这就他就会直接调用 send 方法，而不去处理控制器中内容。tp这块的原理和 laravel 还是不同的，laravel 中是通过array_reduce 不断的去执行绑定匿名函数，tp 中是通过对middleware的queue属性数组中的匿名函数不断shift， 每一个匿名都依赖下一个匿名，但要是当前匿名不需要比如执行下一个匿名 \$next() 的执行，那只会传入一个function， 而没有实际执行。这在我思考为什么 控制器执行的时候 ，明明queue 数组中没有办法shift 匿名函数了，却没有报错时候产生了极大的困惑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call_user_func(&apos;test&apos;, [$callback])  // 不执行，除非test方法中 $callback() 主动调用</span><br><span class="line">call_user_func($callback, [$parama]) // 执行</span><br></pre></td></tr></table></figure><p>接下来我们分析一下 Response 类，</p><p>首先是最重要的方法，</p><ul><li>send</li></ul><p>hook 当中的listen_send ,属于常规操作，在我们response 解析之前</p><p>然后是</p><ul><li>getContent </li></ul><p>对于我们的控制器返回进行处理，生成最后要echo 的内容。其中的output方法就是我们response 文件夹下所有继承response 类要实现的方法，比如json 类，会json_encode, 要是普通的类， response的data 属性就直接赋值给content 属性了，默认content-type 是html.</p><p>思考一下为什么我们在控制器中返回arr 有时候会出错？因为我们最后的数据都要echo ,然后都必须要转换成string， 当我们使用默认的配置文件的时候，如果我们直接返回一个数组，默认生成的类是response 类，他的output 方法就是直接data 给content， 这样就导致我们echo 了一个arr ，能不出错嘛</p><p>后面一段是开启</p><ul><li>trace 调式</li></ul><p>trace 调试我感觉方便的一点就是能看到执行的sql 语句，这在开发中是很必要的。</p><p>再后面就是头信息的处理，</p><ul><li>调用php 原生header</li></ul><p>再后面就是</p><ul><li>echo data</li></ul><p>在后面就是</p><ul><li>fastcgi_finish_request(); </li></ul><p>执行这个方法，这个方法的好处就是在我们尽快把客户端要的内容返回后，php 脚本还能继续执行， <a href="http://www.laruence.com/2011/04/13/1991.html" target="_blank" rel="noopener">参考鸟哥这篇文章</a></p><p>再后面就是客户端输出完成后服务端自己的一些收尾工作</p><p>再来整体分析下response 这个类</p><ul><li>__construct 初始化</li></ul><p>其中content-type charset 拼接很重要，标准的就是拼在一起，有时候当你没有识别json的，想想客户端传过来的content-type 是否多了 charset  utf8 信息</p><ul><li>create 生成一个response </li></ul><p>这个就相当于一个factory， 根据type的不同，生成不同的response， 注意我们控制器中返回的response 或者官方对于控制器中 string 这种的返回包装的response ，都是new 的，而不是从app 容器中取得</p><ul><li>send  解析response对象，给webserver 返回数据</li></ul><ul><li>output 对于data 依据content-type 进行处理，转成对应的string, 比如 json 转string</li></ul><ul><li>sendData  就是最后一步，echo 数据</li></ul><ul><li>options  一些额外的参数配置，比如tp 中，可以对于json_encode 添加参数 ，json_encode 之后汉字我们仍旧能识别</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">options([</span><br><span class="line">        &apos;var_jsonp_handler&apos;     =&gt; &apos;callback&apos;,</span><br><span class="line">        &apos;default_jsonp_handler&apos; =&gt; &apos;jsonpReturn&apos;,</span><br><span class="line">        &apos;json_encode_param&apos;     =&gt; JSON_PRETTY_PRINT,</span><br><span class="line">    ]);</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190930193953.png" alt=""></p><ul><li>data 设置data 属性</li></ul><ul><li>allowCache  设置是否允许缓存request 内容，如果允许的话，会配置header头信息</li></ul><ul><li>header 配置header 头信息</li></ul><ul><li>content 把content 的内容转换成 string</li></ul><ul><li>code 设置http 状态码</li></ul><ul><li>lastModified 设置上次修改时间</li></ul><ul><li>expires  设置过期时间</li></ul><ul><li>etag  设置etag</li></ul><ul><li>cacheControl  设置cacheControl</li></ul><ul><li>nocache 设置不缓存</li></ul><ul><li>contentType 设置contentType</li></ul><ul><li>getHeader  设置请求头</li></ul><ul><li>getData  获取 data属性</li></ul><ul><li>getContent 类似上面的content 方法</li></ul><ul><li>getCode 获取http 状态码</li></ul><ul><li>debugInfo</li></ul><p>补充：</p><p>因为今天在看response类，他对很多header头部信息处理过，比如allowCache, 大致了解几个新的header 头 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ</a></p><p>cache-control  这个我们经常看到，no-cache,但这个其实并不是不缓存的意思（强制确认缓存的意思），no-store 才是不缓存的意思。其中还有max-age 属性，代表这个缓存最大活多久，must-revalidate, 代表使用之前要检验是否过期了。</p><p>expires 代表缓存过期的时间</p><p>今天在控制器中设置header 头发现不生效，原因有两个，</p><ol><li>php的header 蛮反人类的，这样用 header(“Content-Type:application/json”),竟然是字符串。</li><li>后面response send 中header 会覆盖掉控制器中的header</li><li>那为啥文件结尾header 没生效呢，因为response send 方法调用了 fastcgi_finish_request(), 结束了相应</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;框架可能让你对PHP 怎么给webserver 返回内容产生了误解 ！！！&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-异常处理</title>
    <link href="http://yoursite.com/2019/08/30/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/30/tp源码分析-异常处理/</id>
    <published>2019-08-30T05:05:13.000Z</published>
    <updated>2019-10-25T06:58:20.433Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000014977430" target="_blank" rel="noopener">参考文章</a></p><p>上面这篇文章写得很好，让我对异常处理除了 try catch 之外有了更深的认识，大致记录一下对php 异常处理的理解以及结合tp框架的源码分析</p><a id="more"></a><h3 id="PHP-处理错误的两大类方式"><a href="#PHP-处理错误的两大类方式" class="headerlink" title="PHP 处理错误的两大类方式"></a>PHP 处理错误的两大类方式</h3><p>首先我们要明白php 的异常处理分成两个独立的大块，一个是php自身的标准处理，就是我们经常error_reporting ， display_error 的设置（呈现形式就是界面上的php warning 信息， php fatal error 这种）；另一个是我们通过try catch 捕获异常进行处理（我们可能在catch 中 记录 $e-&gt;getMessage()） . 我们要清楚的是这两块对错误的处理级别是相互独立的，互不影响。比如error_reporting(0), 不对任何异常进行处理（ps: -1 ,类似 E_ALL ）,try catch 还是能捕捉到我们的exception。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0); // 0 的时候没有任何错误信息， -1 的时候会打印出 //fatal_error</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  throw new Exception()</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">  var_dump($e-&gt;getMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PHP-标准错误处理-error-reporting-参数的意义"><a href="#PHP-标准错误处理-error-reporting-参数的意义" class="headerlink" title="PHP 标准错误处理 error_reporting() 参数的意义"></a>PHP 标准错误处理 error_reporting() 参数的意义</h3><p>error_reporting(), 不带任何参数，返回的是错误处理级别，带参数意思是设置错误处理级别</p><p>error_reporting(E_ALL ^ E_NOTICE) , ^ 是异或，代表除了E_NOTICE 都进行处理， 或者</p><p>error_reporting(E_ALL &amp; ~E_NOTICE), &amp; 是同或， ~代表取反，和上面是同一个意思，E_ALL是一个常量，数值是 E_NOTICE 那些的结合体</p><p>error_reporting(E_NOTICE | E_WARNING), 包括notice 和 warning 错误  </p><h3 id="PHP的错误等级"><a href="#PHP的错误等级" class="headerlink" title="PHP的错误等级"></a>PHP的错误等级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 系统级用户代码的一些错误类型 可由 try ... catch ... 捕获</span><br><span class="line">E_PARSE          解析时错误 语法解析错误 少个分号 多个逗号一类的 致命错误</span><br><span class="line">E_ERROR          运行时错误 比如调用了未定义的函数或方法 致命错误</span><br><span class="line"></span><br><span class="line"># 系统级用户代码的一些错误类型 可由 set_error_handler 捕获处理</span><br><span class="line">E_WARNING        运行时警告 调用了未定义的变量</span><br><span class="line">E_NOTICE         运行时提醒                  </span><br><span class="line">E_DEPRECATED     运行时已废弃的函数或方法</span><br><span class="line"></span><br><span class="line"># 用户级自定义错误 可由 trigger_error 触发 可由 set_error_handler 捕获处理</span><br><span class="line">E_USER_ERROR      用户自定义错误 致命错误 未处理也会导致程序退出</span><br><span class="line">E_USER_WARNING</span><br><span class="line">E_USER_NOTICE</span><br><span class="line">E_USER_DEPRECATED</span><br><span class="line"></span><br><span class="line">==========================开发中常遇到/不常遇到分割线=======================</span><br><span class="line"></span><br><span class="line"># Zend Engine 内部的一些错误 应该也能通过 try ... catch ... 捕获 略难测试</span><br><span class="line">E_CORE_ERROR</span><br><span class="line">E_CORE_WARNING</span><br><span class="line">E_COMPILE_ERROR</span><br><span class="line">E_COMPILE_WARNING</span><br><span class="line"></span><br><span class="line">#编码标准化警告(建议如何修改以向前兼容)</span><br><span class="line">E_STRICT          部分 try ... catch ... 部分 set_error_handler</span><br><span class="line">E_RECOVERABLE_ERROR</span><br></pre></td></tr></table></figure><p>这个地方需要我们注意的是结合PHP7 的 error 和 exception 来看，php7 的error 和 exception 都来自throwable， 所以我们在 catch  throwable都能捕获到，他和上述php 标准错误级别的关系如下</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190830133738.png" alt=""> </p><p>也就是说我们平时throw 的都是实际的error， 需要注意的是上面的 E_USER_NOTICE,并不指的是我们用户写的代码触发的notice， 或者throw 的 notice (用户throw的都是error)， 这个实际上我也没见过，但我们可以通过trigger_error 函数模拟出来</p><h3 id="PHP-各种错误的触发"><a href="#PHP-各种错误的触发" class="headerlink" title="PHP 各种错误的触发"></a>PHP 各种错误的触发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_repoting(0)</span><br><span class="line">aa</span><br></pre></td></tr></table></figure><p>为什么上述代码还是会抛出parse error， 因为我们在当前脚本中存在着错误，还没有执行error_reporting 就会报错，但有个方法可以让上述代码不报错，就是把 aa 写在另一个文件中，然后require 这个文件 。我们php-fpm 模式的本质，其实就是 php index.php, 所以我们在 index.php 中可以写上很少的代码，至少保证这个index.php 的正确性。</p><p>（可能是因为php是解释性的代码，只会检测require 的文件是否存在，不会检查被包含的该文件正确性，但是会对require 的文件中 require 语句正确性检测，蛮奇怪的,而且require 的文件不存在会抛出两个错误，一个是warning ，一个是fatal error， 这个warning 会被set_error_handle 处理，这个fatal error 不能被捕获， 而且竟然能通过error_reporting 屏蔽，感觉就是严重性介于 文件本身 parse error 和 try catch 捕获的 error 之间）</p><h3 id="关于PHP-异常处理的几个函数"><a href="#关于PHP-异常处理的几个函数" class="headerlink" title="关于PHP 异常处理的几个函数"></a>关于PHP 异常处理的几个函数</h3><ul><li>try catch , 不用做过多的介绍了，老朋友，可以捕获 throw 的所有内容，相当于 php 标准错误的fatal_error, 但不是fatal_error 就等于他，比如 require 的文件错误不存在，就不能被捕获</li></ul><ul><li><p>set_error_handle, 和上面的try catch 互补，try catch 捕获的都是 E_ERROR 级别，对于那些warning ,notice 就靠这个东西来处理了，他有个返回值，当返回false 的时候，错误还是会提交个php 标准错误处理的 （也就是处理错误的流程是先php代码处理，然后php 自身处理， 我觉得php自身处理应该就是日志记录，还有display error 。 php 的错误日志一定要注意位置，很多时候不是php.ini 里面配置的位置，而是虚拟主机 apache  或者 nginx 里面配置的日志位置）</p></li><li><p>set_error_handle要比想象中的强大多了，我们可以在这之中接受 erroNo, erroStr, 封装成 exception 抛出去，那么就会在当时被set_error_handle 捕获的地方抛出 （注意几个常用的 error的数字 ，比如 e_error 1, e_warning, e_notice.  -1 代表 e_all,  0 代表关闭所有的错误报告）（adodb即使开启了错误处理，也只能触发 e_user 级别错误，所以只能被set_error_handle 处理，set_error_handle 再抛出异常，才能被捕获）</p></li><li><p>set_exception_handle, 对于没有用try catch 捕获的错误（注意是没有用！！，而不是不能捕获的，捕获的内容等同于try catch）, 会走到这个里面进行处理，但是这个里面处理后程序就停止了，而try catch 处理之后程序还能接着往下走（ps:其实就我们平常而言，很多时候我们捕获了异常，除非在foreach 中，如果在平时逻辑中，也就直接return 给客户端，停止后面逻辑了）</p></li><li><p>register_shutdown_function， 注册一个程序结束的时候执行的函数，就是无论是崩溃啊，还是正常结束，都在最末尾执行的方法</p></li><li><p>error_get_last, 如果一个错误走到了php标准处理那块，就能通过这个获取错误内容，如果一个错误提前被捕获处理了，那这块就是空的</p></li><li><p>throw new Exception , throw new Error, 通过throw 异常，测试try catch 和 set_exception_handle</p></li><li><p>trigger_error, 对于 warning ，notice 那些错误的触发，测试set_error_handle(当然也可以通过 var_dump 一个不存在的变量来触发)</p><p>​</p><p>tp 所有的异常处理都会走到Error 的 appException 方法中,最后给到 getExceptionHandler方法</p><ol><li>首先最基本的提点try catch 的，会被 set_exception_handle 捕获，包括 \Exception 和 \Throwable, 交给 appException</li><li>warning 和user 级别，会被当做 errorException 抛出，转而到 appExcepiton 当中</li><li>register_shutdown_function , 那些没有被捕获到的错误，通过error_get_last 捕获，然后判断是否要塞入 appException 中</li></ol></li></ul><h3 id="TP-框架中的异常处理"><a href="#TP-框架中的异常处理" class="headerlink" title="TP 框架中的异常处理"></a>TP 框架中的异常处理</h3><p>我们对于异常的处理最好写在代码的最前面，否则error 触发之后，该错误之后的代码都不会生效。</p><p>tp 在base.php 中 Error::register();  ，注册了代码的错误处理。(核心文件 Error.php)</p><p>我们大致测试一下cli 模式下的异常处理</p><ul><li>register</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error_reporting(E_ALL); // php 标准错误处理级别</span><br><span class="line">      set_error_handler([__CLASS__, &apos;appError&apos;]); // 对于warning 级别的处理</span><br><span class="line">      set_exception_handler([__CLASS__, &apos;appException&apos;]); // 用户自定义的try catch , 会在执行完之后停止，但是不会交给php 标准错误处理</span><br><span class="line">      register_shutdown_function([__CLASS__, &apos;appShutdown&apos;]); // 感觉就是只要注册了，不管怎样都会执行</span><br></pre></td></tr></table></figure><ul><li>appError </li></ul><p>接受php 传递过来的参数，生成ErrorException 交给 appException 处理</p><ul><li>appException</li></ul><p>首先判断捕获的异常是error 还是exception， 如果是error ，统一转换成 errorException 处理</p><p>然后获取异常处理类，官方是Handle.php, 因为tp 允许用户重写这个类，如果重写了，需要继承官方的Handle 类，重写的方法是render， 框架会自动调用（为什么要重写这个类呢，因为比如记日志这种统一的方法就不需要重写了，框架会自动调用原先自己的方法）。如果没有重写，单单的给了匿名函数，会把这个匿名函数保存到 handle 的render 属性中，后期执行。如果匿名函数都没有，那就执行官方自己的render 方法</p><ul><li>appShutDown</li></ul><p>如果这个错误没有被处理直接交给了php标准错误，会抛出一个ErrorException, 交给自定义的异常处理，否则就记录下日志就好了</p><ul><li>isFatal</li></ul><p>需要抛出的错误级别</p><ul><li>setExceptionHandle</li></ul><p>设置自定义异常处理级别</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014977430&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面这篇文章写得很好，让我对异常处理除了 try catch 之外有了更深的认识，大致记录一下对php 异常处理的理解以及结合tp框架的源码分析&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>云南</title>
    <link href="http://yoursite.com/2019/08/26/%E4%BA%91%E5%8D%97/"/>
    <id>http://yoursite.com/2019/08/26/云南/</id>
    <published>2019-08-26T07:55:22.000Z</published>
    <updated>2019-08-27T02:55:25.154Z</updated>
    
    <content type="html"><![CDATA[<p>女朋友想让我陪她去洱海，因为上海直达大理的机票太贵啦┭┮﹏┭┮(后来算上住宿, 中间的火车,花的钱差不多)，我决定带着她从昆明，丽江再到大理，最后从大理再回昆明坐飞机回上海。</p><a id="more"></a><ul><li>购买机票</li></ul><p>我是买的早上7点45的飞机票，这个时间段和晚上9 10点的飞机都比较便宜，但不好的就是这么早很难赶到飞机场，再加上如果路途遥远，堵车等元素，很容易误车，然后我惊奇的发现美团上在机场旁边有那种精品酒店，其实就是机场周边的农村盖得房子，提供接送机！！！而且不贵，大概就100来块（当然也有贵的，O(∩_∩)O哈哈~），挺干净，噪音也不大，正常人完全能睡着，酒店阿姨会为你登记送机时间，提前半小时给你打电话，很暖心。</p><ul><li>起飞前的那晚</li></ul><p>这是破蛋25年来第一次带女生出去玩，再加上第一次住这种地方，还有见到女朋友的激动，最最重要的是我每次坐火车或者飞机起码检票前1个小时到目的地，那晚很紧张，没有睡着。后面因为从昆明到丽江，再从丽江到大理，从大理到昆明，这样来回折腾，其实都习惯，哪有那么多的特殊情况，安心睡吧，提前半小时到就好了。</p><ul><li>下飞机</li></ul><p>女票比我先到机场，然后因为天生自带shy属性，我在下飞机之后又在厕所呆了半小时，差点把她气疯了，还好她出门没化妆，在机场打发了一点时间。我们在美团上定的民宿在昆明的五华区，离翠湖公园还有南屏街，云南大学很近，因为担心媳妇嫌弃转车麻烦，我们直接打车过去，相比较重庆50元南山区和渝北区随便跑，80元的车票还是蛮贵的，司机师傅确认了2遍我们是否要开发票被我们说不用后，可能在想这两个瓜娃子是不是钱多了。</p><ul><li>昆明初印象</li></ul><p>昆明这座城市还是蛮破的，可能因为我们在市区的原因，还有时间是8月20日，没有书本中的花城的样子，周围都是破破的，相比较重庆没有那么繁华，现代化</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1d7a86c5c7cd42a59852d9eba53dc3f.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4d723356cb20e57a611ca43cddc8685.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7eefd14ba6a55263a396eb33ee5f132.jpg" width="400"></div></div></div></div><ul><li>玩在昆明</li></ul><p>昆明的景点还是有挺多的，比如翠湖公园，云南大学，南屏街，滇池，海埂公园 （打算去的，可是女朋友嫌弃太晒了，所以我们最后只去了翠湖公园 + 看了场哪吒！！！，翠湖公园很一般，和普通公园差不多），如果时间充足，可以去看一些石林呀，云南名族村，或者11月份之后去，可以在海埂公园喂海鸥。</p><ul><li>吃在昆明</li></ul><p>我们选择了大众点评上的第一家云南菜，云海肴，相比较那么多的好评，其实菜的味道一般般，但价格还是蛮实惠的(民宿老板推荐茄子恰恰)。 我们点了纳西族烤鱼(纳西族是云南这边的主要名族)，鱼腥草(女朋友爱吃，我实在难以下咽), 白切鸡倒上辣椒油(上海的一个味道, 女票爱吃)，还有一个豆尖豆腐汤(豆尖吃不习惯，泥土的味道)，后来想想是因为可能是让女票点菜的原因，没有吃上特色菜，下次就跟着点评上的top走。我们只在昆明呆了1天，所以只吃了3顿饭，其余的两顿中一个是世界级连锁kfc的桶饭，真的难吃，媳妇只是喝了点汤，一个是早餐，昆明的早餐很难找到喝粥的地方，只有米线，我们点了个清汤的和一笼包子，不知道为啥，米线有股臭臭的味道，包子也是皮蛮厚的，华夏大地应该都能吃到。</p><ul><li>昆明总结</li></ul><p>感觉很一般，可能是因为我们去的地方比较少，不推荐住在五华区，也就是市区，这边的景点可能就是翠湖公园</p><ul><li>丽江古城</li></ul><p>从丽江站到丽江古城有公交车可以直达，蛮方便的。相比较之前知乎上写的丽江站有很多黑车拉你去拉市海不骑马不给回，好像是因为政府整治了，丽江站可能是我去过的最干净的一个站，没有任何一家黑车，公交站台比较少，每一站中间距离很大，所以一定不要坐过站，我们住在古城中，在古城停车场下车。古城中有很多客栈，大部分都是木质的房子，不隔音，晚上睡觉的时候时不时有路过宿醉的年轻男女，放声高歌，这都是女票告诉我的，因为男生一般都睡得比较死的哈哈，所以如果你喜欢安静，那就去新城住吧。（ps:不知道是不是女票叫的太大声，客栈老板给我取了个外号，睡哥~^_^。)老板很热心，虽然可能是因为紫外线比较强的原因，皮肤黝黑，但是给我们仔细介绍了古城有哪些景点，大水车，木府（商业化，都是卖茶叶的不推荐），五一街，四方街（酒吧街），狮子山（最高点，可以看到古城全景），忠义市场（水果比较便宜，我们买了，到底便宜不，无从考证，可是没有网上说的日照时间足，甜）。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/73e4d1d3792ad8a7f6a1c030b5c730d.jpg"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/ee30b50aa1af53632c82b26ee3b8a47.jpg"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/889d5d21856799d9982236c9bf14f4b.jpg"></div></div></div></div><ul><li>古城总结</li></ul><p>丽江古城可能是我去过的最好玩的一个古城，古城的地面都是转头，所以行李箱只能拎着！！古城的道路上还有很多狗屎，似乎踩狗屎是这边的一个风俗了，古城里面有个丽江之眼 的观景台，看到的风景和狮子山上差不多。四方街也就是酒吧街很适合拍照，古城中的嘉华鲜花饼是真的好香，袋装的大概32，盒装的56，晚上和女票闹矛盾，如果有时间的一定要去试吃一下。古城的晚上超级多的人，如果怕挤的话，那就白天逛逛，但是肯定没有晚上热闹了，女票买了一个鸡血藤55，原价150，后来在别的地方看到10元三个。陪着女票去了狮子山，她看到一个清吧就钻进去了，点了两杯喝的，一盒瓜子，一盒牦牛肉，175，客栈老板说蛮坑的，但是女票想看夜景呀，后来发现古城的夜景真的好垃圾哦，但也可能我们那个地方不够高，不推荐狮子山上的商业清吧。我们在丽江吃了一顿，滇厨餐厅，还可以，他家的水性杨花（一定要在云南吃水性杨花）很好吃，腊排骨分量太大，两个人吃不完，红豆酸奶味道和别的地方一样，铜锅饭两个人吃刚好，但味道一般，鸡豆凉粉一般，玫瑰糍粑有花的味道，对于我这种很少吃糍粑的人来说一定要点，土豆泥不好吃。</p><ul><li>玉龙雪山</li></ul><p>我们在美团上团了雪山的一日游，320一位，小索道 + 甘海子 + 蓝月谷 + 云杉坪，蛮推荐的，早上八点的时候有师傅来接我们，晚上5点能回到古城。索道一共分成3种，大索道（冰川公园），牦牛坪中索道，云杉坪小索道。当时我们一车8个人，只有我和女票是小索，剩下的都是挑战4680的玉龙雪山，当时害怕死了，以为女票要和我发火，可是后来呢师傅说我们这个季节小索道最好玩，11月到来年2月大索道才好玩，因为现在山顶都是雾，看不到东西，而且没有雪（媳妇夸我功课做得足，嘿嘿），而且大索道需要排队很久。上午的行程就是坐小索道去半山腰，然后徒步去云杉坪，路途很短，中间可能遇到马，可以喂食，所以带点面包或者买个玉米喽，路途的风景就是类似高海拔的林区。栈道的尽头就是云杉坪了，很大的一片草场，有一些牦牛在吃草，还有很多新人在拍照。这边的天气阴晴不定，要随身带着伞，或者纯玩团发的羽绒服，也是可以防雨的。</p><p>小索道的行程一点不紧张，中午有团餐，真的这是我来云南吃的最好吃的一顿（水月阁老山鸡火锅），第一次发现火锅中烫鸡肉能这么好吃，汤汁特别鲜美，泡上米饭，让人欲罢不能，而且可以随便加肉加菜，胃口大的小伙伴们有福了。</p><p>下午我们逛的是蓝月谷，蓝月谷的湖水真的像网上那般蓝绿，但小瀑布处的水又白的那么彻底，从下游走到上游，一路上很多拍婚纱的新人，希望他们的爱情也能永远和这湖水一样纯净，没有杂质，配着远处白云缭绕的玉龙雪山，真的美不胜收。</p><p>逛完蓝月谷之后我们的行程就基本结束了，坐大巴（免费的，都包含在门票中，所以看到大巴就可以随便上）来到入山口，等着纯玩团的小伙伴们集合，一起坐导游师傅的车回古城，沿途路过甘海子，司机会让拍拍照，^_^因为这也算一个景点啦（总共4个），因为太累了，男生们都没有下车，女生会出来走走，其实就是一个大片的小树林。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/ab5f780b76005a77b433648c5665019.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3f081c8c083faf4ecd9a9854a27c2ac.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/41bec6e937e2f1488d379af8736137b.jpg" width="400"></div></div></div></div><ul><li>大理</li></ul><p>在大理住宿的话，大概有两个主要地方，一个是古城，感觉住宿情况应该类似丽江，但肯定只会比丽江差，因为我们去古城玩的时候会看到很多民宿，真的就是那种农村自建的房屋，肯定看不到海，另一个就是双廊，双廊那边因为紧靠洱海，可以看到海，所以住宿比较贵。我们呢选的是滨海俊园，在大理白族自治州博物馆旁边，那家住宿真的除了甲醛味道，应该是我们这次旅行最满意的地方了，所有可能用到的物品（矿泉水，棉花棒，byt，熨斗，雨伞…）能想到的都有，而且很多小设计很贴心，比如浴室的感控灯，浴室的喷头是对着墙，所以刚开始放水的时候喷不到身上，方便我们调整水温，还有因为云南那边四季如春，loft的房屋基本都没有空调。</p><p>我们在大理一共吃了两顿，一家是遇见小仙女，点了豆腐，汽锅鸡，野生菌，因为媳妇不饿，所以我们店的不多。不太好吃，^_^，豆腐很油，汽锅鸡以为和昨天的老山鸡火锅一样才点的，其实他更像是炖鸡，媳妇比较爱吃。最坑的应该hi那个野山菌了，80元，但味道一般，也不下饭。还有一家是方胖子厨房，我们点的是野山菌火锅，点了三种菌加两个蔬菜，加一个鲜牛肉，锅底中有鸡肉，所以两个人能吃的很饱，同样没有很惊艳，汤汁肯定没有老山鸡鲜美啦（哈哈哈，水月阁老山鸡火锅是我的最爱）</p><ul><li>大理景点</li></ul><p>大理古城：一般，肯定比不上丽江古城，也没有什么景点</p><p>大理白族自治州博物馆：很安静，我对历史没有什么兴趣，但值得一去</p><p>花语牧场： 门票蛮贵的，两个人80，媳妇说就拍了几张照片，我感觉还好，要是有喜欢拍照的朋友，还是可以拍出很多漂亮的照片的</p><p>喜洲古镇：一般，没有逛，牛奶冰棒和喜洲粑粑，可能我们没迟到正宗的，一般</p><p>双廊古镇：一般，但是媳妇吃到她最喜欢的猪大肠，还给她妈买了个银镯子，8元一克，后来发现别的家只用6元</p><p>小普陀：停车费10元，然后就没有啥印象啦</p><p>洱海：如果想环洱海的话最好租车，电瓶车肯定不行，而且挺晒的， 价格大概是 80 vs 500, 小伙伴们自行斟酌</p><p>挖色镇，太阳宫都没怎么去，基本都差不多，我们租了车（媳妇说很难开，500一天，蛮贵的当时感觉，我当时想订的是350，但是看到她发朋友圈就感觉蛮值得，毕竟我想订的那个确实不太好看）</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6db5c67eac68dbbe86ba05ad1799b9d.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/d6bdc23ae1d4931cc4797cb65b12019.jpg" width="400"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3ba0a21804552d8eb5e01d3221b935c.jpg" width="400"></div></div></div></div><p>上面大概就是这次云南的五日游，总的来说，丽江最好玩，昆明和大理（农村）一般，但也算是圆了女票的一个梦，这就够了吧，拜拜~~</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/caec0172307f3ff74e800ddfb501ef0.jpg" width="300"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;女朋友想让我陪她去洱海，因为上海直达大理的机票太贵啦┭┮﹏┭┮(后来算上住宿, 中间的火车,花的钱差不多)，我决定带着她从昆明，丽江再到大理，最后从大理再回昆明坐飞机回上海。&lt;/p&gt;
    
    </summary>
    
      <category term="旅游" scheme="http://yoursite.com/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="云南" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-middleware和hook</title>
    <link href="http://yoursite.com/2019/08/09/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-middleware%E5%92%8Chook/"/>
    <id>http://yoursite.com/2019/08/09/tp源码分析-middleware和hook/</id>
    <published>2019-08-09T01:48:42.000Z</published>
    <updated>2019-08-09T06:29:32.503Z</updated>
    
    <content type="html"><![CDATA[<p>这块的中间件主要值的是route 中间件，对于请求发送到controller之前进行一系列的判断，是否缺胳膊少腿不符合要求，如果不符合，返回false, 符合 next($response)</p><p>钩子就是流程执行到某个点，触发用户绑定的方法，之所以这么做是为了用户可以在框架的层面做某些修改，而不用修改框架源码。</p><a id="more"></a><h3 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;start&apos;.&quot;&lt;br&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">        // 在触发钩子之前，绑定行为到指定钩子</span><br><span class="line">        Hook::add(&apos;test_1&apos;,&apos;app\\test\\behavior\\BehaviorTest&apos;); // 添加钩子处理</span><br><span class="line">        Hook::add(&apos;test_2&apos;,&apos;app\\test\\behavior\\BehaviorTest&apos;);</span><br><span class="line"> </span><br><span class="line">        // 调用设置了钩子的函数来触发钩子，进行测试</span><br><span class="line">        Hook::listen(&apos;test_1&apos;,[&apos;name&apos;=&gt;&apos;cy&apos;]); // 设置钩子，并执行钩子绑定的函数方法，第二个变量是数组方式传入钩子函数需要的变量</span><br><span class="line">         Hook::listen(&apos;test_2&apos;,[&apos;name&apos;=&gt;&apos;cy&apos;]);</span><br><span class="line">    </span><br><span class="line"> class BehaviorTest &#123;</span><br><span class="line">    public function test_1($param) &#123;</span><br><span class="line"> </span><br><span class="line">        var_dump($param[&apos;name&apos;])</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public function  test_2($param) &#123;</span><br><span class="line">   var_dump($param[&apos;name&apos;])</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>php 因为是同步的，所以他这个钩子函数和别的语言理解起来还不一样，比如这个listen， 在监听的同时并且执行了后面类中绑定的方法，而不像一些异步语言，listen之后等待着事件的触发。</p><p>还有就是我们绑定的是类，一个类中会有多个方法，默认的初始方法是run ,这个类中还可以有多个方法，多个方法对应多个钩子，方法名和钩子名一样</p><p>分析一下Hook</p><p>tags   核心属性，不同的钩子对应不同的类（可以是多个类组成的数组）</p><p>bind   别名，也是给类绑定别名</p><p>portal  入口方法名称，默认run</p><p>app 应用对象，App的实例，也是单例模式</p><p>__construct</p><p>构造方法，注入App 实例 $app</p><p>portal</p><p>设置入口函数名称</p><p>alias</p><p>修改bind 属性，给行为（对应某个类中特定方法，也是唯一一个方法，所以这个behavior 方法就是是class）绑定别名</p><p>add</p><p>添加点对应的行为，行为可以是关联数组，key _overlay 会让添加的value 覆盖之前的value, key  first 会让添加的value 排在第一位</p><p>import</p><p>批量导入 点对应的行为，可以是让import 和之前的tags 标签合并，也可以是让之前的tags 覆盖import 导入的内容</p><p>get</p><p>获取tags 属性</p><p>listen </p><p>其实就是执行某个点中绑定的类中的方法</p><p>exec</p><p>执行某个类中方法（方法名确定，就是portal）</p><p>execTag</p><p>执行绑定的类中的方法，先去执行listen 的点对应的method是否存在，如果能执行，执行默认方法 </p><h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>中间件用的设计模式是装饰器模式，每个装饰器类中只有一个方法，handle，第一个参数是Request请求，第二个参数是匿名函数 next， 还可以接受额外的参数，他这块也用的是反射，所以你如果没有添加第三个参数，在方法内部用func_get_args() 是获取不到额外的参数的，即使你在路由上middleware 传入了这个参数。因为反射没有获取到第三个参数的存在，所以执行的时候就不会传入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace app\http\middleware;</span><br><span class="line"></span><br><span class="line">class Check</span><br><span class="line">&#123;</span><br><span class="line">    public function handle($request, \Closure $next, $pa1 = 1, $pa2 = 2) // 难道只能装一个参数吗</span><br><span class="line">    &#123;</span><br><span class="line">        var_dump($pa1,&apos;|&apos;, $pa2);exit;</span><br><span class="line">        $request-&gt;name = &apos;cy&apos;;</span><br><span class="line">        return $next($request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Route::get(&apos;/testhook&apos;, &apos;index/testhook&apos;)-&gt;middleware([&apos;Check:name&apos;]);</span><br></pre></td></tr></table></figure><p>如果我们在application下面的middleware.php 中写入，那么全局所有的route都会经过这个中间件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这块的中间件主要值的是route 中间件，对于请求发送到controller之前进行一系列的判断，是否缺胳膊少腿不符合要求，如果不符合，返回false, 符合 next($response)&lt;/p&gt;
&lt;p&gt;钩子就是流程执行到某个点，触发用户绑定的方法，之所以这么做是为了用户可以在框架的层面做某些修改，而不用修改框架源码。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="TinkPHP" scheme="http://yoursite.com/tags/TinkPHP/"/>
    
      <category term="中间件" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="钩子" scheme="http://yoursite.com/tags/%E9%92%A9%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-facecde和ioc</title>
    <link href="http://yoursite.com/2019/08/09/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-facecde%E5%92%8Cioc/"/>
    <id>http://yoursite.com/2019/08/09/tp源码分析-facecde和ioc/</id>
    <published>2019-08-09T01:47:55.000Z</published>
    <updated>2019-08-09T05:32:05.269Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们梳理一下关系，ioc 作为一个容器，是个单例的存在，它存在于自身container的instance 属性中，他还有个instances 属性，作为一个关联数组，key的内容是类名，value 内容是某个类的实例(这个类并不一定要是单例)， 当我们下次再去容器中取这个类实例的时候，还是之前的实例 (!!!千万注意一定是容器中取，才能保证是上次的类实例), 我们从容器中获取类实例，并不一定要提前bindto, bind 本质只是绑定一个别名，通过别名最终还是找到实际的类名，所以没有绑定直接传类名也是可以的。 那什么是facade 呢， 通过返回容器中的类别名或者类实际的名称，去容器中找类实例，然后调用该实际类的方法</p><a id="more"></a><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>Container 实现了arrayAccess (方便数组调用)， iteratorAggregate (方便foreach循环) , countable(方便 count()) 调用</p><p>instance    container 的单例</p><p>instances  []    装的类的实例</p><p>bind  类标识，通过标识寻找实际类</p><p>name  别名，感觉和前面bind差不太多</p><p>getInstance </p><p>获取container 的单例</p><p>setInstance</p><p>设置container 的单例</p><p>get</p><p>从container 的单例instance 的属性 instances 中获取类的实例，对于container 的单例调用 make 方法</p><p>set</p><p>container 实例 绑定一个类、闭包、实例、接口实现到容器，注意可能并没有生成类的实例，也就是instances属性中可能并没有</p><p>remove </p><p>container 实例中instances 属性删除某个类实例</p><p>clear</p><p>bindTo</p><p>修改bind属性，包括关联数组（merge）, 闭包直接赋值，string 修改bind, 对象，修改bind ,并把 instances中绑定这个实例</p><p>instance </p><p>绑定一个实例到容器中，感觉作用相当于bindTo的一部分</p><p>bound</p><p>判断容器中是否存在类标识或者实例</p><p>exists</p><p>判断容器中是否有该类实例</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190809123749.png" alt=""></p><p>从这个方法很容易判断，instances 中key 是实际的类名</p><p>has</p><p>调用的上面bound 方法</p><p>make</p><p>创建类的实例， 第三个参数newInstance 类似我之前写的那个token 文件的第三个参数 force，强制刷新实例。</p><p>make 会先去查看是否有别名，然后换算成实际类的名称，去instances属性中查找。如果没有只能生成啦。如果是匿名函数，通过反射获取参数，然后绑定参数，如果有依赖注入，首先查看是否有传入这个实例，没有的话生成。如果是类的话，会先判断是否有__make 方法，没有的话调用constructor 构造函数，执行函数的过程类似上面执行匿名函数</p><p>delete</p><p>删除instances中的实例</p><p>all</p><p>输出instances内容，也就是生成的所有实例</p><p>flush</p><p>置空 instances ， bind， name 属性</p><p>invokeFunction</p><p>从一个方法中获取反射，然后执行这个方法</p><p>invokeMethod</p><p>从一个类的方法中获取反射，然后执行这个方法</p><p>invokeReflectMethod</p><p>这个方式要求传入实例还有反射，还有参数，（所有的参数都给备齐了）就相当于上面方法的子方法，上面方法也是调用这个方法去实际执行反射类中的方法</p><p>invoke</p><p>实现方法</p><p>invokeClass</p><p>实现类</p><p>bindParams </p><p>生成类或者方法需要的参数，支持依赖注入</p><p>getObjectParam</p><p>bindParams 对于依赖注入的处理需要用到这个方法</p><p>后面的方法都是为了上面那几个接口中方法的实现，操作的都是instance 实例中的instances属性</p><h3 id="Facade"><a href="#Facade" class="headerlink" title="Facade"></a>Facade</h3><p>bind 别名，类似container 中的bind</p><p>alwaysNewInstance ，因为facade 本质上也是从container 中取实例，所以也需要这个强制刷新属性</p><p>bind</p><p>绑定别名</p><p>createFacade</p><p>先根据继承了facade 的类中getFacadeClass 返回的内容中确定类，如果没有，去bind属性中查找（注意这里是self）,都没有的话就用传入的类名。确定了类名去container 中找实例，没有的话自动生成</p><p>getFacadeClass </p><p>返回容器中类的别名或者直接返回类的名称</p><p>instance</p><p>make</p><p>和createFacade 差不多</p><p>__callStatic</p><p>facade 的核心，通过createFacade 实例化实际类，然后用这个实例去调用method方法 （一定要注意我们在调用类中的方法的时候除了static都是在一个类实例上调用的方法，我们的方法中可能会用到\$this ,这个\$this就是对象）</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以Config 举例，\Config 通过class_alias 实际找到的是 \think\facade\config,然后这个类中没有我们想要的方法，调用的是父类 facade中的__callStatic, 这个方法先通过createFacade 生成实例，实例是先从container 中查找别名换成真的类名，然后去instance中查找实例，有就返回，没有再生成。实例获取到后，再去执行方法</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们梳理一下关系，ioc 作为一个容器，是个单例的存在，它存在于自身container的instance 属性中，他还有个instances 属性，作为一个关联数组，key的内容是类名，value 内容是某个类的实例(这个类并不一定要是单例)， 当我们下次再去容器中取这个类实例的时候，还是之前的实例 (!!!千万注意一定是容器中取，才能保证是上次的类实例), 我们从容器中获取类实例，并不一定要提前bindto, bind 本质只是绑定一个别名，通过别名最终还是找到实际的类名，所以没有绑定直接传类名也是可以的。 那什么是facade 呢， 通过返回容器中的类别名或者类实际的名称，去容器中找类实例，然后调用该实际类的方法&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="facecde" scheme="http://yoursite.com/tags/facecde/"/>
    
      <category term="ioc" scheme="http://yoursite.com/tags/ioc/"/>
    
      <category term="依赖注入" scheme="http://yoursite.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-Config</title>
    <link href="http://yoursite.com/2019/08/09/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Config/"/>
    <id>http://yoursite.com/2019/08/09/tp源码分析-Config/</id>
    <published>2019-08-09T01:47:22.000Z</published>
    <updated>2019-08-09T03:49:27.107Z</updated>
    
    <content type="html"><![CDATA[<p>thinkphp config 源码阅读，为了更好的使用~</p><a id="more"></a><p>首先 config  implements ArrayAccess, 所以我们可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$z = new \think\Config();</span><br><span class="line">$z-&gt;load(__DIR__.&apos;test.ini&apos;,&apos;test&apos;);  // test 作为前缀，用来分割不同文件的配置项，如果不加，会放在一级目录，不太合适</span><br><span class="line">// test 内容</span><br><span class="line">[boy]</span><br><span class="line">name=cy</span><br><span class="line">sex=1</span><br><span class="line"></span><br><span class="line">var_dump($z[&apos;test&apos;][&apos;boy&apos;][name]); // cy</span><br></pre></td></tr></table></figure><p>分析Config的几个属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config . 核心，配置文件内容加载进来的存放</span><br><span class="line">prefix   默认前缀，set的时候，如果key 是个string , 默认前缀， 注意set 的内容如果是个数组，那就直接合并</span><br><span class="line">path 初始化构造函数，配置文件的位置</span><br><span class="line">ext  初始化构造函数，配置文件的类型</span><br><span class="line">yaconf 布尔值或者字符串，用来支持yaconf</span><br></pre></td></tr></table></figure><p>__construct </p><p> 配置一些基本的参数，比如path 配置文件路径，ext 配置文件后缀，yaconf 判断是否安装了yaconf扩展</p><p>__make </p><p>获取注入类app 中config文件路径和ext 文件后缀，初始化一个config类</p><p>setYaconf</p><p>注意这个一定要在属性yaconf true 的时候才能设置</p><p>getYaconf </p><p>获取</p><p>setDeafultPrefix</p><p> 设置前缀，比如app</p><p>parse  </p><p>把一个配置文件（config driver 下面支持的类型，默认ini, json, xml）加载到 \$this-&gt;config 属性中</p><p>load </p><p>加载文件(先判断该文件是否存在，不存在添加上文件夹前缀和文件后缀)解析放到config中，调用parse，并添加支持php,yaml.</p><p>getYaconfName  </p><p>Yconf::get(key), 获取的就是这个key</p><p>yaconf </p><p> 获取yaconf 中内容，感觉比如直接调用yaconf 的get</p><p>loadfile</p><p>load = loadfile + yaconf</p><p>has </p><p>判断是否有某个key , 如果没有添加前缀，会添加默认前缀. (默认所有的config 都得挂在某个 一级key 下面，比如app(默认)， 比如 log)</p><p>pull</p><p>获取所有的config 中一级配置，或者yaconf 中的某个属性 + config 中的一级配置</p><p>get</p><p>获取配置，key 中没有 . ,默认添加app 前缀，支持获取多层嵌套</p><p>set</p><p>只能支持两级key ,不包括文件名，如果传入数组，合并原先 config属性（只有在key 是string 的时候才会添加默认prefix ）</p><p>remove </p><p>移除key</p><p>reset</p><p>重置某个key</p><p>剩下arrayAccess 需要实现的方法，方便数组方式调用</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>config 文件中支持 yaconf 和 \$this-&gt;config, 可有的方法是从二者中某个取值(一般都是yaconf优先)， 有的是yaconf 和 config 合并。</p><p>yaconf 的key中，第一个肯定是文件名</p><p>config key 中，如果没有. 默认都会拼上prefix , 想获取一个文件中所有内容，key 可以这样 app. , 感觉没有yaconf 直观，规范</p><h3 id="关于yaconf-具体可以参考鸟哥博客"><a href="#关于yaconf-具体可以参考鸟哥博客" class="headerlink" title="关于yaconf(具体可以参考鸟哥博客)"></a>关于yaconf(具体可以参考鸟哥博客)</h3><p>yaconf 是鸟哥写的一个常驻内存的配置文件扩展，（windows下使用有些问题）</p><p>很简单，默认两个配置项，一个是dir (把该文件夹下的所有的ini文件都加载进内存，不支持文件夹是为了简单，不支持别的类型文件是为了简单),一个是check 更新时间(每隔比如2s检测一下文件是否改动, 只能用mv, 不能用cp, 可能是根据文件修改时间来进行判断是否改动)</p><p>api 也只有两个，</p><p>// test 是文件名，name是属性</p><p>get(‘test.name’)  // 获取内容</p><p>has(‘test.name’) //  判断是否有内容</p><p>我们来想想yaconf 解决的问题：我们在开发itbasic 的时候经常被这样的问题困扰，对于配置项，线上环境和本地环境不一样，所以导致我们每次提交代码都很麻烦，但凡用到配置参数的文件都会和线上文件冲突。后来我们把配置项都写到一个文件中，通过config 去获取，并且不把config文件纳入版本库，其实yaconf的本质也是这样，只是他分的更彻底，把config 完全移除项目代码，和项目代码分离，放到一个单独的文件夹中，可以让运维人员或者任何人员去修改。</p><h3 id="关于配置文件格式"><a href="#关于配置文件格式" class="headerlink" title="关于配置文件格式"></a>关于配置文件格式</h3><p>tp 中有ini, json, xml, yaml, php 文件</p><p>对于ini 文件（.env文件也是ini ）可以直接调用方法解析</p><p>json ,我们直接读取文件内容，然后json_decode </p><p>xml ,我们直接调用方法解析</p><p>yaml ,我们需要安装yaml 扩展（centos7 中安装yaml 工具）</p><p>php, 我们直接include , 文件中的return 内容会被include 返回</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;thinkphp config 源码阅读，为了更好的使用~&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
      <category term="Config" scheme="http://yoursite.com/tags/Config/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-composer加载</title>
    <link href="http://yoursite.com/2019/08/03/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-composer%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/08/03/tp源码分析-composer加载/</id>
    <published>2019-08-03T15:04:50.000Z</published>
    <updated>2019-09-01T02:54:35.272Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇文章是关于composer 的基本用法，这篇文章是composer源码的简单阅读和thinkphp5.1的自动加载。</p><a id="more"></a><p>先来熟悉一个函数，get_declared_classes, 这个函数是干嘛的？是获取当前脚本中已经加载的类的，但凡这个返回结果中有的类，我们都可以直接生成，默认在一个空脚本中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">var_dump(get_declared_classes());</span><br></pre></td></tr></table></figure><p>是当前php中包含的所有扩展类，那如果没有包含在这其中的类我们应该怎么生成实例对象呢？远古时代是通过 require_once，想想添加每个新脚本的时候都要在上面写个require, 这样太不智能了，php给我们提供了一个函数spl_autoload_register, 通过不断的调用这个函数，可以绑定自定义的函数到一个队列中，如果我们生的对象的类在内存中找不到，他就会执行这个队列中的所有自定义方法，直到找到为止， composer 本质上也是基于这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">来自composer ClassLoader.php</span><br><span class="line">&lt;?php</span><br><span class="line">public function register($prepend = false)</span><br><span class="line">    &#123;</span><br><span class="line">        spl_autoload_register(array($this, &apos;loadClass&apos;), true, $prepend);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当我们在github上安装一个包（或者叫库）， 我们先composer require, 安装完了之后再在我们的脚本中加上 vendor/autoload.php, 然后就能用了，注意一定要require_once vendor/autoload.php 这个文件，否则你只是下载了包，当生成对象的时候，内存中还是没有这个类的存在(以klein举例)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190803232124.png" alt=""></p><p>那我们开看一下这个autoload .php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">// autoload.php @generated by Composer</span><br><span class="line"></span><br><span class="line">require_once __DIR__ . &apos;/composer/autoload_real.php&apos;;</span><br><span class="line"></span><br><span class="line">return ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378::getLoader();</span><br></pre></td></tr></table></figure><p>调用的是composer 包中autoload_real 中的getLoader 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static function getLoader()</span><br><span class="line">    &#123;</span><br><span class="line">        if (null !== self::$loader) &#123;</span><br><span class="line">            return self::$loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spl_autoload_register(array(&apos;ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378&apos;, &apos;loadClassLoader&apos;), true, true); // 这个为了能让生成classLoader 的实例对象</span><br><span class="line">        self::$loader = $loader = new \Composer\Autoload\ClassLoader();</span><br><span class="line">        spl_autoload_unregister(array(&apos;ComposerAutoloaderInit23a88103aab8adc5d1263de38cceb378&apos;, &apos;loadClassLoader&apos;));</span><br><span class="line"></span><br><span class="line">        $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined(&apos;HHVM_VERSION&apos;) &amp;&amp; (!function_exists(&apos;zend_loader_file_encoded&apos;) || !zend_loader_file_encoded()); // true</span><br><span class="line">        if ($useStaticLoader) &#123; // 走的这个逻辑</span><br><span class="line">            require_once __DIR__ . &apos;/autoload_static.php&apos;;  // 包含这个文件是因为要调用他的getInitialize()方法，也就是这个方法</span><br><span class="line"></span><br><span class="line">            call_user_func(\Composer\Autoload\ComposerStaticInit23a88103aab8adc5d1263de38cceb378::getInitializer($loader)); // 这个方法的作用就是让一个闭包复制给ClassLoad类(核心类)上，让这个闭包可以访问classLoad 的私有变量 prefixLengthsPsr4， prefixDirsPsr4， classMap （psr0 过时了，不看）。classMap 文件就是composer.json 中classMap, 他会把一个文件夹中的文件中包含的类和文件名对应出来，自动加载的时候通过类名作为key, 去寻找这个文件的位置。想laravel thinkphp 生成类和文件的对应关系，也是基于这个原理</span><br><span class="line">            // 说说prefixlengthsPsr4 还有prefixDirsPsr4 吧，当我们在composer.json 中自定义composer autoload psr4 ,就是就是往这里面写对应关系，首先去类的第一个字母在prefixlengths 中寻找，找到之后再去prefixDirsPsr4中找具体的命名空间对应的文件夹，然后通过把命名空间依据psr4转换成文件名称，在之前找到的文件夹下面寻找这个文件，具体的验证方法可以看classLoad的 loadClass,也就是spl_autoload_register 中注册的</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $map = require __DIR__ . &apos;/autoload_namespaces.php&apos;;</span><br><span class="line">            foreach ($map as $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;set($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $map = require __DIR__ . &apos;/autoload_psr4.php&apos;;</span><br><span class="line">            foreach ($map as $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;setPsr4($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $classMap = require __DIR__ . &apos;/autoload_classmap.php&apos;;</span><br><span class="line">            if ($classMap) &#123;</span><br><span class="line">                $loader-&gt;addClassMap($classMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $loader-&gt;register(true); //注册ClassLoader 的 loadClass 方法作为最终的spl_autoload 方法</span><br><span class="line"></span><br><span class="line">        if ($useStaticLoader) &#123; // true ,走的这个逻辑</span><br><span class="line">            $includeFiles = Composer\Autoload\ComposerStaticInit23a88103aab8adc5d1263de38cceb378::$files; // autoload_static 中的文件，这个文件咋来的，composer.json 中的autload files 选项</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $includeFiles = require __DIR__ . &apos;/autoload_files.php&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123;</span><br><span class="line">            composerRequire23a88103aab8adc5d1263de38cceb378($fileIdentifier, $file); //这个方法就是包含上面的文件，所以 composer.json 中的files 是我们包含了vendor 目录下的autload.php就直接包含进来了，不是后期通过spl_autoload_register 中的方法生成的。为了验证我们可以在这些files 中定义class, 然后不new生成对象，也就没有触发spl_autoload_register中方法，看内存中有没有这个类</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $loader;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好了，我们来总结一下composer 文件夹中的几个比较重要的文件，autoload_real.php 是注册Classload .php 成为spl_autoload_register中的方法，autoload_static.php类似一个配置文件，把他包含的类对应文件夹的属性都绑定到ClassLoad 上，ClassLoad 调用自己的loadClass 方法，根据类名，去自己的属性上找对应的类所在文件位置。</p><p>现在抛出问题，我们如何不通过composer require去安装一个库文件？</p><p>其实很简单，composer require 做了两个工作，首先git clone 那个库到你本地vendor目录，再接着配置autoload_static.php 文件中的两个属性，prefixLengthsPsr4， prefixDirsPsr4，第一个属性是命名空间的首字母对应命名空间，第二个是命名空间对应类的文件位置，配置好了之后，我们就可以试着new class了，看会不会报错，一般情况下不会，除非这个类库中除了psr4 还有classMap 或者files 或者psr0,这样我们一点点的添加，就能完成。</p><p>接着我们看看thinkphp5.1 的自动加载机制，thinkphp的自动加载其实就是composer的翻版，他为了兼容composer, composer 中的文件没有动，只是他没有require vendor 下面的autoload.php， 转而是通过think 库 base.php -&gt;load.php,这个load.php 作用类似composer 的autoload_real 和 CLassLoader, </p><p>load.php 中的register 方法通过获取composer 的autload_static 中的prefixLengthsPsr4’, ‘prefixDirsPsr4 属性，绑定到自身，获取了composer 中通过psr4 加载的类，顺便把自己的think 和 trait也加入其中.</p><p> 对于classMap, 他获取的自己runtime 文件夹下的classMap.php 文件中的内容，该内容需要调用命令生成，就是thinkphp 自身的类和对应文件位置的集合。</p><p>最后是自动加载目录，他的功能类似psr4,就是把自动加载的目录当做根目录，类文件按照psr4，由这个相对根目录展开。</p><p>thinkphp 还有个classAlias 功能，classAlias 利用的是class_alias 这个方法，让两个类一模一样，除了类名，这样可以简写我们的类名长度，注意使用的时候一定要加上根命名空间\，否则可能会在当前命名空间下寻找改类，这个在laravel中用的也很多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 注册类库别名</span><br><span class="line">Loader::addClassAlias([</span><br><span class="line">    &apos;App&apos;      =&gt; facade\App::class,</span><br><span class="line">    &apos;Build&apos;    =&gt; facade\Build::class,</span><br><span class="line">    &apos;Cache&apos;    =&gt; facade\Cache::class,</span><br><span class="line">    &apos;Config&apos;   =&gt; facade\Config::class,</span><br><span class="line">    &apos;Cookie&apos;   =&gt; facade\Cookie::class,</span><br><span class="line">    &apos;Db&apos;       =&gt; Db::class,</span><br><span class="line">    &apos;Debug&apos;    =&gt; facade\Debug::class,</span><br><span class="line">    &apos;Env&apos;      =&gt; facade\Env::class,</span><br><span class="line">    &apos;Facade&apos;   =&gt; Facade::class,</span><br><span class="line">    &apos;Hook&apos;     =&gt; facade\Hook::class,</span><br><span class="line">    &apos;Lang&apos;     =&gt; facade\Lang::class,</span><br><span class="line">    &apos;Log&apos;      =&gt; facade\Log::class,</span><br><span class="line">    &apos;Request&apos;  =&gt; facade\Request::class,</span><br><span class="line">    &apos;Response&apos; =&gt; facade\Response::class,</span><br><span class="line">    &apos;Route&apos;    =&gt; facade\Route::class,</span><br><span class="line">    &apos;Session&apos;  =&gt; facade\Session::class,</span><br><span class="line">    &apos;Url&apos;      =&gt; facade\Url::class,</span><br><span class="line">    &apos;Validate&apos; =&gt; facade\Validate::class,</span><br><span class="line">    &apos;View&apos;     =&gt; facade\View::class,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>好了，大致就这么多了，所以我们可以猜测一波（没有仔细看啦）</p><p>composer dump-autoload,主要是因为我们修改了composer.json文件中的autoload.psr4选项，没有及时修改autload_static 文件，</p><p>composer require 1. git clone 2.修改autoload_static 文件</p><h3 id="实战：如何用命令行的方式运行tp，测试tp中的函数"><a href="#实战：如何用命令行的方式运行tp，测试tp中的函数" class="headerlink" title="实战：如何用命令行的方式运行tp，测试tp中的函数"></a>实战：如何用命令行的方式运行tp，测试tp中的函数</h3><p> 首先因为tp重写了composer 的加载方式（但没有修改composer 的文件, 为了方便composer update, install )， 所以我们用不了vendor 中的_autoload.php, tp起到相同作用的是 Loader::register 方法，这个方法中 对app 文件夹，和 think\composer 进行了psr4 加载，同时把thinkphp 核心文件夹library 下的think 和traits 也进行psr4 进行加载，这样我们就能访问app , think\composer, thinkphp\libraray\think和thinkphp\libraray\traits 下的所有文件了。同时他还通过loader 的addAutoLoadDir 把extend 文件夹做成classmap 进行加载，所以为了测试我建立了cy文件夹，也需要Load::addAutoLoadDir(realpath(‘cy’))。 当然如果我们还可能为了方便使用系统的一些类，需要class_alias。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm.</span><br><span class="line"> * User: cy</span><br><span class="line"> * Date: 2019/8/4</span><br><span class="line"> * Time: 13:08</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//require_once &apos;../vendor/autoload.php&apos;;</span><br><span class="line">require_once &apos;../thinkphp/library/think/Loader.php&apos;; // 为了使用Load中的方法</span><br><span class="line">require_once &apos;../thinkphp/helper.php&apos;; // 为了使用助手函数</span><br><span class="line"></span><br><span class="line">$nowDir = realpath(__DIR__); //获取当前文件夹的绝对位置，方便函数调用</span><br><span class="line"></span><br><span class="line">//var_dump($nowDir);</span><br><span class="line"></span><br><span class="line">\think\Loader::register(); // 把composer 的自动加载接管过来;</span><br><span class="line">\think\Loader::addAutoLoadDir(realpath(__DIR__)); // 加载当前脚本下的类进入psr4</span><br><span class="line"></span><br><span class="line">// 注册类库别名，方便直接调用，比如 \Config</span><br><span class="line">\think\Loader::addClassAlias([  </span><br><span class="line">    &apos;Config&apos;      =&gt; \think\facade\Config::class, </span><br><span class="line">    &apos;Env&apos; =&gt; \think\facade\Env::class</span><br><span class="line"></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>其实为什么要遵循ps4规范，就是为了能够通过命名空间方便查找文件的具体位置，然后require， 当我们主动require 了文件（比如文件数量过少的情况），我们的命名空间可以随便定义的，并没有任何硬性规定一定要和文件夹名称相同，你甚至可以在一个根目录下定义一长串的命名空间前缀，没有任何语法错误的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一篇文章是关于composer 的基本用法，这篇文章是composer源码的简单阅读和thinkphp5.1的自动加载。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="composer" scheme="http://yoursite.com/tags/composer/"/>
    
  </entry>
  
  <entry>
    <title>同步 异步 阻塞 非阻塞</title>
    <link href="http://yoursite.com/2019/07/20/%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2019/07/20/同步-异步-阻塞-非阻塞/</id>
    <published>2019-07-20T07:54:07.000Z</published>
    <updated>2019-07-31T08:41:16.580Z</updated>
    
    <content type="html"><![CDATA[<p>灵感来源别人利用多进程写了个python 的下载器，于是想自己用php试一下</p><a id="more"></a><p>先说下多进程和单进程</p><p>lnmp请求过程</p><p>http请求到达nginx，nginx 转发给php-fpm(一个php进程管理器，~so，这个地方就是多进程啦)，每个进程中实现了fast-cgi 协议(请求完毕，并不重启进程，而是等待下一个请求的到来，除非到达该线程接受http请求最大数量，会自动重启，目的是为了防止一些代码不好，导致内存泄漏)，每个进程中其实就是 php index.php（请求处理完逐个往回返回）, 所以我们可以把lnmp 模型理解成多进程模型，同一时刻并发的数量就是php-fpm配置的进程数量，但为什么别人说php是单进程呢，因为我们平时在开发的过程中，所有的代码都是跑在一个请求中，也就是一个进程中，所以我们可以说php就是单进程的，但php真的只是单进程的吗，不是，php有个扩展叫pcntl ，这个扩展不建议在php-fpm模式下使用，但是在php-cli 下可以正常使用，也就是说我们不建议在php-fpm的工作进程中再fork新的子进程（同理swoole 中也不建议在worker进程中new process 新的进程），既然在工作进程中不涉及fork 子进程，而php也很少操作线程，那么php就和异步搭不上边了。</p><p>同步，异步区别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</span><br><span class="line">  异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</span><br></pre></td></tr></table></figure><p>最常见的异步莫过于前端的ajax，</p><p>ajax 允许浏览器在发出请求的时候浏览器（一个进程）还可以去做别的事情，而不用干等着（同步就不行了，同步阻塞显然不行，同步非阻塞呢？同步虽然进程还可以去做别的事情，但是进程但过一会还得再来询问一下，请求是否完成，所以哪怕是同步非阻塞，代码流程执行到这会，始终会停住，不会继续向下走，这和异步代码能继续往下跑是不一样的，所以同步更符合我们的日常习惯。</p><p>比如异步编程，我们不知道ajax执行的函数啥时候回给我们返回内容，所以我们无法用  $a = ajax(xxx), 去获取ajax 执行的内容，大部分情况下用的是回调函数，然而为什么php中也有回调函数呢，php中的回调更类似于js中的匿名函数，他只是代码同步执行到用户定义的函数中，调用了之前定义的一个匿名函数，和js的回调存在本质上的区别。js中的回调，更类似swoole的回调，发现了嘛，都是通过事件的触发机制（但是这个应该和事件io不一样，之前看的阻塞io 非阻塞io 事件io 信号io都属于同步，只有异步io属于异步方式）</p><p>所以我们平时在看php的代码中就不要考虑异步方式了，基本没有，因为都是同步的，又因为阻塞和非阻塞都会有返回值，所以我们平时的那些函数基本都有返回值，但是有些回调形式的函数返回值有没有用，那就另说，看定义这个函数的人怎么想了。（其实看同步和异步看函数的return 也能看出来，如果return外面能接收到，那就是同步,比如php-fpm,包了那么多header头信息，还是return就能返回，你看swoole中的return ，在事件回调中，他是通过 $response 返回给别的进程的，所以属于异步）。</p><p>(可能有小伙伴看klein 或者larave中的路由函数觉得可能是回调，因为callback 中的内容总在 callback 外面先输出，首先，你在 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/test/test/[test|cry:test]/[i:id]&apos;, function ($request, $response) &#123;</span><br><span class="line"></span><br><span class="line">    $obj = Box::getObject(&apos;out&apos;, &apos;controller&apos;);</span><br><span class="line">    return $obj-&gt;oop($request);</span><br><span class="line">&#125;);</span><br><span class="line">的 respond 方法中返回 值，看外面能不能接收到，能接收到就是同步</span><br></pre></td></tr></table></figure><p>再者，他这个地方绑定了callback，并没有执行callback呀，所以这个地方并没有执行是很正常的，但是php这种没有触发机制，必须得执行呀，看后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;dispath() // 其实是在这里面执行了</span><br></pre></td></tr></table></figure><p>)</p><p>为什么说swoole 的task任务是异步任务，因为我们在worker进程中调用task添加异步任务的时候，当异步任务执行完的时候，我们能在之前的worker进程 中收到task返回的消息（onFinishi事件中）。(在没有swoole 之前，php中对于异步的实现都是通过第三方软件，比如把耗时任务放到消息队列中，由消费者自己去消费，消费者可以通过crontab 这种去轮训消息队列，虽然不太环保，但还是能完成任务)    </p><p>swoole进程模型</p><p>master 整除ractor 线程和manager 进程，</p><p>manager 进程 生出 worker进程（异步非阻塞）和特殊worker进程（task进程，同步阻塞），负责进程重启和 回收</p><p>ractor 线程检查连接，还有可写的socket 发送给worker进程处理</p><p>swoole4之前请求过程</p><p>单个请求被单个worker处理，处理完再处理下一个</p><p>swoole4 之后</p><p>woker可以同时接受多个，遇到io，协程切换，处理下一个请求，当上一个请求io完毕，再切回来（感觉通过fd -&gt; 运行环境），继续往下执行（注意就是这儿，虽然说协程本质上还是异步，但是他的运行方式类似同步，更好理解）</p><p>相较于异步的不容易理解，比如回调地狱，swoole 希望我们仍旧用同步的方式编写代码，但是对于一些io操作同步返回太慢了，所以就出现了异步io，redis, mysql，没有用过~~，swoole4中为了把这个异步摒弃，又引入了上述的协程，协程是比进程线程粒度更小的资源管理。</p><p>关于阻塞和非阻塞：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</span><br><span class="line">有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。 例如，我们在socket中调用recv函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。</span><br><span class="line">非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</span><br></pre></td></tr></table></figure><p>php中虽然sleep， file_get_contents 中有同步阻塞io，但是string， arr这些函数还是同步非阻塞函数</p><p>当我们在项目在swoole的http server中，没有用上面的同步阻塞io的时候，我们整个项目代码就是异步的，但凡用了，那我们的项目代码就是同步的，所以这个同步和异步由两部分决定，一个是swoole server， 一个是我们的项目代码。</p><p>swoole 本质上是为了对标php-fpm,和php本身没有什么关系，他对项目的性能提升类似php7对项目代码的提升，我们不用修改源代码，就能提升并发量，只是php7是对php中函数的改造，而swoole 是对php-fpm的改造或者说php的运行环境的改造，他吧php-fpm 的功能也纳入到我们项目代码中。</p><p>所以总结一下：</p><p>php多进程 ： 针对php-fpm， 或者php-cli 模式下的php进程而言</p><p>php单进程：针对php-fpm模式下php进程而言</p><p>同步: 针多 php-fpm 而言</p><p>异步：针对 swoole 封装的一些io操作而言，比如redis ,mysql ，还有http tcp server，</p><p>还有之前的多进程下载的实现，遍历url，每个url都放到task中执行，完美多进程，easy(不要想着在worker 在生成新的process 哦， 官网上说很占资源)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;灵感来源别人利用多进程写了个python 的下载器，于是想自己用php试一下&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="socket" scheme="http://yoursite.com/tags/socket/"/>
    
  </entry>
  
</feed>
