<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-11T06:57:58.961Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网站升级https</title>
    <link href="http://yoursite.com/2018/09/11/%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7https/"/>
    <id>http://yoursite.com/2018/09/11/网站升级https/</id>
    <published>2018-09-11T06:23:14.000Z</published>
    <updated>2018-09-11T06:57:58.961Z</updated>
    
    <content type="html"><![CDATA[<p>升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。</p><a id="more"></a><p>https原理<br>HTTPS采用共享密钥加密(对称加密)和公开密钥加密(非对称加密，比较出名的有RSA)两者并用的混合加密机制。在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式<br>之所以传输过程中用对称加密，是因为非对称很浪费资源</p><p>(hash加密是单向的，例如md5,不能解密)<br>和对称加密还有非对称加密都是不一样的，不管是对称加密还是非对称加密，通过秘钥都是能解密的，但是hash，只能维持 hash(内容)之后的值保持一致，这也是我们数据库中只保存用户密码加密后的值就可以验证用户的密码是否正确了，因为我们可以每次获取到用户信息之后只要hash一下，然后和数据库中做下对比就可以了。</p><p>https ,首先让服务器和ca交互，获取服务器的公钥，这个过程是非对称加密，获取到公钥</p><p>https升级过程中遇到的问题:</p><ul><li>不允许脚本调用http，可以先把接口转发到我们本地的服务起的https上，然后通过nginx转发到别人网站上的接口，因为本身调用外来接口接口比较少，这样能符合我们的需求</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5525740-442e10f7747a4d2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>https证书申请无效（每个域名都需要申请单独的证书，之前以为只要申请一个www.chenye2017.cn证书就可以了，chrome直接显示https不安全，其实通过微软的edage浏览器访问，能清楚的看到证书不匹配的原因）</li></ul><p>（证书申请是通过腾讯云，腾讯云上有详细的教程，唯一不足的是没有给文件夹权限，导致第一次访问403）</p><p>（https配置虚拟主机应该就和我们在vhost文件里面配置虚拟主机一样，现在是在ssl配置文件里面写）<br>（话说我现在的服务器，域名用的是阿里的，服务器用的是京东的，https证书用的是腾讯的，zz）<br>（还有不知道是hexo的原因还是github page 的原因，我的网站上有http的资源竟然不会显示https错误，不知道他是怎么解决这种http资源不出错的，有空可以了解下）</p><p>https和http的区别</p><p>简单看就是 https = http + SSL</p><p>SSL的运行机制，可以参考<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">阮一峰老师的文章</a>，我对上面的一些内容做了些自己理解的笔记</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-260206ef40194be3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>其中加密传播是因为我们的传播内容都是通过生成一个第三方不知道的公钥，这个公钥是怎么来的呢，首先通过ca证书，因为系统内容ca的公钥，ca用私钥加密文件内容（私钥加密，公钥解密，不被篡改），我们获取服务器的公钥，这个公钥是干什么的呢，并不是用来进行数据的加密的，而是用来加密传递的数据给服务器（公钥加密，私钥解密，不被获取），服务器接收到客户端的数据进行生成公共密钥，这个密钥是我们以后加密数据用来传递的<br>(感觉只要记住证书里面的内容都是能保证绝对正确就好了)</li><li>具有校验机制，是因为我们的证书具有这个作用，比如我上次把我从www.chenye2017.cn 上获取的证书放到虚拟站点blog.chenye2017.cn就直接报错</li><li>配备身份证书，估计也是这个意思</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5525740-62f2352ceaf4787a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>所以ssl 和 tsl 是一样的意思嘛</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-95302aaf96bdae3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>感觉这个握手不是tcp的那个三次握手，这个开始的时候tcp那个三次握手应该都搭建好了，而且这个也是4次握手</p><p>剩下的内容就是4次握手的详细内容了，为什么要4次握手，写的都很详细，就不再补充了，总之这个生成传输加密内容的秘钥也是通过非对称加密，再后面就是http了。</p><p>总结一下：</p><ol><li>通过CA 证书，发送服务器公钥，利用的是非对称加密算法，用的公钥和私钥来自CA（证书的作用是为了保证服务器公钥的正确性，不被篡改）</li><li>通过CA得到的服务器公钥，大家都可能有，但是我们通过公钥加密，私钥才能解密，和服务器交互，让两端都能生成一致的对称加密算法钥匙（随机因素可以通过客户端利用服务器公钥加密传给服务器）</li><li>利用生成的公共密钥进行对称加密，传输数据（这个公共密钥在每次连接的时候生成，别人不知道）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>这可能是东半球最好的git入门了</title>
    <link href="http://yoursite.com/2018/09/07/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%9C%E5%8D%8A%E7%90%83%E6%9C%80%E5%A5%BD%E7%9A%84git%E5%85%A5%E9%97%A8%E4%BA%86/"/>
    <id>http://yoursite.com/2018/09/07/这可能是东半球最好的git入门了/</id>
    <published>2018-09-07T07:51:06.000Z</published>
    <updated>2018-09-08T07:17:52.164Z</updated>
    
    <content type="html"><![CDATA[<p>写后感：以后自己再也不去写关于教程方面的文章了，因为内容实在是太多了，而且很多细小的知识点，其实之前也写过关于python的一个教程，初衷只是担心自己忘记的太快，方便以后的学习，其实就是笔记的整理，反正这两篇写的都很烂，希望自己记住这方面的教训，以后这类文章就是对于自己碰到问题的解决方案吧，实在有些基础内容不记得，就直接看笔记吧</p><p>为什么要取这个名字呢，其实就是我最近看到好多这种名字，然后呢自己很喜欢，就也用了这个名字，但这肯定不是东半球最好的git文章啦，倒数最好的还有可能哦，推荐几篇我比较喜欢的git文章，廖雪峰的git入门教程，掘金小册git教程，其实还有个图解git也挺好的，但我比较笨呢，然后觉得git看了几个就差不多了，图解git可能更适合那些已经用过并了解过git的人，还有就是毕竟不同的人对于git的解读还是不一样的，不同的文章混合在一起看会很难受，最后想说的就是编程要来自实践，工作中不同的困难能加深你对git的认知，因为我们平时用的svn，所以我把git的基本操作记录下来，方便以后的学习。<br><a id="more"></a></p><p>git 和 svn 的区别 ：<br>应该是面试中经常问到的，svn是集中式版本控制系统，git是分布式。<br>1.我们代码的svn提交流程<br>本地修改=》svn服务器=》线上环境，拉取svn服务器最新代码<br>2.我平时用的git提交流程<br>本地修改=》github (远程仓库) =》线上环境<br>哈哈哈，是不是感觉一样，这样使用起来确实是一样的。</p><p>git中每个成员的电脑都相当于一个代码仓库，所以是分布式，svn 只有一个中央服务器，理解成集中式。svn必须联网才能使用，因为我们需要把本地代码提交到中央服务器上，但是git就不需要，因为git可以先把代码提交到本地代码仓库，以后等有网络了再推送到远程仓库，所以是不是可以理解成svn只有在网络许可的情况下，我们才能用他上面的一些功能，但是git不一样，git在本地操作就能完成提交，代码对比的相关功能。</p><p>详细的说下git 推送流程：</p><ol><li>github<br>在github 上新建远程仓库<br>git clone 远程仓库地址<br>git init  (把整个文件夹添托管给git)<br>git add  .  (以后有文件修改的话)<br>git commit -m  “message”  （推送到本地仓库）<br>git push （推送到远程仓库）</li></ol><p>git add .   其实是把文件修改内容添加到暂存区，暂存区是什么，暂存区就是 .git 这个隐藏文件夹下面的index （还记得同事之前说过的让我解决代码冲突时候的一种办法，删除掉.git 或者.svn 文件夹，因为这个文件夹里面保存了我们所有的提交信息，然后我们再设置当前文件夹的远程提交仓库就好了），！！！注意添加到暂存区的是文件修改内容，想象一下，我们每次修改文件后都需要git add 一次就是这个原因，但文件第一次添加后以后没有git add  就是 unstaged, 如果一次都没添加那是 untracked 未追踪的状态，两个还是不一样的。</p><p>撤销git add . (或者文件名)， 通过 git reset head ，可以删除暂存区的内容，这个可以通过git status ，上面会有提示。<br>git commit -m ‘message’ 提交到本地仓库，之后就能看到git log, 其实这也能看做和svn的区别之一？这是掘金小册的作者说的，svn 代码提交就直接在线上环境了，git还只是本地仓库，也可以这么理解吧。<br>git push 远程推送 ，其实是 git push origin master:master ,有时候我们想推送别的分支，可以通过git push origin test:test, origin 是 远程仓库的默认名称。</p><ol><li>一般书上写的团队合作推送流程<br>git checkout dev<br>git checkout -b book<br>git add .<br>git commit<br>git checkout dev<br>git merge<br>git push origin dev:dev</li></ol><p>老大们 ：在master分支上合并dev<br>我们一般在dev分支上开发，我们本地新建一个小的分支，然后进行开发，开发完了合并到dev分支上，然后提交dev分支。<br>以后远程仓库的dev分支合并到master分支上就是老大的事情了</p><p>3.表哥他们的流程<br>每次新建一个本地分支，然后推送到远程，在自己弄得这个分支上开发，然后合并主分支到自己的分支上，开发完了推送到远程分支，因为远程分支是空的，永远不会冲突，但每次自己合并master分支的时候肯定有冲突。</p><p>自己git的日常：</p><ol><li>提交的时候经常看到 up-to-date, 这是最新的意思 （话说简书的md编辑器真的挺好用，复制的图片就直接上传到他们服务器上了，还能转换成md的标签）</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5525740-246f7dc2d79ad61a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p> 这个是我们经常git commit 之后看到的，代表你要提交啦，你本地仓库代表的commit记录已经在远程仓库之前了。</p><p>如果别人也有提交，脑补一下小册上的gif图片，提交肯定有冲突，需要git pull, 下拉代码进行合并。</p><ol><li><p>你需要手动处理冲突，然后git add ., git commit ,然后再git push .<br>注意git push的时候肯定不会冲突，因为git push 就相当于用本地代码覆盖线上代码。</p></li><li><p>head ，master ，branch 都代表一个commit<br><img src="https://upload-images.jianshu.io/upload_images/5525740-19cb5fcfb13f2e0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li></ol><p>有时候我们理解branch ，树枝代表一个很长的提交，其实也还好，但其实不用关心那么长的提交记录啦，知道代表一个commit 就好了，或者是掘金小册中的一个小圆点。</p><ol><li>git log  查看提交记录<br>git log –path   查看详细的修改，其实感觉这种通过ui看就行了，比较方便嘛<br>git log –stat   简单的查看哪些文件修改了</li></ol><p>5 <img src="https://upload-images.jianshu.io/upload_images/5525740-fb95afa267114b40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>head 按理说肯定跟着最新的提交跑，但远程仓库默认就是在master分支上，改不了，所以一直指向的就是master分支上的最新提交</p><ol><li>git branch -a ,可以查看本地分支和远程分支，并不是本地建了分支，远程就要有，需要推送的，然</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写后感：以后自己再也不去写关于教程方面的文章了，因为内容实在是太多了，而且很多细小的知识点，其实之前也写过关于python的一个教程，初衷只是担心自己忘记的太快，方便以后的学习，其实就是笔记的整理，反正这两篇写的都很烂，希望自己记住这方面的教训，以后这类文章就是对于自己碰到问题的解决方案吧，实在有些基础内容不记得，就直接看笔记吧&lt;/p&gt;
&lt;p&gt;为什么要取这个名字呢，其实就是我最近看到好多这种名字，然后呢自己很喜欢，就也用了这个名字，但这肯定不是东半球最好的git文章啦，倒数最好的还有可能哦，推荐几篇我比较喜欢的git文章，廖雪峰的git入门教程，掘金小册git教程，其实还有个图解git也挺好的，但我比较笨呢，然后觉得git看了几个就差不多了，图解git可能更适合那些已经用过并了解过git的人，还有就是毕竟不同的人对于git的解读还是不一样的，不同的文章混合在一起看会很难受，最后想说的就是编程要来自实践，工作中不同的困难能加深你对git的认知，因为我们平时用的svn，所以我把git的基本操作记录下来，方便以后的学习。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于单点登陆的那些事</title>
    <link href="http://yoursite.com/2018/09/04/%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/09/04/关于单点登陆的那些事/</id>
    <published>2018-09-04T02:15:49.000Z</published>
    <updated>2018-09-04T03:38:30.788Z</updated>
    
    <content type="html"><![CDATA[<p>最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.<br><a id="more"></a><br>单点登录：简单理解成一处登陆，到处登陆，一处登出，各处登出。其实在生活中的应用还是满广泛的。比如你登录淘宝的网站，可能当你跳转到天猫上，也不需要登陆，光从界面上看，也能分辨这是两个网站，这两个网站肯定有各自的登陆机制，其实内部就是用了单点登录的原理，让用户无感知的情况下实现一个账户在各个网站下的登陆登出。<br>后来在写的过程中，发现这个单点登录也有点第三方登陆的意思，这个第三方就是sso登陆中心。<br>很多人广从字面意义上看，可能会觉的单点登录应该是这样：一个用户在这个地方登陆了，比如手机上或者上海登陆了，当在电脑上登陆或者安徽登陆了，之前登陆过的账号会下线，但这并不是单点登录哦，想了下，上述功能实现起来也挺简单，比如我们经常存取 token =》 用户信息这样的登陆凭证，又或者是session_id =&gt; session 信息（用户信息）这样的登陆凭证，不妨我们在用户登陆的时候，再存储一封 用户id =&gt; 用户信息，这样我们可以很方便的统计有哪些在线用户，哪个用户是否在线（前面第一种的话需要遍历所有的session文件取出用户id）。当我们登陆接口产生了一个新的token =》 用户信息的时候，我们检测下这个用户是否在已登录列表，如果有，我们服务端直接让之前的token失效就可以了，就能实现前面账号的下线。<br>回归正题，关于单点登录<br><img src="https://upload-images.jianshu.io/upload_images/5525740-5f9c1b27e370fabf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="797930-20161203152650974-276822362.png"><br>单点登录的原理大致就是上面了：<br>1.先登录普通web1，web1后台检测是否登陆了，如果登陆过，直接跳转到web1,如果没有登陆，跳转到sso登陆中心。sso中心检测这个用户是否登陆过，如果没有登陆，跳转到sso登陆界面，输入用户名和密码（之前为什么说单点登录很像第三方登陆呢，因为接入单点登录的web1也不知道即使能登陆到他这个平台上的用户的用户名和密码，用户登陆的操作逻辑都是sso 这个第三方维护的，web1只是在登陆sso成功之后维护一个用户和web1的登陆态，比如web1派发给用户一把钥匙，以后拿着这把钥匙就代表你是web用户了），用户成功登陆sso这个中央站点后（用户和sso之间的登陆成功搭建成，之前我是通过jwt的方式维护用户和sso之间的，jwt相比较传统的cookie和session就是通过签名的方式能防止用户篡改已登录人的信息），sso会回调web1站点上提前设置好的接口（这个我当时是在跳转到登陆中心的时候附带在url后面参数，其实这个可以提前设定好，然后通过传入一个参数web1，sso去后台查找需要的会掉地址），传给他一个参数，可以理解成一个ticket，web1拿着这个ticket可以换取正在登陆的用户的用户信息，拿到之后web1就能实现自己的业务逻辑了，比如检测这个用户是不是第一次登陆，如果是第一次登陆的话需要绑定用户信息之类的，然后维护用户和web1之间的登陆状态建成。<br>上面需要注意的点就是客户端如何接受服务端生成的登陆凭证.<br>首先是用户和sso中心，这个好解决，因为我们的登陆页面可以可以当做一个静态页面，我们可以在上面写js，这就方便了，我们发送一个ajax请求给sso，成功后把返回的登陆凭证放在cookie中，每次调用sso接口比如验证用户是否登陆的时候都会携带着这个cookie，！！！千万要注意，携带这个中在客户端浏览器的cookie的前提是通过ajax之类的访问，你别通过curl之类的访问，curl需要自己手动设置cookie，并不会像浏览器一样自动添加上，所以我们在后台一般要用header  location之类的跳转，而不是curl.<br>web1和用户之间登陆态的维护：<br>这块我没有使用header location跳转，用的是ajax返回给前端页面，前端页面去跳转，之所以这么做，好像是用第一种好像有点问题，没有去研究了，因为时间赶啊！！！前端拿着这个ticket，哈哈哈，你是不是担心不安全，我也担心呢！！而且我这块直接用的url跳转，为什么呢，因为我的后台是获取用户信息之后直接跳转，并不需要ajax那种返回了，如果这里用返回，首先是前台页面并不知道维护好登陆信息之后需要挑战的地址（这个静态页面是sso的），然后呢，如果通过ajax，后台跳转可能有些错误，之前那个sso登陆成功后台跳转不到web1，可能就是这个问题。<br>web1的回调地址里面通过ticket拿到用户信息之后可以做很多自己事情了，比如绑定用户，比如验证用户是否合法等等</p><p>2.单点退出<br>一处退出，处处退出。<br>我是这样做的，当登陆成功后，会在数据库中写入，这个用户的登出地址，当我们登出的时候，查询数据库，所有用户的登出地址，循环调用，需要注意的是我们传给用户的是只能是user_id之类的公有信息，各个子网站接收到之后，需要拿这个信息获取用户的登陆凭证，然后让其失效。我是这样做的：redis中存储着phpsessid（我们用的传统的cookie session）,然后curl 模拟请求的时候cookie带上这个，··然后就实现啦</p><p>思考：如果我们模拟请求的时候带上完全一样的头信息，是不是就能达到和浏览器一样的效果了，··有些能，比如上面的登出，但是设置cookie不可以，明明就是header加上点信息嘛，为什么不可以呢，因为cookie只能在浏览器上使用？<br>还有很多优化的空间，比如回调多个登出接口，用的消息队列，如果一个出错，是记日志吗，还是什么zzz<br>每个网站需要自己的登陆界面嘛，这样每次未登录定位到登陆界面之后就只有个登陆按钮，点击之后才能进入sso输入用户名和密码，相比较之前略麻烦，但是如果sso登陆之后，我们点击就能直接跳转到我们的网站，感觉这样更符合单点登录。<br>而且住校之后我们可以定位到普通网站的登陆界面，而且点击因为可以加回调地址，我觉得还是不能省略的。<br>代码就不放了，放些接口的函数吧<br>sso :<br>login :检测是直接跳转到登陆页面还是检测cookie是否有效，有效回调web1站点地址，无效跳转到登陆界面（看了下仿佛ajax中header location 就是有点问题）<br>logout</p><p>web1:<br>login: 判断是去sso还是直接登陆<br>logout:退出，需要回调 sso 的logout, 注销sso还有各个子网站<br>ssologin:回调登陆地址<br>ssologout：回调登出地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于nginx的那些事</title>
    <link href="http://yoursite.com/2018/08/20/%E5%85%B3%E4%BA%8Enginx%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/08/20/关于nginx的那些事/</id>
    <published>2018-08-20T03:42:26.000Z</published>
    <updated>2018-08-20T03:42:26.033Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2018/08/17/test/"/>
    <id>http://yoursite.com/2018/08/17/test/</id>
    <published>2018-08-17T08:54:57.000Z</published>
    <updated>2018-08-17T08:54:57.684Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel  数据库相关操作</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-数据库相关操作/</id>
    <published>2018-07-29T15:42:59.000Z</published>
    <updated>2018-07-29T15:42:59.679Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel seeder 数据填充</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-seeder-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-seeder-数据填充/</id>
    <published>2018-07-29T15:42:33.000Z</published>
    <updated>2018-07-29T15:42:33.200Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel migrate 数据迁移</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-migrate-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-migrate-数据迁移/</id>
    <published>2018-07-29T15:42:19.000Z</published>
    <updated>2018-07-29T15:42:19.410Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel router</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-router/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-router/</id>
    <published>2018-07-29T15:41:50.000Z</published>
    <updated>2018-08-15T03:08:32.452Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于composer</title>
    <link href="http://yoursite.com/2018/07/29/%E5%85%B3%E4%BA%8Ecomposer/"/>
    <id>http://yoursite.com/2018/07/29/关于composer/</id>
    <published>2018-07-29T15:41:17.000Z</published>
    <updated>2018-10-10T03:42:40.020Z</updated>
    
    <content type="html"><![CDATA[<p>composer,php的包管理工具，类似nodejs的npm，类似python的pip，因为很多时候我们需要接入外来的服务，可能自己的能力不足，又或者是别人有更好的解决办法，不是有说过站在巨人的肩膀上能看的更远么。</p><p>composer require  ```当我们需要安装一个外来服务的时候，注意这个不是安装php的扩展模块，两者有本质上的区别，php的扩展模块是c写的，需要我们源码编译到php中, 而通过composer接入的是php封装的内容。 之前我经常把需要的模块通过手动写入composer.json文件中，然后通过composer install 或者 composer update 这种方式更新，这都是不对的</p><p>composer install  会依据composer.lock 文件进行安装，如果没有这个lock文件按照composer.json进行安装</p><p>composer update 会依据composer.json 进行安装<br>（composer.lock 和 composer.json 的区别lock文件中会严格规定版本号）</p><p>composer init 初始化一个项目被composer 管理（很少用, 一般是手动编写一个composer.json文件，然后install）</p><p>composer 还有文件夹管理的功能，现在一般用的是psr-4,原先项目组织有psr-0,现在废弃了，二者区别就是psr-4通过命名空间更能代表文件位置<br>composer的自动加载有psr-4,我们那个api服务中有使用，注意定义了一个顶级之后，下面的子命名空间可以自动寻找，而不需要你的人为干预<br>files 可以加载配置文件之类的，不用一直include<br>classmap可以不遵循psr-4规范，会扫描指定文件夹，加载里面的类（一般的类名首字母大写，然后类名和文件名一样）<br>当我们修改了composer的自动加载，通过composer dump-autoload来更新</p><p>我们php的框架和python 这种框架有挺大的区别，写了点python，还有问了写python的同事，得到的就是他们写python的时候还用的是面向过程的方式，他们的框架flask感觉更像是php中的包的概念，通过import方式导入，没有各个文件夹的内容规定，给了很大的自由给用户，我们通过composer 安装的文件一般在这个项目文件的vendor目录下，但是我们python 通过pip安装的一般是全局安装，就算是用了pipenv 或者vrtualenv 也是在全局下面然后分成各个子文件夹（仿佛是虚拟站点让php变得这么方便？）</p><p>composer需要注意的东西：</p><ol><li>修改源，下载东西更快</li><li>linux 下安装（composer.phar 就是 php composer, 只是单独使用的话需要composer.phar 需要执行权限 chmod a+x composer.phar）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;composer,php的包管理工具，类似nodejs的npm，类似python的pip，因为很多时候我们需要接入外来的服务，可能自己的能力不足，又或者是别人有更好的解决办法，不是有说过站在巨人的肩膀上能看的更远么。&lt;/p&gt;
&lt;p&gt;composer require  ```
      
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Composer" scheme="http://yoursite.com/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>关于框架操作数据库的几种方式</title>
    <link href="http://yoursite.com/2018/07/28/%E5%85%B3%E4%BA%8E%E6%A1%86%E6%9E%B6%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/28/关于框架操作数据库的几种方式/</id>
    <published>2018-07-28T15:11:56.000Z</published>
    <updated>2018-07-28T15:12:14.011Z</updated>
    
    <content type="html"><![CDATA[<p>其实第一次有这方面的思考是来自七月老师的tp教程，他起了个头，他那个课程的核心就是为了提倡大家使用orm，后来在工作中开始留意这方面的知识.(如果没有那个引子，估计我会把builder query和orm弄混淆吧，因为真的挺相似，调用方法都是链式，orm对于bq方法的使用，又因为区别在于orm的面向对象这个特性上，而且现在基本都不用bq了，就算使用也是可以DB直接调用,而不用像orm那样需要定义一个model类，很难找出bq相对于orm的差别，换句话说因为本身orm就是基于bq的，所以我们需要发现的orm相对于bq的改变，但这个改变刚好是面向对象这种思想上，加上bq的少使用，这个改变很难发现)</p><a id="more"></a><p>看了下php关于linux方面的知识，pdo， builder query ，orm，我这种基础不好接触面不广的人经常混淆。在pdo之前应该是直接利用mysql 和 mysqli进行数据库连接操作，这种的只需要php开启对应的mysql或者mysqli扩展就好了（mysql已经废弃了），这还是我刚学习php的时候书上经常写的，后来在工作中这种的用的就比较少了，主要用的就是pdo了，个人感觉pdo和mysqli用起来查询那些操作还是差不多的，不管是函数还是查询到的结果集，感觉差别最大的还是 一个是new pdo一个是 mysqli_connect吧，:smile:。（pdo使用的时候除了安装pdo扩展，还要开启对应的驱动哦，比如 mysql_pdo）。</p><p>还记的我在学习慕课那个高性能api接口时候接触到的dao层吗，其实dao后来理解起来感觉是不是只有在那种处理比较麻烦和严谨的时候使用</p><pre><code>&lt;?phpclass DB_user extends DB_base {    public function find($username) {        $query = self::$db-&gt;prepare(&quot;select count(*) as c from yaf_user where username = ?&quot;);        $query-&gt;execute([$username]);        $count = $query-&gt;fetchAll();        if ($count[0][&apos;c&apos;] != 0) {            list(self::$errno, self::$errmsg) = Err_map::getCodeMessage(1004);            return false;        }        return true;    }</code></pre><p>看这种，查询一个结果要写这么多，肯定需要独立出来呢。</p><p>后来是builder query，其实和orm是很像的，毕竟orm是基于builder query的，但二者不同之处在于orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例(虽然我们在使用bq的时候可能也是这样想的，但orm不止是想这么简单，他是具体的实现了，比如下面同样调用all方法，虽然查出来的数据类型可能都是collection，但是展开看下，一个下面是关联数组，一个是对象，有具体的public 和private属性)。因为orm基于bq嘛，所以bq的那些方法orm都可以使用，所以我感觉方法的混用也是容易把orm和bq混淆的原因。但你是否还记得bq使用的时候调用的类是 DB,以laravel举例，DB是库facade下面的，但是orm使用的时候我们调用的类是继承model的那个类名字</p><pre><code>DB::table(&apos;student&apos;)-&gt;all()Student::all()</code></pre><p>当我在学习yii的时候还接触到一个概念AR，其实AR只是实现orm的一种方式，比较常用的有AR和··mapper，laravel（Eloquent）和yii现在orm实现方式都是AR，所以不要把这个当做yii和laravel的区别啦。</p><p>AR和mapper的区别在于，mapper把数据对象和数据持久化分开了（啥叫持久化，就是数据存储啊笨蛋···zz，心痛的感觉），mapper中对于数据的保存需要用类似bq中一个统一的类去实现，比如</p><pre><code>//伪代码,方法名纯属虚构，因为懒得去查了$student = new Student();$student-&gt;name = &apos;cy&apos;;$student-&gt;age = 19;DBMAPPER-&gt;config($student);DBMAPPER-&gt;refresh($student);</code></pre><p>现在水平太低，也不知道这样的好处是啥：说是为了把数据对象独立出来，让他的作用就是在各个层中传递.</p><p>大致就这些了吧，最后来一个laravel中最基础的model定义，让我们来更能理解orm的那几个定义</p><pre><code>//orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class Test extends Model{    //定义表名    protected $table = &apos;test&apos;;    //禁止更新时间戳，默认会更新created_at和updated_at    public $timestamps = false;    //可以批量赋值的属性，什么叫做批量赋值，就是我们可以通过create方法插入的，不是save那种，create是直接传入一个索引数组，    //save 是通过给实例的属性一个个赋值，就这点看来，确实有批量赋值的意思    protected $fillable = [&apos;name&apos;];}</code></pre><p>​    </p><p>laravel 中orm的实现用了很多PHP的特性（魔术方法等），比如属性，写的挺好的，在laravel核心框架技术解析中有写到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实第一次有这方面的思考是来自七月老师的tp教程，他起了个头，他那个课程的核心就是为了提倡大家使用orm，后来在工作中开始留意这方面的知识.(如果没有那个引子，估计我会把builder query和orm弄混淆吧，因为真的挺相似，调用方法都是链式，orm对于bq方法的使用，又因为区别在于orm的面向对象这个特性上，而且现在基本都不用bq了，就算使用也是可以DB直接调用,而不用像orm那样需要定义一个model类，很难找出bq相对于orm的差别，换句话说因为本身orm就是基于bq的，所以我们需要发现的orm相对于bq的改变，但这个改变刚好是面向对象这种思想上，加上bq的少使用，这个改变很难发现)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux搭建git仓库</title>
    <link href="http://yoursite.com/2018/07/24/Linux%E6%90%AD%E5%BB%BAgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2018/07/24/Linux搭建git仓库/</id>
    <published>2018-07-24T11:52:40.000Z</published>
    <updated>2018-07-26T06:30:48.453Z</updated>
    
    <content type="html"><![CDATA[<p>故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。<br><a id="more"></a><br>后来老大希望测试下我写的代码，看看需要哪些参数，给了另一台服务器。<br>刚开始想到直接把修改好的代码打个包放上去，后来想了下不是长久之计，因为我的水平肯定要经常修改代码，不能每次修改下就打包一下，太麻烦了。<br>又想到可以通过配置itbasic服务器上的svn，当svn up 的时候忽略掉特定文件夹的更新，百度了下集中方法，大部分是一下集中情况：windows下忽略文件夹，提交代码的时候忽略掉文件夹，很少有更新代码的时候忽略掉文件夹的解决办法。（有，但自己试验失败）。<br>后来想到不如利用git吧，首先大部分都是我一个人操作，我经常向github提交代码，操作已经很熟悉了，再者毕竟用git也能跟上时代的潮流嘛。</p><p>先来介绍一点基础知识：<br>当我们想下载github上的代码（或者说远程仓库的代码），我们可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@ip地址：git远程仓库的地址</span><br><span class="line">//例如</span><br><span class="line">git clone git@github.com:chenye2017/zerg.git</span><br><span class="line">//当需要下载github上的仓库的时候，直接去这个项目首页，会有个clone or download的选项，注意不要选择use https，因为选了那个每次提交代码额时候都要输入密码</span><br><span class="line">//winodows用户可以直接下载zip</span><br><span class="line">git clone git@192.168.56.10:/home/resposity/bbs.git</span><br></pre></td></tr></table></figure></p><p>新建一个目录，自定义名称<br>进入到这个目录内，执行上述操作，就能把项目目录中的代码下载下来。</p><p>但上面仅仅只是下载项目，我们为了和远程仓库进行联动，我们需要在本地的这个文件夹建造一个git仓库，然后和远程仓库的某个分支比如master进行绑定，当我们修改完成的时候进行代码推送到远程的时候，别人下次再次clone或者pull就能收到我们提交的修改。<br>下面就是创建本地仓库的实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd dir</span><br><span class="line">//进入上面执行git clone的文件夹</span><br><span class="line">git init</span><br><span class="line">git add.  //把修改的文件夹都添加进来</span><br><span class="line">git commit -m &apos;init&apos;  //提交到本地代码库</span><br><span class="line">git remote -v //查看远端仓库</span><br><span class="line">//如果有远程仓库，可以进行删除</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@192.168.50.16:/home/resposity/bbs.git //添加远程仓库</span><br><span class="line">git push origin master  //和远程仓库的master分支绑定，以后提交只需要git push</span><br><span class="line">git pull origin master //同上，以后使用也只要git push 就好了</span><br></pre></td></tr></table></figure><p>当我们提交代码的时候肯定是不成功的，提示我们需要输入密码，···而且每次都会提示，怎么办呢，可以通过一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>在windows中，生成密钥位置会在C:\Users\admin 下面，这个下面有.ssh文件夹，进去复制末尾是.pua 也就是公钥的文件，粘贴到你的git仓库所在的服务器的git 主目录下，比如我的是 /home/git/.ssh/authorized_keys,粘贴到文件末尾即可，如果还不能提交代码，重启下sshd服务，netstat -antp|grep sshd, kill, /usr/bin/sshd 启动<br>如果还不行，可以查看这篇文章修改下配置 <a href="https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873" target="_blank" rel="noopener">https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873</a></p><p>一直提交需要填写密码其实是个很常见的问题，收集了几篇文章，因为之前一直不成功，但后来成功了，但其实不是下面这几个问题，是我对git远程仓库理解出现了问题，所以操作不对.<br><a href="https://www.jianshu.com/p/9dbb1dea5929，" target="_blank" rel="noopener">https://www.jianshu.com/p/9dbb1dea5929，</a> （文件夹权限），<br><a href="https://ruby-china.org/topics/14182" target="_blank" rel="noopener">https://ruby-china.org/topics/14182</a> （ssh真的出问题了，需要查看日志）</p><p>最后也是最终的要一步，按理说这应该是第一步的，就是linux上远程创建git仓库。<br>本身应该 1. 创建远程仓库 2 git clone 3. git push<br>这也是我们平时使用github 的主要步骤，但因为这一步最重要所以我放在了最后。</p><p>git创建远程仓库 <a href="http://www.runoob.com/git/git-server.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-server.html</a> 菜鸟教程上已经说得很清楚了，只是我们需要区别一下两行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure></p><p>第一个我们经常用到是实例化本地仓库，第二个是创建一个裸库，什么意思呢，就是这个裸库就是我们平时那个 git clone ip地址后的路径，这个仓库装的都是我们的提交记录，本身是并没有代码的，但我们通过git clone能生成最新的代码，以我的服务器为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/resposity  //专门用来放远程仓库的文件夹</span><br><span class="line">/home/resposity/bbs.git  //我的bbs远程代码库</span><br><span class="line">/home/code/bbs  这是我的服务器上实际项目代码，也是被人访问我的项目的路径</span><br></pre></td></tr></table></figure></p><p>当我本地修改好了代码（windows下），提交到远程仓库中，然后在服务器的/home/code/bbs (线上项目文件夹)下进行更新git pull最新的代码,别人就能访问到我本机的最新代码了。</p><p>对了，还记的我们当初svn代码更新提交失败，提示svn clean也不行的时候怎么处理的吗，就是清除.svn 下面两张表里面的数据 (通过Navicat建立连接).当时刚开始是不会这种方法的，同事告诉我直接删除.svn这个文件夹，说svn管理这个文件夹都是通过他，现在想起来挺有道理的，但没有试过（以前直接是删除了svn这个软件，然后肯定不成功啦，现在想想这和svn半毛钱的关系都没有撒，但感觉不能删除.svn,因为删除了，那些diff都找不到了）git应该也是通过.git这个文件管理的。</p><p>对了，关于免密码登录，当我们通过命令生成的ssh密钥linux下，一般在这个用户目录下面，比如root用户，在/root/.ssh 下面，我们需要把这个公钥粘贴到需要进行提交的git远程仓库的服务器中git的安装目录下面的ssh的auth···——key，里面，追加在文件末尾，注意着这两个地方文件名虽然类似，但一定要分清把那个粘贴到哪个上面，分清主从关系。</p><p>关于忽略文件夹，编辑.gitignore 文件，在项目根目录下面，因为windows下面不能这样命名文件，可以在linux下面编辑保存，编辑之后这个文件就是untracked形式,以后的提交就不会把这个文件保存在内，即使用了git add.</p><p>但是之前把.idea这个文件夹包含进去了，怎么办呢，git remove -n -r –cached</p><p>–cached  只是git仓库删除了，本地不会删除，-r 类似删除文件夹的时候递归删除， -n 先列出来要删除的文件，真正想删除的时候不要加这个参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网站部署随笔</title>
    <link href="http://yoursite.com/2018/06/20/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/06/20/网站部署随笔/</id>
    <published>2018-06-20T13:36:20.000Z</published>
    <updated>2018-06-20T14:48:01.622Z</updated>
    
    <content type="html"><![CDATA[<p>618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。</p><a id="more"></a><p>好久之前在阿里云上买过一个域名，29一年，chenye2017.cn,主要这个名字和我的github账号也是一致的，比较好记。当我想绑定域名到服务器上的时候，其实有点担心，我在阿里云上买的域名能绑定到服务器上吗？</p><p>试试吧。首先需要对域名进行实名认证，域名的实名认证其实挺简单的，填下身份证号和联系电话就好了，后面需要备案，这点需要注意的是，我绑定的是京东云，所以需要在京东云上备案。之前对于域名的购买，我的理解是购买一款厂商的产品，但其实不是这样的，试想一下我们购买域名的时候是不是只要先构思一个自己想要的域名，然后查询域名是否在使用，如果没有使用就可以进行购买，这个凭空想象出来的域名厂商不可能提前为我们准备好，他能做的就是通过域名解析器dns把我们的域名注册进世界的万维网当中，当世界中的某个人通过浏览器进行访问的时候，dns能把域名解析成ip地址找到我们的服务器，既然这样，那我们是不是只需要在我们的服务器上搭建一个域名服务，就能不通过购买他的域名，直接使用自己注册的域名就可以了呢？理论上是可以的，但我没有去实践过。</p><p>备案未完成…</p><p>之前帮前端同事部署过一个vue项目，其实和部署一个php项目 极为相似，甚至更简单，都是通过找寻唯一入口文件，因为前端项目都是静态文件，而且apache默认找的文件夹下面的第一个文件就是index.html,所以都不需要进行特殊的设置（php的话因为要找index.php,所以要做更多的设置），唯一需要注意的就是前段项目的很多路径都是绝对路径，他本质上是相对网站的根目录来的，也就是默认项目部署在网站的根目录下，如果网站没有部署在根目录下，比如itbasic bbs，需要我对引入的静态资源路径进行适当的修改。比如给需要找的静态资源建立个软链接ln -s ,到新的静态资源目录下。</p><p>因为之前是根据网上教程搭建的hexo，其实不懂他的实现原理。</p><p>而且在教程的开始，就说了要使用node，对于我这种js都不好的人，看到node，首先就觉的完了。其实很多前端项目用到node，并不是用到nodejs的语法，而是用nodejs搭建了一个web服务，承载前端项目，然自己置身于一个联网的状态中，就能发出类似ajax这样的联网请求，因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是<a href="http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。" target="_blank" rel="noopener">http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。</a></p><p>我看了下上传到github上的文件夹，和我本地的项目代码结构还是有挺大区别的，我的理解就是把本地代码进行了打包，打包好的文件上传到github上了（类似vue代码的发布），上传到github上的文件夹全是静态目录结构，我惊喜的发现了index.html,于是大胆的假设了下如果把那个目录放在我的站点根目录下，是否也能进行访问了呢，我就不用通过chenye2017.github.io去访问，而是通过我自己的站点去访问呢，毕竟服务器在国内，访问速度也比较快。</p><p>结果是成功的，印证了我的假设。</p><p>在网站部署的时候还遇到了几个问题，比如源码编译apache2.4,在之前还需要安装apr,apr-util,之类的文件，apache2.4的改文件访问权限和之前的apache还不一样，还有文件夹名字结尾不能有空格，否则识别不出来，加载vhost.conf,启动apache失败，修改server localhost之类的apache配置文件，还有apachectl restart开始不管用，需要自己手动配置脚本····</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>无限递归</title>
    <link href="http://yoursite.com/2018/06/13/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/06/13/无限递归/</id>
    <published>2018-06-13T08:00:30.000Z</published>
    <updated>2018-06-13T09:15:47.146Z</updated>
    
    <content type="html"><![CDATA[<p>无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。</p><a id="more"></a><p>以部门举例，我们在使用的过程中，需要找到这个部门的相关父级部门（子孙树），或者我们需要知道某个部门是否属于某个部门，我们既可以用家谱树去实现，也可以用子孙树去实现，用子孙树去实现的一个好处就是，当我们知道父级节点，一次性求出这个父级节点的所有子孙，通过判断子节点是否在这个父级节点的子孙中，就能知道是否满足条件。但如果我们通过家谱树，我们需要每次根据子节点，去求一次家谱，然后来判断家谱树中是否有这个父级节点存在，来判断是否符合条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$address = array(</span><br><span class="line">    array(&apos;id&apos;=&gt;1  , &apos;address&apos;=&gt;&apos;安徽&apos; , &apos;parent_id&apos; =&gt; 0),</span><br><span class="line">    array(&apos;id&apos;=&gt;2  , &apos;address&apos;=&gt;&apos;江苏&apos; , &apos;parent_id&apos; =&gt; 0),</span><br><span class="line">    array(&apos;id&apos;=&gt;3  , &apos;address&apos;=&gt;&apos;合肥&apos; , &apos;parent_id&apos; =&gt; 1),</span><br><span class="line">    array(&apos;id&apos;=&gt;4  , &apos;address&apos;=&gt;&apos;庐阳区&apos; , &apos;parent_id&apos; =&gt; 3),</span><br><span class="line">    array(&apos;id&apos;=&gt;5  , &apos;address&apos;=&gt;&apos;大杨镇&apos; , &apos;parent_id&apos; =&gt; 4),</span><br><span class="line">    array(&apos;id&apos;=&gt;6  , &apos;address&apos;=&gt;&apos;南京&apos; , &apos;parent_id&apos; =&gt; 2),</span><br><span class="line">    array(&apos;id&apos;=&gt;7  , &apos;address&apos;=&gt;&apos;玄武区&apos; , &apos;parent_id&apos; =&gt; 6),</span><br><span class="line">    array(&apos;id&apos;=&gt;8  , &apos;address&apos;=&gt;&apos;梅园新村街道&apos;, &apos;parent_id&apos; =&gt; 7),</span><br><span class="line">    array(&apos;id&apos;=&gt;9  , &apos;address&apos;=&gt;&apos;上海&apos; , &apos;parent_id&apos; =&gt; 0),</span><br><span class="line">    array(&apos;id&apos;=&gt;10 , &apos;address&apos;=&gt;&apos;黄浦区&apos; , &apos;parent_id&apos; =&gt; 9),</span><br><span class="line">    array(&apos;id&apos;=&gt;11 , &apos;address&apos;=&gt;&apos;外滩&apos; , &apos;parent_id&apos; =&gt; 10),</span><br><span class="line">    array(&apos;id&apos;=&gt;12 , &apos;address&apos;=&gt;&apos;安庆&apos; , &apos;parent_id&apos; =&gt; 1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">function test($data, $pid)</span><br><span class="line">&#123;</span><br><span class="line">    static $arr = [];</span><br><span class="line">    foreach ($data as $key=&gt;$value) &#123;</span><br><span class="line">        if ($value[&apos;id&apos;] == $pid) &#123;</span><br><span class="line">            $arr[] = $value;</span><br><span class="line">            test($data, $value[&apos;parent_id&apos;]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(test($address, 4));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">庐阳区，合肥，安徽</span><br></pre></td></tr></table></figure><p>子孙树的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function test1($data, $id, $level = 1)</span><br><span class="line">&#123;</span><br><span class="line">    static $arr = [];</span><br><span class="line">    foreach ($data as $key=&gt;$value) &#123;</span><br><span class="line">        if ($value[&apos;parent_id&apos;] == $id) &#123;</span><br><span class="line">            $value[&apos;level&apos;] = $level;</span><br><span class="line">            $arr[] = $value;</span><br><span class="line">            test1($data, $value[&apos;id&apos;], $level + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">//level主要用来显示是几级的儿子</span><br></pre></td></tr></table></figure><p>还记得我们在大学学习数据结构的时候，因为递归对于效率有影响，所以经常需要把递归改成迭代，上述家谱树容易修改，子孙树需要用到栈，自己不是很理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function test2($data, $pid)</span><br><span class="line">&#123;</span><br><span class="line">    static $arr = [];</span><br><span class="line">    while ($pid != 0) &#123;</span><br><span class="line">        foreach($data as $key=&gt;$value) &#123;</span><br><span class="line">            if ($value[&apos;id&apos;] == $pid) &#123;</span><br><span class="line">                $arr[] = $value;</span><br><span class="line">                $pid = $value[&apos;parent_id&apos;];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(test2($address, 4));</span><br><span class="line">//迭代和递归的转换主要就是靠迭代找到那个停止往上找的条件</span><br></pre></td></tr></table></figure><p>大致就是上面这些，像面包屑导航，不要看着从左到右，其实他也是一棵家谱树，因为他从始至终就只有一棵树。</p><p>还有就是移动各个部门位置问题：</p><p>想象一下，一棵树，我把某个分支截取下来放到另一个分支上是很正常的事情，但问题是有时候，我会出现把父亲节点的父亲设置成自己的子节点，这样树枝就断了，这样是不可取的，除此之外，任意移动都是可以的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域 cookie</title>
    <link href="http://yoursite.com/2018/06/06/%E8%B7%A8%E5%9F%9F-cookie/"/>
    <id>http://yoursite.com/2018/06/06/跨域-cookie/</id>
    <published>2018-06-06T10:30:54.000Z</published>
    <updated>2018-06-06T12:20:16.767Z</updated>
    
    <content type="html"><![CDATA[<p>cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。</p><a id="more"></a><p>cookie,对于传统的lamp架构，在服务器端想获取可以通过$_COOKIE[]数组获取到，但是对于swoole这种自己搭建web服务的东西，只能通过request请求获取，其实lamp里面本质也是这样，也是把apache或者nginx获取到的请求内容放到了php的\$_COOKIE里面，类似的\$_SERVER, \$_GET,这些在swoole里面都是永不了得，你可以把http-&gt;request-&gt;get 的值在请求到来的时候给与\$_GET数组，这样就能在swoole搭建的web服务里面和普通的lamp架构一样使用\$__GET数组了。正因为swoole的这些特性，像如果在swoole里面使用session登录机制需要自己去实现，还有对于一些框架的集成，因为外部传入的参数不在那些数组中了，所以需要对框架进行修改，让框架能获取到对应的参数，保证框架的运行，比如：swoole集成slime框架(swoole在客户端设置cookie也得用它自带的方法而不是setcookie)。</p><p>回归正题，通过上述，我们也只cookie是一个数组，那其中哪把钥匙是用来打开session的呢，答案是PHPSESSID,这个值是可以设定的，在php.ini,或者通过php的session函数来获取到。</p><p>对于session，我觉得他更像是一个模块的扩展，他不仅仅是提供一系列的简单的函数，这些函数其实还有具体的活动的封装。比如开启session的时候，session_start(),他做的东西有很多，首先检测客户端是否有 phpsessid，如果没有，通过函数setcookie，在客户端种植，其实底层就是通过在返回的header头信息中加入set-cookie，如果已经有phpsessid，会通过寻找客户端对应的session，获取里面的信息。那问题又来了，这个phpsessid的cookie是怎么传送给服务端的呢，我不记得我有加入这个cookie啊，一般情况下，在发送http请求的时候，默认都会带上浏览器的cookie。如果禁用了还可以通过url传递哦，话说从url中获取phpsessid也是在session_start()函数中实现的，可见这个函数的复杂性，和普通的函数还是不一样的，里面有具体的逻辑。</p><p>对于cookie的设置，也是有跨域问题的，a.test.com下的cookie,在b.test.com下面不能获取到，但是如果在test.com下面就能获取到了，为什么呢？看看跨域吧。不信？你可以设置下，在/path页面下设置另一个path的cookie，然后去对应的path下刷新，看是否有，答案是肯定有的啦。所以cookie的设定。path是不影响的。</p><p>既然能设定，自然就能删除，设定和删除可以归为一类操作（直接把过期时间设定成当前时间-100就可以删除了，注意cookie有max-age存在的时间和expire过期时间之分，php的setcookie设定的时间是expire时间，所以需要在过期时间+time()!!之前就犯了这个错误）</p><p>其实php的setcookie也能验证这点。在控制器中调用setcookie，如果不传path，默认是当前path，但也可以加path,比如/。</p><p>但需要注意的是不同path下面不能相互读取!!!怎么试验呢，可以在chrom的application下面写,然后在当前path写同一个域名下的另一个path，刷新cookie，发现另一个页面下面的有这个设置的cookie，请求的时候也能带上，但是自己这个设定页面没有，所以有时候如果setcookie没错误，但也没出现cookie，可以考虑下是不是设置路径错误了，虽然设置上了，但是看不见。这种情况特别容易出现在前后端分离的情况下，前端在80端口下，后端在8080端口下，后端api设定cookie是装在了8080那个域名下面，所以你无论怎么刷新前端页面都不会有这个cookie，但是没关系，当你请求后端接口的时候，请求会自动加上！！但要注意，请求的时候，http请求只能把他当前能看到的cookie带上，对于他看不见的肯定不会带上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2018/06/06/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/06/06/跨域/</id>
    <published>2018-06-06T09:34:20.000Z</published>
    <updated>2018-06-06T13:55:05.334Z</updated>
    
    <content type="html"><![CDATA[<p>跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。</p><a id="more"></a><p>关于浏览器同源策略的原因，可以网上查看各种资料，阮一峰的博客是个很好的选择。</p><p>什么时候会出现跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br><span class="line">组成一个域名（协议号：//ip地址：端口号）三者任意一个不同就会出现跨域</span><br></pre></td></tr></table></figure><p>如果解决跨域呢，自己主要了解的有两种，分别是cors和jsonp,自己平时用的主要是cors。</p><p>cors可以让后端代码不用做过多的变动，只需要对返回的内容多添加些头部信息即可。</p><p>jsonp主要是通过script，img标签这类不存在跨域，回忆一下，是不是通过img加载过百度的图片，通过script的src加载过cdn上的jquery。</p><p>通过script返回的内容因为在script标签内部，所以可以执行script代码，所以当我们传给后端我们定义好的方法名，然后让他们把我们需要的数据放进去，再返回来，类似 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showData(&#123;&quot;1&quot;:&quot;boy&quot;&#125;);</span><br></pre></td></tr></table></figure><p>上面的返回结果在script代码中自动执行，就能得到我们想要的结果（需要注意的是传入的数据必须是json类型哦，毕竟后端和js是不同的语言类型，然后我们只需要在showData里面对json数据进行转换成js能识别的数据即可）。</p><p>对于jsonp，我用的比较少，因为很多时候不想特别写专门用来跨域的api接口，所以如果要用jsonp，后端逻辑代码需要更改（百度php如何配合jsnop完成数据传输）。</p><p>对于前端，像jquery有对jsonp的封装，可以自定义函数，然后传入，返回的数据会先走定义的函数，然后来到success函数里面，注意success传入的参数data是不包括后端返回的内容中的函数，而是函数的参数们。</p><p>juqery默认传的自定义函数名称是jquery带一长串数字，具体的用法可以百度查看，我没咋用过。</p><p>还有哦，jsonp只能支持get请求。</p><p>鉴于上面诸多的麻烦，我用的主要是cors。</p><p>首先我们需要知道浏览器将跨域请求分成了简单请求和非简单请求，什么是非简单请求，就是那些不是get post（请求方式）,返回头信息中加入token这类自定义的东西，就是非简单请求，一般情况下，我们的请求都是非简单请求，毕竟简单请求content-type 好像都不能是json类型。</p><p>对于非简单请求，会先在正式请求之前发送一个options请求，当有跨域请求的时候，我们可以看下Chrome的控制面板，很清楚的能看到。对于返回信息，我们需要加以下头信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); //允许的ip</span><br><span class="line">$response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;); //允许的方法</span><br><span class="line">$response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, token&apos;);</span><br><span class="line">//自定义的头部信息</span><br></pre></td></tr></table></figure><p>大致只需要做这些处理，一般像php，只需要在router的 end（返回具体信息）之前加上上面的信息就可以了。</p><p>像node，或者swoole都在启动web服务的文件处加上即可。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP opcache</title>
    <link href="http://yoursite.com/2018/05/25/PHP-opcache/"/>
    <id>http://yoursite.com/2018/05/25/PHP-opcache/</id>
    <published>2018-05-25T07:38:57.000Z</published>
    <updated>2018-05-25T08:02:29.565Z</updated>
    
    <content type="html"><![CDATA[<p>opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。</p><a id="more"></a><p>原理：大概的意思就是把php的脚本一次性全存入内存中，然后每次读取脚本直接从这里面取，而不用每个连接都读取一份脚本。</p><p>但这样就存在修改数据后服务器识别不到，可以配置参数，多少秒服务器检查一次，但一般生产环境直接把配置成0，就是间隔时间是0，单位是s，然后停止检查，而开发环境参数配置成1，一直检查，这样就不会存在修改文件，没有效果了。</p><p>还可以手动清除，必须脚本中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcache_reset()</span><br></pre></td></tr></table></figure><p>但需要注意的就是不同模式下储存脚本是在不同的内存空间中，比如cli下执行脚本文件，和通过浏览器这种mod_php清除是不一样的，所以浏览器访问的话就通过浏览器的方式去执行脚本吧。</p><p>当然，如果和我们swoole那样，每次修改代码后重启web服务器，那是根本不存在这种情况的。</p><p>话说偶然间发现代码的不同方式发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.类似前端代码那种，每次新代码的发布都会重新打个包，然后把站点目录通过软连接指向这个新包</span><br><span class="line">2.我们现在用的，通过在服务器上更新svn上的代码，来发布新的代码</span><br></pre></td></tr></table></figure><p>首先运行环境是php7.014,线上环境是php5.6,效果不是十分明显，还有opcache_reset() byte-code不是十分好用。</p><p>首先得开启这个扩展，在phpinfo中查找opcache或者 php -m 中查找opcache，其实直接php -m就好了，会有个很显眼的ZendOpcache,</p><p>安装方法就是因为默认编译的时候大部分都有–enable-opcache,或者phpinfo页面上可以看见编译的参数，直接在php.ini 里面开启zend_extension=opcahce.so就好了，或者下载文件源码编译。</p><p>或者重新编译一下php（这个忘记了）</p><p>或者可以像pgsql那样去php源码包里面找源文件进行编译？这样可行吗，没有试过。</p><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opcache.validate_timestamps=1 //是否检测修改</span><br><span class="line">opcache.revalidate_freq=0//单位时间</span><br><span class="line">opcache.memory_consumption=64  //memory_consumption 这个参数很好理解，代表这块内存区开辟的大小，另外需要注意不同 PHP SAPI 内存区不是共享的，就是说同一个 PHP 文件，运行在命令行模式或者 PHP-FPM 模式下，对应的 byte-code 会存储在不同的内存区中。</span><br><span class="line">opcache.max_accelerated_files=4000 //如果命中率不搞，可以适当提升这个值，直到1。</span><br><span class="line">opcache.opcache.fast_shutdown=1  //modern php上面说这个写1就可以了</span><br></pre></td></tr></table></figure><p>（opcache_get_configuration()和 and opcache_get_status()）获取配置信息和运行信息，比如了解那些文件被缓存了、使用了多少内存、内存命中率等等。</p><p>感觉就是基于这两个函数出了两个opcache的项目，一个是单页面，一个比较复杂</p><p>1.<a href="https://github.com/PeeHaa/OpCacheGUI" target="_blank" rel="noopener">PeeHaa / OpCacheGUI</a></p><p>2.<a href="https://github.com/rlerdorf/opcache-status" target="_blank" rel="noopener">rlerdorf / opcache-status</a></p><p>单页面的部署直接放在网站根目录下就好了，就理解成phpadmin那种网点就好了，利用的就是php的函数获取php的运行环境，然后可视化展示出来</p><p>opcache_invalidate()，这个函数就是更新特定的文件缓存，没去试验过，因为项目小啦，直接重启web server。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP yield</title>
    <link href="http://yoursite.com/2018/05/25/PHP-yield/"/>
    <id>http://yoursite.com/2018/05/25/PHP-yield/</id>
    <published>2018-05-25T05:55:52.000Z</published>
    <updated>2018-05-25T06:51:23.789Z</updated>
    
    <content type="html"><![CDATA[<p>yield，生成器，自己感觉还是挺重要的，因为php在读取大文件的时候经常会有内存溢出的错误，其实yield还会涉及spl，这部分内容自己目前了解的还不是十分清楚，所以，暂时就把yield的作用归类于放置变量过大在内存中占用本大空间，导致内存溢出吧。</p><a id="more"></a><p>关于yield这种数据类型，还有迭代器，还有collection，都是能用foreach进行循环遍历的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function productNum($length)</span><br><span class="line">&#123;</span><br><span class="line"> $data = [];</span><br><span class="line">  for ($i=0; $i&lt; $length; $i++)&#123;</span><br><span class="line">     $data[] = $i;</span><br><span class="line">&#125;</span><br><span class="line"> return $data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$data = productNum($100000000);</span><br><span class="line">foreach ($data as $key=&gt;$value) &#123;</span><br><span class="line">  var_dump($value);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用php执行上端代码会报出超出分配给php的内存错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function productNum($length)</span><br><span class="line">&#123;</span><br><span class="line"> //$data = [];</span><br><span class="line">  for ($i=0; $i&lt; $length; $i++)&#123;</span><br><span class="line">     //$data[] = $i;</span><br><span class="line">     yield $i;</span><br><span class="line">&#125;</span><br><span class="line"> //return $data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$data = productNum($100000000);</span><br><span class="line">foreach ($data as $key=&gt;$value) &#123;</span><br><span class="line">  var_dump($value);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能执行成功，其实这个时候打印$data变量，可以看出来他是一个类。</p><p>每次foreach 去$data中取数据，上面的那个for循环就会执行一次，再次输出一个变量\$i。</p><p>so，如果使用yield的内容，每次也得循环使用吗？</p><p>yield定义的内容不能有返回。</p><p>下面写一个读取文件，再往另一个文件中写入内容的例子，其实这个例子不具有实际价值，其实就是一个copy文件，用shell_exec执行linux命令就可以，或者file_get_contents,file_put_contents这样就好了，使用yield分多次，唯一可以想到的好处就是控制对内存占用的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getContent($file)</span><br><span class="line">&#123;</span><br><span class="line">  $res = fopen($file);</span><br><span class="line">  while (feof($resource) === false ) &#123;</span><br><span class="line">         yield fgets($resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$res = fopen(&apos;/home/itbasic/3.pdf&apos;, &apos;a&apos;);</span><br><span class="line">foreach ($content as $c_key=&gt;$c_value) &#123;</span><br><span class="line">    fwrite($res, $c_value);</span><br><span class="line">&#125;</span><br><span class="line">fclose($res);</span><br><span class="line">echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;;  //使用: 362640B</span><br></pre></td></tr></table></figure><p>用传统方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$res = file_get_contents($file);</span><br><span class="line">file_put_contents(&apos;/home/itbasic/1.pdf&apos;, $res);</span><br><span class="line">echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;; //使用: 39875608B</span><br></pre></td></tr></table></figure><p>显然超过一个数量级，yield就是把一个结果集分批的给你，你什么时候问他要下一个结果集，他什么时候给你。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yield，生成器，自己感觉还是挺重要的，因为php在读取大文件的时候经常会有内存溢出的错误，其实yield还会涉及spl，这部分内容自己目前了解的还不是十分清楚，所以，暂时就把yield的作用归类于放置变量过大在内存中占用本大空间，导致内存溢出吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架学习0</title>
    <link href="http://yoursite.com/2018/05/21/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A00/"/>
    <id>http://yoursite.com/2018/05/21/框架学习0/</id>
    <published>2018-05-21T15:17:51.000Z</published>
    <updated>2018-05-21T15:28:27.580Z</updated>
    
    <content type="html"><![CDATA[<p>想了下，还是把框架的基础知识也记录下来。</p><a id="more"></a><p>首先我们需要认识到框架也是一个脚本，不要因为现代的框架都是oop而忽略了面向过程。框架的入口文件其实可以看做框架的处理文件，就是一个php文件，只是因为框架把对于问题的处理发送到内部的面向对象库中去了，所以我们才会忽略框架本身的面向过程，这就经常会让小伙伴不知道比如记录用户的访问信息，如果不写在登录接口中应该写在哪呢。</p><p>框架中对于常量的定义，对于辅助函数的定义（没有用命名空间，类似原生php函数的使用）我们经常只是在框架定义好的文件中添加，但忽略了为什么在这个地方写就能这样使用，其实本质上都是因为在入口文件出有include 这个文件才会这样。</p><p>一般入口文件只写一些文件加载，像返回数据的处理之类的一般写在route之中，我们那个bbs写在了入口文件中，添加返回头信息啊之类的，感觉也还行。对于异常的捕获处理一般也写在最外层的入口文件处，这样很暴力，这样每当我们有错误的时候想立刻终止可以通过马上抛出异常，而不用执行到脚本的末尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想了下，还是把框架的基础知识也记录下来。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架学习1</title>
    <link href="http://yoursite.com/2018/05/21/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/"/>
    <id>http://yoursite.com/2018/05/21/框架学习1/</id>
    <published>2018-05-21T14:38:24.000Z</published>
    <updated>2018-05-24T04:02:43.427Z</updated>
    
    <content type="html"><![CDATA[<p>对于框架源码的学习，可以帮助我们以后快速学习一个框架的使用，虽然同样的效果同样可以使用多学习几个框架，比如你把tp学完你学习laravel和yii发现很多时候都是一样的，但这仅限于你对框架的使用，增删改查的使用，当你想去修改一个框架的时候（不包括把框架中常量提取出来放在一个文件中，给框架增加一个validate等等这种情况）而是类似于把框架原来的隐式路由改成显式路由这种情况，如果你没有动手搭建过框架，你会不知所措。</p><p>我们这里对于框架的搭建还不是从头到尾写一个框架这种情况，composer（php的包管理工具，类似前端的npm），我们可以像拼接乐高积木那样搭建一个框架，那用什么来充当积木间的凹槽呢，我觉得命名空间可以充当凹槽之一。</p><a id="more"></a><p>命名空间在我的理解中就是把项目代码看做一个文件夹，然后名称是/,然后下面的各个文件夹名称就是命名空间，为了区分不同文件夹下的相同文件夹名称，我们需要把文件夹名称的路径记录下来。如果我的文件放在文件夹中的目录结构比较深，那么外层的文件夹名称是否可以不要呢，答案是肯定的，我觉得这也是文件夹相对于使用路径的好处之一。</p><p>上文说到了composer，我们要怎么使用这个工具呢。在项目的根目录下（注意不是网站的根目录下，网站的根目录往往是入口文件的根目录）执行composer install，linux下需要时php composer.phar install,他会找composer.json文件，第一次可能没有，我们可以通过composer require xxx/xxxx 来安装一个依赖，这时候会多出composer.json , composer.lock, vendor 目录，我们在入口文件出只需要include  vendor/autoload.php, 就能使用vendor中的依赖了。我们项目中自定义的文件夹也可以通过composer 的autoload来实现自动加载。php的psr-4和psr-0都有对命名空间的规定，但是0废弃了，现在大家都是用4，比较下0和4，比如 \controller\test.php,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace controller;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//psr-0</span><br><span class="line">&#123;</span><br><span class="line">  &apos;autoload&apos; : &#123;</span><br><span class="line">  &apos;controller//&apos; : &apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//psr-4</span><br><span class="line">&#123;</span><br><span class="line">  &apos;autoload&apos; : &#123;</span><br><span class="line">  &apos;controller//&apos; : &apos;controller&apos;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>psr-0会把规定的路径再拼上命名空间当做相对路径去文件夹下找，而psr-4会直接把规定的路径当做命名空间去寻找，上面的例子只是针对简单的一层命名空间，还是看不出什么效果，多层的更容易看出0是多么的脑残。</p><p>还有当注册了controller文件夹，controller的子文件夹的命名空间默认注册。</p><p>我们在修改命名空间的时候只需要修改composer.json文件就可以了，对于composer的具体怎么加载的其实不用管的，他应用这么广泛，一般不会出现什么问题。</p><p>todo:</p><p>use 的时候命名空间顶层不用加\,但是new的时候如果顶层写要加\，不是十分理解。</p><p>来自modern php</p><ol><li>首先use 的时候默认的是来自绝对，默认会在前面加上\</li><li>同一个命名空间下的类相互引用，不用引入命名空间，比如我同一个controller下面代码的相互使用</li><li>xxx/xxxx,这种的一般第一个 xxx是厂商的命名空间，顶层命名空间，比较重要，第二个xxxx是子命名空间。</li><li>仅仅use 其实默认用了as取别名，只是类名和别名一样</li><li>Exception默认是php自带的，应该在顶层命名空间下，用\，如果使用的时候不加，他会默认在当前命名空间下寻找，会出现错误</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于框架源码的学习，可以帮助我们以后快速学习一个框架的使用，虽然同样的效果同样可以使用多学习几个框架，比如你把tp学完你学习laravel和yii发现很多时候都是一样的，但这仅限于你对框架的使用，增删改查的使用，当你想去修改一个框架的时候（不包括把框架中常量提取出来放在一个文件中，给框架增加一个validate等等这种情况）而是类似于把框架原来的隐式路由改成显式路由这种情况，如果你没有动手搭建过框架，你会不知所措。&lt;/p&gt;
&lt;p&gt;我们这里对于框架的搭建还不是从头到尾写一个框架这种情况，composer（php的包管理工具，类似前端的npm），我们可以像拼接乐高积木那样搭建一个框架，那用什么来充当积木间的凹槽呢，我觉得命名空间可以充当凹槽之一。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
