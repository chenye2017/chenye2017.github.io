<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-17T07:19:22.822Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>速查笔记</title>
    <link href="http://yoursite.com/2020/07/17/%E9%80%9F%E6%9F%A5%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/17/速查笔记/</id>
    <published>2020-07-17T03:01:39.000Z</published>
    <updated>2020-07-17T07:19:22.822Z</updated>
    
    <content type="html"><![CDATA[<p>工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-X/--request [GET|POST|PUT|DELETE|…]  指定请求的 HTTP 方法</span><br><span class="line">-H/--header                           指定请求的 HTTP Header</span><br><span class="line">-d/--data                             指定请求的 HTTP 消息体（Body）</span><br><span class="line">-v/--verbose                          输出详细的返回信息</span><br><span class="line">-u/--user                             指定账号、密码</span><br><span class="line">-b/--cookie                           读取 cookie  </span><br><span class="line"></span><br><span class="line">例子:curl -v -XPOST -H &quot;Content-Type: application/json&quot; http://127.0.0.1:8080/user -d&apos;&#123;&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin1234&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>w10 修改环境变量</p><p>set name=cy</p><p>echo %name% (golang 这些编辑器中想生效，就得重启编辑器)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作中有些小东西总容易忘，主要本身也不用去深究，只需要记住怎么使用就行了，记录下，方便平时的快速查找，临时搜索可能造成的问题就是需要提炼出对自己有效的信息。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>gin 的那点事</title>
    <link href="http://yoursite.com/2020/07/17/gin-%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://yoursite.com/2020/07/17/gin-的那点事/</id>
    <published>2020-07-17T02:45:57.000Z</published>
    <updated>2020-07-17T03:01:16.305Z</updated>
    
    <content type="html"><![CDATA[<p>最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事</p><a id="more"></a><p>abort ，next 方法</p><p>gin 的中间件和别的中间件还不一样，gin 的中间件没有next 也能正常执行，next 只是控制自己的代码和中间件的代码执行顺序。中间件中用return 不能停止中间件的执行，只能用abort 方法才能停止后面程序的执行</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近沉迷王者荣耀，好久没有认真学习go了，不应该，记录下gin 学习的那点事&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="gin" scheme="http://yoursite.com/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>go 小知识点</title>
    <link href="http://yoursite.com/2020/07/14/go-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/2020/07/14/go-小知识点/</id>
    <published>2020-07-14T09:57:32.000Z</published>
    <updated>2020-07-14T10:15:13.892Z</updated>
    
    <content type="html"><![CDATA[<p>读源码学到的新的语法，补充自己对go的更多了解</p><a id="more"></a><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>今天在看别人代码的时候发现了一个 interface.([]int) 新用法，以前不知道，这个其实就是断言 assert， 其实php 中也经常用到</p><p>go 中目前我接触到断言</p><p>1.取map值的时候 ，a, ok :=  map[“name”],  虽然没有这个ok 也是能正确运行的，比如 a := map[“name”]</p><p>2.interface 断言， interface.([]int), 转换成[]int类型</p><h1 id="channel定义"><a href="#channel定义" class="headerlink" title="channel定义"></a>channel定义</h1><p>之前看过对channel 的定义最好不要在全局，之前不知道为啥原因，当时因为想做缓冲channel， 而以为var 没法做，所以一直没用全局channel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var channel = make([]chan task, 10)</span><br><span class="line">// 10 个的缓冲， 然后是 task 组成的chan 的slice</span><br><span class="line"></span><br><span class="line">slice 用make 和 自身 定义的区别</span><br><span class="line">make([]int, 10)  [0 0 0 ..]</span><br><span class="line">[]int&#123;&#125;  就是nil</span><br></pre></td></tr></table></figure><h1 id="goroutine的意义"><a href="#goroutine的意义" class="headerlink" title="goroutine的意义"></a>goroutine的意义</h1><p>把一个任务分成很多部分，每个任务完成的周期很短。多个任务中我们可以通过channel 进行通信。如果我们通过单个channel ，在进行io的时候会阻塞的， 所以我们需要多个channel 来配合多个goroutine。多个goroutine消耗多个channel, 取数据的时候，可以把channel 传入goroutine当中，来消耗特定的channel。投递数据的时候咋办？当往特定的channel 中投递任务，因为go不像php 那样可以拼变量名，我们可以先把多个channel 放在一个数组中，然后通过数组index 去取特定的channel。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;读源码学到的新的语法，补充自己对go的更多了解&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go 包的学习</title>
    <link href="http://yoursite.com/2020/07/03/go-%E5%8C%85%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/03/go-包的学习/</id>
    <published>2020-07-03T06:41:03.000Z</published>
    <updated>2020-07-03T06:47:03.682Z</updated>
    
    <content type="html"><![CDATA[<p>go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们</p><a id="more"></a><p>math/rand</p><p>随机数我们经常用到，php 中rand(), 就能生成一个随机数，但是go中不行，详见 <a href="https://blog.sqrtthree.com/articles/random-number-in-golang/" target="_blank" rel="noopener">https://blog.sqrtthree.com/articles/random-number-in-golang/</a></p><p>这篇文章的解释。php 中也有seed 的概念，不太清楚php中默认seed 是什么，因为一直改变，导致rand() 产生的随机数一直在变，我们可以通过函数设置seed 固定，这样rand 产生的随机数就不变了</p><p>ps: seed 并不是 rand 产生随机数从上限的概念，应该是随机数算法中用到的。还有go rand产生的随机数好像都是从1 开始的，比如我们想从5 开始，可以给产生的随机数都 + 5， 就能满足需求了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 语言太底层，为了方便大家的日常，出现了很多包，对底层api 的封装，产生的作用类似php 中各个函数（php 的函数相较于go，都属于高阶的），学习他们，使用他们&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go-并发</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/07/02/go-并发/</id>
    <published>2020-07-02T13:56:22.000Z</published>
    <updated>2020-07-14T09:57:48.688Z</updated>
    
    <content type="html"><![CDATA[<p>这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较go 的多进程 （process）和 java的多线程（thread）更轻量。</p><a id="more"></a><p>我们在我们项目代码中可以随意的通过 go func（）{} （） 生成一个goroutine， 不同的goroutine 可以执行不同的逻辑，我们的主进程也可以看成一个goroutine，他会不等待 其他的goroutine, 如果main 执行完了，其他的goroutine 会自动结束，不管有没有执行完， 所以我们经常在代码的尾部，sleep ，等待其他goroutine执行完。但这只是demo，真正工作中无法知道一个goroutine 要执行的时间，比如 curl的返回，多种方法可以解决上述的问题，等待goroutine 执行完。</p><p>1.我们可以通过go 的sync 包，同步阻塞，等待所有的goroutine 执行完。</p><p>sync.waitGroup 只是让goroutine 在没有channel 的执行下也阻塞住了，等待goroutine的执行，但并没有解决线程安全的问题。</p><p>2.通过channel ，我们在channel 的使用过程中经常会发生死锁问题，这恰恰是我们可以通过channel 等待goroutine 执行的关键所在。</p><p><a href="https://studygolang.com/articles/18800" target="_blank" rel="noopener">https://studygolang.com/articles/18800</a></p><p>这篇文章很好的解释了channel 造成死锁的几个原因。</p><p><a href="https://juejin.im/post/5d216f07e51d4550bf1ae8e0" target="_blank" rel="noopener">https://juejin.im/post/5d216f07e51d4550bf1ae8e0</a></p><p>掘金的这篇文章比较简单，但也说明了channel的几个使用场景。</p><p>关于并发：</p><p>首先想说一下关于并发的场景，其实并发在生活中很常见，只要用户量足够多，同一时刻很可能有两个人在做同样的事情，但这不是高并发，高并发常见的场景就是秒杀的时候，很多用户在某一个时刻被召集起来争抢有限的资源。总结：就是某一时刻某个api 被大量请求，这就是我们压测的原因， 在高并发的情况下我们的服务是否稳定。</p><p>其实很多时候我们的接口在高并发下其实没啥影响，比如幂等的接口（获取某个后台配置），只要我们的服务器撑得住，多少的并发量不是问题，这不是目前我想表达的并发，想说的是非幂等性接口在高并发下的危险性，比如秒杀情况下的超卖。为什么会出现超卖，就是我们在获取数据的同时并不是立马就能处理逻辑，比如在我们减少库存的途中，另一个请求先完成了，导致库存数已经为0了，这时候虽然我们之前的库存1 ，减少为0 合情合理，但其实我们在减少库存1的时候库存数量已经是0了，我们并不知道，所以实际库存已经是 -1了，这就是超卖。</p><p>这个库存可以类比到我们代码中就是公共变量，在lnmp的架构中，因为我们的webserver其实是 fpm提供的，fpm 会有多个进程，每个进程中有php，我们的业务代码存在于每个进程中，每当请求结束，这个进程中的变量生命周期就结束了，这种同步模式不存在公共变量读写不一致问题，唯一可能的就是我们从第三方中间件比如redis 比如 mysql中数据读写不一致问题，一般是redis ，所以就有了 redis + lua 的 原子性操作。</p><p>而在go 中，当我们用go 的 net/http 包做webserver 的时候，对于全局变量，不同的goroutine会存在读写不一致问题， 这时候我们就会引入sync 包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决goroutine 一起完成我们引入了</span><br><span class="line">w sync.WaitGroup</span><br><span class="line"></span><br><span class="line">// 添加4个goroutine</span><br><span class="line">w.add(4)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">  defer w.Done()</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line">// 完成</span><br><span class="line">w.Wait()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决读写不一致问题</span><br><span class="line">// 互斥锁</span><br><span class="line">r sync.Mutex</span><br><span class="line"></span><br><span class="line">r.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.Unlock()</span><br><span class="line"></span><br><span class="line">// 注意这个锁是针对代码的，而不是针对资源的，同一时刻只能有一个goroutine能执行</span><br><span class="line">// 我们不能随便用 defer r.Unlock() , 当锁不存在的时候会报错</span><br><span class="line">// 互斥锁有时候太严格，比如两个读操作，并不需要等待</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 为了解决上述问题，出现了读写锁</span><br><span class="line">r Sync.RWMutex</span><br><span class="line"></span><br><span class="line">// 读锁</span><br><span class="line">r.Rlock()</span><br><span class="line">r.RUnlock()</span><br><span class="line"></span><br><span class="line">// 写锁</span><br><span class="line">r.Lock()</span><br><span class="line">r.Unlock()</span><br></pre></td></tr></table></figure><p>模拟并发的出现也是个技术活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样正常情况下不会发生超卖，因为间隔时间太短</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for &#123;</span><br><span class="line">  if n &gt; 0 &#123;</span><br><span class="line">    n := read()  //10</span><br><span class="line">    </span><br><span class="line">    //</span><br><span class="line">     time.Sleep(5 * time.Second)  // 睡个5s ，必然出现</span><br><span class="line">     </span><br><span class="line">    fmt.Println(n--)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">除了锁之外，还可以通过原子性操作解决并发问题</span><br><span class="line">// data++ 这种操作原来也会出现线程不安全问题</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这些天go的学习，相比较php，给我最大的感觉就是go 更偏向底层，相比较php有更多的接口能让我们和os交互。再者就是go 天生支持高并发，也就是goroutine （coroutine 协程），相比较go 的多进程 （process）和 java的多线程（thread）更轻量。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>go-反射</title>
    <link href="http://yoursite.com/2020/07/02/go-%E5%8F%8D%E5%B0%84/"/>
    <id>http://yoursite.com/2020/07/02/go-反射/</id>
    <published>2020-07-02T08:13:01.000Z</published>
    <updated>2020-07-02T08:38:33.837Z</updated>
    
    <content type="html"><![CDATA[<p>反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。</p><a id="more"></a><p>go中反射的使用当然包含上述依赖注入的场景，目前我接触到的场景就是struct 中tag 的使用，比如struct 在json string 中 对于json属性名的自动转小写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">type Name struct&#123;</span><br><span class="line">   name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := Name&#123;&quot;111&quot;&#125;</span><br><span class="line"></span><br><span class="line">r := reflect.TypeOf(a)  // 返回一个type 类型</span><br><span class="line">r.NumField()  // 返回属性的个数</span><br><span class="line">r.Field(i) // 返回第i 个属性</span><br><span class="line">r.Name() // 获取属性的名称</span><br><span class="line">r.Kind() // 获取属性的类别 ，比如自定义结构体叫myStruct, kind 返回 struct, name 返回myStruct</span><br><span class="line"></span><br><span class="line">// 对于地址类型</span><br><span class="line">r := reflect.TypeOf(a).Elem() // 返回一个type类型，我们就能愉快的使用接下来的那些方法了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v := reflect.ValueOf(a)  // 返回一个value 类型 ，（把类型和值分开了，虽然感觉很奇怪）</span><br><span class="line">v.Field(i) 这个返回的类型和上面type 的类型还不一样，上面的那个可以获取tag等属性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 还有个很重要的就是函数的反射</span><br><span class="line"></span><br><span class="line">func Sum(a int, b int) int &#123;</span><br><span class="line">   return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := reflect.ValueOf(Sum)</span><br><span class="line"></span><br><span class="line">// 注意call 调用的时候必须是[]value, 然后单个value 可以用ValueOf 来返回</span><br><span class="line">p.Call(reflect.Value&#123;reflect.ValueOf(10), reflect.ValueOf(20)&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;反射在php 中的应用场景主要是依赖注入的时候，通过控制器在调用函数的时候对于传入参数 class 类名的限制，自动从di容器中取出对应class 的单例类实体，方便我们在使用的时候不需要主动传入。&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>go-加密</title>
    <link href="http://yoursite.com/2020/06/17/go-%E5%8A%A0%E5%AF%86/"/>
    <id>http://yoursite.com/2020/06/17/go-加密/</id>
    <published>2020-06-17T07:23:40.000Z</published>
    <updated>2020-06-17T07:27:06.817Z</updated>
    
    <content type="html"><![CDATA[<p>加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;加密 和 hash 在web 开发中经常用到，比如后端比较流行的jwt，用的就是hash，简单记录一下在go 中这些包的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://yoursite.com/categories/Go/"/>
    
    
      <category term="GO" scheme="http://yoursite.com/tags/GO/"/>
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>go 数据库原生操作</title>
    <link href="http://yoursite.com/2020/06/09/go-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%94%9F%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/06/09/go-数据库原生操作/</id>
    <published>2020-06-09T12:28:16.000Z</published>
    <updated>2020-06-09T12:52:51.286Z</updated>
    
    <content type="html"><![CDATA[<p>go web 开发，操作mysql 是基础啦</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;database/sql&quot;</span><br><span class="line">   _ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line">首先是包的引入，很常见吧，下面那个驱动引入，却未使用可能是只希望使用这个包的 init()方法</span><br></pre></td></tr></table></figure><blockquote><p>通常来说, 不应该直接使用驱动所提供的方法, 而是应该使用 sql.DB, 因此在导入 mysql 驱动时, 这里使用了匿名导入的方式(在包路径前添加 _), 当导入了一个数据库驱动后, 此驱动会自行初始化并注册自己到Golang的database/sql上下文中, 因此我们就可以通过 database/sql 包提供的方法访问数据库了.</p><p>可能这就是interface 的作用吧</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type DbWorker struct &#123;</span><br><span class="line">    //mysql data source name</span><br><span class="line">    Dsn string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    dbw := DbWorker&#123;</span><br><span class="line">        Dsn: &quot;user:password@tcp(127.0.0.1:3306)/test&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    db, err := sql.Open(&quot;mysql&quot;,</span><br><span class="line">        dbw.Dsn) // 返回一个sql.DB 的指针</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>sql.Open并不会立即建立一个数据库的网络连接, 也不会对数据库链接参数的合法性做检验, 它仅仅是初始化一个sql.DB对象. 当真正进行第一次数据库查询操作时, 此时才会真正建立网络连接;</li><li>sql.DB表示操作数据库的抽象接口的对象，但不是所谓的数据库连接对象，sql.DB对象只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法;</li><li>sql.Open返回的sql.DB对象是协程并发安全的.</li><li>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</li></ol><p>所以我们平时用的都是长连接，在池子里面可以复用的啦。平时我们在 prepare ，query(查询)， exec(插入，修改) 之后都要及时 close</p><p>MySQL 5.5 之前， UTF8 编码只支持1-3个字节,从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，utf8mb4兼容utf8，所以能支持更多的字符集;关于emoji表情的话mysql的utf8是不支持，需要修改设置为utf8mb4，才能支持。</p><p>(4 字节的utf8 我们应该一直在用啦)</p></blockquote><p>插入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;insert tasks (content, user, create_at, update_at, deleted) values (?, ?, ?, ?, ?)&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">now, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2016-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">update := time.Now().Format(&quot;2006-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">result, err := stmt.Exec(&quot;测试&quot;, &quot;cy&quot;, now, update, 0)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(result.LastInsertId())</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;update tasks set content = ? where id = ?&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">stmt.Exec(&quot;ceshi11111&quot;, 2)</span><br></pre></td></tr></table></figure><p>查询代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:wyqnkxk2012_CY@tcp(118.184.219.156)/cy&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">err = db.Ping()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//update(db)</span><br><span class="line">//return</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(&quot;select * from tasks where id = ?&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(stmt)</span><br><span class="line">&#125;</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">rows, err := stmt.Query(3)</span><br><span class="line"></span><br><span class="line">defer rows.Close()</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := []*task&#123;&#125;</span><br><span class="line"></span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">tmp := &amp;task&#123;&#125;</span><br><span class="line">rows.Scan(&amp;tmp.id, &amp;tmp.content, &amp;tmp.user, &amp;tmp.create_at, &amp;tmp.update_at, &amp;tmp.deleted)</span><br><span class="line">arr = append(arr, tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go web 开发，操作mysql 是基础啦&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go time</title>
    <link href="http://yoursite.com/2020/06/09/go-time/"/>
    <id>http://yoursite.com/2020/06/09/go-time/</id>
    <published>2020-06-09T11:47:50.000Z</published>
    <updated>2020-07-03T08:50:54.958Z</updated>
    
    <content type="html"><![CDATA[<p>go 中时间包的使用</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">time.Now() // time 包的 Time 类型</span><br><span class="line"></span><br><span class="line">// Time</span><br><span class="line">// 2018-05-31 09:22:19 +0800 CST Time 类型打印出来长这样</span><br><span class="line">time.Now() // 获取当前时间的Time 类型</span><br><span class="line">time.Now().Unix()  Time 类型装 int64</span><br><span class="line">time.Now().Unix()Formate(&quot;2006-01-02 15:04:05&quot;) // 格式化</span><br><span class="line">time.Now().in(a)  // 使用某个时区，返回的是Time 类型，所以可以用</span><br><span class="line"></span><br><span class="line">// location</span><br><span class="line">time.Location() // 返回时区信息</span><br><span class="line">a,_ := time.LoadLocation(&quot;UTC&quot;)  // time 包的 location,如果想用时区，就得用这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数字转Time</span><br><span class="line">time.Unix(11111)</span><br><span class="line"></span><br><span class="line">// 字符串转Time</span><br><span class="line">time.Parse() 和 Time.Format() 是互逆的两个函数</span><br><span class="line">time.Parse() 解析字符串成Time 的时候需要时区信息，我们可以用Loadlocation获取时区信息，然后作为第三个参数传进去</span><br><span class="line"></span><br><span class="line">// Duration </span><br><span class="line">这个在sleep 的时候经常用到</span><br><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond          = 1000 * Nanosecond</span><br><span class="line">    Millisecond          = 1000 * Microsecond</span><br><span class="line">    Second               = 1000 * Millisecond</span><br><span class="line">    Minute               = 60 * Second</span><br><span class="line">    Hour                 = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>今天遇到一个问题，比如sleep() ,这个参数需要是 time.duration, 但是我需要可控的 整数， 6 <em> time.Second， 这样执行不了，需要把 6转换成 time.Duration(6) </em> time.Second, 这样就能运算了。</p><p>这个其实并不是包的特殊性，还是golang语法自身问题自己了解的不足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type c int</span><br><span class="line"></span><br><span class="line">var cparam int</span><br><span class="line">cparam = 1</span><br><span class="line"></span><br><span class="line">o := 1</span><br><span class="line"></span><br><span class="line">fmt.Println(cparam == o)  // 必然报错，虽然是别名，但还是不同类型</span><br><span class="line"></span><br><span class="line">time.Sleep(6 * time.Second) // 这是因为 6可以当做 time.Duration 类型</span><br><span class="line"></span><br><span class="line">可是</span><br><span class="line">r := rand.Int() // int</span><br><span class="line"></span><br><span class="line">time.Sleep(r * time.Second) // 不同的数据类型不能相乘</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天还发现 time 包的一个很牛逼的方法，涉及channl， 所以只有 goroutine 的时候用得到。 time.After() 是一个channl 在规定时间后可以读取一个数据，利用select 机制，可以控制超时问题。</span><br></pre></td></tr></table></figure><p>今天 发现go 去修改时间也很方便，比如</p><p>time.Add() 比如 + 1天， -1 天，</p><p>Sub() 计算两天的差值（不是用来算负数天的哦）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 中时间包的使用&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>go 环境搭建</title>
    <link href="http://yoursite.com/2020/06/06/go-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/06/go-环境搭建/</id>
    <published>2020-06-06T08:24:09.000Z</published>
    <updated>2020-07-01T13:02:18.471Z</updated>
    
    <content type="html"><![CDATA[<p>go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了</p><a id="more"></a><p>学习任何一门语言，刚开始面对的第一个问题就是环境的搭建吧，相较于php的编译安装，go的环境搭建更加简单。</p><p>首先要明确的一点是go 是交叉编译，所以我们无论在win 还是 mac 还是 linux 下开发都是一样的。php 有很多扩展比如redis ，在win下版本比较少，所以我们不得不需要一个linux 环境， 我们平时开发php ，是把远程服务器的代码sftp 到本地，然后本地代码的修改实时上传到服务器上，在服务器上跑。go不需要 （goland 甚至连着个功能都没有，需要装插件）。</p><ol><li><p>下载go的安装包，因为墙的原因，我们可以去 studygolang 上面下载，win和 mac 都是那种点击下一步傻瓜般的安装，linux 下安装也很简单，下载解压完之后就是一个编译好的二进制包（就像php 编译完成那样）。我们只需要把 我们环境变量的 path ，添加上 go下载包中的bin，就能直接使用go的命令了。linux 下可以直接编译 /etc/profile, source /etc/profile 生效。保存好后 echo  $PATH，查看path 。</p></li><li><p>go 安装需要注意的几个路基</p><p>goroot  就是我们（linux 下解压完go 安装包的地址，win 和 mac 下是我们自己制定的go 安装路基）</p><p>gopath 是我们自己制定的一个文件夹，需要在这下面手动建立 bin， pkg， src 三个目录，其中bin 是我们日后编译生成二进制文件的地方，pkg 很重要，里面的mod 文件就是我们安装的第三方库所在的目录，src 就是在 go mod 没出现前，我们存放我们项目代码的地方(之前就觉得我们的代码只能存放在一个地方，很不方便，go mod 的出现就不需要管这个文件夹了）</p><p>go env 我们可以查看和 go 相关的 环境变量，必要重要的有  GO111MODULE, 怎么设置  go env -w </p><p> GO111MODULE=”on”,  还有 GOPROXY=<a href="https://goproxy.cn,direct，" target="_blank" rel="noopener">https://goproxy.cn,direct，</a> goproxy.cn 就是 七牛云搞的golang 下载包中国镜像，后面的direct 代表如果找不到，就直接按照网址下载。go 的第三方包的命名很好玩，基本就是这个仓库所在的可以访问的url 路径，比如 code.chenye2017.cn/xxx/xxx, 不需要像composer 那样中间走一层代理，那层代理还要给你开访问权限，才能下载。</p></li></ol><p>3.在用goland 编辑的时候，会遇到包找不到的请款，我们需要手动 seting 去配置 goroot  gopath ，还要开启vgo（就是gomod）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200606164735.png" alt=""></p><p>这个地方要选空，否则还是会出现包找不到的问题。</p><p>4.go mod 的使用，go mod init xxx 初始化项目，生成 go mod 文件，类似composer init 生成 composer.json，go run main.go 开始跑项目啦。会自动下载需要的安装包，这个相比于composer install 更加的方便。</p><p>今天在初始化别人项目的时候发现goland 的 go vgo 已经设置好了，但是还是找不到go module 的位置，仔细一看发现是自定义的package name 找不到。当我们想用go module 的时候，我们一定要 go init 起一个默认的命名空间，然后当我们使用自己定义的包名的时候，都会用到这个这个命名空间做前缀。</p><p>以上就是总结的 go 环境安装，完结~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq记录</title>
    <link href="http://yoursite.com/2020/05/26/rabbitmq%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/05/26/rabbitmq记录/</id>
    <published>2020-05-26T03:45:16.000Z</published>
    <updated>2020-10-10T07:21:06.465Z</updated>
    
    <content type="html"><![CDATA[<p>rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 <a href="http://docs.php.net/manual/da/book.amqp.php" target="_blank" rel="noopener">http://docs.php.net/manual/da/book.amqp.php</a>，一种是市面上比较流行的库<a href="https://github.com/php-amqplib/php-amqplib" target="_blank" rel="noopener">https://github.com/php-amqplib/php-amqplib</a>， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。</p><a id="more"></a><h3 id="不同的角色"><a href="#不同的角色" class="headerlink" title="不同的角色"></a>不同的角色</h3><p>关于rabbitmq 的理论知识，<a href="https://www.cnblogs.com/wutianqi/p/10043011.html" target="_blank" rel="noopener">https://www.cnblogs.com/wutianqi/p/10043011.html</a>， 这篇文章讲解的很清楚。</p><p>生产者 : 也是通过channel， 去 declare 一个 队列 ，然后发送消息（为什么要使用channel， 因为tcp 连接断开重建很浪费资源）。如果中间没走exchange 的 话，就不需要 routing key 了 。很多人经常把routing key 和  队列名称写一样，因为可能这个消息当初考虑的时候就是专门给这个队列queue 使用的。但其实 routing key  和 queue 可以不一样的，消费者在定义自己的队列便于接受 exchange 投递过来的消息，routing key 就相当于一把钥匙，可以打开这个队列的门。</p><p>上面关于生产者的描述并不准确，上面的过程大概就是单个脚本发送消息的过程，是一种翻译。准确的生产者只做一件事，就是发送消息。首先获取connection， 再通过connection 去获取channel (如果是消费者的channel ，我们在rabbitmq的管理界面还能获取到这个消费者的详细信息)。然后通过channel 去 publish 消息，就结束了。其中关于exchange 的 declare ，是重复的操作，我们可以提取出来，而不分给生产者发送消息这个行为 ，因为publish 的时候我们是不需要exchange 的declare 的，我们完全可以手动在web 上新建exchange， 然后publish的时候填入 exchange 的名称。同理 queue的declare 也是如此。所以我们在生产者消费者的同时，我们可以一方去declare 就好了。</p><p>channel 的publish 方法第二个参数是key ，当我们是 简单或者工作或者 fanout 模式的时候，这个key 就是 queue的名称。一定要注意如果这个key 是空的，或者不存在，我们的消息就会丢弃，因为没地方存储。</p><p>说到这里，就需要注意一下我之前的一个误区，开了生产者，然后启动消费者，消费者拿不到消息，消息为啥丢失了吗？我的理解中，不应该消息积存了，后来消费者启动了，开始消费吗？其实主要是exchange 不能存消息的，当我们启动消费者的时候，经常会启动一个队列，如果这个队列以前不存在，exchange拿着routing key 匹配不到 队列，就会把这个消息丢失。</p><p>消费者：和上面的生产者对应</p><p>同理，消息者其实也是获取到一个connection， connection 获取到channel ，我们就可以去消费消息了 （go 消费消息好像只能用协程的方式）。channel consume 的时候需要一个 queue 的名称，其他什么都不需要。但我们需要把这个queue 绑定到对应的exchange 上，注意了！！！因为识货一直用的routing key 都是字符串，所以不涉及匹配模式，所以我们很容易把生产者的routing key 和 消费者的routing key 当做一个，其实在topic 模式下  queue的 routingkey 需要是正则表达式，比如 #.coupon.#, 生产者 1.coupon.2 就能被这个消费者消费到，不要搞反了。 #可以接收到所有的消息。</p><p>总结：</p><p>所以我觉得，对于生产者，可以定义exchange ，但是queue 这些没必要，因为我们发送消息的时候只要exchange ，和 routing key 。</p><p>对于消费者，可以定义exchange （如果生产者没定义）。需要定义queue，因为consume 的时候需要，需要queue bind exchange 利用 binding key。</p><p>消息代理： broker ，kafka 也有这个玩意，但kafka 的broker 上面有分区，可以存储消息 （rabbitmq 就是一种消息代理）</p><p>虚拟主机：vhost,  识货到现在都没用 （可以利用不同域名区分生产和开发环境，识货直接用的不同的ip）</p><p>交换机：exchange，识货到现在只用一个exchange 就是 amp.topic</p><p>绑定： binding， 把队列queue 和 exchange 绑定起来</p><p>路由键： routing key， 生产者把消息推送到 exchange 上</p><p>队列：queue</p><p>连接： connection</p><p>通道： channel</p><p>消费者： consumer</p><h3 id="不同的工作模式"><a href="#不同的工作模式" class="headerlink" title="不同的工作模式"></a>不同的工作模式</h3><p>一共有5中</p><p>没有exchange 的有simple 和 work 模式，simple  p -&gt; queue-&gt;c,  这样</p><p>work  p-&gt; queue -&gt;(c1, c2)</p><p>exchange 又分多种工作模式，比如topic, direct, fanout. (这三种相较于上面的 work 模式就是不同的队列消费的是同样的消息)。工作中其实我们无意的都在使用work 模式，因为会启动多个消费者。之所以多个消费者消费不同的消息，是因为我们的生产者的routingkey 是不一样的，即使我们消费者的binding key 是一样的。</p><p>识货用的都是direct  （虽然 amq.topic 这个交换机的类型是topic ），但是绑定 exchange 的queue 的 bindingkey 一直类似 a.b.c 这样，所以其实就是direct。这种有个坏处就是某个queue 需要另一个routing key的数据，我们不得不在这个queue上绑定一个新的bindingkey 对应这个新的routing key， topic 模式就是为了解决这个问题出现的 ， bindingkey 对于 routing key 的模糊匹配。那什么是fanout呢，fanout就是不要routing key 的 direct， 直接推所有绑定到 exchange的 queue。</p><h3 id="写代码的时候应该注意的几个属性"><a href="#写代码的时候应该注意的几个属性" class="headerlink" title="写代码的时候应该注意的几个属性"></a>写代码的时候应该注意的几个属性</h3><p>交换机的属性：（识货就用一个交换机 amp.topic 所以这些都没用用过）</p><p>name:</p><p>durable: 持久化，消息代理重启后，交换机是否还存在。交换机有两个状态，持久（durable）、暂存（transient）。持久化的交换机会在消息代理重启后依旧存在，而暂存的交换机则不会。</p><p>auto-delete: 当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它。</p><p>arguments: 依赖代理本身</p><p>队列属性：</p><p>name:</p><p>durable: 消息代理重启后，队列是否还在。</p><p>exclusive:  只被一个连接使用，连接关闭后，将立即删除队列。（这个排他性也很坑爹，如果设置了，经常别的连接不能用）</p><p>auto-delete: 当所有的消费者都退订队列后将自动删除该队列 .(如果设置false， 经常就是消费者没了，队列也就没了)</p><p>消息属性：(识货这边从来没设置过，照样跑)</p><ul><li><p>Content type（内容类型）</p></li><li><p>Content encoding（内容编码）</p></li><li><p>Routing key（路由键）</p></li><li><p>Delivery mode (persistent or not)</p><p>Delivery mode (persistent or not)<br>投递模式（持久化 或 非持久化）</p></li><li><p>Message priority（消息优先权）</p></li><li><p>Message publishing timestamp（消息发布的时间戳）</p></li><li><p>Expiration period（消息有效期）</p></li><li><p>Publisher application id（发布应用的ID）</p></li></ul><p>消息确认：</p><p>消息确认开启后，如果我们没有确认消息，消息会是 unack 状态，当消费者挂掉后，几秒中unack的消息会重置成total 未消费状态 (一定要注意)</p><p>未确认的东西。识货的消息从来没有设置持久化状态，但是mq 挂掉了之后消息还能找回来。</p><p>(消息能够以持久化的方式发布，AMQP代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162641.png" alt=""></p><p>要善于利用rabbitmq 的管理界面，注意detail 那块，这是我们使用死信队列造成延迟队列。</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162949.png" alt=""></p><p>下面的consumer 可以知道绑定的消费者</p><p>下面的binding 就是通过routingkey 绑定的信息</p><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列的应用场景：比如订单三十分钟内付款有效。</p><p>实现方式：<a href="https://www.cnblogs.com/-mrl/p/11113989.html" target="_blank" rel="noopener">https://www.cnblogs.com/-mrl/p/11113989.html</a></p><p>rabbitmq 延迟队列的实现方式：通过消息过期，转发到死信交换机中。消息过期有两种方式，一种是消息自己的存活时间到达还没有消费，一种是队列的时间到达但其中的消息没有被消费，这两种情况消息都会被投递到死信队列中。</p><p>区别：第一种我们可以单独对每个消息设置存活时间，不需要为了每个不同的时间建立不同的队列，比如a消息三十分钟过期，b消息40分钟过期，我们都投递到一个没有消费者的队列中，消息到期了自动转发到死信队列中。</p><p>补充：</p><p><a href="https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/" target="_blank" rel="noopener">https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/</a></p><p>上面的做法好像缺点更大，容易造成队列堵塞，所以还是弄成不同时间级别的队列吧。</p><p>​</p><p>识货从来没有nack 这种操作，只有ack。</p><p>nack 不等同于超时，超时是还没有应答，属于 unack，nack 是应答错误 ，是程序执行完了。（nack 如果需要重回队列，需要设置 repeat  true，消息回到队列头部重新开始消费，我们需要注意消费消息的幂等性， 还要小心造成死循环。如果没有设置repeat true ，消息会被丢弃）</p><p>unack 的消息在这个消费者挂掉重启的时候会重新被消费 （或者可以被自己的兄弟消费者消费掉）</p><p>好久没用rabbitmq ，认知又有点生疏，以识货代码为例</p><p>produce</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$routingKey = $queName = &apos;apps_kb_other&apos;;</span><br><span class="line">$connection = sfContext::getInstance()-&gt;getDatabaseConnection(&apos;rabbitmqHeartbeat&apos;);</span><br><span class="line">            $arguments = array(</span><br><span class="line">                &quot;x-dead-letter-exchange&quot; =&gt; array(&quot;S&quot;, &quot;amq.topic&quot;),</span><br><span class="line">                &quot;x-message-ttl&quot; =&gt; array(&quot;I&quot;, 2000),</span><br><span class="line">                &quot;x-dead-letter-routing-key&quot; =&gt; array(&quot;S&quot;, $routingKey)</span><br><span class="line">            );</span><br><span class="line">            $channel = $connection-&gt;channel();</span><br><span class="line"></span><br><span class="line">            //var_dump(get_class($channel));exit;</span><br><span class="line">            $channel-&gt;queue_declare($queName, false, true, false, false, false, $arguments);</span><br><span class="line">      </span><br><span class="line">     // 声明了一个队列，但在识货这个队列是没啥用的，一般就是等待这个队列的message ttl 到期，然后给到交换机 amq.topic, 利用routing key 绑定一个新的队列，消费者消费这个队列。</span><br></pre></td></tr></table></figure><p>consumer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$routingKey = &apos;apps_kb_other&apos;;</span><br><span class="line">           $quename = &apos;apps_kb_other_queue&apos;;</span><br><span class="line"></span><br><span class="line">       //    $this-&gt;callback(&apos;&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           // mq consume</span><br><span class="line">           $channel = $connection-&gt;channel();</span><br><span class="line">           $channel-&gt;queue_declare($quename, false, true, false, false, false);</span><br><span class="line">// 这个地方声明的是一个新的queue，跟着routingkey 绑定</span><br><span class="line"></span><br><span class="line">           $channel-&gt;basic_qos(null, 10, null);</span><br><span class="line">         // 一次性不要取出来过多，导致unack 过多  </span><br><span class="line">           $channel-&gt;queue_bind($quename, &quot;amq.topic&quot;, $routingKey);</span><br><span class="line">// 这个新的队列和routingkey 绑定，一定不要和之前那个ttl message 的队列名称一样，虽然不会报错</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">           $channel-&gt;basic_consume($quename, &apos;&apos;, false, false, false, false, [$this, &apos;callback&apos;]);</span><br><span class="line">          // 这个地方quename 也不要写成routingkey 虽然也不会报错吧</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 &lt;a href=&quot;http://docs.php.net/manual/da/book.amqp.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.php.net/manual/da/book.amqp.php&lt;/a&gt;，一种是市面上比较流行的库&lt;a href=&quot;https://github.com/php-amqplib/php-amqplib&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/php-amqplib/php-amqplib&lt;/a&gt;， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>golang-类型转换</title>
    <link href="http://yoursite.com/2020/05/07/golang-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/07/golang-类型转换/</id>
    <published>2020-05-07T13:08:47.000Z</published>
    <updated>2020-05-07T13:15:16.446Z</updated>
    
    <content type="html"><![CDATA[<p>类型转换经常用来</p><a id="more"></a><p>golang是强类型语言, 就算int64 和 int 都要相互转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.Atoi   字符串转int</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型转换经常用来&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://yoursite.com/categories/golang/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>外接广告</title>
    <link href="http://yoursite.com/2020/04/21/%E5%A4%96%E6%8E%A5%E5%B9%BF%E5%91%8A/"/>
    <id>http://yoursite.com/2020/04/21/外接广告/</id>
    <published>2020-04-21T03:36:04.000Z</published>
    <updated>2020-04-21T07:58:39.475Z</updated>
    
    <content type="html"><![CDATA[<p>最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。</p><a id="more"></a><p>首先介绍一下前置知识吧，对于ios 和 android 手机的标识。ios手机现在一般用idfa， 但是用户可以关闭广告追踪，那我们获取到的就是一堆 0000-000··这样乱七八糟的东西，毫无价值，为了实验效果，我们一定要开启ios手机的广告追踪。（怎么快速获取当前手机的idfa，可以在appstore中下载一个myidfa,可以快速获取到，注意字母都是大写）。所以要是苹果手机用户关闭了广告跟踪，那么我们就完全追踪不到点击广告的用户信息了，广告的转化率我们必然</p><p>android 手机五花八门，之前一般都是用的imei ，然后有的手机可能还有多个，目前没有考虑很多的情况，都是取的默认的第一个。但现在imei好像逐渐开始也获取不到了，国内的手机一般用的都建议用oaid，据说覆盖量已经 80%以上（但是oaid是国内手机联盟定的东西，像海外的安卓机器是没有的，而且现在识货android客户端也是不支持回传oaid的）</p><p>主要流程：当我们app（识货）在头条（或者朋友圈）上面投放广告的时候，当用户点击我们投放的广告，会给我们的web server发送一条请求，这个请求包括用户的基本信息，比如ios 的idfa 或者android 的imei,还有个call_back,类似标识这个用户信息是头条回传给我们的，我们拿到这个信息存储下来，当用户启动我们app的时候，我们可以把这个用户的信息（imei 或者 idfa）和 头条回传给我们的信息作比对，如果对应上，然后时间间隔在我们希望之内（比如两天），就可以当做这个用户是头条带来的。</p><h1 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h1><p>头条应该是接入的几个广告主中最简单的。头条是没有账号区分的（接口中让我们传入sign，但其实可以不用传），所以当我门投放部使用多账户进行广告投放，在我们代码中是没有影响的，我门只需要调用头条的上传用户行为的接口，传入设备信息和call_back 就好了。</p><p>坑点：</p><p>1.首先我们要区分开发者和广告主两个角色，开发者角色在这次广告对接中基本没啥用处，就是用来看开发者文档的。广告主角色很重要，因为我们配置好监控链接，联调上传行为的时候需要用广告主角色登陆后台管理界面，进行联调（填写头条用户id，然后刷新头条信息流，出现联调广告，点击，观察头条发起调用我们的url，我们可以直接拿这条url测试我们的监控接口是否正常，然后取出callback 和 idfa或者imei，作为参数调用头条的上传用户行为,这就是整个步骤啦，注意imei属于隐私数据，所以会用md5加密）</p><p>2.在我们联调的时候需要填写很多信息，比如下载链接，ios就是App Store我们应用的连接，android 需要我们上传apk到头条或者自己上传一个到七牛云，说白了，用户点击广告需要下载，我们给他们提供一个下载地址（好像不能用应用宝地址，因为腾讯？）</p><p>3.主要就是上面两个，剩下的就是代码设计方面，首先是对于表的设计，因为头条那边我们回传用户行为不需要去重，所以我们之前的代码中自己检测到属于头条带来的新用户直接就上报了，自己没做任何处理，比如记录日志，比如存表。这样带来一个坏处就是万一逻辑哪里出错了，不好排查，比如我们和bi那边做数据差异对比，完全拿不出证据证明这个用户在我们逻辑中属于新用户，为什么bi那边不算新用户，所以可以把用户的上报行为时间也存下来。</p><h1 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h1><p>快手和头条内容基本一致，就是快手不支持去重，只能我们这边自己去重，所以我们终究要保存下我们上传的用户信息，再次触发上报条件的时候，需要检测之前是否上报过。</p><p>（为什么我们会触发多次激活的上报条件？按理说不正常，但历史原因是识货这边在获取用户启动信息的list里面可能第一次没有获取到imei 或者idfa，这样用户虽然激活了，但是没法匹配到头条那边的点击广告信息，只能在第二次用户启动app的时候去激活）</p><p>快手比价坑的就是他的callback往往很长，··长的你不能想象，所以我们要注意数据库是否会自动截断。</p><h1 id="广点通"><a href="#广点通" class="headerlink" title="广点通"></a>广点通</h1><p>广点通相比较上面二者更加复杂，首先就是多账户系统和开发者。</p><p>1.开发者需要把多账户（多个广告主）接通流程，首先开发者需要自己建立一个应用（这个应用不用区分ios 和 android ，目的就是获取一个appkey 和 appsecret, 这个信息在我们上传用户行为的时候需要，头条那边之前以为也需要，但是他那个sign 可以不传，所以这个应用可以不建立）</p><p>2.建立好应用之后就需要我们通过腾讯系老一套的oauth2.0 ，把广告主账户挂载在这个应用下面，因为应用需要获取我们的广告主信息，所以需要通过模拟第三方登陆，让我们应用获取到广告主的信息（比如accesstoken）,这个accesstoken 很重要，上传用户行为就靠他了。ps:这个accesstoken 有时间限制的，为了让他一直有效，我们需要通过refreshtoken 一直刷新accesstoken 的时间（感觉上就是类似redis 的set， 不断的刷新有效期，可以写个定时任务）</p><p>3.获取到accesstoken ，我们再建立用户行为，（但是激活和次留可以用一个行为id），然后把accesstoken ，行为id，事件回传就可以了</p><p>综上，其实各家广告厂商套路其实都差不多，我们提供给他们的广告连接都是可以加上我们自己的参数的，类似微信登陆我们在回调的时候对于scene字段传入我们自定义的值。我们可以利用这个值作为不同的投放计划名称，方便我们不同计划的统计，虽然头条他们本身也能传给我们计划名称。</p><p>各家公司对于ios 和 android 需要建立不同的计划，但是我们的检测链接可不需要，因为我们可以从他们回传的内容中获取到os,判断是android 还是 ios，而且毕竟是mysql，关系型数据库，我们只需要把它们返回的内容都保存就好了，有个例外就是快手不行，因为他们的回传内容中获取不到os，我们无法判断是android还是ios，（android 和 ios 匹配头条用户信息的逻辑不一样，所以要区分）难道通过idfa或者imei去判断，显然不保险，不如填写两条不同的检测链接，标识哪个是ios ，哪个是android。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="广告" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-validate验证器</title>
    <link href="http://yoursite.com/2019/12/16/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-validate%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/16/tp源码分析-validate验证器/</id>
    <published>2019-12-15T16:12:26.000Z</published>
    <updated>2019-12-15T17:06:37.418Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。</p><p>曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。</p><a id="more"></a><p>首先说下php 的验证库可以做哪些事吧，还是蛮丰富的。</p><ol><li>首先是验证器，在我看来验证器就是单独抽象了一个层出来，我们在controller里面只需要调用，让controller更加简洁，而且也能复用，验证器类都继承于think\validate。</li><li>其次controller 里面的validate 方法可以直接调用，本质上和前面一样都是调用tp的验证器库。</li><li>最后我们如果想单独使用验证器，就当做普通方法那样也是可以的，毕竟有时候我们除了对于传入参数的验证，业务代码中也有一些内容需要验证的。</li></ol><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>属性：</p><p>static type : 这个主要是我们第三种方法独立验证器用到的。rule 规则都存在这里面，当我们使用独立验证器的时候，想扩展验证规则，extend 方法修改的就是这个属性，因为是static， 所以在本次请求的下次使用中，也能调用上次extend 的验证规则</p><p>alias： 就是我们rule 中可以用  &gt;: 5, 当做 gt: 5 来使用</p><p>rule: 验证规则，我们在写验证器的时候，重写的就是这个属性</p><p>message: 提示信息的重写。包含5个占位符，:attribute, :rule, :1, :2, :3</p><p>field: 字段的描述，主要作用用在message中message 中的占位符 :attribute 会被这个内容替代</p><p>typeMsg: 提示信息呗，这块是英文的，最终会通过 lang\zh-cn.php 转换成中文</p><p>currentScene: 当前验证的场景，这个感觉就是为了验证器准备的（场景），其实也蛮实用的，方便验证器中规则的自由组合。</p><p>filter: 主要是利用php filter_var函数的验证</p><p>regex: 主要是用到正则的验证, ctype 也是php 很好用的一个扩展，方便一些特殊字符的验证</p><p>scene: 场景</p><p>error: 错误信息，只有控制器中错误才能抛出异常</p><p>batch: 当前参数验证错误，还能轮到下一个参数</p><p>only: 场景中哪些参数被验证</p><p>remove: 场景中移除</p><p>append: 场景中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">看源码写的一点总结</span><br><span class="line">// remove 不可能移除所有，除非append 中是空</span><br><span class="line">// remove 连续移除是通过 |</span><br><span class="line">// remove append 的最佳实践是二者不要存在顺序关系，因为程序不会鉴别</span><br></pre></td></tr></table></figure><p>方法：</p><p>__construct:  </p><p>rule 验证规则， message 提醒， field 字段描述 :attribute 占位符实际内容</p><p>make:</p><p>new self 生成一个验证器</p><p>rule:</p><p>独立验证修改rule 和 field 属性，供后面check 使用。方便直接传入 rule 和 message </p><p>extend:</p><p>独立验证器中的方法扩展</p><p>setTypeMsg:</p><p>独立验证器中使用</p><p>message:</p><p>提示信息</p><p>scene:</p><p>修改当前验证场景</p><p>hasScene:</p><p>scene 优先考虑 sceneEdit 方法，再考虑 scene -&gt; [‘edit’ =&gt; []] 属性</p><p>batch:</p><p>批量验证</p><p>only:</p><p>场景的使用验证哪些字段</p><p>remove:</p><p>场景移除验证规则</p><p>append:</p><p>场景添加沿正规则: 上线 remove 和 append的调用的时候没有先后顺序 ！！！</p><p>check:</p><p>验证器核心，这时候传入的内容会覆盖掉初始化的内容。</p><p>getScene:</p><p>根据传入的scene 和 current scene 修改 only  remove add 内容</p><p>getDataValue: </p><p>根据传入的data 数组和 可以， 获取对应的内容</p><p>checkItem:</p><p>实际的验证，通过 call_user_func 去调用对应的验证内容</p><p>checkRule:</p><p>官网上这么说，</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191216005751.png" alt=""></p><p>感觉意义不大，毕竟静态方法make 创造的更好用点</p><p>getRuleMsg: </p><p>获取错误信息，可以好好看看，挺好的，调用了lang 类。因为自定义的closure ，如果 不是 === true， 就当做error， 结果就当做errorMsg，和调用类方法还是有点区别的。</p><p>getValidateType:</p><p>像一些 is，比如 isEmail, isIp 都走的is 方法</p><p>后面就是一些验证方法了，以后写代码都可以借鉴下</p><h3 id="ValidateRule"><a href="#ValidateRule" class="headerlink" title="ValidateRule"></a>ValidateRule</h3><p>这个类的主要用途就是通过rule 类的形式去调用对应的验证规则</p><p>属性：</p><p>title  :attribute</p><p>rule 规则</p><p>message 提示信息</p><p>方法：</p><p>addItem ：</p><p>为 is 方法统一添加rule，message 属性</p><p>getRule  getTile  getMesage 获取对应属性</p><p>title 设定title</p><p>——call  </p><p>——callStatic </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。&lt;/p&gt;
&lt;p&gt;曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPhP" scheme="http://yoursite.com/tags/ThinkPhP/"/>
    
      <category term="validate" scheme="http://yoursite.com/tags/validate/"/>
    
  </entry>
  
  <entry>
    <title>持久化</title>
    <link href="http://yoursite.com/2019/12/03/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/12/03/持久化/</id>
    <published>2019-12-03T11:59:55.000Z</published>
    <updated>2020-05-28T13:59:32.128Z</updated>
    
    <content type="html"><![CDATA[<p>我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。</p><a id="more"></a><p>举个例子吧，之前接手的一个任务毒和nike关联出价，当前台下发撤单任务的时候，因为牵扯到很多curl 请求，不能同步实现，1.感觉可以通过把请求内容放到mq当中，然后利用daemon 化的task始终监听这个mq，如果有内容，则触发任务，往后执行，否则停歇1min 继续监听。2.那个前作者是通过把内容放到redis中，通过daemon化的task监听这个redis，如果检测到这个redis这个key，就执行相应任务。</p><p>总结一下吧，其实上面两个方式php的daemon话都是通过while true，那么supervisor 的作用是啥呢，当php的这个脚本挂掉了，supervisor可以重新拉起这个脚本。同理pm2也可以，而且不一定是脚本挂掉，脚本执行完了，也可以重新拉起，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo date(&apos;Y-m-d H:i:s&apos;)</span><br><span class="line">echo &apos;end&apos;;</span><br><span class="line">// 利用上面两个进程管理工具之后，可以一直输出</span><br></pre></td></tr></table></figure><p>上面的例子还有个很重要的技术点就是定时触发。相比较crontab 的task，上面的task 触发任务时间不一致，触发时间靠前台控制，所以我们这时候就通过始终运行一个后台任务，然后靠前台触发一个开关，后端始终运行的task始终监测这个开关，如果是开就运行，虽然可能存在一定时间的误差，但大体上还是能完成任务的。</p><p>再比如之前接手的一个安卓灰度更新的任务，当某个渠道开启灰度之后，我们需要每隔30min发送一条钉钉消息，我们同样可以检测表中渠道是否有开启灰度的状态，如果有，则发一条消息，并记录通知时间，下次的循环任务检测是否灰度还在开启，如果还在开启，检测时间通知是否超过30min，如果超过了，再发送消息，并更新通知时间。</p><p>上面的任务看似已经解决，但还是会涉及一个多进程问题，再举个例子，比如erp系统，需要爬取商户的店铺信息，这个task 要一直执行，如果我们有100个商户，就得运行100个task，启动100个脚本。我们上面灰度通知的好解决，一种办法就是检测运行的渠道，循环运行的渠道列表，然后发送消息通知，另一种就是一次性检测，把渠道更新信息包含在一条短消息中发出去，之所以这么做是因为后续的任务（发送钉钉通知）可以在很短时间内完成，如果像erp的那种爬虫任务，只能通过启动多个脚本了。</p><p>关于php的多进程扩展pnctl 这里暂时不做讨论，说一下pm2 和 supervisor 的简单使用。</p><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p><a href="https://juejin.im/post/5b823506e51d4538d517662f" target="_blank" rel="noopener">这篇文章关于pm2讲解的很好</a></p><p>我比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br><span class="line">pm2 app.js --name wx_spider --watch   // name 名称，方便理解， watch 文件变动，方便重启，类似nodemon</span><br><span class="line">pm2 delete all</span><br><span class="line">pm2 delete (:id)</span><br><span class="line">pm2 restart app</span><br><span class="line">pm2 logs (:name)</span><br></pre></td></tr></table></figure><p>pm2 配置简单，非常好用，echo 的内容之间在log中能看到，除了node， php也是能管理的</p><p>（PM2 的安装需要通过node 和 npm， node 的安装很简单，但我们一定要注意npm 安装的module 位置，如果是linux 下，一定要配置好node_path ,否则 npm -g 安装的内容可能不能使用， npm config  get prefix  可以查看node -g 包安装的位置 。同理node的安装位置最好也是/usr/local/ 下面，方便直接访问）</p><p>今天在使用pm2 管理我的一个task的时候遇到一个问题，就是普通的脚本pm2 start app.js 或者 pm2 start test.php, 但是我现在的命令是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php symfony trade:UpdateCommentDgTags updateUserPublishment  --split=4</span><br></pre></td></tr></table></figure><p>之前的那个命令是肯定不可以的，需要使用配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; //统计报表更新</span><br><span class="line">  &quot;name&quot;: &quot;up4&quot;, // 随便取</span><br><span class="line">  &quot;args&quot;: &quot;trade:UpdateCommentDgTags updateUserPublishment  --split=4&quot;, // 这些都属于参数</span><br><span class="line">  &quot;script&quot;: &quot;symfony&quot;, // 这个地方一定要注意，symfony 其实是脚本，只是没有 .php 的后缀</span><br><span class="line">  &quot;exec_interpreter&quot;: &quot;php&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;Cluster&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;fork&quot;,</span><br><span class="line">  &quot;max_memory_restart&quot;: &quot;100M&quot;,</span><br><span class="line">  &quot;cwd&quot;： &quot;../&quot;  // 上一级目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要注意，这个地方symonfy 是脚本，怪不得之前我在执行task 命令的时候忘记输入symfony ,他说找不到脚本。 后面的那一长串都会统一看成参数，只是参数解析的形式不一样，比如 trade:UpdateCommentDgTags, 解析成方法名称，–split = 4 解析成参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps:   php test.php --goods_id=12 uo22</span><br><span class="line"></span><br><span class="line">test.php</span><br><span class="line">&lt;?php</span><br><span class="line">var_dump($argv)</span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; test.php</span><br><span class="line">    [1] =&gt; uo22</span><br><span class="line">    [2] =&gt; --goods_id=12</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>pm2 log日志的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error log path    │ /home/username/.pm2/logs/app-error-0.log</span><br><span class="line">out log path      │ /home/username/.pm2/logs/app-out-0.log</span><br></pre></td></tr></table></figure><p>需要注意的是这个error 应该是pm2 自身的error, 一般我们程序抛出的都是在out 日志里面</p><p>！！~notice: pm2 虽然香，但也不能乱用，比如之前我在预发布机器上跑的一个task 脚本，因为跑完了，脚本 die， 不断的被pm2重启，导致cpu 很快被耗尽，所以很多脚本停止的时候 都会有个sleep 操作，过一段时间再重启。当然如果你是那种常驻内存，比如node 做的webserver 肯定不用，因为一般不会崩溃，唯一一种就是你的代码有问题，不断的报错，导致服务不断的被唤醒。</p><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p><a href="https://learnku.com/laravel/t/2126/supervisor-installation-configuration-use" target="_blank" rel="noopener">使用和安装可以大致看看这个文章，但这篇文章的配置文件有问题</a></p><p>配置文件里面一定要有[supervisord]和[supervisorctl] 部分，否则会报错。<a href="https://juejin.im/post/5c66be44f265da2de52d784d" target="_blank" rel="noopener">这篇文章应该还可以</a> 需要注意的就是监听端口从 127.0.0.1:9001 改成 0.0.0.0:9001 ,方便外网访问，贴个图</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191203210626.png" alt=""></p><p>基本就能用啦 （比如我那几百万的任务task就能通过这两个处理，不用我一直看着了，跑完了看看 log就好了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="daemon" scheme="http://yoursite.com/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>复盘一下代码的提交流程</title>
    <link href="http://yoursite.com/2019/11/28/%E5%A4%8D%E7%9B%98%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/28/复盘一下代码的提交流程/</id>
    <published>2019-11-28T06:20:02.000Z</published>
    <updated>2019-11-28T10:36:20.370Z</updated>
    
    <content type="html"><![CDATA[<p>昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。</p><a id="more"></a><p>首先我们开发一个功能需要从master上面下拉代码</p><ol><li><p>注意是远程的master，本地的master没啥屌用，因为一般为了提交方便和方便记忆，本地分支和远程分支保持同名，如果你用master 的话，总不能推送到远程master上吧，似乎没人有这个权限。</p></li><li><p>提交代码前是否要合并master ？ 血的例子，别吧。如果你往master上面提交代码没冲突，那就别合并了，对吧，为啥要合并呢 ？只要你的代码正常上线，dont care anything ，因为要是你真的在这个时候合并了远程master，然后远程master 0.01%的可能是个脏master，这时候你的开发分支也就脏了，意味着你合并master 之后改的东西，在领导发现master 脏了之后，都是要被回滚的，回滚的终结点不一定，凭他们的感觉吧，其实感觉就是那个人把release 合并到master 上的点。那问题来了，如果，万一你真的合并了脏master，咋办，其实也好办，你git reset 到合并master之前的那个commit，重新提交给master，看是否能合并，不能合并，再去解决冲突（后面会介绍冲突解决办法），所以感觉在merge 别的分支的时候一定要做好commit message （最好不要改merge 的info，比如当时我修改改成conflict resolve 我都不知道我要回退到哪个版本，其实只要回退到merge 之前的版本就好了）， 有时候真的会帮大忙，方便你的开发分支剔除掉别的合并的内容</p></li><li><p>开发feature中是否要合并master ？ 还是血的例子，别吧。万一你开发分支合并了错误的master，万一你不知道，接着在错误分支上开发，当开发很多的时候，当master 需要回滚的时候会很艰难，毕竟开发了那么多。这时候只能继续相信master， 不断的合并master，其实没啥屌用，你的开发分支已经领先master了，如果你没回滚，你合并的时候只会在人家前面，你会多提交很多内容，这些内容在你给领导要求pr merge 的时候被看到肯定会打回来，~~~不知道咋解决</p></li><li><p>我的流程总结。开发的时候下拉master成为一个开发分支，比如chenye/feature/gray_test, 开发完了，提交dev。万一和dev冲突，下来dev到本地，merge gray_test,看冲突是啥，万一是自己的文件，直接解决。解决完了，推送到远程，给dev提交pr，合并之后，自己的gray_test 就能合并到dev了。注意，在解决冲突的时候一定不要修改自己的开发分支，也就是gray_test, 万一在release 或者 master合并的时候修改了自己的开发分支，一定要dev， release ，master 按顺序重新提交一遍！！！！！否则，别人拉代码的时候一定会冲突。</p></li><li><p>当发现别人的代码冲突的时候咋办，最好的办法就是告诉别人，因为你不知道以哪个为标准。</p><p>你觉得是以master为标准，毕竟线上跑着呢，万一人家当初并不想把代码提交到master上，被另一个同学误操作了，也就是你clone的master是错误代码，这时候以master会覆盖调用dev的正确代码。</p><p>你说以dev标准，毕竟dev是最新的代码 ？还是不对，可能别人着急，直接提交了master，也就是说master代码比dev新，这样dev就会覆盖掉master上的新代码。</p><p>所以遇到这种情况，直接告知吧，任何一种自己修改别人冲突的方法都是不负责任的行为。</p></li></ol><p>顺带提一下最近遇到的win 和 linux 下空格遇到的问题，我们都知道代码是跑在linux下的，所以我们的换行一定要</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160209.png" alt=""></p><p>用这个LF, win下是</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160245.png" alt=""></p><p>我们既然改变不了win，可以通过phpstorm自带的功能，去编辑文件，模拟在linux下的编辑。</p><p>（ps:我是怎么发现这个问题的，在用php的heredoc 换行的时候就能发现）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="虎扑" scheme="http://yoursite.com/tags/%E8%99%8E%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-数据库操作</title>
    <link href="http://yoursite.com/2019/11/17/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/11/17/tp源码分析-数据库操作/</id>
    <published>2019-11-17T07:45:09.000Z</published>
    <updated>2019-11-17T07:53:51.947Z</updated>
    
    <content type="html"><![CDATA[<p>tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo</p><p>的api 去操作数据就好了。</p><a id="more"></a><p>我们先来看看常用的pdo api</p><p>首先是关于pdo的安装部分，我们要安装统一的pdo扩展，然后在这个扩展的基础上安装 pdo mysql ,或者 pdo postgresql，类似针对不同的数据库的驱动的感觉。</p><p>预定义常量：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo&lt;/p&gt;
&lt;p&gt;的api 去操作数据就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go 基础变量</title>
    <link href="http://yoursite.com/2019/11/17/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/go-学习笔记/</id>
    <published>2019-11-17T07:44:14.000Z</published>
    <updated>2020-07-02T08:12:30.665Z</updated>
    
    <content type="html"><![CDATA[<p>php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能</p><a id="more"></a><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>slice 切片的申明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">slice  底层是指向数组的指针,所以如果我们用 var 去声明的话，默认得到的是一个nil</span><br><span class="line">相比较map 的nil， slice 的 nil 我们是可以append，map的nil 之后我们是没法属性或者给属性赋值的。</span><br><span class="line"></span><br><span class="line">一般 arr := make(a, 0, 10)</span><br><span class="line">arr := []int&#123;1,2&#125;  // 这种方式也用的多，容易被忽略</span><br><span class="line"></span><br><span class="line">ps: 在go中经常有 type cy int, 这种别名</span><br><span class="line">[]cy&#123;&#125;, 这样给切片值其实很正常，类似 []int&#123;&#125;</span><br></pre></td></tr></table></figure><p>map 的申明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map</span><br><span class="line">map[string]string&#123;&quot;namme&quot;: &quot;ccc&quot;&#125;</span><br></pre></td></tr></table></figure><p>变量申明多种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var num int  // 没给初始值，默认 0</span><br><span class="line">num := 1  // 这样更简洁更方便， 函数外不给使用</span><br><span class="line"></span><br><span class="line">int, float64, bool 这都是和别的语言一样的，array , slice, map</span><br><span class="line"></span><br><span class="line">arr1 := [...]int&#123;1,2&#125;  // 因为不能扩展，用的比较少</span><br><span class="line">slice1 := []int&#123;1,2&#125;  // 关联数组</span><br><span class="line">map1 := map1[string]string&#123;&#125; // 索引数组</span><br><span class="line"></span><br><span class="line">// 换一种看法看go， 下面两种都代表数组，只是填充的对象是byte 或者是rune</span><br><span class="line">[]byte&#123;&#125;</span><br><span class="line">[]rune&#123;&#125;</span><br><span class="line">(不管是byte 还是 rune，对应的字符序列都是 十进制，要想转换成 十六进制需要通过 hex.encodetostring ,或者 printf , 第一个只能对 slice 处理，第二个可以对数组)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结构体，类似</span><br><span class="line">type cy struct &#123;</span><br><span class="line">name string `json:Name` // json 的时候生成key 的名称</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cy1 := new(cy)</span><br><span class="line">cy1.name = &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(cy1.name)</span><br><span class="line">//cy 类似类名，所以我们还需要变量名</span><br><span class="line"></span><br><span class="line">// 别名</span><br><span class="line">type</span><br><span class="line"></span><br><span class="line">// map value 定义成某个字段太局限了，可以 map[string]interface&#123;&#125; 这样，更灵活</span><br><span class="line">// :=  map[string]interface&#123;&#125;&#123;&#125; ,一定要给初始值</span><br><span class="line"></span><br><span class="line">// go 中 printf %v  struct 这种不够，因为 名称打印不出来，需要 %+v 打印</span><br></pre></td></tr></table></figure><p>一次性给多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1, arr2 := []int&#123;1,2&#125;, []int&#123;2,3&#125;</span><br></pre></td></tr></table></figure><p>因为go 中的异常机制和php还是有点区别的，很多函数在使用之后会有error 的返回，我们根据 error != nil ,就能知道是否错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if _,error := test(x , y ); error != nil &#123;</span><br><span class="line">  错误处理</span><br><span class="line">&#125; </span><br><span class="line">:=  ,只有多个变量中有一个是新的，:= 不会报错</span><br><span class="line"></span><br><span class="line">真实因为go 的这种语言机制，导致 if 才能这样用，最多有两个表达式，第二个 值的内容是布尔 （上面 _ 属于匿名）</span><br><span class="line"></span><br><span class="line">还有go 中和 js let 一样，都有块状作用域，比如那个 if 里面赋值的变量，只能在 &#123;&#125; 中使用</span><br></pre></td></tr></table></figure><p>var 和 const 一次性声明多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">test1 int</span><br><span class="line">test2 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 枚举，内部可以用iota</span><br><span class="line">const (</span><br><span class="line">test2 iota</span><br><span class="line">test3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>go 中 if 和 for 都是不用括号包裹的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>node 学习笔记</title>
    <link href="http://yoursite.com/2019/11/17/node-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/node-学习笔记/</id>
    <published>2019-11-17T07:44:05.000Z</published>
    <updated>2019-11-17T07:44:05.685Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>虎扑这几天的git流程总结</title>
    <link href="http://yoursite.com/2019/11/12/%E8%99%8E%E6%89%91%E8%BF%99%E5%87%A0%E5%A4%A9%E7%9A%84git%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/12/虎扑这几天的git流程总结/</id>
    <published>2019-11-12T08:04:56.000Z</published>
    <updated>2020-05-02T06:34:58.446Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下虎扑的代码开发流程（包括提交，发布流程不太明白，对金啃死了解太少）。公司给每个人分了台虚拟机(类似云主机)，</p><p>我原先的想法是通过在虚拟机上clone 代码，然后通过phpstorm 的远程连接主机的功能，实现在本地开发，然后映射到虚拟机上代码改变。可是这样有一个问题就是虚拟机linux上clone的代码的换行和我本地win上的换行不一样，虽然开发的时候没有影响，但是要是在win上提交代码就会出现很多没有修改的代码也会有modifyed（其实git 本身做了兼容，在clone的时候，但主要是我现在把linux代码拉取到本地，所以才会这样）。而且我也不可能在linux上提交，毕竟提交的时候需要通过一些工具观察文件的改变，所以改成了第二种方式</p><p>通过在本地和远程都clone 代码，然后通过sftp实现两个文件夹的关联，本地代码的修改也能直接映射到虚拟机，而且可以在windows上提交代码，因为是在win上clone迁出远程仓库的代码，所以提交的时候不会出现换行(crlf)的问题。</p><a id="more"></a><p>首先是开发分支的命名。 </p><p>姓名/feature(bugfix) 特征/ 自定义名称 （这样切割之后，在一些git 工具上可以发现是以文件夹方式显示的）</p><p>开发完了，推送到远程</p><p> git push origin chenye/feature/dgtag(本地分支):chenye/feature/dgtag(远程分支)</p><p>然后给develop 提交一个pr，再合并（最好不要直接给develop提交，就算提交也是通过git fetch origin develop(远程分支):deve1 去提交, 千万不要把自己的分支推到远程的develop分支上了，防止覆盖）</p><p>当我们提交的时候出现conflect 的时候，我们可以 git fetch origin develop:dev1, 然后在dev 上merge 我们的分支 chenye/feature/dgtag, 合并完了，再推送到远程新建分支，再把这个分支和dev分支合并。</p><p>当我们merge本地分支的时候肯定会出冲突，这个冲突的来源有两种可能，一种自己的，这个很好办，把head 到 ==== 中间删除，替换成自己最新的。</p><p>还有种可能是别人的，要是别人的呢，也好办，最暴力的方法就是用dev替换自己分支上最新的，这样自己的分支和dev合并就没有冲突了，但这个只适用于dev哈，如果是release 和 master ，一定要问一下出现conflect文件的那个人！！！</p><p>远程仓库更新完了，我们需要更新服务器上的代码，这和itbasic 一样，直接去28机器上git clone 就好了</p><p>唯一有区别的就是release， 我们这边release 的发布类似以前，每次发布之后都会在服务器上产生一个新的文件夹，通过改变软链接指向的文件夹，保证每次发布成新的代码（而不是通过代码覆盖，感觉这样是不是发布更快速，如果是clone的话，有时候需要很久才能全部完成）</p><p>进入release 环境，我们第一个选2， 第二个选项是不同的php， 7.1 和 7.2，7.2的count() 真的很坑呀，要注意，其中3环境我们每次执行完脚本要及时删除 文件夹下的cache， 否则脚本执行不了 （很奇怪~~）。</p><p>有时候我们在release 环境修改文件会发现没生效，这可能是因为有人发布代码了，所以你后面再次进入修改的文件，可能对应的文件夹已经不是之前你修改的那个了。</p><p>这几天git常用的几个命令</p><p>git pull origin master:master1 </p><p>注意这个和 git pull origin master 不一样，后者会下拉master 并和 当前分支合并，前者即使当前在master1 分支上，也是用master 强制覆盖master1 ，类似push 。</p><p>git fetch origin master:master1 </p><p>下拉远程master 在本地新建master 1</p><p>git reset   commitId  回退本地 commit 的内容到工作区（并不是删除）</p><p>(如果没有 –hard， 内容会再次回到工作区，需要 git checkout . 抛弃， 默认是 git reset –soft)</p><p>git checkout  .  删除工作区的内容</p><p>git clean  删除添加的文件，或者直接 rm  删除文件</p><p>git branch –delete  分支名 删除本地分支</p><p>git  push origin  –delete 分支名 删除远程分支</p><p>git merge  ing 的时候如果想放弃，也可以通过删除merge的文件，这样是不是能少记一个命令呢，哈哈哈</p><p>我们在解决冲突的时候，千万不要把develop，或者release 上面的代码合并到自己的开发分支上， 因为自己的开发分支最终是要合并到master上的，所以我们对这两个分支解决冲突只能通过新拉分支来解决，解决完也不要推送到自己的开发分支上，可以推送到远程的临时分支上，与dev和release合并</p><ul><li>今天在给一个新项目做远程sftp配置的时候（本地clone，远程也是clone）,始终配置不上server， </li></ul><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191112232234.png" alt=""></p><p>options 这块总是显示mapping 不对，打开 configuration</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191112232326.png" alt=""></p><p>注意那个地方一定要有个 / !!!!</p><ul><li>今天用sftp 发现，为了删除文件，只能在phpstorm上面删除，如果自己打开文件夹删除，是更新不到服务器上的</li></ul><ul><li>今天用git 的时候，想给部署多个仓库</li></ul><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191205161629.png" alt=""></p><p>小垃圾们看一下，~是不是对origin 有更深刻的理解了 ，地址<a href="https://segmentfault.com/q/1010000008366409" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008366409</a></p><ul><li>今天在推送本地分支到远程的时候推送错了，导致远程分支提前自己的开发分支，所以只能强推，当然只有自己的分支能这么坐哈，~公共分支千万别，因为感觉强推就是覆盖</li></ul><p>git push origin dev -f</p><ul><li>今天在提交代码的时候，发现想删除某个提交，其实这个情况蛮常见的，比如之前某个大佬把release合并到master上，我们只需要</li></ul><p>git rebase -i  还是蛮重要的，目前我就用在删除当前分支的某次提交。变基的时候如果没有修改同一个文件的话，没有冲突的话，改起来话挺快的，可以快速删除某个不想要的提交，比如：<a href="https://www.36nu.com/post/275" target="_blank" rel="noopener">https://www.36nu.com/post/275</a>，</p><p>但是如果改了同一个文件的话，可能存在某种冲突，所以变基操作会每个commit 慢慢操作，只需要 git rebase –continue 这样就行了</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191206114054.png" alt=""></p><ul><li>git reset 的后遗症蛮严重的，特别是自己开发分支修复不当，所以我们每次提交一定要严格执行合并dev， release，master 流程，一旦开发分支修改过，都要重走一遍。今天有人合并分支出现冲突，强推了merge，导致我的代码被覆盖，但归根结底都是之前提交代码不规范，~一定要引以为戒</li></ul><p>最近虎扑多了个新的git tag的功能，主要是为了发布代码的稳定性，方便回滚。</p><p>git tag  <a href="https://www.zhihu.com/question/28784805" target="_blank" rel="noopener">https://www.zhihu.com/question/28784805</a>  这篇文章讲的蛮好。</p><p>需要注意的就是我们要在自己想要的branch 上打tag （就是对于自己想要的commit 取一个别名）</p><ul><li>重温了git 小册，看打了git rebase ，其实这个功能大家不常用很正常，因为我们现在往往提交代码都是通过pr的方式，合并代码都是在gitlab 上手动执行就好了，很少关注git merge 这些事情，本地也很少merge 代码 （我一般开发一个功能就是fetch 一个 master as other branch，然后去开发）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说一下虎扑的代码开发流程（包括提交，发布流程不太明白，对金啃死了解太少）。公司给每个人分了台虚拟机(类似云主机)，&lt;/p&gt;
&lt;p&gt;我原先的想法是通过在虚拟机上clone 代码，然后通过phpstorm 的远程连接主机的功能，实现在本地开发，然后映射到虚拟机上代码改变。可是这样有一个问题就是虚拟机linux上clone的代码的换行和我本地win上的换行不一样，虽然开发的时候没有影响，但是要是在win上提交代码就会出现很多没有修改的代码也会有modifyed（其实git 本身做了兼容，在clone的时候，但主要是我现在把linux代码拉取到本地，所以才会这样）。而且我也不可能在linux上提交，毕竟提交的时候需要通过一些工具观察文件的改变，所以改成了第二种方式&lt;/p&gt;
&lt;p&gt;通过在本地和远程都clone 代码，然后通过sftp实现两个文件夹的关联，本地代码的修改也能直接映射到虚拟机，而且可以在windows上提交代码，因为是在win上clone迁出远程仓库的代码，所以提交的时候不会出现换行(crlf)的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
