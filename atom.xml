<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-23T15:26:05.422Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP常用工具</title>
    <link href="http://yoursite.com/2018/11/23/PHP%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2018/11/23/PHP常用工具/</id>
    <published>2018-11-23T15:26:05.000Z</published>
    <updated>2018-11-23T15:26:05.422Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThinkPHP的感觉</title>
    <link href="http://yoursite.com/2018/11/12/ThinkPHP%E7%9A%84%E6%84%9F%E8%A7%89/"/>
    <id>http://yoursite.com/2018/11/12/ThinkPHP的感觉/</id>
    <published>2018-11-12T10:12:27.000Z</published>
    <updated>2018-11-23T14:49:20.988Z</updated>
    
    <content type="html"><![CDATA[<p>学习，为了更好地适应未来的工作。简单的解除了下tp和laravel，总体来说tp比laravel简单多了，封装的也没有那么深，所以用起来还是很方便的，用的是5.0，5.1和5.0区别就挺大了，不如有了门脸，又是一个使用类不知道到底用哪个命名空间下类比较好的时候了，还有获取参数的方式，5.1已经没有getInstance()这种东西了，记录一下这几天的感觉,方便交流</p><a id="more"></a><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/5525740-1711c1f695c442d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>首先是模块的创建，主要是为了方便后台模块和 api 模块的分开</p><p>后台模块， 这个项目中主要是通过接口能返回html 模板</p><p>但是 api 模块，单单只用返回json 数据</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>关于api 模块的json 返回，我们只要调用json() 方法就可以了，不需要做进一步的配置，  我们还可以通过json 方法的进一步封装，让调用起来更加方便</p><p>[图片上传失败…(image-14c2c0-1542018168779)]</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-3f4891bc6eed7db0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这种方法其实就是在返回头上加上个别的信息</p><p>这种公共的方法我们可以写在 common.php 文件中</p><p>控制器中获取传过来的参数</p><p>有个坑就是5.0 和 5.1 通过request 获取参数的方式竟然就不一样了，</p><p>5.0 中 其中一种 Request::instance()-&gt;get()</p><p>5.1 Request::get() (5.1中已经开始出现faceade这种看不懂的东西了)</p><p>其实用助手函数就没有上述问题了，···但无奈我不喜欢用，但感觉助手函数的话对不同版本的tp代码都是通用的</p><p>对于put 参数，我们在用postman 提交代码的时候需要通过第二种方式提交，第一种方式是获取不到的，可能是因为表单默认屏蔽了put delete 提交方式</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-2a8c7fec8f0290ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-ae6d9385c9e24a62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这个header 头信息是真的坑，解决这个办法就是先把$header 信息保留成数组，然后再通过数组去寻找这个变量</p><p>讲道理，还是有点不明白_initialize 和 __construct(） 的区别</p><p>关于文件的定义，基本上除了配置文件，剩下的都是class 文件，按照psr4 ,类名要和文件名一样，我之前有过类名和文件名不一样，导致文件加载失败</p><p>异常处理那块，当调用父的 异常处理函数，需要return ,否则会报错，感觉和调用模板也需要return 是一个道理</p><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>关于 tp 的路由，好久之前就知道被吐槽pathinfo 模式，虽然我不知道是因为什么被吐槽，除了pathinfo 还有别的模式吗？</p><p>除了默认的pathinfo, 我们对于api 接口（admin 那种返回html 的可以不用管），可以使用路由注册的形式，就是在route.php 中进行路由注册，他会首先匹配,没找到的会使用pathinfo 模式，这块需要我们在配置文件中进行配置</p><p>（可以完全关闭pathinfo 或者 路由注册的形式）</p><p>（关于路由注册这块，tp 的路由注册和laravel 的还不一样，他不是使用命名空间的形式，用的是感觉自己定义的形式， 但感觉因为这个方面，路tp的路由方面应该不能单独拆出来给别的项目使用），但其实也挺好理解， 注意</p><p>完全路由匹配，还有路由参数的限制</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-916eb13b10cccba8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>参照： <a href="https://www.jianshu.com/p/73ed6e42d389" target="_blank" rel="noopener">https://www.jianshu.com/p/73ed6e42d389</a></p><h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p>今天因为不太知道config() 助手函数都是从哪里获取的数据，查了一下，这篇文章写得还是蛮好的</p><p><a href="https://www.jianshu.com/p/cd8b68143fde" target="_blank" rel="noopener">https://www.jianshu.com/p/cd8b68143fde</a></p><p>比如我们那个api模块的接口需要很多额外的参数，我们只需要在application 最外层定义一个extra 的目录，然后会自动引入里面的文件</p><p>我们配置文件的数据返回大致如下</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-e2abedcb35db3400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过 config() 可以看到全局的配置参数</p><h3 id="DB"><a href="#DB" class="headerlink" title="DB"></a>DB</h3><p>model 最近用的都是orm,不管是后台admin 还是api接口，都可以公用，所以新建了一个common模块，在里面写入了model,通过model() 或者命名空间的方式都能使用（我比较喜欢用命名空间的方式去使用，tp的orm可以分离出来去别的项目中使用，当然model()方法引入model类就不可以了，只能通过命名空间的方式）</p><p>题外话 ：关于为什么用model() 就能引入common 模块下的model，我们可以理解成约定俗成，甚至可以理解成1 + 1  = 2， 之前我纠结这些问题很久，但其实他就像我们使用别的约定俗成的概念是一样的，只是这个可能是由于框架的封装，在我们的印象中很难站住脚 ，或者没有看到官方给的白纸黑字的文档，能做的就是看源码，model 是怎么执行加载的，表哥说过，你可以画上 1年半载去弄懂框架的源码，但如果你弄不懂的话，你也可以通过专注业务区提升自己的能力，有些东西能用就好了。</p><p>基本的方法:</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-7f4cbfcd522b2d30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>通过在数据库配置文件中设置表前缀，默认类名称是  ‘表前缀_类名’ ， laravel 是表名单数</p><p><strong>查询</strong></p><p>select   获取集合  ，这个直接json 返回外面就是array ,在项目里面打印是 是object ,这个项目里面转换成 array 需要 collection($arr)-&gt;toArray()， 这个Db::  用select , 查出来竟让也是 object ,想变成 array,可以通过toArray()</p><p>find   只能获取一条 ,这个直接 就是数组</p><p>column, 查询单列</p><p>value  查询单个值（那种集合的查询调用 value 也是只返回一个值）</p><p>field  获取哪些对应字段,还可以给字段取别名（感觉很强大，还能用函数 sum(score)）</p><p>order   同上</p><p>limit  5 size</p><p>page  1  页码  (感觉这个page 还是和limit 分开来使用比较方便)</p><p><strong>查询方法</strong></p><p>where  =&gt;   [‘id’=&gt; 1, ‘status’=&gt; 1],  多条件等于情况， [‘id’, ‘status’]  代表两个column</p><p>where =&gt; [‘id’ =&gt; [‘&gt;’, 3]]   id 大于3的情况</p><p>whereOr</p><p><strong>插入</strong></p><p>insert</p><p>insertAll  批量插入</p><p>insertGetId  插入成功之后返回id</p><p>getLastInsID  返回最新插入的id</p><p><strong>更新</strong></p><p>update</p><p>setField 更新某个字段</p><p>setInc   自增</p><p>setDec 自减</p><p><strong>删除</strong></p><p>delete </p><p>关于链式操作，注意select() ，table 这些不属于链式操作，所以需要放在最后面，剩下的那些链式操作没有顺序要求</p><p>alias  给表取别名</p><p>groupby  分组</p><p>having  （最好在group by 中使用count这种的聚合函数）</p><p>子查询和 union 基本不用</p><p>distinct 唯一不同的值，不同的值，比如这个返回admin和chunice</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-e8cdd9dd8a20254d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>count  这个好像需要放在 where 条件后面，要不然也会报错</p><p>orm 之所以能调用这些db的方法是因为orm 的基础是db</p><p>自动写入时间戳都是针对orm 这种操作可以的，db 操作是不可以的， 上面的操作都是db 的操作</p><p>注意用Db 进行操作的时候，命名前缀已经失效了，记住要用表的全名</p><p>关于join 表，老师和表哥说都不要join ,因为数据多的时候join会出问题，对于用户和用户名的对应的时候，利用先找出所有数据，再把userid 取出来进行in 的查询，再通过遍历之前需要处理的数据，把username 链接进去，这样是可以的，但是对于zan这种，可能不存在这条数据</p><p>这几种join是当初面试的时候经常问的</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-70d997091c479147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>comment  给sql语句增加注释（··感觉好没用啊）</p><p>fetchSql 返回sql 语句 （ 感觉挺好，可以知道执行了什么，但用with 那种关联关系，只能返回第一条语句···，太废物了）</p><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>其实，感觉：查询出来的是object 对象，还是纯种的array ,就是看调用者，如果是 Db::table 调用，就是 数组</p><p>如果是 User::  这种方式调用，就是 object， object 又有 user  和 collection 之分</p><p><strong>新增</strong></p><p>save   插入 这个不能用静态方法，只能实例化调用</p><p>saveAll 批量</p><p>返回值是受影响的行数，我们想获取到自增id ,可以通过 </p><p>$user = new User()</p><p>$user-&gt;save([])</p><p>echo $user-&gt;id ,这种方式获取到，因为save 不能非静态化的调用， save() 返回值是受影响的行数</p><p>批量新增 saveAll()</p><p>create  静态调用</p><p>User::create() , 返回值是自增id</p><p><strong>修改</strong></p><p>save ,需要传入主键</p><p>saveAll  批量</p><p>update 静态调用 ,这个方法也可以直接调用，Db和模型都有这个方法</p><p>据说通过 -&gt;where-&gt;update() 这种就不能使用tp模型的事件功能（什么是事件功能？就是那种更新表前会有什么操作，类似钩子）</p><p>感觉这个方法除了静态调用，就不知道有什么比较方便的地方了，感觉那种直接通过模型只使用update() 方法不太好，不太直观，感觉很多时候应该是不止是就是用一个update 方法这么简单</p><p><strong>删除</strong></p><p>delete 删除，也是模型和Db 都能使用的</p><p>destroy 删除</p><p><strong>查询</strong></p><p>get （条件） </p><p>，find</p><p>感觉查询的功能真的是各种强大，慢慢学习吧</p><p>获取器的重要作用：</p><p>其实我们在平时的开发中总会遇到类似的问题，就是数据库中对于status 存储着各种数字，然后给前端展示的时候，循环结果，把结果中的每条数据的status 对应的中文取出来，然后再加上，读取器就是为了这个产生的，我们在读取一个</p><p>attr 的时候，类似定义一个钩子，他会自动帮我们把取到的数据进行修改（其实有两个参数的，第一个是这个值，第二个是整条数据的值）</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-2ea087a1d37bc10a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>all (条件) select ()</p><p><strong>软删除</strong></p><p>这种事很常用的，我们平时使用的时候通过加入一个标志位，然后tp中也是使用标志位，delete_time ,但筛选数据的时候不用我们处理，仿佛真的就删除一样，可是在管理工具中还是能看见</p><p>关于orm 的执行日志，或者是说sql日志，统一的开启数据库调试模式，然后直接在log中查看就好了</p><p>notice : 就是很灵活，因为orm 也是基于数据库的，所以数据库中的很多方法在orm 中也可以用，甚至同名，比如update,但返回的内容不一样，orm 的update 返回的是更新的实例，数据库的update 返回的是兽影响的行数</p><p>感觉就是模型的话要是不用with 这些关联属性，意义会小很多，可是后来发现，那些处理orm 查出来的的数据，确实会方便很多</p><p>关联：</p><p>1对 1 ： </p><p>虽然感觉有时候反着写也是对的，但最好还是遵从 （虽然七月老师说是二者是不对等的，比如 user 和 userinfo  ,userinfo 有 userid ,但user 找不到 userinfo ,但如果是 1对 1 ，是真的都能通过定义 hasOne 和 belongsTo 去获取对方）</p><p>（按照编辑器的推荐，确实 hasOne 更准确点）</p><p>（user  hasOne  userinfo   这个也更符合我们的习惯）</p><p>感觉上反正很怪，如果编辑器能提醒就好了，但只能提醒是主键还是外键，并不是提醒是哪种表的主键，那张表的外键</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-bd87f301d2501d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>user  -&gt; info</p><p>user 中定义 hasOne</p><p>$this-&gt;hasOne(‘info’, ‘user_id’,’id’），这个提示比较符合大众的想法</p><p>info 中定义 belongsTo</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-da97683778092efd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>$this-&gt;belongsTo(‘user’, ‘user_id,’id’)</p><p>单个模型还能通过</p><p>$banner-&gt;hidden([‘update_time’, ‘delete_time’]); 来隐藏对应的字段</p><p><em>感觉最好还是在model 的定义的时候隐藏</em></p><p><em>注意select () 这种查找出来的都是数据集合 collection</em></p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-3b17ab3543bd69a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>看一下这个例子，通过嵌套关系，可以实现images 内部数据的排序，所以关联关系也是可以嵌套的</p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>自己新建的缓存文件不要和 thinkphp里面的字段名称一样，否则回报错误</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a><strong>Exception</strong></h3><p>配置文件中开启debug 模式，要不然总是 ‘tp 专为api而生，十年磨一剑’的错误信息</p><p>开启之后还需要处理，因为我们前台只需要json数据，我们需要考虑程序上线之后如果发生错误了我们该怎么处理，其实没法处理，因为我们不知道什么时候会发生，想象一下如果我们知道他会发生，那我们为什么不去阻止而让他发生呢，此时我们需要一个监听全局异常事件的东西，当php抛出异常的时候我们只要去捕获他，然后处理就好了，类似前端的钩子 。 </p><p>知道吗 ？在我们原生的php当中，其实有个专门对全局异常进行处理的函数，可以自己定义，可是呢··我没有自己去试过，首先是异常自己理解的比较浅，再者对于框架的使用比较少，</p><p>tp的全局异常处理应该也是这个原理，本质上应该还是修改这个函数，当我们在tp中想改变全局异常处理函数只需要修改配置文件中的异常处理函数名称，改成自己需要配置的就好了</p><p>接下来我们重写下全局异常处理函数，让他更符合我们的要求</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-747c9b0c36acb611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>首先需要继承tp自带的异常处理，然后重写他的render 方法，，为什么？因为我们在bug模式的时候需要tp给我们提示错误信息，总比我们自己看 $e-&gt;getMessage() 方便详细的多</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-5fc354627abfef17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>接下来， Basci Exception 是自己默认定义的exception， 既然是自己定义的错误，自然不用tp的异常处理，直接返回前台json 数据就好了，因为自己定义的错误，一般是手动抛出，自己了解错误的原因</p><p>然后是非自己定义，首先要是判断是否开启了debug 模式，如果开启了，说明在调试，直接使用tp自带的就好了，千万注意要加上return ,要不然会报错，毕竟是html 页面的返回（类似可以想象一下tp中模板的返回）</p><p>再者是如果是上线环境，只需要告知前台服务器错误就好了，定义个固定的数组，返回给前端，然后记日志</p><p>（记录日志也是很简单的，log::error(), 写在runtime的log下面）</p><p>异常处理定义完毕，就要开始定义异常类了。使用异常类的原因就是告别传统的遇到错误的返回方式，还记得之前我们在嵌套函数中执行错误后怎么返回的吗，只能层层往上抛出，到了最外层的controller 返回，可是异常就不一样了，当异常处理检测到这个地方抛出的异常，就能直接进入异常处理函数中，多方便。</p><p>（还有一点我觉得定义异常的好处，就是之前我们对错误信息的输出总是 code =&gt; message =&gt; ,有时候为了规范我们通过写一个方法，通过code 去获取message ，但你想象一下，当你写完接口之后，满屏的 code ，你也不知道这个code 代表的啥意思，当然我们可以约定code的规范，如果我们通过throw new ParamErrorException([code=&gt; , message=&gt;]), 我们就会知道这个错误大致属于前端参数的错误）</p><p>notice :<br>1.不管是什么框架，我们定义的异常都一定继承于最原始的php \Exception</p><p>2.常用的方法 $e-&gt;getMessage(),获取错误信息</p><p>3.注意异常类因为继承自exception，我们一定不能定义exception中有的属性，比如我之前在异常类中定义过一个message属性，这个属性是exception 中的protected，然后在参数验证那块会出现莫名其妙的异常错误</p><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>说实话，我到现在还没有明白验证器的具体作用，平时那种</p><p>new Vdalidate()</p><p>-&gt;bitch()-&gt;check()</p><p>感觉就能符合需要，可是要是真的每次在valiate里面写上同样的验证规则， 确实可能会有重复定义的嫌疑</p><p>但我感觉要真的发挥验证器的作用，必须介乎scene() 场景来使用，一个validate 对应一个类，或者model，这个validate有各个属性的校验，通过定义scene ，让我们不会定义过多的validate 类</p><p>在 $rule 里面</p><p>有各个报错信息 $message =  [‘id.require’ =&gt;] 这种细致的分层，让错误信息准确的定位，或者直接 id =&gt; ,这样可能id对应多个验证规则的时候，需要把错误信息都加上，如果出错了，不知道具体是哪条规则出错了</p><p>scene ,对应场景，可能某个实体过来了，我需要验证其中valdiate 类中的某几个属性，我就用scene 去细分，如果不用scene 的话，想象一下，这个地方比如user 模型需要name 和 sex ，另一个地方需要 name 和 img ，难道我们需要为此定义两个validate ，感觉一点都不灵活（exception如果遇到这种通过向里面传入不同的参数来解决）</p><p>重写validate 和 重写 exception 不一样，重写valdiate ，其实是对传统 validate check 方法的封装，和 定义方法的更多加入，因为check 之后，所有的错误信息都会储存在 error  这个属性中（或者 $this-&gt;geterror()来获取），然后通过异常把这个错误信息抛出去给前台页面</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-993df227105522ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><img src="https://upload-images.jianshu.io/upload_images/5525740-e8860b37d1293f63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>laravel 中也有相似功能，感觉就和路由中间件一样，在执行到这一步之前都会先执行这个验证操作</p><p>感觉这个比那个__initze() 什么方法方便多了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>还有太多太多我不会用的，所以后面的路还很长啊，只是 为了更好的入门</p><p>### </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习，为了更好地适应未来的工作。简单的解除了下tp和laravel，总体来说tp比laravel简单多了，封装的也没有那么深，所以用起来还是很方便的，用的是5.0，5.1和5.0区别就挺大了，不如有了门脸，又是一个使用类不知道到底用哪个命名空间下类比较好的时候了，还有获取参数的方式，5.1已经没有getInstance()这种东西了，记录一下这几天的感觉,方便交流&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 关于blade</title>
    <link href="http://yoursite.com/2018/10/10/Laravel-%E5%85%B3%E4%BA%8Eblade(%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E)/"/>
    <id>http://yoursite.com/2018/10/10/Laravel-关于blade(模板引擎)/</id>
    <published>2018-10-10T08:45:23.000Z</published>
    <updated>2018-10-11T11:48:42.158Z</updated>
    
    <content type="html"><![CDATA[<p>其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。</p><a id="more"></a><p>itbasic 用的也是模板引擎，名twig，其实和blade没有多少不同的地方，只是自己发现的twig新功能还比较少，只是一直在原先的基础上堆代码，感觉上在模板引擎里面还是不要做过多的逻辑判断，否则后面会越写越复杂，而且难于维护。</p><p>对于web网站，我们有很多页面，但这些页面大部分都是相同的？因为我们的布局需要相同，这个其实在写itbasic的时候应该能感觉到，我们似乎只需要填充中间的content部分就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;@yield(&apos;title&apos;,&apos;测试&apos;)&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        @yield(&apos;content&apos;)</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>什么是yield ,就是让继承者可以填充的东西，继承者通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@extends(&apos;layout.blade&apos;) //继承上一个模板</span><br><span class="line">@section(&apos;title&apos;, &apos;cy&apos;)  //填充数据</span><br><span class="line"></span><br><span class="line">@section(&apos;content&apos;)   //这种方式填充数据要有结束符号</span><br><span class="line">&lt;h1&gt;222&lt;/h1&gt;</span><br><span class="line">@stop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@include(&apos;default.ce&apos;)  // 包含额外的页面</span><br><span class="line">//传递变量，include(&apos;default.ce&apos;, [&apos;user&apos;=&gt;$user])</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//判断</span><br><span class="line">@if ($a &gt; 0)</span><br><span class="line">&lt;h1&gt;cc&lt;/h1&gt;</span><br><span class="line">@endif</span><br><span class="line"></span><br><span class="line">//循环</span><br><span class="line">@foreach($counts as $count)</span><br><span class="line">&lt;li&gt;&lt;/li&gt;</span><br><span class="line">@endforeach</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实现在都是前后端分离的，应该蛮少用到模板引擎这种东西，作为上一个web时代的产物，其实模板引擎开发起来还是蛮快的，而且挺简单的。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>网站升级https</title>
    <link href="http://yoursite.com/2018/09/11/%E7%BD%91%E7%AB%99%E5%8D%87%E7%BA%A7https/"/>
    <id>http://yoursite.com/2018/09/11/网站升级https/</id>
    <published>2018-09-11T06:23:14.000Z</published>
    <updated>2018-09-11T06:57:58.961Z</updated>
    
    <content type="html"><![CDATA[<p>升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。</p><a id="more"></a><p>https原理<br>HTTPS采用共享密钥加密(对称加密)和公开密钥加密(非对称加密，比较出名的有RSA)两者并用的混合加密机制。在交换密钥使用环节使用公开密钥加密方式，之后建立的通信交换报文阶段则使用共享密钥加密方式<br>之所以传输过程中用对称加密，是因为非对称很浪费资源</p><p>(hash加密是单向的，例如md5,不能解密)<br>和对称加密还有非对称加密都是不一样的，不管是对称加密还是非对称加密，通过秘钥都是能解密的，但是hash，只能维持 hash(内容)之后的值保持一致，这也是我们数据库中只保存用户密码加密后的值就可以验证用户的密码是否正确了，因为我们可以每次获取到用户信息之后只要hash一下，然后和数据库中做下对比就可以了。</p><p>https ,首先让服务器和ca交互，获取服务器的公钥，这个过程是非对称加密，获取到公钥</p><p>https升级过程中遇到的问题:</p><ul><li>不允许脚本调用http，可以先把接口转发到我们本地的服务起的https上，然后通过nginx转发到别人网站上的接口，因为本身调用外来接口接口比较少，这样能符合我们的需求</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5525740-442e10f7747a4d2f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>https证书申请无效（每个域名都需要申请单独的证书，之前以为只要申请一个www.chenye2017.cn证书就可以了，chrome直接显示https不安全，其实通过微软的edage浏览器访问，能清楚的看到证书不匹配的原因）</li></ul><p>（证书申请是通过腾讯云，腾讯云上有详细的教程，唯一不足的是没有给文件夹权限，导致第一次访问403）</p><p>（https配置虚拟主机应该就和我们在vhost文件里面配置虚拟主机一样，现在是在ssl配置文件里面写）<br>（话说我现在的服务器，域名用的是阿里的，服务器用的是京东的，https证书用的是腾讯的，zz）<br>（还有不知道是hexo的原因还是github page 的原因，我的网站上有http的资源竟然不会显示https错误，不知道他是怎么解决这种http资源不出错的，有空可以了解下）</p><p>https和http的区别</p><p>简单看就是 https = http + SSL</p><p>SSL的运行机制，可以参考<a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">阮一峰老师的文章</a>，我对上面的一些内容做了些自己理解的笔记</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-260206ef40194be3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ol><li>其中加密传播是因为我们的传播内容都是通过生成一个第三方不知道的公钥，这个公钥是怎么来的呢，首先通过ca证书，因为系统内容ca的公钥，ca用私钥加密文件内容（私钥加密，公钥解密，不被篡改），我们获取服务器的公钥，这个公钥是干什么的呢，并不是用来进行数据的加密的，而是用来加密传递的数据给服务器（公钥加密，私钥解密，不被获取），服务器接收到客户端的数据进行生成公共密钥，这个密钥是我们以后加密数据用来传递的<br>(感觉只要记住证书里面的内容都是能保证绝对正确就好了)</li><li>具有校验机制，是因为我们的证书具有这个作用，比如我上次把我从www.chenye2017.cn 上获取的证书放到虚拟站点blog.chenye2017.cn就直接报错</li><li>配备身份证书，估计也是这个意思</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/5525740-62f2352ceaf4787a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>所以ssl 和 tsl 是一样的意思嘛</p><p><img src="https://upload-images.jianshu.io/upload_images/5525740-95302aaf96bdae3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>感觉这个握手不是tcp的那个三次握手，这个开始的时候tcp那个三次握手应该都搭建好了，而且这个也是4次握手</p><p>剩下的内容就是4次握手的详细内容了，为什么要4次握手，写的都很详细，就不再补充了，总之这个生成传输加密内容的秘钥也是通过非对称加密，再后面就是http了。</p><p>总结一下：</p><ol><li>通过CA 证书，发送服务器公钥，利用的是非对称加密算法，用的公钥和私钥来自CA（证书的作用是为了保证服务器公钥的正确性，不被篡改）</li><li>通过CA得到的服务器公钥，大家都可能有，但是我们通过公钥加密，私钥才能解密，和服务器交互，让两端都能生成一致的对称加密算法钥匙（随机因素可以通过客户端利用服务器公钥加密传给服务器）</li><li>利用生成的公共密钥进行对称加密，传输数据（这个公共密钥在每次连接的时候生成，别人不知道）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;升级https的原因：老大把公司人事管理系统升级到了https,面试的时候可能经常问到https,自己之前了解过https,但是没有去实践过，现在太多网站都是https····还有升级过程并不是十分复杂，那就去做呗。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于git</title>
    <link href="http://yoursite.com/2018/09/07/%E8%BF%99%E5%8F%AF%E8%83%BD%E6%98%AF%E4%B8%9C%E5%8D%8A%E7%90%83%E6%9C%80%E5%A5%BD%E7%9A%84git%E5%85%A5%E9%97%A8%E4%BA%86/"/>
    <id>http://yoursite.com/2018/09/07/这可能是东半球最好的git入门了/</id>
    <published>2018-09-07T07:51:06.000Z</published>
    <updated>2018-10-31T12:44:03.955Z</updated>
    
    <content type="html"><![CDATA[<p>公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨</p><a id="more"></a><ol><li>关于分支. git branch -a ，可以查看项目的本地分支和远程分支（分支有本地分支和远程分支这两种，本地分支推送到远程就变成了远程分支，以后别人clone的时候就会包含这个分支）。当我们git clone 远程项目的时候，会把这个项目的远程分支都拉下来，我们可以在本地切换各个分支。各个分支的作用？可以作为开发的时间节点来用，比如慕课网上各个讲课阶段，每次代码开发前，先开个本地分支，开发完了推送到远程，然后和并到主分支上。我们通过切换到各个分支，就知道老师讲到哪了，还能对比代码有哪些变化，以后查看的时候还可以通过编辑器<img src="https://upload-images.jianshu.io/upload_images/5525740-502973ccb71c0779.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ol><p>来进行切换，注意切换的时候会在本地自动新建一个分支，不用担心，你想啊，本地要是不新建，你直接改动的内容算哪的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司一直用svn, 怕git 的相关内容以后用到，所以学习了，只是简单记录git 使用过程中自己的问题，不是教程，欢迎一起探讨&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于单点登陆的那些事</title>
    <link href="http://yoursite.com/2018/09/04/%E5%85%B3%E4%BA%8E%E5%8D%95%E7%82%B9%E7%99%BB%E9%99%86%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/09/04/关于单点登陆的那些事/</id>
    <published>2018-09-04T02:15:49.000Z</published>
    <updated>2018-09-04T03:38:30.788Z</updated>
    
    <content type="html"><![CDATA[<p>最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.<br><a id="more"></a><br>单点登录：简单理解成一处登陆，到处登陆，一处登出，各处登出。其实在生活中的应用还是满广泛的。比如你登录淘宝的网站，可能当你跳转到天猫上，也不需要登陆，光从界面上看，也能分辨这是两个网站，这两个网站肯定有各自的登陆机制，其实内部就是用了单点登录的原理，让用户无感知的情况下实现一个账户在各个网站下的登陆登出。<br>后来在写的过程中，发现这个单点登录也有点第三方登陆的意思，这个第三方就是sso登陆中心。<br>很多人广从字面意义上看，可能会觉的单点登录应该是这样：一个用户在这个地方登陆了，比如手机上或者上海登陆了，当在电脑上登陆或者安徽登陆了，之前登陆过的账号会下线，但这并不是单点登录哦，想了下，上述功能实现起来也挺简单，比如我们经常存取 token =》 用户信息这样的登陆凭证，又或者是session_id =&gt; session 信息（用户信息）这样的登陆凭证，不妨我们在用户登陆的时候，再存储一封 用户id =&gt; 用户信息，这样我们可以很方便的统计有哪些在线用户，哪个用户是否在线（前面第一种的话需要遍历所有的session文件取出用户id）。当我们登陆接口产生了一个新的token =》 用户信息的时候，我们检测下这个用户是否在已登录列表，如果有，我们服务端直接让之前的token失效就可以了，就能实现前面账号的下线。<br>回归正题，关于单点登录<br><img src="https://upload-images.jianshu.io/upload_images/5525740-5f9c1b27e370fabf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="797930-20161203152650974-276822362.png"><br>单点登录的原理大致就是上面了：<br>1.先登录普通web1，web1后台检测是否登陆了，如果登陆过，直接跳转到web1,如果没有登陆，跳转到sso登陆中心。sso中心检测这个用户是否登陆过，如果没有登陆，跳转到sso登陆界面，输入用户名和密码（之前为什么说单点登录很像第三方登陆呢，因为接入单点登录的web1也不知道即使能登陆到他这个平台上的用户的用户名和密码，用户登陆的操作逻辑都是sso 这个第三方维护的，web1只是在登陆sso成功之后维护一个用户和web1的登陆态，比如web1派发给用户一把钥匙，以后拿着这把钥匙就代表你是web用户了），用户成功登陆sso这个中央站点后（用户和sso之间的登陆成功搭建成，之前我是通过jwt的方式维护用户和sso之间的，jwt相比较传统的cookie和session就是通过签名的方式能防止用户篡改已登录人的信息），sso会回调web1站点上提前设置好的接口（这个我当时是在跳转到登陆中心的时候附带在url后面参数，其实这个可以提前设定好，然后通过传入一个参数web1，sso去后台查找需要的会掉地址），传给他一个参数，可以理解成一个ticket，web1拿着这个ticket可以换取正在登陆的用户的用户信息，拿到之后web1就能实现自己的业务逻辑了，比如检测这个用户是不是第一次登陆，如果是第一次登陆的话需要绑定用户信息之类的，然后维护用户和web1之间的登陆状态建成。<br>上面需要注意的点就是客户端如何接受服务端生成的登陆凭证.<br>首先是用户和sso中心，这个好解决，因为我们的登陆页面可以可以当做一个静态页面，我们可以在上面写js，这就方便了，我们发送一个ajax请求给sso，成功后把返回的登陆凭证放在cookie中，每次调用sso接口比如验证用户是否登陆的时候都会携带着这个cookie，！！！千万要注意，携带这个中在客户端浏览器的cookie的前提是通过ajax之类的访问，你别通过curl之类的访问，curl需要自己手动设置cookie，并不会像浏览器一样自动添加上，所以我们在后台一般要用header  location之类的跳转，而不是curl.<br>web1和用户之间登陆态的维护：<br>这块我没有使用header location跳转，用的是ajax返回给前端页面，前端页面去跳转，之所以这么做，好像是用第一种好像有点问题，没有去研究了，因为时间赶啊！！！前端拿着这个ticket，哈哈哈，你是不是担心不安全，我也担心呢！！而且我这块直接用的url跳转，为什么呢，因为我的后台是获取用户信息之后直接跳转，并不需要ajax那种返回了，如果这里用返回，首先是前台页面并不知道维护好登陆信息之后需要挑战的地址（这个静态页面是sso的），然后呢，如果通过ajax，后台跳转可能有些错误，之前那个sso登陆成功后台跳转不到web1，可能就是这个问题。<br>web1的回调地址里面通过ticket拿到用户信息之后可以做很多自己事情了，比如绑定用户，比如验证用户是否合法等等</p><p>2.单点退出<br>一处退出，处处退出。<br>我是这样做的，当登陆成功后，会在数据库中写入，这个用户的登出地址，当我们登出的时候，查询数据库，所有用户的登出地址，循环调用，需要注意的是我们传给用户的是只能是user_id之类的公有信息，各个子网站接收到之后，需要拿这个信息获取用户的登陆凭证，然后让其失效。我是这样做的：redis中存储着phpsessid（我们用的传统的cookie session）,然后curl 模拟请求的时候cookie带上这个，··然后就实现啦</p><p>思考：如果我们模拟请求的时候带上完全一样的头信息，是不是就能达到和浏览器一样的效果了，··有些能，比如上面的登出，但是设置cookie不可以，明明就是header加上点信息嘛，为什么不可以呢，因为cookie只能在浏览器上使用？<br>还有很多优化的空间，比如回调多个登出接口，用的消息队列，如果一个出错，是记日志吗，还是什么zzz<br>每个网站需要自己的登陆界面嘛，这样每次未登录定位到登陆界面之后就只有个登陆按钮，点击之后才能进入sso输入用户名和密码，相比较之前略麻烦，但是如果sso登陆之后，我们点击就能直接跳转到我们的网站，感觉这样更符合单点登录。<br>而且住校之后我们可以定位到普通网站的登陆界面，而且点击因为可以加回调地址，我觉得还是不能省略的。<br>代码就不放了，放些接口的函数吧<br>sso :<br>login :检测是直接跳转到登陆页面还是检测cookie是否有效，有效回调web1站点地址，无效跳转到登陆界面（看了下仿佛ajax中header location 就是有点问题）<br>logout</p><p>web1:<br>login: 判断是去sso还是直接登陆<br>logout:退出，需要回调 sso 的logout, 注销sso还有各个子网站<br>ssologin:回调登陆地址<br>ssologout：回调登出地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近老大希望把项目中的用户登陆模块独立出来，起初是公司的各个部门都有一些自己的小项目，但因为是公司内部的项目，所以肯定就不能走一半网站的那种注册流程，一般情况下需要个审批人，注册的时候只有公司内部员工可以通过。可能通过接口ip的限制，比如智能内网访问注册接口可以起到同样的作用，但他们一致决定后这个东西还是独立出来，然后老大就交给了我，于是乎开始了解了下单点登录.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于nginx的那些事</title>
    <link href="http://yoursite.com/2018/08/20/%E5%85%B3%E4%BA%8Enginx%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/08/20/关于nginx的那些事/</id>
    <published>2018-08-20T03:42:26.000Z</published>
    <updated>2018-08-20T03:42:26.033Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2018/08/17/test/"/>
    <id>http://yoursite.com/2018/08/17/test/</id>
    <published>2018-08-17T08:54:57.000Z</published>
    <updated>2018-08-17T08:54:57.684Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel  数据库相关操作</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-数据库相关操作/</id>
    <published>2018-07-29T15:42:59.000Z</published>
    <updated>2018-07-29T15:42:59.679Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel seeder 数据填充</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-seeder-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-seeder-数据填充/</id>
    <published>2018-07-29T15:42:33.000Z</published>
    <updated>2018-07-29T15:42:33.200Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel migrate 数据迁移</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-migrate-%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-migrate-数据迁移/</id>
    <published>2018-07-29T15:42:19.000Z</published>
    <updated>2018-10-11T02:32:25.730Z</updated>
    
    <content type="html"><![CDATA[<p>虽然表哥说他们都不用这种方式，但这种方式确实很方便的解决了团队合作的时候数据库表的同步问题，像我们itbasic 就每次上线或者给队友同步数据库的时候都得自己手动去处理，而且这种方式更多的把sql语句转换成php语言处理，不知道建索引那些会不会很方便.</p><a id="more"></a><p>文件位置和命名：</p><ul><li>database/migrations/2014_10_12_000000_create_users_table.php</li></ul><p>通过artisan 命令能直接生成对应目录下的文件</p><p>注意up 和 down 方法，分别是的执行的时候，还有回滚的时候的执行</p><p>注意create 和 update 表结构的时候的区别</p><p>自增：increment </p><p>字符串： string  ， 方法的第二个参数限制最大长度</p><p>唯一： unique，感觉就像数据库的唯一索引</p><p>创建时间和修改时间，通过 timestamps 就能生成</p><p>记住我： rememberToken, 虽然一直不太清楚这个干啥的</p><p>create =&gt;  dropIfExists() , 创建 回滚的时候对应 删除</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然表哥说他们都不用这种方式，但这种方式确实很方便的解决了团队合作的时候数据库表的同步问题，像我们itbasic 就每次上线或者给队友同步数据库的时候都得自己手动去处理，而且这种方式更多的把sql语句转换成php语言处理，不知道建索引那些会不会很方便.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Laravel router</title>
    <link href="http://yoursite.com/2018/07/29/Laravel-router/"/>
    <id>http://yoursite.com/2018/07/29/Laravel-router/</id>
    <published>2018-07-29T15:41:50.000Z</published>
    <updated>2018-10-11T03:53:04.177Z</updated>
    
    <content type="html"><![CDATA[<p>关于路由的一些总结</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">Route::get(&apos;/&apos;, &apos;StaticPagesController@home&apos;)-&gt;name(&apos;home&apos;);</span><br><span class="line">Route::get(&apos;/help&apos;, &apos;StaticPagesController@help&apos;)-&gt;name(&apos;help&apos;);</span><br><span class="line">Route::get(&apos;/about&apos;, &apos;StaticPagesController@about&apos;)-&gt;name(&apos;about&apos;);</span><br></pre></td></tr></table></figure><p>这个name是用来命名的，命名有什么用，看下面</p><p>route(‘help’)  =&gt; 这个help 是路由命名，user.help 更为准确</p><p>route(‘help’,[1,2])  =&gt; 多个参数传递数组</p><p>这个函数的参数，通过下面这个函数，配合配置得环境变量，可以生成前端可以访问路径的，如果很直白的写url，以后url改动的时候但凡用到的地方，都需要改动</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于路由的一些总结&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>关于composer</title>
    <link href="http://yoursite.com/2018/07/29/%E5%85%B3%E4%BA%8Ecomposer/"/>
    <id>http://yoursite.com/2018/07/29/关于composer/</id>
    <published>2018-07-29T15:41:17.000Z</published>
    <updated>2018-10-10T06:20:01.444Z</updated>
    
    <content type="html"><![CDATA[<p>composer,php的包管理工具，类似nodejs的npm，类似python的pip，因为很多时候我们需要接入外来的服务，可能自己的能力不足，又或者是别人有更好的解决办法，不是有说过站在巨人的肩膀上能看的更远么。</p><a id="more"></a><p>composer require  ```当我们需要安装一个外来服务的时候，注意这个不是安装php的扩展模块，两者有本质上的区别，php的扩展模块是c写的，需要我们源码编译到php中, 而通过composer接入的是php封装的内容。 之前我经常把需要的模块通过手动写入composer.json文件中，然后通过composer install 或者 composer update 这种方式更新，这都是不对的</p><p>composer install  会依据composer.lock 文件进行安装，如果没有这个lock文件按照composer.json进行安装</p><p>composer update 会依据composer.json 进行安装<br>（composer.lock 和 composer.json 的区别lock文件中会严格规定版本号）</p><p>composer init 初始化一个项目被composer 管理（很少用, 一般是手动编写一个composer.json文件，然后install）</p><p>composer 还有文件夹管理的功能，现在一般用的是psr-4,原先项目组织有psr-0,现在废弃了，二者区别就是psr-4通过命名空间更能代表文件位置<br>composer的自动加载有psr-4,我们那个api服务中有使用，注意定义了一个顶级之后，下面的子命名空间可以自动寻找，而不需要你的人为干预<br>files 可以加载配置文件之类的，不用一直include<br>classmap可以不遵循psr-4规范，会扫描指定文件夹，加载里面的类（一般的类名首字母大写，然后类名和文件名一样）<br>当我们修改了composer的自动加载，通过composer dump-autoload来更新</p><p>我们php的框架和python 这种框架有挺大的区别，写了点python，还有问了写python的同事，得到的就是他们写python的时候还用的是面向过程的方式，他们的框架flask感觉更像是php中的包的概念，通过import方式导入，没有各个文件夹的内容规定，给了很大的自由给用户，我们通过composer 安装的文件一般在这个项目文件的vendor目录下，但是我们python 通过pip安装的一般是全局安装，就算是用了pipenv 或者vrtualenv 也是在全局下面然后分成各个子文件夹（仿佛是虚拟站点让php变得这么方便？）</p><p>composer需要注意的东西：</p><ol><li>修改源，下载东西更快</li><li>linux 下安装（composer.phar 就是 php composer, 只是单独使用的话需要composer.phar 需要执行权限 chmod a+x composer.phar）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;composer,php的包管理工具，类似nodejs的npm，类似python的pip，因为很多时候我们需要接入外来的服务，可能自己的能力不足，又或者是别人有更好的解决办法，不是有说过站在巨人的肩膀上能看的更远么。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Composer" scheme="http://yoursite.com/tags/Composer/"/>
    
  </entry>
  
  <entry>
    <title>关于框架操作数据库的几种方式</title>
    <link href="http://yoursite.com/2018/07/28/%E5%85%B3%E4%BA%8E%E6%A1%86%E6%9E%B6%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/28/关于框架操作数据库的几种方式/</id>
    <published>2018-07-28T15:11:56.000Z</published>
    <updated>2018-07-28T15:12:14.011Z</updated>
    
    <content type="html"><![CDATA[<p>其实第一次有这方面的思考是来自七月老师的tp教程，他起了个头，他那个课程的核心就是为了提倡大家使用orm，后来在工作中开始留意这方面的知识.(如果没有那个引子，估计我会把builder query和orm弄混淆吧，因为真的挺相似，调用方法都是链式，orm对于bq方法的使用，又因为区别在于orm的面向对象这个特性上，而且现在基本都不用bq了，就算使用也是可以DB直接调用,而不用像orm那样需要定义一个model类，很难找出bq相对于orm的差别，换句话说因为本身orm就是基于bq的，所以我们需要发现的orm相对于bq的改变，但这个改变刚好是面向对象这种思想上，加上bq的少使用，这个改变很难发现)</p><a id="more"></a><p>看了下php关于linux方面的知识，pdo， builder query ，orm，我这种基础不好接触面不广的人经常混淆。在pdo之前应该是直接利用mysql 和 mysqli进行数据库连接操作，这种的只需要php开启对应的mysql或者mysqli扩展就好了（mysql已经废弃了），这还是我刚学习php的时候书上经常写的，后来在工作中这种的用的就比较少了，主要用的就是pdo了，个人感觉pdo和mysqli用起来查询那些操作还是差不多的，不管是函数还是查询到的结果集，感觉差别最大的还是 一个是new pdo一个是 mysqli_connect吧，:smile:。（pdo使用的时候除了安装pdo扩展，还要开启对应的驱动哦，比如 mysql_pdo）。</p><p>还记的我在学习慕课那个高性能api接口时候接触到的dao层吗，其实dao后来理解起来感觉是不是只有在那种处理比较麻烦和严谨的时候使用</p><pre><code>&lt;?phpclass DB_user extends DB_base {    public function find($username) {        $query = self::$db-&gt;prepare(&quot;select count(*) as c from yaf_user where username = ?&quot;);        $query-&gt;execute([$username]);        $count = $query-&gt;fetchAll();        if ($count[0][&apos;c&apos;] != 0) {            list(self::$errno, self::$errmsg) = Err_map::getCodeMessage(1004);            return false;        }        return true;    }</code></pre><p>看这种，查询一个结果要写这么多，肯定需要独立出来呢。</p><p>后来是builder query，其实和orm是很像的，毕竟orm是基于builder query的，但二者不同之处在于orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例(虽然我们在使用bq的时候可能也是这样想的，但orm不止是想这么简单，他是具体的实现了，比如下面同样调用all方法，虽然查出来的数据类型可能都是collection，但是展开看下，一个下面是关联数组，一个是对象，有具体的public 和private属性)。因为orm基于bq嘛，所以bq的那些方法orm都可以使用，所以我感觉方法的混用也是容易把orm和bq混淆的原因。但你是否还记得bq使用的时候调用的类是 DB,以laravel举例，DB是库facade下面的，但是orm使用的时候我们调用的类是继承model的那个类名字</p><pre><code>DB::table(&apos;student&apos;)-&gt;all()Student::all()</code></pre><p>当我在学习yii的时候还接触到一个概念AR，其实AR只是实现orm的一种方式，比较常用的有AR和··mapper，laravel（Eloquent）和yii现在orm实现方式都是AR，所以不要把这个当做yii和laravel的区别啦。</p><p>AR和mapper的区别在于，mapper把数据对象和数据持久化分开了（啥叫持久化，就是数据存储啊笨蛋···zz，心痛的感觉），mapper中对于数据的保存需要用类似bq中一个统一的类去实现，比如</p><pre><code>//伪代码,方法名纯属虚构，因为懒得去查了$student = new Student();$student-&gt;name = &apos;cy&apos;;$student-&gt;age = 19;DBMAPPER-&gt;config($student);DBMAPPER-&gt;refresh($student);</code></pre><p>现在水平太低，也不知道这样的好处是啥：说是为了把数据对象独立出来，让他的作用就是在各个层中传递.</p><p>大致就这些了吧，最后来一个laravel中最基础的model定义，让我们来更能理解orm的那几个定义</p><pre><code>//orm把一张表看做一个模型model了，列看做模型对象的属性了，记录看做模型的实例&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class Test extends Model{    //定义表名    protected $table = &apos;test&apos;;    //禁止更新时间戳，默认会更新created_at和updated_at    public $timestamps = false;    //可以批量赋值的属性，什么叫做批量赋值，就是我们可以通过create方法插入的，不是save那种，create是直接传入一个索引数组，    //save 是通过给实例的属性一个个赋值，就这点看来，确实有批量赋值的意思    protected $fillable = [&apos;name&apos;];}</code></pre><p>​    </p><p>laravel 中orm的实现用了很多PHP的特性（魔术方法等），比如属性，写的挺好的，在laravel核心框架技术解析中有写到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实第一次有这方面的思考是来自七月老师的tp教程，他起了个头，他那个课程的核心就是为了提倡大家使用orm，后来在工作中开始留意这方面的知识.(如果没有那个引子，估计我会把builder query和orm弄混淆吧，因为真的挺相似，调用方法都是链式，orm对于bq方法的使用，又因为区别在于orm的面向对象这个特性上，而且现在基本都不用bq了，就算使用也是可以DB直接调用,而不用像orm那样需要定义一个model类，很难找出bq相对于orm的差别，换句话说因为本身orm就是基于bq的，所以我们需要发现的orm相对于bq的改变，但这个改变刚好是面向对象这种思想上，加上bq的少使用，这个改变很难发现)&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux搭建git仓库</title>
    <link href="http://yoursite.com/2018/07/24/Linux%E6%90%AD%E5%BB%BAgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2018/07/24/Linux搭建git仓库/</id>
    <published>2018-07-24T11:52:40.000Z</published>
    <updated>2018-07-26T06:30:48.453Z</updated>
    
    <content type="html"><![CDATA[<p>故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。<br><a id="more"></a><br>后来老大希望测试下我写的代码，看看需要哪些参数，给了另一台服务器。<br>刚开始想到直接把修改好的代码打个包放上去，后来想了下不是长久之计，因为我的水平肯定要经常修改代码，不能每次修改下就打包一下，太麻烦了。<br>又想到可以通过配置itbasic服务器上的svn，当svn up 的时候忽略掉特定文件夹的更新，百度了下集中方法，大部分是一下集中情况：windows下忽略文件夹，提交代码的时候忽略掉文件夹，很少有更新代码的时候忽略掉文件夹的解决办法。（有，但自己试验失败）。<br>后来想到不如利用git吧，首先大部分都是我一个人操作，我经常向github提交代码，操作已经很熟悉了，再者毕竟用git也能跟上时代的潮流嘛。</p><p>先来介绍一点基础知识：<br>当我们想下载github上的代码（或者说远程仓库的代码），我们可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone git@ip地址：git远程仓库的地址</span><br><span class="line">//例如</span><br><span class="line">git clone git@github.com:chenye2017/zerg.git</span><br><span class="line">//当需要下载github上的仓库的时候，直接去这个项目首页，会有个clone or download的选项，注意不要选择use https，因为选了那个每次提交代码额时候都要输入密码</span><br><span class="line">//winodows用户可以直接下载zip</span><br><span class="line">git clone git@192.168.56.10:/home/resposity/bbs.git</span><br></pre></td></tr></table></figure></p><p>新建一个目录，自定义名称<br>进入到这个目录内，执行上述操作，就能把项目目录中的代码下载下来。</p><p>但上面仅仅只是下载项目，我们为了和远程仓库进行联动，我们需要在本地的这个文件夹建造一个git仓库，然后和远程仓库的某个分支比如master进行绑定，当我们修改完成的时候进行代码推送到远程的时候，别人下次再次clone或者pull就能收到我们提交的修改。<br>下面就是创建本地仓库的实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd dir</span><br><span class="line">//进入上面执行git clone的文件夹</span><br><span class="line">git init</span><br><span class="line">git add.  //把修改的文件夹都添加进来</span><br><span class="line">git commit -m &apos;init&apos;  //提交到本地代码库</span><br><span class="line">git remote -v //查看远端仓库</span><br><span class="line">//如果有远程仓库，可以进行删除</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote add origin git@192.168.50.16:/home/resposity/bbs.git //添加远程仓库</span><br><span class="line">git push origin master  //和远程仓库的master分支绑定，以后提交只需要git push</span><br><span class="line">git pull origin master //同上，以后使用也只要git push 就好了</span><br></pre></td></tr></table></figure><p>当我们提交代码的时候肯定是不成功的，提示我们需要输入密码，···而且每次都会提示，怎么办呢，可以通过一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></p><p>在windows中，生成密钥位置会在C:\Users\admin 下面，这个下面有.ssh文件夹，进去复制末尾是.pua 也就是公钥的文件，粘贴到你的git仓库所在的服务器的git 主目录下，比如我的是 /home/git/.ssh/authorized_keys,粘贴到文件末尾即可，如果还不能提交代码，重启下sshd服务，netstat -antp|grep sshd, kill, /usr/bin/sshd 启动<br>如果还不行，可以查看这篇文章修改下配置 <a href="https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873" target="_blank" rel="noopener">https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873</a></p><p>一直提交需要填写密码其实是个很常见的问题，收集了几篇文章，因为之前一直不成功，但后来成功了，但其实不是下面这几个问题，是我对git远程仓库理解出现了问题，所以操作不对.<br><a href="https://www.jianshu.com/p/9dbb1dea5929，" target="_blank" rel="noopener">https://www.jianshu.com/p/9dbb1dea5929，</a> （文件夹权限），<br><a href="https://ruby-china.org/topics/14182" target="_blank" rel="noopener">https://ruby-china.org/topics/14182</a> （ssh真的出问题了，需要查看日志）</p><p>最后也是最终的要一步，按理说这应该是第一步的，就是linux上远程创建git仓库。<br>本身应该 1. 创建远程仓库 2 git clone 3. git push<br>这也是我们平时使用github 的主要步骤，但因为这一步最重要所以我放在了最后。</p><p>git创建远程仓库 <a href="http://www.runoob.com/git/git-server.html" target="_blank" rel="noopener">http://www.runoob.com/git/git-server.html</a> 菜鸟教程上已经说得很清楚了，只是我们需要区别一下两行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure></p><p>第一个我们经常用到是实例化本地仓库，第二个是创建一个裸库，什么意思呢，就是这个裸库就是我们平时那个 git clone ip地址后的路径，这个仓库装的都是我们的提交记录，本身是并没有代码的，但我们通过git clone能生成最新的代码，以我的服务器为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/resposity  //专门用来放远程仓库的文件夹</span><br><span class="line">/home/resposity/bbs.git  //我的bbs远程代码库</span><br><span class="line">/home/code/bbs  这是我的服务器上实际项目代码，也是被人访问我的项目的路径</span><br></pre></td></tr></table></figure></p><p>当我本地修改好了代码（windows下），提交到远程仓库中，然后在服务器的/home/code/bbs (线上项目文件夹)下进行更新git pull最新的代码,别人就能访问到我本机的最新代码了。</p><p>对了，还记的我们当初svn代码更新提交失败，提示svn clean也不行的时候怎么处理的吗，就是清除.svn 下面两张表里面的数据 (通过Navicat建立连接).当时刚开始是不会这种方法的，同事告诉我直接删除.svn这个文件夹，说svn管理这个文件夹都是通过他，现在想起来挺有道理的，但没有试过（以前直接是删除了svn这个软件，然后肯定不成功啦，现在想想这和svn半毛钱的关系都没有撒，但感觉不能删除.svn,因为删除了，那些diff都找不到了）git应该也是通过.git这个文件管理的。</p><p>对了，关于免密码登录，当我们通过命令生成的ssh密钥linux下，一般在这个用户目录下面，比如root用户，在/root/.ssh 下面，我们需要把这个公钥粘贴到需要进行提交的git远程仓库的服务器中git的安装目录下面的ssh的auth···——key，里面，追加在文件末尾，注意着这两个地方文件名虽然类似，但一定要分清把那个粘贴到哪个上面，分清主从关系。</p><p>关于忽略文件夹，编辑.gitignore 文件，在项目根目录下面，因为windows下面不能这样命名文件，可以在linux下面编辑保存，编辑之后这个文件就是untracked形式,以后的提交就不会把这个文件保存在内，即使用了git add.</p><p>但是之前把.idea这个文件夹包含进去了，怎么办呢，git remove -n -r –cached</p><p>–cached  只是git仓库删除了，本地不会删除，-r 类似删除文件夹的时候递归删除， -n 先列出来要删除的文件，真正想删除的时候不要加这个参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网站部署随笔</title>
    <link href="http://yoursite.com/2018/06/20/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/06/20/网站部署随笔/</id>
    <published>2018-06-20T13:36:20.000Z</published>
    <updated>2018-06-20T14:48:01.622Z</updated>
    
    <content type="html"><![CDATA[<p>618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。</p><a id="more"></a><p>好久之前在阿里云上买过一个域名，29一年，chenye2017.cn,主要这个名字和我的github账号也是一致的，比较好记。当我想绑定域名到服务器上的时候，其实有点担心，我在阿里云上买的域名能绑定到服务器上吗？</p><p>试试吧。首先需要对域名进行实名认证，域名的实名认证其实挺简单的，填下身份证号和联系电话就好了，后面需要备案，这点需要注意的是，我绑定的是京东云，所以需要在京东云上备案。之前对于域名的购买，我的理解是购买一款厂商的产品，但其实不是这样的，试想一下我们购买域名的时候是不是只要先构思一个自己想要的域名，然后查询域名是否在使用，如果没有使用就可以进行购买，这个凭空想象出来的域名厂商不可能提前为我们准备好，他能做的就是通过域名解析器dns把我们的域名注册进世界的万维网当中，当世界中的某个人通过浏览器进行访问的时候，dns能把域名解析成ip地址找到我们的服务器，既然这样，那我们是不是只需要在我们的服务器上搭建一个域名服务，就能不通过购买他的域名，直接使用自己注册的域名就可以了呢？理论上是可以的，但我没有去实践过。</p><p>备案未完成…</p><p>之前帮前端同事部署过一个vue项目，其实和部署一个php项目 极为相似，甚至更简单，都是通过找寻唯一入口文件，因为前端项目都是静态文件，而且apache默认找的文件夹下面的第一个文件就是index.html,所以都不需要进行特殊的设置（php的话因为要找index.php,所以要做更多的设置），唯一需要注意的就是前段项目的很多路径都是绝对路径，他本质上是相对网站的根目录来的，也就是默认项目部署在网站的根目录下，如果网站没有部署在根目录下，比如itbasic bbs，需要我对引入的静态资源路径进行适当的修改。比如给需要找的静态资源建立个软链接ln -s ,到新的静态资源目录下。</p><p>因为之前是根据网上教程搭建的hexo，其实不懂他的实现原理。</p><p>而且在教程的开始，就说了要使用node，对于我这种js都不好的人，看到node，首先就觉的完了。其实很多前端项目用到node，并不是用到nodejs的语法，而是用nodejs搭建了一个web服务，承载前端项目，然自己置身于一个联网的状态中，就能发出类似ajax这样的联网请求，因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是<a href="http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。" target="_blank" rel="noopener">http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。</a></p><p>我看了下上传到github上的文件夹，和我本地的项目代码结构还是有挺大区别的，我的理解就是把本地代码进行了打包，打包好的文件上传到github上了（类似vue代码的发布），上传到github上的文件夹全是静态目录结构，我惊喜的发现了index.html,于是大胆的假设了下如果把那个目录放在我的站点根目录下，是否也能进行访问了呢，我就不用通过chenye2017.github.io去访问，而是通过我自己的站点去访问呢，毕竟服务器在国内，访问速度也比较快。</p><p>结果是成功的，印证了我的假设。</p><p>在网站部署的时候还遇到了几个问题，比如源码编译apache2.4,在之前还需要安装apr,apr-util,之类的文件，apache2.4的改文件访问权限和之前的apache还不一样，还有文件夹名字结尾不能有空格，否则识别不出来，加载vhost.conf,启动apache失败，修改server localhost之类的apache配置文件，还有apachectl restart开始不管用，需要自己手动配置脚本····</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>无限递归</title>
    <link href="http://yoursite.com/2018/06/13/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/06/13/无限递归/</id>
    <published>2018-06-13T08:00:30.000Z</published>
    <updated>2018-11-15T07:21:59.684Z</updated>
    
    <content type="html"><![CDATA[<p>无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。</p><a id="more"></a><p>以部门举例，我们在使用的过程中，需要找到这个部门的相关父级部门（子孙树），或者我们需要知道某个部门是否属于某个部门，我们既可以用家谱树去实现，也可以用子孙树去实现，用子孙树去实现的一个好处就是，当我们知道父级节点，一次性求出这个父级节点的所有子孙，通过判断子节点是否在这个父级节点的子孙中，就能知道是否满足条件。但如果我们通过家谱树，我们需要每次根据子节点，去求一次家谱，然后来判断家谱树中是否有这个父级节点存在，来判断是否符合条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$address = array(</span><br><span class="line">    array(&apos;id&apos;=&gt;1  , &apos;address&apos;=&gt;&apos;安徽&apos; , &apos;parent_id&apos; =&gt; 0),</span><br><span class="line">    array(&apos;id&apos;=&gt;2  , &apos;address&apos;=&gt;&apos;江苏&apos; , &apos;parent_id&apos; =&gt; 0),</span><br><span class="line">    array(&apos;id&apos;=&gt;3  , &apos;address&apos;=&gt;&apos;合肥&apos; , &apos;parent_id&apos; =&gt; 1),</span><br><span class="line">    array(&apos;id&apos;=&gt;4  , &apos;address&apos;=&gt;&apos;庐阳区&apos; , &apos;parent_id&apos; =&gt; 3),</span><br><span class="line">    array(&apos;id&apos;=&gt;5  , &apos;address&apos;=&gt;&apos;大杨镇&apos; , &apos;parent_id&apos; =&gt; 4),</span><br><span class="line">    array(&apos;id&apos;=&gt;6  , &apos;address&apos;=&gt;&apos;南京&apos; , &apos;parent_id&apos; =&gt; 2),</span><br><span class="line">    array(&apos;id&apos;=&gt;7  , &apos;address&apos;=&gt;&apos;玄武区&apos; , &apos;parent_id&apos; =&gt; 6),</span><br><span class="line">    array(&apos;id&apos;=&gt;8  , &apos;address&apos;=&gt;&apos;梅园新村街道&apos;, &apos;parent_id&apos; =&gt; 7),</span><br><span class="line">    array(&apos;id&apos;=&gt;9  , &apos;address&apos;=&gt;&apos;上海&apos; , &apos;parent_id&apos; =&gt; 0),</span><br><span class="line">    array(&apos;id&apos;=&gt;10 , &apos;address&apos;=&gt;&apos;黄浦区&apos; , &apos;parent_id&apos; =&gt; 9),</span><br><span class="line">    array(&apos;id&apos;=&gt;11 , &apos;address&apos;=&gt;&apos;外滩&apos; , &apos;parent_id&apos; =&gt; 10),</span><br><span class="line">    array(&apos;id&apos;=&gt;12 , &apos;address&apos;=&gt;&apos;安庆&apos; , &apos;parent_id&apos; =&gt; 1)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">function test($data, $pid)</span><br><span class="line">&#123;</span><br><span class="line">    static $arr = [];</span><br><span class="line">    foreach ($data as $key=&gt;$value) &#123;</span><br><span class="line">        if ($value[&apos;id&apos;] == $pid) &#123;</span><br><span class="line">            $arr[] = $value;</span><br><span class="line">            test($data, $value[&apos;parent_id&apos;]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(test($address, 4));</span><br><span class="line"></span><br><span class="line">// 上面方法在多次循环获取的时候因为static变量的原因会出现一直叠加的错误</span><br><span class="line">// 下面是改进的方法</span><br><span class="line"></span><br><span class="line">function test1($data, $pid, &amp;$arr)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    foreach ($data as $key=&gt;$value) &#123;</span><br><span class="line">        if ($value[&apos;id&apos;] == $pid) &#123;</span><br><span class="line">            $arr[] = $value;</span><br><span class="line">            test($data, $value[&apos;parent_id&apos;]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var_dump(test($address, 4, []));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">庐阳区，合肥，安徽</span><br></pre></td></tr></table></figure><p>子孙树的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function test1($data, $id, $level = 1， &amp;$arr)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    foreach ($data as $key=&gt;$value) &#123;</span><br><span class="line">        if ($value[&apos;parent_id&apos;] == $id) &#123;</span><br><span class="line">            $value[&apos;level&apos;] = $level;</span><br><span class="line">            $arr[] = $value;</span><br><span class="line">            test1($data, $value[&apos;id&apos;], $level + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//level主要用来显示是几级的儿子</span><br></pre></td></tr></table></figure><p>还记得我们在大学学习数据结构的时候，因为递归对于效率有影响，所以经常需要把递归改成迭代，上述家谱树容易修改，子孙树需要用到栈，自己不是很理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 家谱树递归的修改成普通方式</span><br><span class="line">function test2($data, $pid， &amp;$arr)</span><br><span class="line">&#123;</span><br><span class="line">    while ($pid != 0) &#123;</span><br><span class="line">        foreach($data as $key=&gt;$value) &#123;</span><br><span class="line">            if ($value[&apos;id&apos;] == $pid) &#123;</span><br><span class="line">                $arr[] = $value;</span><br><span class="line">                $pid = $value[&apos;parent_id&apos;];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br><span class="line">var_dump(test2($address, 4));</span><br><span class="line">//迭代和递归的转换主要就是靠迭代找到那个停止往上找的条件</span><br></pre></td></tr></table></figure><p>大致就是上面这些，像面包屑导航，不要看着从左到右，其实他也是一棵家谱树，因为他从始至终就只有一棵树。</p><p>还有就是移动各个部门位置问题：</p><p>想象一下，一棵树，我把某个分支截取下来放到另一个分支上是很正常的事情，但问题是有时候，我会出现把父亲节点的父亲设置成自己的子节点，这样树枝就断了，这样是不可取的，除此之外，任意移动都是可以的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域 cookie</title>
    <link href="http://yoursite.com/2018/06/06/%E8%B7%A8%E5%9F%9F-cookie/"/>
    <id>http://yoursite.com/2018/06/06/跨域-cookie/</id>
    <published>2018-06-06T10:30:54.000Z</published>
    <updated>2018-06-06T12:20:16.767Z</updated>
    
    <content type="html"><![CDATA[<p>cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。</p><a id="more"></a><p>cookie,对于传统的lamp架构，在服务器端想获取可以通过$_COOKIE[]数组获取到，但是对于swoole这种自己搭建web服务的东西，只能通过request请求获取，其实lamp里面本质也是这样，也是把apache或者nginx获取到的请求内容放到了php的\$_COOKIE里面，类似的\$_SERVER, \$_GET,这些在swoole里面都是永不了得，你可以把http-&gt;request-&gt;get 的值在请求到来的时候给与\$_GET数组，这样就能在swoole搭建的web服务里面和普通的lamp架构一样使用\$__GET数组了。正因为swoole的这些特性，像如果在swoole里面使用session登录机制需要自己去实现，还有对于一些框架的集成，因为外部传入的参数不在那些数组中了，所以需要对框架进行修改，让框架能获取到对应的参数，保证框架的运行，比如：swoole集成slime框架(swoole在客户端设置cookie也得用它自带的方法而不是setcookie)。</p><p>回归正题，通过上述，我们也只cookie是一个数组，那其中哪把钥匙是用来打开session的呢，答案是PHPSESSID,这个值是可以设定的，在php.ini,或者通过php的session函数来获取到。</p><p>对于session，我觉得他更像是一个模块的扩展，他不仅仅是提供一系列的简单的函数，这些函数其实还有具体的活动的封装。比如开启session的时候，session_start(),他做的东西有很多，首先检测客户端是否有 phpsessid，如果没有，通过函数setcookie，在客户端种植，其实底层就是通过在返回的header头信息中加入set-cookie，如果已经有phpsessid，会通过寻找客户端对应的session，获取里面的信息。那问题又来了，这个phpsessid的cookie是怎么传送给服务端的呢，我不记得我有加入这个cookie啊，一般情况下，在发送http请求的时候，默认都会带上浏览器的cookie。如果禁用了还可以通过url传递哦，话说从url中获取phpsessid也是在session_start()函数中实现的，可见这个函数的复杂性，和普通的函数还是不一样的，里面有具体的逻辑。</p><p>对于cookie的设置，也是有跨域问题的，a.test.com下的cookie,在b.test.com下面不能获取到，但是如果在test.com下面就能获取到了，为什么呢？看看跨域吧。不信？你可以设置下，在/path页面下设置另一个path的cookie，然后去对应的path下刷新，看是否有，答案是肯定有的啦。所以cookie的设定。path是不影响的。</p><p>既然能设定，自然就能删除，设定和删除可以归为一类操作（直接把过期时间设定成当前时间-100就可以删除了，注意cookie有max-age存在的时间和expire过期时间之分，php的setcookie设定的时间是expire时间，所以需要在过期时间+time()!!之前就犯了这个错误）</p><p>其实php的setcookie也能验证这点。在控制器中调用setcookie，如果不传path，默认是当前path，但也可以加path,比如/。</p><p>但需要注意的是不同path下面不能相互读取!!!怎么试验呢，可以在chrom的application下面写,然后在当前path写同一个域名下的另一个path，刷新cookie，发现另一个页面下面的有这个设置的cookie，请求的时候也能带上，但是自己这个设定页面没有，所以有时候如果setcookie没错误，但也没出现cookie，可以考虑下是不是设置路径错误了，虽然设置上了，但是看不见。这种情况特别容易出现在前后端分离的情况下，前端在80端口下，后端在8080端口下，后端api设定cookie是装在了8080那个域名下面，所以你无论怎么刷新前端页面都不会有这个cookie，但是没关系，当你请求后端接口的时候，请求会自动加上！！但要注意，请求的时候，http请求只能把他当前能看到的cookie带上，对于他看不见的肯定不会带上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2018/06/06/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/06/06/跨域/</id>
    <published>2018-06-06T09:34:20.000Z</published>
    <updated>2018-06-06T13:55:05.334Z</updated>
    
    <content type="html"><![CDATA[<p>跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。</p><a id="more"></a><p>关于浏览器同源策略的原因，可以网上查看各种资料，阮一峰的博客是个很好的选择。</p><p>什么时候会出现跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/dir2/other.html：同源</span><br><span class="line">http://example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</span><br><span class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</span><br><span class="line">组成一个域名（协议号：//ip地址：端口号）三者任意一个不同就会出现跨域</span><br></pre></td></tr></table></figure><p>如果解决跨域呢，自己主要了解的有两种，分别是cors和jsonp,自己平时用的主要是cors。</p><p>cors可以让后端代码不用做过多的变动，只需要对返回的内容多添加些头部信息即可。</p><p>jsonp主要是通过script，img标签这类不存在跨域，回忆一下，是不是通过img加载过百度的图片，通过script的src加载过cdn上的jquery。</p><p>通过script返回的内容因为在script标签内部，所以可以执行script代码，所以当我们传给后端我们定义好的方法名，然后让他们把我们需要的数据放进去，再返回来，类似 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showData(&#123;&quot;1&quot;:&quot;boy&quot;&#125;);</span><br></pre></td></tr></table></figure><p>上面的返回结果在script代码中自动执行，就能得到我们想要的结果（需要注意的是传入的数据必须是json类型哦，毕竟后端和js是不同的语言类型，然后我们只需要在showData里面对json数据进行转换成js能识别的数据即可）。</p><p>对于jsonp，我用的比较少，因为很多时候不想特别写专门用来跨域的api接口，所以如果要用jsonp，后端逻辑代码需要更改（百度php如何配合jsnop完成数据传输）。</p><p>对于前端，像jquery有对jsonp的封装，可以自定义函数，然后传入，返回的数据会先走定义的函数，然后来到success函数里面，注意success传入的参数data是不包括后端返回的内容中的函数，而是函数的参数们。</p><p>juqery默认传的自定义函数名称是jquery带一长串数字，具体的用法可以百度查看，我没咋用过。</p><p>还有哦，jsonp只能支持get请求。</p><p>鉴于上面诸多的麻烦，我用的主要是cors。</p><p>首先我们需要知道浏览器将跨域请求分成了简单请求和非简单请求，什么是非简单请求，就是那些不是get post（请求方式）,返回头信息中加入token这类自定义的东西，就是非简单请求，一般情况下，我们的请求都是非简单请求，毕竟简单请求content-type 好像都不能是json类型。</p><p>对于非简单请求，会先在正式请求之前发送一个options请求，当有跨域请求的时候，我们可以看下Chrome的控制面板，很清楚的能看到。对于返回信息，我们需要加以下头信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); //允许的ip</span><br><span class="line">$response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;); //允许的方法</span><br><span class="line">$response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, token&apos;);</span><br><span class="line">//自定义的头部信息</span><br></pre></td></tr></table></figure><p>大致只需要做这些处理，一般像php，只需要在router的 end（返回具体信息）之前加上上面的信息就可以了。</p><p>像node，或者swoole都在启动web服务的文件处加上即可。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP opcache</title>
    <link href="http://yoursite.com/2018/05/25/PHP-opcache/"/>
    <id>http://yoursite.com/2018/05/25/PHP-opcache/</id>
    <published>2018-05-25T07:38:57.000Z</published>
    <updated>2018-05-25T08:02:29.565Z</updated>
    
    <content type="html"><![CDATA[<p>opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。</p><a id="more"></a><p>原理：大概的意思就是把php的脚本一次性全存入内存中，然后每次读取脚本直接从这里面取，而不用每个连接都读取一份脚本。</p><p>但这样就存在修改数据后服务器识别不到，可以配置参数，多少秒服务器检查一次，但一般生产环境直接把配置成0，就是间隔时间是0，单位是s，然后停止检查，而开发环境参数配置成1，一直检查，这样就不会存在修改文件，没有效果了。</p><p>还可以手动清除，必须脚本中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opcache_reset()</span><br></pre></td></tr></table></figure><p>但需要注意的就是不同模式下储存脚本是在不同的内存空间中，比如cli下执行脚本文件，和通过浏览器这种mod_php清除是不一样的，所以浏览器访问的话就通过浏览器的方式去执行脚本吧。</p><p>当然，如果和我们swoole那样，每次修改代码后重启web服务器，那是根本不存在这种情况的。</p><p>话说偶然间发现代码的不同方式发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.类似前端代码那种，每次新代码的发布都会重新打个包，然后把站点目录通过软连接指向这个新包</span><br><span class="line">2.我们现在用的，通过在服务器上更新svn上的代码，来发布新的代码</span><br></pre></td></tr></table></figure><p>首先运行环境是php7.014,线上环境是php5.6,效果不是十分明显，还有opcache_reset() byte-code不是十分好用。</p><p>首先得开启这个扩展，在phpinfo中查找opcache或者 php -m 中查找opcache，其实直接php -m就好了，会有个很显眼的ZendOpcache,</p><p>安装方法就是因为默认编译的时候大部分都有–enable-opcache,或者phpinfo页面上可以看见编译的参数，直接在php.ini 里面开启zend_extension=opcahce.so就好了，或者下载文件源码编译。</p><p>或者重新编译一下php（这个忘记了）</p><p>或者可以像pgsql那样去php源码包里面找源文件进行编译？这样可行吗，没有试过。</p><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opcache.validate_timestamps=1 //是否检测修改</span><br><span class="line">opcache.revalidate_freq=0//单位时间</span><br><span class="line">opcache.memory_consumption=64  //memory_consumption 这个参数很好理解，代表这块内存区开辟的大小，另外需要注意不同 PHP SAPI 内存区不是共享的，就是说同一个 PHP 文件，运行在命令行模式或者 PHP-FPM 模式下，对应的 byte-code 会存储在不同的内存区中。</span><br><span class="line">opcache.max_accelerated_files=4000 //如果命中率不搞，可以适当提升这个值，直到1。</span><br><span class="line">opcache.opcache.fast_shutdown=1  //modern php上面说这个写1就可以了</span><br></pre></td></tr></table></figure><p>（opcache_get_configuration()和 and opcache_get_status()）获取配置信息和运行信息，比如了解那些文件被缓存了、使用了多少内存、内存命中率等等。</p><p>感觉就是基于这两个函数出了两个opcache的项目，一个是单页面，一个比较复杂</p><p>1.<a href="https://github.com/PeeHaa/OpCacheGUI" target="_blank" rel="noopener">PeeHaa / OpCacheGUI</a></p><p>2.<a href="https://github.com/rlerdorf/opcache-status" target="_blank" rel="noopener">rlerdorf / opcache-status</a></p><p>单页面的部署直接放在网站根目录下就好了，就理解成phpadmin那种网点就好了，利用的就是php的函数获取php的运行环境，然后可视化展示出来</p><p>opcache_invalidate()，这个函数就是更新特定的文件缓存，没去试验过，因为项目小啦，直接重启web server。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
