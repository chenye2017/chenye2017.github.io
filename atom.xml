<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-09T12:52:51.286Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>go 数据库原生操作</title>
    <link href="http://yoursite.com/2020/06/09/go-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%94%9F%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/06/09/go-数据库原生操作/</id>
    <published>2020-06-09T12:28:16.000Z</published>
    <updated>2020-06-09T12:52:51.286Z</updated>
    
    <content type="html"><![CDATA[<p>go web 开发，操作mysql 是基础啦</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">   &quot;database/sql&quot;</span><br><span class="line">   _ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">)</span><br><span class="line">首先是包的引入，很常见吧，下面那个驱动引入，却未使用可能是只希望使用这个包的 init()方法</span><br></pre></td></tr></table></figure><blockquote><p>通常来说, 不应该直接使用驱动所提供的方法, 而是应该使用 sql.DB, 因此在导入 mysql 驱动时, 这里使用了匿名导入的方式(在包路径前添加 _), 当导入了一个数据库驱动后, 此驱动会自行初始化并注册自己到Golang的database/sql上下文中, 因此我们就可以通过 database/sql 包提供的方法访问数据库了.</p><p>可能这就是interface 的作用吧</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type DbWorker struct &#123;</span><br><span class="line">    //mysql data source name</span><br><span class="line">    Dsn string </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    dbw := DbWorker&#123;</span><br><span class="line">        Dsn: &quot;user:password@tcp(127.0.0.1:3306)/test&quot;,</span><br><span class="line">    &#125;</span><br><span class="line">    db, err := sql.Open(&quot;mysql&quot;,</span><br><span class="line">        dbw.Dsn) // 返回一个sql.DB 的指针</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>sql.Open并不会立即建立一个数据库的网络连接, 也不会对数据库链接参数的合法性做检验, 它仅仅是初始化一个sql.DB对象. 当真正进行第一次数据库查询操作时, 此时才会真正建立网络连接;</li><li>sql.DB表示操作数据库的抽象接口的对象，但不是所谓的数据库连接对象，sql.DB对象只有当需要使用时才会创建连接，如果想立即验证连接，需要用Ping()方法;</li><li>sql.Open返回的sql.DB对象是协程并发安全的.</li><li>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</li></ol><p>所以我们平时用的都是长连接，在池子里面可以复用的啦。平时我们在 prepare ，query(查询)， exec(插入，修改) 之后都要及时 close</p><p>MySQL 5.5 之前， UTF8 编码只支持1-3个字节,从MYSQL5.5开始，可支持4个字节UTF编码utf8mb4，一个字符最多能有4字节，utf8mb4兼容utf8，所以能支持更多的字符集;关于emoji表情的话mysql的utf8是不支持，需要修改设置为utf8mb4，才能支持。</p><p>(4 字节的utf8 我们应该一直在用啦)</p></blockquote><p>插入代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;insert tasks (content, user, create_at, update_at, deleted) values (?, ?, ?, ?, ?)&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">now, _ := time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2016-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">update := time.Now().Format(&quot;2006-01-02 15:04:05&quot;)</span><br><span class="line"></span><br><span class="line">result, err := stmt.Exec(&quot;测试&quot;, &quot;cy&quot;, now, update, 0)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(result.LastInsertId())</span><br></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(&quot;update tasks set content = ? where id = ?&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">stmt.Exec(&quot;ceshi11111&quot;, 2)</span><br></pre></td></tr></table></figure><p>查询代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:wyqnkxk2012_CY@tcp(118.184.219.156)/cy&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">err = db.Ping()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//update(db)</span><br><span class="line">//return</span><br><span class="line"></span><br><span class="line">stmt, err := db.Prepare(&quot;select * from tasks where id = ?&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(stmt)</span><br><span class="line">&#125;</span><br><span class="line">defer stmt.Close()</span><br><span class="line"></span><br><span class="line">rows, err := stmt.Query(3)</span><br><span class="line"></span><br><span class="line">defer rows.Close()</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Println(rows)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr := []*task&#123;&#125;</span><br><span class="line"></span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">tmp := &amp;task&#123;&#125;</span><br><span class="line">rows.Scan(&amp;tmp.id, &amp;tmp.content, &amp;tmp.user, &amp;tmp.create_at, &amp;tmp.update_at, &amp;tmp.deleted)</span><br><span class="line">arr = append(arr, tmp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go web 开发，操作mysql 是基础啦&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>go time 包</title>
    <link href="http://yoursite.com/2020/06/09/go-time-%E5%8C%85/"/>
    <id>http://yoursite.com/2020/06/09/go-time-包/</id>
    <published>2020-06-09T11:47:50.000Z</published>
    <updated>2020-06-09T12:39:13.881Z</updated>
    
    <content type="html"><![CDATA[<p>go 中时间包的使用</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">time.Now() // time 包的 Time 类型</span><br><span class="line"></span><br><span class="line">// Time</span><br><span class="line">// 2018-05-31 09:22:19 +0800 CST Time 类型打印出来长这样</span><br><span class="line">time.Now() // 获取当前时间的Time 类型</span><br><span class="line">time.Now().Unix()  Time 类型装 int64</span><br><span class="line">time.Now().Unix()Formate(&quot;2006-01-02 15:04:05&quot;) // 格式化</span><br><span class="line">time.Now().in(a)  // 使用某个时区，返回的是Time 类型，所以可以用</span><br><span class="line"></span><br><span class="line">// location</span><br><span class="line">time.Location() // 返回时区信息</span><br><span class="line">a,_ := time.LoadLocation(&quot;UTC&quot;)  // time 包的 location,如果想用时区，就得用这个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 数字转Time</span><br><span class="line">time.Unix(11111)</span><br><span class="line"></span><br><span class="line">// 字符串转Time</span><br><span class="line">time.Parse() 和 Time.Format() 是互逆的两个函数</span><br><span class="line">time.Parse() 解析字符串成Time 的时候需要时区信息，我们可以用Loadlocation获取时区信息，然后作为第三个参数传进去</span><br><span class="line"></span><br><span class="line">// Duration </span><br><span class="line">这个在sleep 的时候经常用到</span><br><span class="line">const (</span><br><span class="line">    Nanosecond  Duration = 1</span><br><span class="line">    Microsecond          = 1000 * Nanosecond</span><br><span class="line">    Millisecond          = 1000 * Microsecond</span><br><span class="line">    Second               = 1000 * Millisecond</span><br><span class="line">    Minute               = 60 * Second</span><br><span class="line">    Hour                 = 60 * Minute</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 中时间包的使用&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="time" scheme="http://yoursite.com/tags/time/"/>
    
  </entry>
  
  <entry>
    <title>go 环境搭建</title>
    <link href="http://yoursite.com/2020/06/06/go-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/06/go-环境搭建/</id>
    <published>2020-06-06T08:24:09.000Z</published>
    <updated>2020-06-06T08:51:03.191Z</updated>
    
    <content type="html"><![CDATA[<p>go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了</p><a id="more"></a><p>学习任何一门语言，刚开始面对的第一个问题就是环境的搭建吧，相较于php的编译安装，go的环境搭建更加简单。</p><p>首先要明确的一点是go 是交叉编译，所以我们无论在win 还是 mac 还是 linux 下开发都是一样的。php 有很多扩展比如redis ，在win下版本比较少，所以我们不得不需要一个linux 环境， 我们平时开发php ，是把远程服务器的代码sftp 到本地，然后本地代码的修改实时上传到服务器上，在服务器上跑。go不需要 （goland 甚至连着个功能都没有，需要装插件）。</p><ol><li><p>下载go的安装包，因为墙的原因，我们可以去 studygolang 上面下载，win和 mac 都是那种点击下一步傻瓜般的安装，linux 下安装也很简单，下载解压完之后就是一个编译好的二进制包（就像php 编译完成那样）。我们只需要把 我们环境变量的 path ，添加上 go下载包中的bin，就能直接使用go的命令了。linux 下可以直接编译 /etc/profile, source /etc/profile 生效。保存好后 echo  $PATH，查看path 。</p></li><li><p>go 安装需要注意的几个路基</p><p>goroot  就是我们（linux 下解压完go 安装包的地址，win 和 mac 下是我们自己制定的go 安装路基）</p><p>gopath 是我们自己制定的一个文件夹，需要在这下面手动建立 bin， pkg， src 三个目录，其中bin 是我们日后编译生成二进制文件的地方，pkg 很重要，里面的mod 文件就是我们安装的第三方库所在的目录，src 就是在 go mod 没出现前，我们存放我们项目代码的地方(之前就觉得我们的代码只能存放在一个地方，很不方便，go mod 的出现就不需要管这个文件夹了）</p><p>go env 我们可以查看和 go 相关的 环境变量，必要重要的有  GO111MODULE, 怎么设置  go env -w </p><p> GO111MODULE=”on”,  还有 GOPROXY=<a href="https://goproxy.cn,direct，" target="_blank" rel="noopener">https://goproxy.cn,direct，</a> goproxy.cn 就是 七牛云搞的golang 下载包中国镜像，后面的direct 代表如果找不到，就直接按照网址下载。go 的第三方包的命名很好玩，基本就是这个仓库所在的可以访问的url 路径，比如 code.shihuo.cn/xxx/xxx, 不需要像composer 那样中间走一层代理，那层代理还要给你开访问权限，才能下载。</p></li></ol><p>3.在用goland 编辑的时候，会遇到包找不到的请款，我们需要手动 seting 去配置 goroot  gopath ，还要开启vgo（就是gomod）</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200606164735.png" alt=""></p><p>这个地方要选空，否则还是会出现包找不到的问题。</p><p>4.go mod 的使用，go mod init xxx 初始化项目，生成 go mod 文件，类似composer init 生成 composer.json，go run main.go 开始跑项目啦。会自动下载需要的安装包，这个相比于composer install 更加的方便。</p><p>以上就是总结的 go 环境安装，完结~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go越来越流行了，加上公司的业务需求，迫使我必须得开始学习go了&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="环境搭建" scheme="http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>rabbitmq记录</title>
    <link href="http://yoursite.com/2020/05/26/rabbitmq%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/05/26/rabbitmq记录/</id>
    <published>2020-05-26T03:45:16.000Z</published>
    <updated>2020-06-07T10:55:50.893Z</updated>
    
    <content type="html"><![CDATA[<p>rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 <a href="http://docs.php.net/manual/da/book.amqp.php" target="_blank" rel="noopener">http://docs.php.net/manual/da/book.amqp.php</a>，一种是市面上比较流行的库<a href="https://github.com/php-amqplib/php-amqplib" target="_blank" rel="noopener">https://github.com/php-amqplib/php-amqplib</a>， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。</p><a id="more"></a><h3 id="不同的角色"><a href="#不同的角色" class="headerlink" title="不同的角色"></a>不同的角色</h3><p>关于rabbitmq 的理论知识，<a href="https://www.cnblogs.com/wutianqi/p/10043011.html" target="_blank" rel="noopener">https://www.cnblogs.com/wutianqi/p/10043011.html</a>， 这篇文章讲解的很清楚。</p><p>生产者 : 也是通过channel， 去 declare 一个 队列 ，然后发送消息（为什么要使用channel， 因为tcp 连接断开重建很浪费资源）。如果中间没走exchange 的 话，就不需要 routing key 了 。很多人经常把routing key 和  队列名称写一样，因为可能这个消息当初考虑的时候就是专门给这个队列queue 使用的。但其实 routing key  和 queue 可以不一样的，消费者在定义自己的队列便于接受 exchange 投递过来的消息，routing key 就相当于一把钥匙，可以打开这个队列的门。</p><p>上面关于生产者的描述并不准确，上面的过程大概就是单个脚本发送消息的过程，是一种翻译。准确的生产者只做一件事，就是发送消息。首先获取connection， 再通过connection 去获取channel (如果是消费者的channel ，我们在rabbitmq的管理界面还能获取到这个消费者的详细信息)。然后通过channel 去 publish 消息，就结束了。其中关于exchange 的 declare ，是重复的操作，我们可以提取出来，而不分给生产者发送消息这个行为 ，因为publish 的时候我们是不需要exchange 的declare 的，我们完全可以手动在web 上新建exchange， 然后publish的时候填入 exchange 的名称。同理 queue的declare 也是如此。所以我们在生产者消费者的同时，我们可以一方去declare 就好了。</p><p>channel 的publish 方法第二个参数是key ，当我们是 简单或者工作或者 fanout 模式的时候，这个key 就是 queue的名称。一定要注意如果这个key 是空的，或者不存在，我们的消息就会丢弃，因为没地方存储。</p><p>说到这里，就需要注意一下我之前的一个误区，开了生产者，然后启动消费者，消费者拿不到消息，消息为啥丢失了吗？我的理解中，不应该消息积存了，后来消费者启动了，开始消费吗？其实主要是exchange 不能存消息的，当我们启动消费者的时候，经常会启动一个队列，如果这个队列以前不存在，exchange拿着routing key 匹配不到 队列，就会把这个消息丢失。</p><p>消费者：和上面的生产者对应</p><p>同理，消息者其实也是获取到一个connection， connection 获取到channel ，我们就可以去消费消息了 （go 消费消息好像只能用协程的方式）。channel consume 的时候需要一个 queue 的名称，其他什么都不需要。但我们需要把这个queue 绑定到对应的exchange 上，注意了！！！因为识货一直用的routing key 都是字符串，所以不涉及匹配模式，所以我们很容易把生产者的routing key 和 消费者的routing key 当做一个，其实在topic 模式下  queue的 routingkey 需要是正则表达式，比如 #.coupon.#, 生产者 1.coupon.2 就能被这个消费者消费到，不要搞反了。 #可以接收到所有的消息。</p><p>总结：</p><p>所以我觉得，对于生产者，可以定义exchange ，但是queue 这些没必要，因为我们发送消息的时候只要exchange ，和 routing key 。</p><p>对于消费者，可以定义exchange （如果生产者没定义）。需要定义queue，因为consume 的时候需要，需要queue bind exchange 利用 binding key。</p><p>消息代理： broker ，kafka 也有这个玩意，但kafka 的broker 上面有分区，可以存储消息 （rabbitmq 就是一种消息代理）</p><p>虚拟主机：vhost,  识货到现在都没用 （可以利用不同域名区分生产和开发环境，识货直接用的不同的ip）</p><p>交换机：exchange，识货到现在只用一个exchange 就是 amp.topic</p><p>绑定： binding， 把队列queue 和 exchange 绑定起来</p><p>路由键： routing key， 生产者把消息推送到 exchange 上</p><p>队列：queue</p><p>连接： connection</p><p>通道： channel</p><p>消费者： consumer</p><h3 id="不同的工作模式"><a href="#不同的工作模式" class="headerlink" title="不同的工作模式"></a>不同的工作模式</h3><p>一共有5中</p><p>没有exchange 的有simple 和 work 模式，simple  p -&gt; queue-&gt;c,  这样</p><p>work  p-&gt; queue -&gt;(c1, c2)</p><p>exchange 又分多种工作模式，比如topic, direct, fanout. (这三种相较于上面的 work 模式就是不同的队列消费的是同样的消息)。工作中其实我们无意的都在使用work 模式，因为会启动多个消费者。之所以多个消费者消费不同的消息，是因为我们的生产者的routingkey 是不一样的，即使我们消费者的binding key 是一样的。</p><p>识货用的都是direct  （虽然 amq.topic 这个交换机的类型是topic ），但是绑定 exchange 的queue 的 bindingkey 一直类似 a.b.c 这样，所以其实就是direct。这种有个坏处就是某个queue 需要另一个routing key的数据，我们不得不在这个queue上绑定一个新的bindingkey 对应这个新的routing key， topic 模式就是为了解决这个问题出现的 ， bindingkey 对于 routing key 的模糊匹配。那什么是fanout呢，fanout就是不要routing key 的 direct， 直接推所有绑定到 exchange的 queue。</p><h3 id="写代码的时候应该注意的几个属性"><a href="#写代码的时候应该注意的几个属性" class="headerlink" title="写代码的时候应该注意的几个属性"></a>写代码的时候应该注意的几个属性</h3><p>交换机的属性：（识货就用一个交换机 amp.topic 所以这些都没用用过）</p><p>name:</p><p>durable: 持久化，消息代理重启后，交换机是否还存在。交换机有两个状态，持久（durable）、暂存（transient）。持久化的交换机会在消息代理重启后依旧存在，而暂存的交换机则不会。</p><p>auto-delete: 当所有与之绑定的消息队列都完成了对此交换机的使用后，删掉它。</p><p>arguments: 依赖代理本身</p><p>队列属性：</p><p>name:</p><p>durable: 消息代理重启后，队列是否还在。</p><p>exclusive:  只被一个连接使用，连接关闭后，将立即删除队列。（这个排他性也很坑爹，如果设置了，经常别的连接不能用）</p><p>auto-delete: 当所有的消费者都退订队列后将自动删除该队列 .(如果设置false， 经常就是消费者没了，队列也就没了)</p><p>消息属性：(识货这边从来没设置过，照样跑)</p><ul><li><p>Content type（内容类型）</p></li><li><p>Content encoding（内容编码）</p></li><li><p>Routing key（路由键）</p></li><li><p>Delivery mode (persistent or not)</p><p>Delivery mode (persistent or not)<br>投递模式（持久化 或 非持久化）</p></li><li><p>Message priority（消息优先权）</p></li><li><p>Message publishing timestamp（消息发布的时间戳）</p></li><li><p>Expiration period（消息有效期）</p></li><li><p>Publisher application id（发布应用的ID）</p></li></ul><p>消息确认：</p><p>消息确认开启后，如果我们没有确认消息，消息会是 unack 状态，当消费者挂掉后，几秒中unack的消息会重置成total 未消费状态 (一定要注意)</p><p>未确认的东西。识货的消息从来没有设置持久化状态，但是mq 挂掉了之后消息还能找回来。</p><p>(消息能够以持久化的方式发布，AMQP代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。)</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162641.png" alt=""></p><p>要善于利用rabbitmq 的管理界面，注意detail 那块，这是我们使用死信队列造成延迟队列。</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20200526162949.png" alt=""></p><p>下面的consumer 可以知道绑定的消费者</p><p>下面的binding 就是通过routingkey 绑定的信息</p><h3 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h3><p>延迟队列的应用场景：比如订单三十分钟内付款有效。</p><p>实现方式：<a href="https://www.cnblogs.com/-mrl/p/11113989.html" target="_blank" rel="noopener">https://www.cnblogs.com/-mrl/p/11113989.html</a></p><p>rabbitmq 延迟队列的实现方式：通过消息过期，转发到死信交换机中。消息过期有两种方式，一种是消息自己的存活时间到达还没有消费，一种是队列的时间到达但其中的消息没有被消费，这两种情况消息都会被投递到死信队列中。</p><p>区别：第一种我们可以单独对每个消息设置存活时间，不需要为了每个不同的时间建立不同的队列，比如a消息三十分钟过期，b消息40分钟过期，我们都投递到一个没有消费者的队列中，消息到期了自动转发到死信队列中。</p><p>补充：</p><p><a href="https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/" target="_blank" rel="noopener">https://jaskey.github.io/blog/2018/08/15/rabbitmq-delay-queue/</a></p><p>上面的做法好像缺点更大，容易造成队列堵塞，所以还是弄成不同时间级别的队列吧。</p><p>​</p><p>识货从来没有nack 这种操作，只有ack。</p><p>nack 不等同于超时，超时是还没有应答，属于 unack，nack 是应答错误 ，是程序执行完了。（nack 如果需要重回队列，需要设置 repeat  true，消息回到队列头部重新开始消费，我们需要注意消费消息的幂等性， 还要小心造成死循环。如果没有设置repeat true ，消息会被丢弃）</p><p>unack 的消息在这个消费者挂掉重启的时候会重新被消费 （或者可以被自己的兄弟消费者消费掉）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;rabbitmq是一款实现amqp 协议的软件，我们在通过php 使用rabbitmq 的时候有两种方式（类似php 使用redis，一种是通过c扩展的方式，一种是纯php实现的lib 包。其实还有异步引擎，swoole是通过c扩展的方式，workman 是通过php 实现的lib包），一种是安装php 的amqp扩展 &lt;a href=&quot;http://docs.php.net/manual/da/book.amqp.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.php.net/manual/da/book.amqp.php&lt;/a&gt;，一种是市面上比较流行的库&lt;a href=&quot;https://github.com/php-amqplib/php-amqplib&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/php-amqplib/php-amqplib&lt;/a&gt;， 识货内部就是通过简单使用这个库来进行和rabbitmq的交互。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="rabbitmq" scheme="http://yoursite.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>golang-类型转换</title>
    <link href="http://yoursite.com/2020/05/07/golang-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/07/golang-类型转换/</id>
    <published>2020-05-07T13:08:47.000Z</published>
    <updated>2020-05-07T13:15:16.446Z</updated>
    
    <content type="html"><![CDATA[<p>类型转换经常用来</p><a id="more"></a><p>golang是强类型语言, 就算int64 和 int 都要相互转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strconv.Atoi   字符串转int</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类型转换经常用来&lt;/p&gt;
    
    </summary>
    
      <category term="golang" scheme="http://yoursite.com/categories/golang/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>外接广告</title>
    <link href="http://yoursite.com/2020/04/21/%E5%A4%96%E6%8E%A5%E5%B9%BF%E5%91%8A/"/>
    <id>http://yoursite.com/2020/04/21/外接广告/</id>
    <published>2020-04-21T03:36:04.000Z</published>
    <updated>2020-04-21T07:58:39.475Z</updated>
    
    <content type="html"><![CDATA[<p>最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。</p><a id="more"></a><p>首先介绍一下前置知识吧，对于ios 和 android 手机的标识。ios手机现在一般用idfa， 但是用户可以关闭广告追踪，那我们获取到的就是一堆 0000-000··这样乱七八糟的东西，毫无价值，为了实验效果，我们一定要开启ios手机的广告追踪。（怎么快速获取当前手机的idfa，可以在appstore中下载一个myidfa,可以快速获取到，注意字母都是大写）。所以要是苹果手机用户关闭了广告跟踪，那么我们就完全追踪不到点击广告的用户信息了，广告的转化率我们必然</p><p>android 手机五花八门，之前一般都是用的imei ，然后有的手机可能还有多个，目前没有考虑很多的情况，都是取的默认的第一个。但现在imei好像逐渐开始也获取不到了，国内的手机一般用的都建议用oaid，据说覆盖量已经 80%以上（但是oaid是国内手机联盟定的东西，像海外的安卓机器是没有的，而且现在识货android客户端也是不支持回传oaid的）</p><p>主要流程：当我们app（识货）在头条（或者朋友圈）上面投放广告的时候，当用户点击我们投放的广告，会给我们的web server发送一条请求，这个请求包括用户的基本信息，比如ios 的idfa 或者android 的imei,还有个call_back,类似标识这个用户信息是头条回传给我们的，我们拿到这个信息存储下来，当用户启动我们app的时候，我们可以把这个用户的信息（imei 或者 idfa）和 头条回传给我们的信息作比对，如果对应上，然后时间间隔在我们希望之内（比如两天），就可以当做这个用户是头条带来的。</p><h1 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h1><p>头条应该是接入的几个广告主中最简单的。头条是没有账号区分的（接口中让我们传入sign，但其实可以不用传），所以当我门投放部使用多账户进行广告投放，在我们代码中是没有影响的，我门只需要调用头条的上传用户行为的接口，传入设备信息和call_back 就好了。</p><p>坑点：</p><p>1.首先我们要区分开发者和广告主两个角色，开发者角色在这次广告对接中基本没啥用处，就是用来看开发者文档的。广告主角色很重要，因为我们配置好监控链接，联调上传行为的时候需要用广告主角色登陆后台管理界面，进行联调（填写头条用户id，然后刷新头条信息流，出现联调广告，点击，观察头条发起调用我们的url，我们可以直接拿这条url测试我们的监控接口是否正常，然后取出callback 和 idfa或者imei，作为参数调用头条的上传用户行为,这就是整个步骤啦，注意imei属于隐私数据，所以会用md5加密）</p><p>2.在我们联调的时候需要填写很多信息，比如下载链接，ios就是App Store我们应用的连接，android 需要我们上传apk到头条或者自己上传一个到七牛云，说白了，用户点击广告需要下载，我们给他们提供一个下载地址（好像不能用应用宝地址，因为腾讯？）</p><p>3.主要就是上面两个，剩下的就是代码设计方面，首先是对于表的设计，因为头条那边我们回传用户行为不需要去重，所以我们之前的代码中自己检测到属于头条带来的新用户直接就上报了，自己没做任何处理，比如记录日志，比如存表。这样带来一个坏处就是万一逻辑哪里出错了，不好排查，比如我们和bi那边做数据差异对比，完全拿不出证据证明这个用户在我们逻辑中属于新用户，为什么bi那边不算新用户，所以可以把用户的上报行为时间也存下来。</p><h1 id="快手"><a href="#快手" class="headerlink" title="快手"></a>快手</h1><p>快手和头条内容基本一致，就是快手不支持去重，只能我们这边自己去重，所以我们终究要保存下我们上传的用户信息，再次触发上报条件的时候，需要检测之前是否上报过。</p><p>（为什么我们会触发多次激活的上报条件？按理说不正常，但历史原因是识货这边在获取用户启动信息的list里面可能第一次没有获取到imei 或者idfa，这样用户虽然激活了，但是没法匹配到头条那边的点击广告信息，只能在第二次用户启动app的时候去激活）</p><p>快手比价坑的就是他的callback往往很长，··长的你不能想象，所以我们要注意数据库是否会自动截断。</p><h1 id="广点通"><a href="#广点通" class="headerlink" title="广点通"></a>广点通</h1><p>广点通相比较上面二者更加复杂，首先就是多账户系统和开发者。</p><p>1.开发者需要把多账户（多个广告主）接通流程，首先开发者需要自己建立一个应用（这个应用不用区分ios 和 android ，目的就是获取一个appkey 和 appsecret, 这个信息在我们上传用户行为的时候需要，头条那边之前以为也需要，但是他那个sign 可以不传，所以这个应用可以不建立）</p><p>2.建立好应用之后就需要我们通过腾讯系老一套的oauth2.0 ，把广告主账户挂载在这个应用下面，因为应用需要获取我们的广告主信息，所以需要通过模拟第三方登陆，让我们应用获取到广告主的信息（比如accesstoken）,这个accesstoken 很重要，上传用户行为就靠他了。ps:这个accesstoken 有时间限制的，为了让他一直有效，我们需要通过refreshtoken 一直刷新accesstoken 的时间（感觉上就是类似redis 的set， 不断的刷新有效期，可以写个定时任务）</p><p>3.获取到accesstoken ，我们再建立用户行为，（但是激活和次留可以用一个行为id），然后把accesstoken ，行为id，事件回传就可以了</p><p>综上，其实各家广告厂商套路其实都差不多，我们提供给他们的广告连接都是可以加上我们自己的参数的，类似微信登陆我们在回调的时候对于scene字段传入我们自定义的值。我们可以利用这个值作为不同的投放计划名称，方便我们不同计划的统计，虽然头条他们本身也能传给我们计划名称。</p><p>各家公司对于ios 和 android 需要建立不同的计划，但是我们的检测链接可不需要，因为我们可以从他们回传的内容中获取到os,判断是android 还是 ios，而且毕竟是mysql，关系型数据库，我们只需要把它们返回的内容都保存就好了，有个例外就是快手不行，因为他们的回传内容中获取不到os，我们无法判断是android还是ios，（android 和 ios 匹配头条用户信息的逻辑不一样，所以要区分）难道通过idfa或者imei去判断，显然不保险，不如填写两条不同的检测链接，标识哪个是ios ，哪个是android。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近好久没有写文章了，主要是因为太忙了最近，加上前段时间生病了，没有时间学习，最近在做广告的投放，出了蛮多岔子的，总结一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="广告" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-validate验证器</title>
    <link href="http://yoursite.com/2019/12/16/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-validate%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/16/tp源码分析-validate验证器/</id>
    <published>2019-12-15T16:12:26.000Z</published>
    <updated>2019-12-15T17:06:37.418Z</updated>
    
    <content type="html"><![CDATA[<p>我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。</p><p>曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。</p><a id="more"></a><p>首先说下php 的验证库可以做哪些事吧，还是蛮丰富的。</p><ol><li>首先是验证器，在我看来验证器就是单独抽象了一个层出来，我们在controller里面只需要调用，让controller更加简洁，而且也能复用，验证器类都继承于think\validate。</li><li>其次controller 里面的validate 方法可以直接调用，本质上和前面一样都是调用tp的验证器库。</li><li>最后我们如果想单独使用验证器，就当做普通方法那样也是可以的，毕竟有时候我们除了对于传入参数的验证，业务代码中也有一些内容需要验证的。</li></ol><h3 id="Validate"><a href="#Validate" class="headerlink" title="Validate"></a>Validate</h3><p>属性：</p><p>static type : 这个主要是我们第三种方法独立验证器用到的。rule 规则都存在这里面，当我们使用独立验证器的时候，想扩展验证规则，extend 方法修改的就是这个属性，因为是static， 所以在本次请求的下次使用中，也能调用上次extend 的验证规则</p><p>alias： 就是我们rule 中可以用  &gt;: 5, 当做 gt: 5 来使用</p><p>rule: 验证规则，我们在写验证器的时候，重写的就是这个属性</p><p>message: 提示信息的重写。包含5个占位符，:attribute, :rule, :1, :2, :3</p><p>field: 字段的描述，主要作用用在message中message 中的占位符 :attribute 会被这个内容替代</p><p>typeMsg: 提示信息呗，这块是英文的，最终会通过 lang\zh-cn.php 转换成中文</p><p>currentScene: 当前验证的场景，这个感觉就是为了验证器准备的（场景），其实也蛮实用的，方便验证器中规则的自由组合。</p><p>filter: 主要是利用php filter_var函数的验证</p><p>regex: 主要是用到正则的验证, ctype 也是php 很好用的一个扩展，方便一些特殊字符的验证</p><p>scene: 场景</p><p>error: 错误信息，只有控制器中错误才能抛出异常</p><p>batch: 当前参数验证错误，还能轮到下一个参数</p><p>only: 场景中哪些参数被验证</p><p>remove: 场景中移除</p><p>append: 场景中添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">看源码写的一点总结</span><br><span class="line">// remove 不可能移除所有，除非append 中是空</span><br><span class="line">// remove 连续移除是通过 |</span><br><span class="line">// remove append 的最佳实践是二者不要存在顺序关系，因为程序不会鉴别</span><br></pre></td></tr></table></figure><p>方法：</p><p>__construct:  </p><p>rule 验证规则， message 提醒， field 字段描述 :attribute 占位符实际内容</p><p>make:</p><p>new self 生成一个验证器</p><p>rule:</p><p>独立验证修改rule 和 field 属性，供后面check 使用。方便直接传入 rule 和 message </p><p>extend:</p><p>独立验证器中的方法扩展</p><p>setTypeMsg:</p><p>独立验证器中使用</p><p>message:</p><p>提示信息</p><p>scene:</p><p>修改当前验证场景</p><p>hasScene:</p><p>scene 优先考虑 sceneEdit 方法，再考虑 scene -&gt; [‘edit’ =&gt; []] 属性</p><p>batch:</p><p>批量验证</p><p>only:</p><p>场景的使用验证哪些字段</p><p>remove:</p><p>场景移除验证规则</p><p>append:</p><p>场景添加沿正规则: 上线 remove 和 append的调用的时候没有先后顺序 ！！！</p><p>check:</p><p>验证器核心，这时候传入的内容会覆盖掉初始化的内容。</p><p>getScene:</p><p>根据传入的scene 和 current scene 修改 only  remove add 内容</p><p>getDataValue: </p><p>根据传入的data 数组和 可以， 获取对应的内容</p><p>checkItem:</p><p>实际的验证，通过 call_user_func 去调用对应的验证内容</p><p>checkRule:</p><p>官网上这么说，</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191216005751.png" alt=""></p><p>感觉意义不大，毕竟静态方法make 创造的更好用点</p><p>getRuleMsg: </p><p>获取错误信息，可以好好看看，挺好的，调用了lang 类。因为自定义的closure ，如果 不是 === true， 就当做error， 结果就当做errorMsg，和调用类方法还是有点区别的。</p><p>getValidateType:</p><p>像一些 is，比如 isEmail, isIp 都走的is 方法</p><p>后面就是一些验证方法了，以后写代码都可以借鉴下</p><h3 id="ValidateRule"><a href="#ValidateRule" class="headerlink" title="ValidateRule"></a>ValidateRule</h3><p>这个类的主要用途就是通过rule 类的形式去调用对应的验证规则</p><p>属性：</p><p>title  :attribute</p><p>rule 规则</p><p>message 提示信息</p><p>方法：</p><p>addItem ：</p><p>为 is 方法统一添加rule，message 属性</p><p>getRule  getTile  getMesage 获取对应属性</p><p>title 设定title</p><p>——call  </p><p>——callStatic </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在写接口的时候经常要对传入的参数进行验证，平时供客户端调用的接口还好，一般他们不会乱传什么内容，但也保不准他们的参数是从某个地方获取的，然后误传了，所以我们还是需要做好我们自己的防线，防止后端服务崩溃。还有种情况就是我们开发的后端管理模块，是给运营他们使用的，他们有时候可能配置出错了，这很容易导致我们配置的app比如界面崩溃，所以这块我们的代码一定要严谨。&lt;/p&gt;
&lt;p&gt;曾想着看laravel 的验证器咋写的，！！！但真的类封装的太多了，头疼，算了还是看tp的吧，简简单单两个类搞定。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPhP" scheme="http://yoursite.com/tags/ThinkPhP/"/>
    
      <category term="validate" scheme="http://yoursite.com/tags/validate/"/>
    
  </entry>
  
  <entry>
    <title>持久化</title>
    <link href="http://yoursite.com/2019/12/03/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2019/12/03/持久化/</id>
    <published>2019-12-03T11:59:55.000Z</published>
    <updated>2020-05-28T13:59:32.128Z</updated>
    
    <content type="html"><![CDATA[<p>我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。</p><a id="more"></a><p>举个例子吧，之前接手的一个任务毒和nike关联出价，当前台下发撤单任务的时候，因为牵扯到很多curl 请求，不能同步实现，1.感觉可以通过把请求内容放到mq当中，然后利用daemon 化的task始终监听这个mq，如果有内容，则触发任务，往后执行，否则停歇1min 继续监听。2.那个前作者是通过把内容放到redis中，通过daemon化的task监听这个redis，如果检测到这个redis这个key，就执行相应任务。</p><p>总结一下吧，其实上面两个方式php的daemon话都是通过while true，那么supervisor 的作用是啥呢，当php的这个脚本挂掉了，supervisor可以重新拉起这个脚本。同理pm2也可以，而且不一定是脚本挂掉，脚本执行完了，也可以重新拉起，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo date(&apos;Y-m-d H:i:s&apos;)</span><br><span class="line">echo &apos;end&apos;;</span><br><span class="line">// 利用上面两个进程管理工具之后，可以一直输出</span><br></pre></td></tr></table></figure><p>上面的例子还有个很重要的技术点就是定时触发。相比较crontab 的task，上面的task 触发任务时间不一致，触发时间靠前台控制，所以我们这时候就通过始终运行一个后台任务，然后靠前台触发一个开关，后端始终运行的task始终监测这个开关，如果是开就运行，虽然可能存在一定时间的误差，但大体上还是能完成任务的。</p><p>再比如之前接手的一个安卓灰度更新的任务，当某个渠道开启灰度之后，我们需要每隔30min发送一条钉钉消息，我们同样可以检测表中渠道是否有开启灰度的状态，如果有，则发一条消息，并记录通知时间，下次的循环任务检测是否灰度还在开启，如果还在开启，检测时间通知是否超过30min，如果超过了，再发送消息，并更新通知时间。</p><p>上面的任务看似已经解决，但还是会涉及一个多进程问题，再举个例子，比如erp系统，需要爬取商户的店铺信息，这个task 要一直执行，如果我们有100个商户，就得运行100个task，启动100个脚本。我们上面灰度通知的好解决，一种办法就是检测运行的渠道，循环运行的渠道列表，然后发送消息通知，另一种就是一次性检测，把渠道更新信息包含在一条短消息中发出去，之所以这么做是因为后续的任务（发送钉钉通知）可以在很短时间内完成，如果像erp的那种爬虫任务，只能通过启动多个脚本了。</p><p>关于php的多进程扩展pnctl 这里暂时不做讨论，说一下pm2 和 supervisor 的简单使用。</p><h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p><a href="https://juejin.im/post/5b823506e51d4538d517662f" target="_blank" rel="noopener">这篇文章关于pm2讲解的很好</a></p><p>我比较常用的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pm2 list</span><br><span class="line">pm2 app.js --name wx_spider --watch   // name 名称，方便理解， watch 文件变动，方便重启，类似nodemon</span><br><span class="line">pm2 delete all</span><br><span class="line">pm2 delete (:id)</span><br><span class="line">pm2 restart app</span><br><span class="line">pm2 logs (:name)</span><br></pre></td></tr></table></figure><p>pm2 配置简单，非常好用，echo 的内容之间在log中能看到，除了node， php也是能管理的</p><p>（PM2 的安装需要通过node 和 npm， node 的安装很简单，但我们一定要注意npm 安装的module 位置，如果是linux 下，一定要配置好node_path ,否则 npm -g 安装的内容可能不能使用， npm config  get prefix  可以查看node -g 包安装的位置 。同理node的安装位置最好也是/usr/local/ 下面，方便直接访问）</p><p>今天在使用pm2 管理我的一个task的时候遇到一个问题，就是普通的脚本pm2 start app.js 或者 pm2 start test.php, 但是我现在的命令是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php symfony trade:UpdateCommentDgTags updateUserPublishment  --split=4</span><br></pre></td></tr></table></figure><p>之前的那个命令是肯定不可以的，需要使用配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123; //统计报表更新</span><br><span class="line">  &quot;name&quot;: &quot;up4&quot;, // 随便取</span><br><span class="line">  &quot;args&quot;: &quot;trade:UpdateCommentDgTags updateUserPublishment  --split=4&quot;, // 这些都属于参数</span><br><span class="line">  &quot;script&quot;: &quot;symfony&quot;, // 这个地方一定要注意，symfony 其实是脚本，只是没有 .php 的后缀</span><br><span class="line">  &quot;exec_interpreter&quot;: &quot;php&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;Cluster&quot;,</span><br><span class="line">  // &quot;exec_mode&quot;: &quot;fork&quot;,</span><br><span class="line">  &quot;max_memory_restart&quot;: &quot;100M&quot;,</span><br><span class="line">  &quot;cwd&quot;： &quot;../&quot;  // 上一级目录</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一定要注意，这个地方symonfy 是脚本，怪不得之前我在执行task 命令的时候忘记输入symfony ,他说找不到脚本。 后面的那一长串都会统一看成参数，只是参数解析的形式不一样，比如 trade:UpdateCommentDgTags, 解析成方法名称，–split = 4 解析成参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ps:   php test.php --goods_id=12 uo22</span><br><span class="line"></span><br><span class="line">test.php</span><br><span class="line">&lt;?php</span><br><span class="line">var_dump($argv)</span><br><span class="line"></span><br><span class="line">输出内容：</span><br><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [0] =&gt; test.php</span><br><span class="line">    [1] =&gt; uo22</span><br><span class="line">    [2] =&gt; --goods_id=12</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>pm2 log日志的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error log path    │ /home/username/.pm2/logs/app-error-0.log</span><br><span class="line">out log path      │ /home/username/.pm2/logs/app-out-0.log</span><br></pre></td></tr></table></figure><p>需要注意的是这个error 应该是pm2 自身的error, 一般我们程序抛出的都是在out 日志里面</p><p>！！~notice: pm2 虽然香，但也不能乱用，比如之前我在预发布机器上跑的一个task 脚本，因为跑完了，脚本 die， 不断的被pm2重启，导致cpu 很快被耗尽，所以很多脚本停止的时候 都会有个sleep 操作，过一段时间再重启。当然如果你是那种常驻内存，比如node 做的webserver 肯定不用，因为一般不会崩溃，唯一一种就是你的代码有问题，不断的报错，导致服务不断的被唤醒。</p><h2 id="supervisor"><a href="#supervisor" class="headerlink" title="supervisor"></a>supervisor</h2><p><a href="https://learnku.com/laravel/t/2126/supervisor-installation-configuration-use" target="_blank" rel="noopener">使用和安装可以大致看看这个文章，但这篇文章的配置文件有问题</a></p><p>配置文件里面一定要有[supervisord]和[supervisorctl] 部分，否则会报错。<a href="https://juejin.im/post/5c66be44f265da2de52d784d" target="_blank" rel="noopener">这篇文章应该还可以</a> 需要注意的就是监听端口从 127.0.0.1:9001 改成 0.0.0.0:9001 ,方便外网访问，贴个图</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191203210626.png" alt=""></p><p>基本就能用啦 （比如我那几百万的任务task就能通过这两个处理，不用我一直看着了，跑完了看看 log就好了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在php-fpm 模式下编写的代码一般是同步阻塞的，很少能实现像redis 或者 node 那种等待监听固定端口的形式（通过daemon 或者 nohup参数让其在后台执行），一般php 想实现同样的方式，都是通过加一个死循环，while (true),  但这种方式有一个缺点就是程序挂掉了不能重写启动，不像php-fpm 或者 swoole 的http server  在对子进程进行管理的时候，当工作进程挂掉之后，会重新拉起一个新进程，怎么办呢？可以通过两个工具 pm2 或者 supervisor 。supervisor 的工作原理就是把管理的进程当做自己的子进程，pm2 原理没有了解过。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="daemon" scheme="http://yoursite.com/tags/daemon/"/>
    
  </entry>
  
  <entry>
    <title>复盘一下代码的提交流程</title>
    <link href="http://yoursite.com/2019/11/28/%E5%A4%8D%E7%9B%98%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/11/28/复盘一下代码的提交流程/</id>
    <published>2019-11-28T06:20:02.000Z</published>
    <updated>2019-11-28T10:36:20.370Z</updated>
    
    <content type="html"><![CDATA[<p>昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。</p><a id="more"></a><p>首先我们开发一个功能需要从master上面下拉代码</p><ol><li><p>注意是远程的master，本地的master没啥屌用，因为一般为了提交方便和方便记忆，本地分支和远程分支保持同名，如果你用master 的话，总不能推送到远程master上吧，似乎没人有这个权限。</p></li><li><p>提交代码前是否要合并master ？ 血的例子，别吧。如果你往master上面提交代码没冲突，那就别合并了，对吧，为啥要合并呢 ？只要你的代码正常上线，dont care anything ，因为要是你真的在这个时候合并了远程master，然后远程master 0.01%的可能是个脏master，这时候你的开发分支也就脏了，意味着你合并master 之后改的东西，在领导发现master 脏了之后，都是要被回滚的，回滚的终结点不一定，凭他们的感觉吧，其实感觉就是那个人把release 合并到master 上的点。那问题来了，如果，万一你真的合并了脏master，咋办，其实也好办，你git reset 到合并master之前的那个commit，重新提交给master，看是否能合并，不能合并，再去解决冲突（后面会介绍冲突解决办法），所以感觉在merge 别的分支的时候一定要做好commit message （最好不要改merge 的info，比如当时我修改改成conflict resolve 我都不知道我要回退到哪个版本，其实只要回退到merge 之前的版本就好了）， 有时候真的会帮大忙，方便你的开发分支剔除掉别的合并的内容</p></li><li><p>开发feature中是否要合并master ？ 还是血的例子，别吧。万一你开发分支合并了错误的master，万一你不知道，接着在错误分支上开发，当开发很多的时候，当master 需要回滚的时候会很艰难，毕竟开发了那么多。这时候只能继续相信master， 不断的合并master，其实没啥屌用，你的开发分支已经领先master了，如果你没回滚，你合并的时候只会在人家前面，你会多提交很多内容，这些内容在你给领导要求pr merge 的时候被看到肯定会打回来，~~~不知道咋解决</p></li><li><p>我的流程总结。开发的时候下拉master成为一个开发分支，比如chenye/feature/gray_test, 开发完了，提交dev。万一和dev冲突，下来dev到本地，merge gray_test,看冲突是啥，万一是自己的文件，直接解决。解决完了，推送到远程，给dev提交pr，合并之后，自己的gray_test 就能合并到dev了。注意，在解决冲突的时候一定不要修改自己的开发分支，也就是gray_test, 万一在release 或者 master合并的时候修改了自己的开发分支，一定要dev， release ，master 按顺序重新提交一遍！！！！！否则，别人拉代码的时候一定会冲突。</p></li><li><p>当发现别人的代码冲突的时候咋办，最好的办法就是告诉别人，因为你不知道以哪个为标准。</p><p>你觉得是以master为标准，毕竟线上跑着呢，万一人家当初并不想把代码提交到master上，被另一个同学误操作了，也就是你clone的master是错误代码，这时候以master会覆盖调用dev的正确代码。</p><p>你说以dev标准，毕竟dev是最新的代码 ？还是不对，可能别人着急，直接提交了master，也就是说master代码比dev新，这样dev就会覆盖掉master上的新代码。</p><p>所以遇到这种情况，直接告知吧，任何一种自己修改别人冲突的方法都是不负责任的行为。</p></li></ol><p>顺带提一下最近遇到的win 和 linux 下空格遇到的问题，我们都知道代码是跑在linux下的，所以我们的换行一定要</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160209.png" alt=""></p><p>用这个LF, win下是</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191128160245.png" alt=""></p><p>我们既然改变不了win，可以通过phpstorm自带的功能，去编辑文件，模拟在linux下的编辑。</p><p>（ps:我是怎么发现这个问题的，在用php的heredoc 换行的时候就能发现）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天某位仁兄把远程的release合并到master ！！！虽然每个人都会犯错，但是我还想抽他，当然我自己能力不够也是一方面原因，记录一下虎扑最最最最正确的提交流程。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
      <category term="虎扑" scheme="http://yoursite.com/tags/%E8%99%8E%E6%89%91/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-数据库操作</title>
    <link href="http://yoursite.com/2019/11/17/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/11/17/tp源码分析-数据库操作/</id>
    <published>2019-11-17T07:45:09.000Z</published>
    <updated>2019-11-17T07:53:51.947Z</updated>
    
    <content type="html"><![CDATA[<p>tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo</p><p>的api 去操作数据就好了。</p><a id="more"></a><p>我们先来看看常用的pdo api</p><p>首先是关于pdo的安装部分，我们要安装统一的pdo扩展，然后在这个扩展的基础上安装 pdo mysql ,或者 pdo postgresql，类似针对不同的数据库的驱动的感觉。</p><p>预定义常量：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tp 操作数据库有两种方式，一种是orm，一种是链式操作，其实这两种的本质都是（基于mysql）pdo的封装操作。所以当我们接触一个新的框架，在没有文档或者学习比较慢的是否，我们只需要找到这个数据库操作类中的连接（一般名称 con, 继承于pdo的类的实例，或者干脆就是pdo的实例），然后用pdo&lt;/p&gt;
&lt;p&gt;的api 去操作数据就好了。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>go 学习笔记</title>
    <link href="http://yoursite.com/2019/11/17/go-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/go-学习笔记/</id>
    <published>2019-11-17T07:44:14.000Z</published>
    <updated>2020-01-17T13:42:35.926Z</updated>
    
    <content type="html"><![CDATA[<p>php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能</p><a id="more"></a><h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>和php 的安装基本没啥区别，找篇文章就能解决。需要注意的是</p><ol><li>go 1.13 以上加了 goproxy 的功能，我的理解就是类似composer 中国镜像， github 上有个goproxy-cn, 修改一下就好了。</li><li>然后go 运行脚本是 go run  xxx.go, 需要这个脚本 package 是main, 执行的当前方法是 main (go build 那些以后用到再补充)</li><li>gopath 那些概念在1.13以上好像都淡化了，以后用到再补充</li></ol><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量申明多种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var num int  // 没给初始值，默认 0</span><br><span class="line">num := 1  // 这样更简洁更方便， 函数外不给使用</span><br><span class="line"></span><br><span class="line">int, float64, bool 这都是和别的语言一样的，array , slice, map</span><br><span class="line"></span><br><span class="line">arr1 := [...]int&#123;1,2&#125;  // 因为不能扩展，用的比较少</span><br><span class="line">slice1 := []int&#123;1,2&#125;  // 关联数组</span><br><span class="line">map1 := map1[string]string&#123;&#125; // 索引数组</span><br><span class="line"></span><br><span class="line">// 换一种看法看go， 下面两种都代表数组，只是填充的对象是byte 或者是rune</span><br><span class="line">[]byte&#123;&#125;</span><br><span class="line">[]rune&#123;&#125;</span><br><span class="line">(不管是byte 还是 rune，对应的字符序列都是 十进制，要想转换成 十六进制需要通过 hex.encodetostring ,或者 printf , 第一个只能对 slice 处理，第二个可以对数组)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 结构体，类似</span><br><span class="line">type cy struct &#123;</span><br><span class="line">name string `json:Name` // json 的时候生成key 的名称</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cy1 := new(cy)</span><br><span class="line">cy1.name = &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">fmt.Println(cy1.name)</span><br><span class="line">//cy 类似类名，所以我们还需要变量名</span><br><span class="line"></span><br><span class="line">// 别名</span><br><span class="line">type</span><br><span class="line"></span><br><span class="line">// map value 定义成某个字段太局限了，可以 map[string]interface&#123;&#125; 这样，更灵活</span><br><span class="line">// :=  map[string]interface&#123;&#125;&#123;&#125; ,一定要给初始值</span><br><span class="line"></span><br><span class="line">// go 中 printf %v  struct 这种不够，因为 名称打印不出来，需要 %+v 打印</span><br></pre></td></tr></table></figure><p>一次性给多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr1, arr2 := []int&#123;1,2&#125;, []int&#123;2,3&#125;</span><br></pre></td></tr></table></figure><p>因为go 中的异常机制和php还是有点区别的，很多函数在使用之后会有error 的返回，我们根据 error != nil ,就能知道是否错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if _,error := test(x , y ); error != nil &#123;</span><br><span class="line">  错误处理</span><br><span class="line">&#125; </span><br><span class="line">:=  ,只有多个变量中有一个是新的，:= 不会报错</span><br><span class="line"></span><br><span class="line">真实因为go 的这种语言机制，导致 if 才能这样用，最多有两个表达式，第二个 值的内容是布尔 （上面 _ 属于匿名）</span><br><span class="line"></span><br><span class="line">还有go 中和 js let 一样，都有块状作用域，比如那个 if 里面赋值的变量，只能在 &#123;&#125; 中使用</span><br></pre></td></tr></table></figure><p>var 和 const 一次性声明多个值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var (</span><br><span class="line">test1 int</span><br><span class="line">test2 int</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 枚举，内部可以用iota</span><br><span class="line">const (</span><br><span class="line">test2 iota</span><br><span class="line">test3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>go 中 if 和 for 都是不用括号包裹的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php 活不下去了，┭┮﹏┭┮，开始学习go了，其实还好，多一门语言，多一个视角，~希望2020年识货给我的礼物就是go 和 node 的编写技能&lt;/p&gt;
    
    </summary>
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
      <category term="go" scheme="http://yoursite.com/tags/go/"/>
    
      <category term="php" scheme="http://yoursite.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>node 学习笔记</title>
    <link href="http://yoursite.com/2019/11/17/node-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/17/node-学习笔记/</id>
    <published>2019-11-17T07:44:05.000Z</published>
    <updated>2019-11-17T07:44:05.685Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>虎扑这几天的git流程总结</title>
    <link href="http://yoursite.com/2019/11/12/%E8%99%8E%E6%89%91%E8%BF%99%E5%87%A0%E5%A4%A9%E7%9A%84git%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/11/12/虎扑这几天的git流程总结/</id>
    <published>2019-11-12T08:04:56.000Z</published>
    <updated>2020-05-02T06:34:58.446Z</updated>
    
    <content type="html"><![CDATA[<p>首先说一下虎扑的代码开发流程（包括提交，发布流程不太明白，对金啃死了解太少）。公司给每个人分了台虚拟机(类似云主机)，</p><p>我原先的想法是通过在虚拟机上clone 代码，然后通过phpstorm 的远程连接主机的功能，实现在本地开发，然后映射到虚拟机上代码改变。可是这样有一个问题就是虚拟机linux上clone的代码的换行和我本地win上的换行不一样，虽然开发的时候没有影响，但是要是在win上提交代码就会出现很多没有修改的代码也会有modifyed（其实git 本身做了兼容，在clone的时候，但主要是我现在把linux代码拉取到本地，所以才会这样）。而且我也不可能在linux上提交，毕竟提交的时候需要通过一些工具观察文件的改变，所以改成了第二种方式</p><p>通过在本地和远程都clone 代码，然后通过sftp实现两个文件夹的关联，本地代码的修改也能直接映射到虚拟机，而且可以在windows上提交代码，因为是在win上clone迁出远程仓库的代码，所以提交的时候不会出现换行(crlf)的问题。</p><a id="more"></a><p>首先是开发分支的命名。 </p><p>姓名/feature(bugfix) 特征/ 自定义名称 （这样切割之后，在一些git 工具上可以发现是以文件夹方式显示的）</p><p>开发完了，推送到远程</p><p> git push origin chenye/feature/dgtag(本地分支):chenye/feature/dgtag(远程分支)</p><p>然后给develop 提交一个pr，再合并（最好不要直接给develop提交，就算提交也是通过git fetch origin develop(远程分支):deve1 去提交, 千万不要把自己的分支推到远程的develop分支上了，防止覆盖）</p><p>当我们提交的时候出现conflect 的时候，我们可以 git fetch origin develop:dev1, 然后在dev 上merge 我们的分支 chenye/feature/dgtag, 合并完了，再推送到远程新建分支，再把这个分支和dev分支合并。</p><p>当我们merge本地分支的时候肯定会出冲突，这个冲突的来源有两种可能，一种自己的，这个很好办，把head 到 ==== 中间删除，替换成自己最新的。</p><p>还有种可能是别人的，要是别人的呢，也好办，最暴力的方法就是用dev替换自己分支上最新的，这样自己的分支和dev合并就没有冲突了，但这个只适用于dev哈，如果是release 和 master ，一定要问一下出现conflect文件的那个人！！！</p><p>远程仓库更新完了，我们需要更新服务器上的代码，这和itbasic 一样，直接去28机器上git clone 就好了</p><p>唯一有区别的就是release， 我们这边release 的发布类似以前，每次发布之后都会在服务器上产生一个新的文件夹，通过改变软链接指向的文件夹，保证每次发布成新的代码（而不是通过代码覆盖，感觉这样是不是发布更快速，如果是clone的话，有时候需要很久才能全部完成）</p><p>进入release 环境，我们第一个选2， 第二个选项是不同的php， 7.1 和 7.2，7.2的count() 真的很坑呀，要注意，其中3环境我们每次执行完脚本要及时删除 文件夹下的cache， 否则脚本执行不了 （很奇怪~~）。</p><p>有时候我们在release 环境修改文件会发现没生效，这可能是因为有人发布代码了，所以你后面再次进入修改的文件，可能对应的文件夹已经不是之前你修改的那个了。</p><p>这几天git常用的几个命令</p><p>git pull origin master:master1 </p><p>注意这个和 git pull origin master 不一样，后者会下拉master 并和 当前分支合并，前者即使当前在master1 分支上，也是用master 强制覆盖master1 ，类似push 。</p><p>git fetch origin master:master1 </p><p>下拉远程master 在本地新建master 1</p><p>git reset   commitId  回退本地 commit 的内容到工作区（并不是删除）</p><p>(如果没有 –hard， 内容会再次回到工作区，需要 git checkout . 抛弃， 默认是 git reset –soft)</p><p>git checkout  .  删除工作区的内容</p><p>git clean  删除添加的文件，或者直接 rm  删除文件</p><p>git branch –delete  分支名 删除本地分支</p><p>git  push origin  –delete 分支名 删除远程分支</p><p>git merge  ing 的时候如果想放弃，也可以通过删除merge的文件，这样是不是能少记一个命令呢，哈哈哈</p><p>我们在解决冲突的时候，千万不要把develop，或者release 上面的代码合并到自己的开发分支上， 因为自己的开发分支最终是要合并到master上的，所以我们对这两个分支解决冲突只能通过新拉分支来解决，解决完也不要推送到自己的开发分支上，可以推送到远程的临时分支上，与dev和release合并</p><ul><li>今天在给一个新项目做远程sftp配置的时候（本地clone，远程也是clone）,始终配置不上server， </li></ul><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191112232234.png" alt=""></p><p>options 这块总是显示mapping 不对，打开 configuration</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191112232326.png" alt=""></p><p>注意那个地方一定要有个 / !!!!</p><ul><li>今天用sftp 发现，为了删除文件，只能在phpstorm上面删除，如果自己打开文件夹删除，是更新不到服务器上的</li></ul><ul><li>今天用git 的时候，想给部署多个仓库</li></ul><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191205161629.png" alt=""></p><p>小垃圾们看一下，~是不是对origin 有更深刻的理解了 ，地址<a href="https://segmentfault.com/q/1010000008366409" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008366409</a></p><ul><li>今天在推送本地分支到远程的时候推送错了，导致远程分支提前自己的开发分支，所以只能强推，当然只有自己的分支能这么坐哈，~公共分支千万别，因为感觉强推就是覆盖</li></ul><p>git push origin dev -f</p><ul><li>今天在提交代码的时候，发现想删除某个提交，其实这个情况蛮常见的，比如之前某个大佬把release合并到master上，我们只需要</li></ul><p>git rebase -i  还是蛮重要的，目前我就用在删除当前分支的某次提交。变基的时候如果没有修改同一个文件的话，没有冲突的话，改起来话挺快的，可以快速删除某个不想要的提交，比如：<a href="https://www.36nu.com/post/275" target="_blank" rel="noopener">https://www.36nu.com/post/275</a>，</p><p>但是如果改了同一个文件的话，可能存在某种冲突，所以变基操作会每个commit 慢慢操作，只需要 git rebase –continue 这样就行了</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20191206114054.png" alt=""></p><ul><li>git reset 的后遗症蛮严重的，特别是自己开发分支修复不当，所以我们每次提交一定要严格执行合并dev， release，master 流程，一旦开发分支修改过，都要重走一遍。今天有人合并分支出现冲突，强推了merge，导致我的代码被覆盖，但归根结底都是之前提交代码不规范，~一定要引以为戒</li></ul><p>最近虎扑多了个新的git tag的功能，主要是为了发布代码的稳定性，方便回滚。</p><p>git tag  <a href="https://www.zhihu.com/question/28784805" target="_blank" rel="noopener">https://www.zhihu.com/question/28784805</a>  这篇文章讲的蛮好。</p><p>需要注意的就是我们要在自己想要的branch 上打tag （就是对于自己想要的commit 取一个别名）</p><ul><li>重温了git 小册，看打了git rebase ，其实这个功能大家不常用很正常，因为我们现在往往提交代码都是通过pr的方式，合并代码都是在gitlab 上手动执行就好了，很少关注git merge 这些事情，本地也很少merge 代码 （我一般开发一个功能就是fetch 一个 master as other branch，然后去开发）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先说一下虎扑的代码开发流程（包括提交，发布流程不太明白，对金啃死了解太少）。公司给每个人分了台虚拟机(类似云主机)，&lt;/p&gt;
&lt;p&gt;我原先的想法是通过在虚拟机上clone 代码，然后通过phpstorm 的远程连接主机的功能，实现在本地开发，然后映射到虚拟机上代码改变。可是这样有一个问题就是虚拟机linux上clone的代码的换行和我本地win上的换行不一样，虽然开发的时候没有影响，但是要是在win上提交代码就会出现很多没有修改的代码也会有modifyed（其实git 本身做了兼容，在clone的时候，但主要是我现在把linux代码拉取到本地，所以才会这样）。而且我也不可能在linux上提交，毕竟提交的时候需要通过一些工具观察文件的改变，所以改成了第二种方式&lt;/p&gt;
&lt;p&gt;通过在本地和远程都clone 代码，然后通过sftp实现两个文件夹的关联，本地代码的修改也能直接映射到虚拟机，而且可以在windows上提交代码，因为是在win上clone迁出远程仓库的代码，所以提交的时候不会出现换行(crlf)的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-数据库和模型</title>
    <link href="http://yoursite.com/2019/10/25/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/10/25/tp源码分析-数据库和模型/</id>
    <published>2019-10-25T07:05:40.000Z</published>
    <updated>2019-10-25T07:05:40.160Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tp源码分析-Cache</title>
    <link href="http://yoursite.com/2019/10/22/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Cache/"/>
    <id>http://yoursite.com/2019/10/22/tp源码分析-Cache/</id>
    <published>2019-10-22T01:45:16.000Z</published>
    <updated>2019-10-25T06:45:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>需要改变的观点是</p><ol><li><p>这个cache 并不能完全替代redis， 这个cache 只提供一些缓存比如redis,memcache，file 方法的聚合，比如set 设置缓存，如果配置的是redis， 走的是redis string的get 方法，如果配置的是file， 则对文件名进行hash， 然后存储在对应文件下面 （redis 键的过期不用我们代码中主动考虑，当我们使用redis 的set 命令的时候自动帮我们实现（redis有自己的键过期策略），但是file 没法设置过期时间，只有在get的时候拿着文件的mktime 加上 存储的expire time 和当前时间进行对比，如果超过了就返回null，并删除文件，当然我们在调用的时候不用考虑，单纯的通过 Cache::set() 就行了，上面的操作都是 cache的driver 之一 file 帮我们封装好了）</p></li><li><p>介绍一下 cache 库的基本结构</p><p>首先 \Cache -&gt; facade Cache -&gt; think Cache,  所以上述三个类都能调用cache，前面两个类等同，都只能通过 静态方式调用方法 ！！！，走的是我们的默认配置。think\Cache 属于实际类，他没有 _call_static 方法，所以我们不能用这个类静态的调用方法，需要先实例化，然后去调用。</p><p>这个库包含三个基本文件</p><ol><li><p>cache.php ,这个类是入口，实例化的时候走的是他的_construct, 生成handel实际处理句柄，干啥的？ 对于set， get 操作，实际发起者就是他。然后就就是一些config 的配置，具体的操作并不涉及。</p></li><li><p>cache 文件夹下的 driver.php .是一个abstract class （abstract 相比较interface ，首先abstract 是类，类只能单继承，interface 是接口，可以多实现。再者abstract 中可以包含 方法实体，但是interface 中的方法都不能包含实体。这个driver.php 应该用abstract，因为他包含一些公共方法，比如 pull -&gt;取出缓存中的一个数据并删除，可以直接通过各个cache driver 的 get 和rm 方法的组合，并不需要每个  cache driver 各自定义，所以他的pull 方法可以直接包含方法体）。</p></li></ol></li></ol><a id="more"></a><p>首先来看一下 think\Config</p><p>instance</p><p>容器类，装着一个个 options 的驱动类，这些驱动的名字默认是配置项（options）序列化，保证同样的配置不会生成多个实例</p><p>config </p><p>配置属性，用来选择使用哪个驱动，file ? redis or memcache</p><p>handler</p><p> 注意这个和driver 下面的驱动类的handle 区分开，那个handle 是实现具体操作的句柄，比如 驱动是 redis， 那个handle 是 new \Redis （c 实现的php扩展）， 而Cache 中的handle 是驱动类， think\cache\Redis</p><p>__construct()</p><p>初始化方法，config 属性的赋值，然后调用init() 方法</p><p>connect()</p><p>根据配置生成实际的cache 文件夹的实体类，存储在instance 属性中 （可以有多个cache配置），名字用配置项的序列化生成的字符串。返回的内容是实体类</p><p>init()</p><p>返回内容也是实体类，但操作的是 handle，handle属于instance 中的一个，是当前调用Cache 时候某个config 生成的实体类，不多于一个。因为这个条件的限制，所以只有第二个参数force 在 true 的时候，或者当前handle 是null（比如file），才能实现 cache 加载类的切换。</p><p>getConfig()</p><p>获取options, 操作的属性名叫config （不叫options）</p><p>setConfig()</p><p>设置options,操作的属性名叫config</p><p>store()</p><p>上面也说了init 方法不太方便切换当前操作的cache， 这个store很方便，通过传入不同配置项的名称，实现cache 加载的config 的切换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">return [</span><br><span class="line">    // 使用复合缓存类型</span><br><span class="line">    &apos;type&apos;  =&gt;  &apos;complex&apos;,</span><br><span class="line">    // 默认使用的缓存</span><br><span class="line">    &apos;default&apos;   =&gt;  [</span><br><span class="line">        // 驱动方式</span><br><span class="line">        &apos;type&apos;   =&gt; &apos;file&apos;,</span><br><span class="line">        // 缓存保存目录</span><br><span class="line">        &apos;path&apos;   =&gt; &apos;../runtime/default&apos;,</span><br><span class="line">    ],</span><br><span class="line">    // 文件缓存</span><br><span class="line">    &apos;file&apos;   =&gt;  [</span><br><span class="line">        // 驱动方式</span><br><span class="line">        &apos;type&apos;   =&gt; &apos;file&apos;,</span><br><span class="line">        // 设置不同的缓存保存目录</span><br><span class="line">        &apos;path&apos;   =&gt; &apos;../runtime/file/&apos;,</span><br><span class="line">    ],  </span><br><span class="line">    // redis缓存</span><br><span class="line">    &apos;redis&apos;   =&gt;  [</span><br><span class="line">        // 驱动方式</span><br><span class="line">        &apos;type&apos;   =&gt; &apos;redis&apos;,</span><br><span class="line">        // 服务器地址</span><br><span class="line">        &apos;host&apos;       =&gt; &apos;127.0.0.1&apos;,</span><br><span class="line">    ],     </span><br><span class="line">]</span><br><span class="line">复合cache， 通过传入redis， file ，还可以定义更多的</span><br></pre></td></tr></table></figure><p>再看一下cache 文件夹下的Driver.php</p><p>handle</p><p>实体类操作句柄，类似 redis 的 new Redis, pdo 的 new Pdo</p><p>readTimes  </p><p>读取次数，自身用的比较少 （每次读取都会增加）</p><p>writeTimes</p><p>写入次数，用的比较少 （每次写入都会增加）</p><p>options</p><p>tag</p><p>给缓存加标签，比较方便的就是 clear 的时候会清除掉tag 绑定的缓存，而不是整个redis 库的flushDB</p><p>serialize </p><p> 一个数组，其中的四个参数分别代表，序列化方法，反序列化方法，缓存前缀，缓存前缀的字符数量</p><p>abstract  has</p><p>是否有这个缓存</p><p>abstract get</p><p>读取这个缓存</p><p>abstract set 设置这个缓存</p><p>abstract inc 新增步长</p><p>abstract dec 减少步长</p><p>abstract rm 删除缓存</p><p>abstract clear  删除缓存</p><p>getExpireTime</p><p>这个方法太傻比了，不知道咋用，传入的参数是个时间，返回的还是时间，没啥用</p><p>getCacheKey </p><p>正如名字上写的，获取缓存的名字，比如redis 的key值，file 通过这个返回的内容加上自身逻辑，生成对应文件名（其实就是options 中的prefix 拼接上 key）</p><p>pull</p><p>get 和 rm 的组合</p><p>remember</p><p>不存在则写入，类似redis 的分布式锁，5s 中内每隔 0.2 s 执行一次 看是否能设置成功。 5s 中后直接操作，不管有没有锁 （按理说锁的存在时间不应该这么久，所以直接覆盖了之前的锁）</p><p>tag</p><p>给当前类设置属性tag.</p><p>如果传入额外的key, 则把传入的key 存入该tag 名下，这个tag 和key的对应关系如下 ： tag 名根据定义关系生成key,  把对应的key 连接成字符串当做value， 做成 key -&gt; value 映射 （整个cache 库的映射关系都是 key value 形式，没有别的数据结构）</p><p>setTagItem</p><p>给当前tag 加入新的 key</p><p>getTagItem</p><p>获取当前tag 对应的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protected function getTagItem($tag)</span><br><span class="line">    &#123;</span><br><span class="line">        $key   = &apos;tag_&apos; . md5($tag);</span><br><span class="line">        $value = $this-&gt;get($key);</span><br><span class="line"></span><br><span class="line">        if ($value) &#123;</span><br><span class="line">            return array_filter(explode(&apos;,&apos;, $value)); </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return [];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 发现上面的array_filter 方法用的蛮多的，用来过滤 数组中的 false， 蛮好用的</span><br></pre></td></tr></table></figure><p>serialize </p><p>获取的上面 serialize 属性参数1对应的序列化方法序列化</p><p>unserialize</p><p>获取的是上面serialize 属性参数2对应的序列化方法反学历恶化</p><p>registerSerialize</p><p>修改serialize 属性</p><p>handler()</p><p>获取句柄</p><p>getReadTimes</p><p>获取读取次数</p><p>getWriteTimes</p><p>获取写入次数</p><p>下面是cache 文件中的驱动，随便选一个，比如 redis.php 分析 (看了这个类很容易自己封装一个 redis 操作库)</p><p>（为啥还需要自己封装redis 操作库，因为这个cache 类只是简单的使用redis 的string 类型，更多的操作类型并没有）</p><p>（封装redis lib 其实蛮简单的，把这个redis 连接抄一下，然后加入一个_call 方法就好了，最简单的redis lib）</p><p>(其他的lib 比如es lib 也可以这么考虑，重要的就是一个tcp 连接)</p><p>options  </p><p>redis连接的参数</p><p>_construct</p><p>建立redis 连接 （支持 php 扩展 redis （phpredis） 和 predis (单纯用php 实现的redis 客户端)）</p><p>has</p><p>调用redis 的 exists 方法</p><p>get</p><p>调用redis 的get 方法</p><p>set</p><p>调用redis 的set 方法，其实 setex 可以直接用set 实现</p><p>inc</p><p>redis incrby 方法</p><p>dec</p><p>redis decrby 方法</p><p>rm </p><p>redis delete 方法</p><p>clear</p><p>redis delete 或者 flushDB !!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要改变的观点是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这个cache 并不能完全替代redis， 这个cache 只提供一些缓存比如redis,memcache，file 方法的聚合，比如set 设置缓存，如果配置的是redis， 走的是redis string的get 方法，如果配置的是file， 则对文件名进行hash， 然后存储在对应文件下面 （redis 键的过期不用我们代码中主动考虑，当我们使用redis 的set 命令的时候自动帮我们实现（redis有自己的键过期策略），但是file 没法设置过期时间，只有在get的时候拿着文件的mktime 加上 存储的expire time 和当前时间进行对比，如果超过了就返回null，并删除文件，当然我们在调用的时候不用考虑，单纯的通过 Cache::set() 就行了，上面的操作都是 cache的driver 之一 file 帮我们封装好了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;介绍一下 cache 库的基本结构&lt;/p&gt;
&lt;p&gt;首先 \Cache -&amp;gt; facade Cache -&amp;gt; think Cache,  所以上述三个类都能调用cache，前面两个类等同，都只能通过 静态方式调用方法 ！！！，走的是我们的默认配置。think\Cache 属于实际类，他没有 _call_static 方法，所以我们不能用这个类静态的调用方法，需要先实例化，然后去调用。&lt;/p&gt;
&lt;p&gt;这个库包含三个基本文件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;cache.php ,这个类是入口，实例化的时候走的是他的_construct, 生成handel实际处理句柄，干啥的？ 对于set， get 操作，实际发起者就是他。然后就就是一些config 的配置，具体的操作并不涉及。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cache 文件夹下的 driver.php .是一个abstract class （abstract 相比较interface ，首先abstract 是类，类只能单继承，interface 是接口，可以多实现。再者abstract 中可以包含 方法实体，但是interface 中的方法都不能包含实体。这个driver.php 应该用abstract，因为他包含一些公共方法，比如 pull -&amp;gt;取出缓存中的一个数据并删除，可以直接通过各个cache driver 的 get 和rm 方法的组合，并不需要每个  cache driver 各自定义，所以他的pull 方法可以直接包含方法体）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Cache" scheme="http://yoursite.com/tags/Cache/"/>
    
  </entry>
  
  <entry>
    <title>三个星期的PHP面试</title>
    <link href="http://yoursite.com/2019/10/01/%E4%B8%89%E4%B8%AA%E6%98%9F%E6%9C%9F%E7%9A%84PHP%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2019/10/01/三个星期的PHP面试/</id>
    <published>2019-10-01T13:36:20.000Z</published>
    <updated>2019-10-01T15:51:38.926Z</updated>
    
    <content type="html"><![CDATA[<p>故事发生背景：男，94年，工作经验2.5年，普通一本，软件工程，裸辞，8月9日裸辞！！！然后在上海和家呆了一星期，去云南玩了一星期，后来回上海写简历，租临时住所一星期，9月1日正式开启我的找工作之旅。</p><a id="more"></a><h1 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h1><p>简历真的很重要，因为很多hr真的会把你的简历筛掉 </p><p> <img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/2e55660f533d8ada1971e2ead31f030.jpgg" width="300"></p><p>所以啦，不能怪他们，只能怪我们自己没有写的好，怎么写好PHP面试的建立？老李的文章写得很详细，这里我就大致说一下我自己的看法：</p><p>首先是对于基础的掌握程度，比如各种框架的生命周期，composer加载原理，facade，ioc，各种设计模式，比如单例，工厂，装饰器。又比如网络层面的基础，比如tcp三次握手4次挥手，https原理，tcp 编程，php-fpm fastcgi swoole。再者就是各种更深层次的原理，比如php7 的优化，redis 数据结构，索引b+ 树最左前缀。</p><p>写完基础，就要看项目经验了，是否有电商的项目经验，redis的应用场景，mysql 的分库分表，最高并发和最多数据量的表是多少，是否有服务拆分，微服务相关经验。是否有app 开发的相关经验，代码发布流程。</p><p>很大程度上面试官都会依据着你写的简历问你相关的问题，哪方面比较擅长就多写点呗，很多时候面试官都会给你机会让你在你擅长的领域上发挥，我们不用管我们擅长的是项目还是PHP本身，把你最好的表现出来就好了，一定不要因为你觉得更熟悉框架对请求的加载流程相较于有高并发经验比较低级，硬往上面靠，到头来不仅没有因为你擅长的东西得到面试官的青睐，还会因为表达不清楚或者说瞎编被抛弃（深有感触，在sty面试之后有感）</p><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p>首先想说一下关于裸辞这件事。</p><p>本身我是很赞成裸辞的，毕竟觉得找工作单纯靠着上班时间请假很难完成，而且觉得自己有能力，辞职之后还可以专心准备找工作。但是经历了这三个星期之后，我的想法产生了极大的变化，可能以后我还会裸辞，但是我想告诉大家一些事情，当你裸辞之后你要做好长时间找不到工作，又或者是下家比上家还差的打算。下面是我大致的新路历程：</p><h3 id="第一周"><a href="#第一周" class="headerlink" title="第一周"></a>第一周</h3><p>因为2年多从来没面试过，很仿徨，觉得redis 数据结构不懂，php 源码不会，总感觉自己没准备好，而且为了练手，我在拉钩上只投了很小的几个企业，大致规模是 150人以下，收到了4个面试邀约（很少了，其实如果裸辞的话，一周感觉10个吧，然后筛选一下到7个，也不会很累）。</p><p>第一家是做线上培训的。公司很小(一层楼都没有)，大概类似传统行业的格子间 。首先是做面试题嘛，他家的面试题很杂，大概就是网上找的那些html+css+js+mysql+php, 其实这些都是web开发应该会的，但是他家的题很恶性，类似那种mysql 改密码一共有多少种方式，以下哪个js 语法有错误，mysql事务的4个特征属性是什么，唯一一道有参考价值的应该是末尾的用php写一个广度优先。后面就是面试官，balabal，问了一个场景，同时4w人考试的系统怎么设计(全国范围内)。在后面是 ceo 宣传了1个小时他家的产品，给的很低，而且试用期打折，pass。</p><p>第二家是做的一个类似实体店铺的导购，完全没有面试官，就是ceo 宣传（！真的敢这么招人，仿佛来了就要），没有学到一点面试经验，所以呢，以后小伙伴们投递的时候对于50 人左右的公司， 或者是ceo直接在拉钩上招人的公司，慎重投递，没啥意义。</p><p>第三家，sty (二面很惨)。 这应该是这一周唯一一次有价值的面试了，公司蛮大的，研发也挺多，环境高大上，hr 挺好看，就是有点冷漠 （不要水的话，他们不会给你倒的哦）。做题。一面，说一下地址栏输入地址之后的过程。这个我擅长呀，先hosts 文件，浏览器缓存，dns解析，域名转ip 地址，然后和服务器建立连接，nginx 传php-fpm , 给php ，我顺便补充了一下tp框架执行流程。 那你用过composer吗，用过，然后我直接给他说了composer 源码加载原理。用过redis吗， 说一下场景 （我这个级别，很多时候就考这个，redis 命令一定要记熟悉！！！比如怎么获取zsort 中元素数量），还问了redis 集群，raft算法 (不会啦，redis 真的很重要) ，git 怎么回退 （！！！啧啧啧，真的很少用 git reset），说一下array 经常用的方法。本来以为很简单的过了，和朋友都发了短信，二面面试官来了。真的很厉害，tcp 三次握手建立连接除了syn ack包还有那些 ？pdo 是长连接还是短连接 ？连接池有什么作用 ？到底用长连接还是短连接比较好 ？为什么主键需要连续 ？索引怎么查找的 ？事务没提交出现大量close_wait 错误是出在哪里，php 还是mysql ？</p><p>第四家，rt 。第四家在soho 的地下室，其实面的感觉还不错，但是没要，不知道是不是像我朋友说的那样套路创意，因为之前他面的ios， 聊得很不错，后来就没消息了。面试题很不错，总共4道题，第一眼看上去可能一道都不会，第一道是对msyql 表的设计，给了一个场景。第二道是对laravel 的collection 一个方法的实现。第三道是写一个sql。第四道是关于mysql 可重复读时候修改数据阻塞的考察，问的内容大致就是一些简单项目，还有一点点es。</p><h3 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h3><p>因为第一周面试之后给我的阴影蛮大的(最主要sty的二面让我真的认识到自己的不足)，周六和周日投的基本是b轮以上的公司或者是150人以上的，可竟然周一一个面试机会都没有！！！</p><p>我慌了！！！</p><p>周一晚上疯狂的海投（但是类似lb，bd，tx，fl，hp，yw，bz 这些大厂还没有投，想留在第三周），终于约了4个面试。</p><p>第一家，yhxc。大概两个小时的车程，主要到了那边下地铁之后坐不到公交车，对的，你没有听错，在上海竟然等不到公交车（ps，可能之前都住在比较靠近市里的地方，公交车基本10分钟以内一班），打车去的软件园。公司挺大，一层楼，很高档，相比sty 的 ins风，这边更加温馨，但可以看得出来，不缺钱。笔试，拿走了手机。面试，面试官对着我两个for 写的冒泡看了半天，说不对，··我讲了半天我自己都怀疑了，然后他拿来的dell 笔记本，我写了一下，运行正确，他又看了5分钟····二面，一个不喜欢我用DateTime 去写时间的人，说实话，我挺反感的，主要是他直接定义我date 用的不熟，于是我直接用date 实现了一遍，他还是不服气，因为他的题是 2018-9-7，~~不同人的看法不一样，这tm 和 2018-09-07 的考察点的区别真的很大吗。后面就是hr面，背调了2个小时，真的！！！本来想着凑合着他过吧，出现了另一家拯救我的公司，yx。</p><p>第二家，yx的面试是下午5点钟，因为中午回去不了，我找了家星巴克（肉疼）。没有笔试题，一面面试官来自百姓网，穿个大裤衩，北方人，看上去就很放荡不羁，一直擦着鼻涕，但真的很厉害好嘛~~~我们之间的面试很短暂，可能是我了解的知识正好是他get的点，而且聊到情深处，他自问自答，当他对我说索引 b+树查找原理之后，我顺便拿着这个回答了二面面试官。真的蛮想去他那，可是呢，996，对不起了，如果以后有机会的话，真的想认识一下。二面面试官也很厉害，他更注重项目经验，眼光狠毒辣，仿佛我的两年半工作经历都被他看穿了，不管我怎么掩饰。tinyint 占用几个字节，能表示的数多大，你们代码发布流程？没有app的开发经验。然后是hr面</p><p>上面两家公司的offer 让我很是头疼，是去一个类似国企的公司还是去一个技术更占优势但是996的公司，我失眠了。</p><p>第三家，xyk。要是xyk 给的钱多的话，可能就没有后续了。笔试题， 8 % -2 多少？ 0！！！，他们那的一个对我影响蛮深的面试题就是 setcookie, var_dump($_COOKIE); 答案是 null。一面面试官就对着面试题询问，我们大概聊了1个小时，他和我工作经验差不多，然后人很好，很热情，对于面试题上出现的没达到他想要的内容都会耐心引导，一度让我以为他很闲（哈哈哈，真的，小哥人真的超级好）。二面面试官，首先不说他技术咋样，反正蛮反感的，就是类似比如觉得你restful 说的不全面，但自己也不说哪不对，滚混去查~~~。hr面，钱给的少，pass。技术还行，不加班，介于上面二者之间，氛围不错</p><p>第四家，ydkd。是一家在青浦的快递公司，真的PHP的兄弟们！！！不要去，真的。首先面试距离远不说，去了要做一份智力题，不过不给面试，那些题目真的恶心到家了。而且公司里面员工都穿着快递服装，进门就是一股浓浓的网吧味道（塑料胶门）。因为那边的环境，逻辑题8分钟糊弄完，没过，滚回家了。</p><h3 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h3><p>第一家，sm。┭┮﹏┭┮，sm真的不是司马的意思，但去知乎上面搜一下，这个公司的负面新闻真的蛮多的，这也是我面试以来第一次没通过一面的公司。比较难的点 php 源码，zend 引擎， docker 和 k8s。不管你答得好不好，他反正没有反馈，真的很sm 那。唯一一点好处就是，以前一直没关注abstract 和 interface 的区别，这次回来自己弄明白了。面完之后朋友说半小时内你可能会受到一个面试反馈，这家公司应该是hr在刷kpi，果真这也是我第一次收到面试反馈···</p><p>第二家，lb。lb 那三道万年不变的面试题。但和面试官沟通之后，学会了几个技巧，比如有序数组，就要想到二分查找，原先的结果反转，就可能得到组合的效果。lb里面人的反馈蛮差的，本身觉得他和pdd有什么关系，但实际上好像并没有，面了两轮技术，一轮hr， 最后一轮hr没面到。</p><p>第三家，fl。笔试题好像很不错，好像错了一道，直接过了。然后是两轮技术。fl不是一个技术驱动的公司，他们那更多的在乎是业务。fl的前台真的巨好看，好想再去面一次。fl的面试中午提供午餐，真的很好吃。26号入职，fl也给你交社保。fl的hr 真的超级贴心。对不起，fl。</p><p>第四家hp。 面试官，我要给你奉献我的心脏。</p><p>第五家bd。真的sb bd， 周三约电话面试，我推掉了所有的事情，你tm值面了我10分钟，让周五去现场面试。周五我推掉了所有的面试，你tm周五早上对我说面试官有事情，只能下周一，我之前就清楚的说了我下周一就要入职了。你的股价跌也是有原因的。</p><p>第六家，lyg。lyg和hp的评价在看准网上都挺低的，我一度不想去lyg面试了，可真当我可lyg的面试官交流后，我发现他是面试以来最和蔼的人top3。二面，可能没get到他的点，他也没问我啥。（lyg在宜山路一栋楼，好像饮料也都是免费的，如果能进去应该不错，在做类似比心的陪玩)。二面面试官类似lb面试官跑去和hr商量了一下，回来说hr不在。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是这次大致的面试经历，其中第三周还省略了好几家，比如一家上机面试（hr夸我厉害，说很少有人能做出来，后来给的很多，而且6险2金）,一家洗涤公司（希望我做过二次开发，为啥？因为这样读别人的烂代码就有经验了），收到了蛮多offer的，相比前两周的失意，第三周仿佛开了挂一般，虽然大公司不多。所以想告知小伙伴们，如果裸辞了，一定要做好打持久战的准备，而且可能这个城市没机会了，只能换一个城市，（中国也就上海 北京了吧，php的话），所以呢为了保险起见，还是不要裸辞了，安安心心做事，踏踏实实学本领，总会变得有钱的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事发生背景：男，94年，工作经验2.5年，普通一本，软件工程，裸辞，8月9日裸辞！！！然后在上海和家呆了一星期，去云南玩了一星期，后来回上海写简历，租临时住所一星期，9月1日正式开启我的找工作之旅。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于ob函数</title>
    <link href="http://yoursite.com/2019/09/30/%E5%85%B3%E4%BA%8Eob%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2019/09/30/关于ob函数/</id>
    <published>2019-09-30T11:40:50.000Z</published>
    <updated>2019-09-30T11:52:09.020Z</updated>
    
    <content type="html"><![CDATA[<p>在看源代码的时候还有phpexcel 的时候经常都会看到ob 函数，ob函数主要是用于处理php 的缓存的，默认cli 下ob 是关闭的，需要我们手动打开</p><p><a href="http://www.laruence.com/2010/04/15/1414.html" target="_blank" rel="noopener">ob_flush和flush</a></p><p><a href="http://www.laruence.com/2010/12/17/1833.html" target="_blank" rel="noopener">echo</a></p><p><a href="http://www.laruence.com/2011/02/13/1870.html" target="_blank" rel="noopener">加速echo</a></p><p>(之前看到的fastcgi-finish-request 和上面的缓存也是有一点关系的哦), 每当php 返回数据的时候，我们可以这么看待传输过程，首先是php把数据给webserver， webserver 再把数据给cli ，webserver 在传输给cli 的过程中php的处理进程并没有结束，所以这之间的传输效率也会影响php进程的存活时间，当这之中传输过慢的时候，就会导致大量的php进程存在（php维护的的数据库单例连接也就存在），有时候我们想尽快的结束这个php进程，可以让php 传输给webserver 的时候开启一个缓冲池，当缓冲池满的时候一次性推给webserver，然后fastcgi_finish_request ,这之后就和php进程没关系了，php就可以接受下一个请求或者断开都可以</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看源代码的时候还有phpexcel 的时候经常都会看到ob 函数，ob函数主要是用于处理php 的缓存的，默认cli 下ob 是关闭的，需要我们手动打开&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2010/04/15/1414.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ob_flush和flush&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2010/12/17/1833.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;echo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.laruence.com/2011/02/13/1870.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;加速echo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(之前看到的fastcgi-finish-request 和上面的缓存也是有一点关系的哦), 每当php 返回数据的时候，我们可以这么看待传输过程，首先是php把数据给webserver， webserver 再把数据给cli ，webserver 在传输给cli 的过程中php的处理进程并没有结束，所以这之间的传输效率也会影响php进程的存活时间，当这之中传输过慢的时候，就会导致大量的php进程存在（php维护的的数据库单例连接也就存在），有时候我们想尽快的结束这个php进程，可以让php 传输给webserver 的时候开启一个缓冲池，当缓冲池满的时候一次性推给webserver，然后fastcgi_finish_request ,这之后就和php进程没关系了，php就可以接受下一个请求或者断开都可以&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-Response</title>
    <link href="http://yoursite.com/2019/09/30/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-Response/"/>
    <id>http://yoursite.com/2019/09/30/tp源码分析-Response/</id>
    <published>2019-09-30T09:36:34.000Z</published>
    <updated>2019-12-29T14:52:57.237Z</updated>
    
    <content type="html"><![CDATA[<p>框架可能让你对PHP 怎么给webserver 返回内容产生了误解 ！！！</p><a id="more"></a><p>PHP 是怎么把数据返回给前端的？通过response 对象？因为我们一直在用框架，框架中对于这些返回都是包裹成了response 对象，然后我们想要改变返回的内容，直接修改这个response对象就好了，比如在itbasic上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/[:controller]/[:func]&apos;, function ($request, $response) &#123;</span><br><span class="line">    $res  = $obj-&gt;$func($request, $response);</span><br><span class="line"></span><br><span class="line">    //$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;);</span><br><span class="line">    $response-&gt;header(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br><span class="line"></span><br><span class="line">    $response-&gt;json($res);</span><br><span class="line">    // return json_encode($res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面就是一种很常见的route 组件的使用，很多时候我们可能以为代码就在这结束了，殊不知，这块只是我们定义个的一个callback， 框架代码在执行了这段之后只是完成了response 对象的封装，之后他们还会处理response 对象，比如调用php原生header 处理response的header 属性，echo response 对象的data 属性。</p><p>又或者下面这种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$router-&gt;respond([&apos;GET&apos;, &apos;POST&apos;], &apos;/[:controller]&apos;, function ($request, $response, $service) &#123;</span><br><span class="line">    return $obj-&gt;$func($request, $response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>直接返回数据，并没有返回response 对象，那后面程序就可以根绝默认的配置比如content-type html, 然后echo  返回的string。</p><p>上面两种方式大概就是一般路由的使用方法，下面我们来看看tp 中到底是怎么处理的。我们查看一下入口文件index.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 执行应用并响应</span><br><span class="line">Container::get(&apos;app&apos;)-&gt;run()-&gt;send();</span><br><span class="line">从容器中获取 App.php 的实例，执行run 方法</span><br></pre></td></tr></table></figure><p>run 方法很长，我们筛选这次用的几个重要点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 初始化应用</span><br><span class="line">            $this-&gt;initialize(); // 这个里面会帮我们加载自定义的路由中间件到 middleware 的queue 属性中</span><br><span class="line"></span><br><span class="line">····</span><br><span class="line">        $this-&gt;middleware-&gt;add(function (Request $request, $next) use ($dispatch, $data) &#123;</span><br><span class="line">            // var_dump(&apos;ppp&apos;);</span><br><span class="line">           // var_dump($data);</span><br><span class="line">            // 没错误，直接走的run 方法</span><br><span class="line">            // 这个地方因为 next 用不到了，所以</span><br><span class="line">            return is_null($data) ? $dispatch-&gt;run() : $data;</span><br><span class="line">        &#125;);</span><br><span class="line">        // 这个地方往middleware 的queue 属性中加入一个callback， 如果之前有路由中间件，这块就是前面需要需要的参数 $next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        $response = $this-&gt;middleware-&gt;dispatch($this-&gt;request); // 中间件的执行，包括控制器的执行都在这里面</span><br><span class="line"></span><br><span class="line">        // 监听app_end</span><br><span class="line">        $this-&gt;hook-&gt;listen(&apos;app_end&apos;, $response); // 钩子 app end 执行</span><br><span class="line"></span><br><span class="line">        return $response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>所以呢，通过上面的代码可以看出来在tp 中路由中间件和控制器其实是同一个层面的，他们的核心就是返回一个response， 比如中间件过滤失败 ，我们也需要返回一个response，万万不可以在路由中间件里面返回false， 因为后面的send() 方法需要response 类来调用，控制器中之所以可以直接返回数据是上面那个回调函数写的好，\$dispatch-&gt;run() 中有对控制器返回内容的自适应，如果控制器返回的是一个response，那就直接让他调用send 方法，否则会根据配置文件包装一个response 方法返回。 </p><p>但凡我们想停止路由中间件的执行，我们可以不执行 $next() 方法，直接返回response， 这就他就会直接调用 send 方法，而不去处理控制器中内容。tp这块的原理和 laravel 还是不同的，laravel 中是通过array_reduce 不断的去执行绑定匿名函数，tp 中是通过对middleware的queue属性数组中的匿名函数不断shift， 每一个匿名都依赖下一个匿名，但要是当前匿名不需要比如执行下一个匿名 \$next() 的执行，那只会传入一个function， 而没有实际执行。这在我思考为什么 控制器执行的时候 ，明明queue 数组中没有办法shift 匿名函数了，却没有报错时候产生了极大的困惑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">call_user_func(&apos;test&apos;, [$callback])  // 不执行，除非test方法中 $callback() 主动调用</span><br><span class="line">call_user_func($callback, [$parama]) // 执行</span><br></pre></td></tr></table></figure><p>接下来我们分析一下 Response 类，</p><p>首先是最重要的方法，</p><ul><li>send</li></ul><p>hook 当中的listen_send ,属于常规操作，在我们response 解析之前</p><p>然后是</p><ul><li>getContent </li></ul><p>对于我们的控制器返回进行处理，生成最后要echo 的内容。其中的output方法就是我们response 文件夹下所有继承response 类要实现的方法，比如json 类，会json_encode, 要是普通的类， response的data 属性就直接赋值给content 属性了，默认content-type 是html.</p><p>思考一下为什么我们在控制器中返回arr 有时候会出错？因为我们最后的数据都要echo ,然后都必须要转换成string， 当我们使用默认的配置文件的时候，如果我们直接返回一个数组，默认生成的类是response 类，他的output 方法就是直接data 给content， 这样就导致我们echo 了一个arr ，能不出错嘛</p><p>后面一段是开启</p><ul><li>trace 调式</li></ul><p>trace 调试我感觉方便的一点就是能看到执行的sql 语句，这在开发中是很必要的。</p><p>再后面就是头信息的处理，</p><ul><li>调用php 原生header</li></ul><p>再后面就是</p><ul><li>echo data</li></ul><p>在后面就是</p><ul><li>fastcgi_finish_request(); </li></ul><p>执行这个方法，这个方法的好处就是在我们尽快把客户端要的内容返回后，php 脚本还能继续执行， <a href="http://www.laruence.com/2011/04/13/1991.html" target="_blank" rel="noopener">参考鸟哥这篇文章</a></p><p>再后面就是客户端输出完成后服务端自己的一些收尾工作</p><p>再来整体分析下response 这个类</p><ul><li>__construct 初始化</li></ul><p>其中content-type charset 拼接很重要，标准的就是拼在一起，有时候当你没有识别json的，想想客户端传过来的content-type 是否多了 charset  utf8 信息</p><ul><li>create 生成一个response </li></ul><p>这个就相当于一个factory， 根据type的不同，生成不同的response， 注意我们控制器中返回的response 或者官方对于控制器中 string 这种的返回包装的response ，都是new 的，而不是从app 容器中取得</p><ul><li>send  解析response对象，给webserver 返回数据</li></ul><ul><li>output 对于data 依据content-type 进行处理，转成对应的string, 比如 json 转string</li></ul><ul><li>sendData  就是最后一步，echo 数据</li></ul><ul><li>options  一些额外的参数配置，比如tp 中，可以对于json_encode 添加参数 ，json_encode 之后汉字我们仍旧能识别</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">options([</span><br><span class="line">        &apos;var_jsonp_handler&apos;     =&gt; &apos;callback&apos;,</span><br><span class="line">        &apos;default_jsonp_handler&apos; =&gt; &apos;jsonpReturn&apos;,</span><br><span class="line">        &apos;json_encode_param&apos;     =&gt; JSON_PRETTY_PRINT,</span><br><span class="line">    ]);</span><br></pre></td></tr></table></figure><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190930193953.png" alt=""></p><ul><li>data 设置data 属性</li></ul><ul><li>allowCache  设置是否允许缓存request 内容，如果允许的话，会配置header头信息</li></ul><ul><li>header 配置header 头信息</li></ul><ul><li>content 把content 的内容转换成 string</li></ul><ul><li>code 设置http 状态码</li></ul><ul><li>lastModified 设置上次修改时间</li></ul><ul><li>expires  设置过期时间</li></ul><ul><li>etag  设置etag</li></ul><ul><li>cacheControl  设置cacheControl</li></ul><ul><li>nocache 设置不缓存</li></ul><ul><li>contentType 设置contentType</li></ul><ul><li>getHeader  设置请求头</li></ul><ul><li>getData  获取 data属性</li></ul><ul><li>getContent 类似上面的content 方法</li></ul><ul><li>getCode 获取http 状态码</li></ul><ul><li>debugInfo</li></ul><p>补充：</p><p>因为今天在看response类，他对很多header头部信息处理过，比如allowCache, 大致了解几个新的header 头 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ</a></p><p>cache-control  这个我们经常看到，no-cache,但这个其实并不是不缓存的意思（强制确认缓存的意思），no-store 才是不缓存的意思。其中还有max-age 属性，代表这个缓存最大活多久，must-revalidate, 代表使用之前要检验是否过期了。</p><p>expires 代表缓存过期的时间</p><p>今天在控制器中设置header 头发现不生效，原因有两个，</p><ol><li>php的header 蛮反人类的，这样用 header(“Content-Type:application/json”),竟然是字符串。</li><li>后面response send 中header 会覆盖掉控制器中的header</li><li>那为啥文件结尾header 没生效呢，因为response send 方法调用了 fastcgi_finish_request(), 结束了相应</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;框架可能让你对PHP 怎么给webserver 返回内容产生了误解 ！！！&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="ThinkPHP" scheme="http://yoursite.com/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>tp源码分析-异常处理</title>
    <link href="http://yoursite.com/2019/08/30/tp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/30/tp源码分析-异常处理/</id>
    <published>2019-08-30T05:05:13.000Z</published>
    <updated>2019-10-25T06:58:20.433Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000014977430" target="_blank" rel="noopener">参考文章</a></p><p>上面这篇文章写得很好，让我对异常处理除了 try catch 之外有了更深的认识，大致记录一下对php 异常处理的理解以及结合tp框架的源码分析</p><a id="more"></a><h3 id="PHP-处理错误的两大类方式"><a href="#PHP-处理错误的两大类方式" class="headerlink" title="PHP 处理错误的两大类方式"></a>PHP 处理错误的两大类方式</h3><p>首先我们要明白php 的异常处理分成两个独立的大块，一个是php自身的标准处理，就是我们经常error_reporting ， display_error 的设置（呈现形式就是界面上的php warning 信息， php fatal error 这种）；另一个是我们通过try catch 捕获异常进行处理（我们可能在catch 中 记录 $e-&gt;getMessage()） . 我们要清楚的是这两块对错误的处理级别是相互独立的，互不影响。比如error_reporting(0), 不对任何异常进行处理（ps: -1 ,类似 E_ALL ）,try catch 还是能捕捉到我们的exception。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_reporting(0); // 0 的时候没有任何错误信息， -1 的时候会打印出 //fatal_error</span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">  throw new Exception()</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">  var_dump($e-&gt;getMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PHP-标准错误处理-error-reporting-参数的意义"><a href="#PHP-标准错误处理-error-reporting-参数的意义" class="headerlink" title="PHP 标准错误处理 error_reporting() 参数的意义"></a>PHP 标准错误处理 error_reporting() 参数的意义</h3><p>error_reporting(), 不带任何参数，返回的是错误处理级别，带参数意思是设置错误处理级别</p><p>error_reporting(E_ALL ^ E_NOTICE) , ^ 是异或，代表除了E_NOTICE 都进行处理， 或者</p><p>error_reporting(E_ALL &amp; ~E_NOTICE), &amp; 是同或， ~代表取反，和上面是同一个意思，E_ALL是一个常量，数值是 E_NOTICE 那些的结合体</p><p>error_reporting(E_NOTICE | E_WARNING), 包括notice 和 warning 错误  </p><h3 id="PHP的错误等级"><a href="#PHP的错误等级" class="headerlink" title="PHP的错误等级"></a>PHP的错误等级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 系统级用户代码的一些错误类型 可由 try ... catch ... 捕获</span><br><span class="line">E_PARSE          解析时错误 语法解析错误 少个分号 多个逗号一类的 致命错误</span><br><span class="line">E_ERROR          运行时错误 比如调用了未定义的函数或方法 致命错误</span><br><span class="line"></span><br><span class="line"># 系统级用户代码的一些错误类型 可由 set_error_handler 捕获处理</span><br><span class="line">E_WARNING        运行时警告 调用了未定义的变量</span><br><span class="line">E_NOTICE         运行时提醒                  </span><br><span class="line">E_DEPRECATED     运行时已废弃的函数或方法</span><br><span class="line"></span><br><span class="line"># 用户级自定义错误 可由 trigger_error 触发 可由 set_error_handler 捕获处理</span><br><span class="line">E_USER_ERROR      用户自定义错误 致命错误 未处理也会导致程序退出</span><br><span class="line">E_USER_WARNING</span><br><span class="line">E_USER_NOTICE</span><br><span class="line">E_USER_DEPRECATED</span><br><span class="line"></span><br><span class="line">==========================开发中常遇到/不常遇到分割线=======================</span><br><span class="line"></span><br><span class="line"># Zend Engine 内部的一些错误 应该也能通过 try ... catch ... 捕获 略难测试</span><br><span class="line">E_CORE_ERROR</span><br><span class="line">E_CORE_WARNING</span><br><span class="line">E_COMPILE_ERROR</span><br><span class="line">E_COMPILE_WARNING</span><br><span class="line"></span><br><span class="line">#编码标准化警告(建议如何修改以向前兼容)</span><br><span class="line">E_STRICT          部分 try ... catch ... 部分 set_error_handler</span><br><span class="line">E_RECOVERABLE_ERROR</span><br></pre></td></tr></table></figure><p>这个地方需要我们注意的是结合PHP7 的 error 和 exception 来看，php7 的error 和 exception 都来自throwable， 所以我们在 catch  throwable都能捕获到，他和上述php 标准错误级别的关系如下</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/20190830133738.png" alt=""> </p><p>也就是说我们平时throw 的都是实际的error， 需要注意的是上面的 E_USER_NOTICE,并不指的是我们用户写的代码触发的notice， 或者throw 的 notice (用户throw的都是error)， 这个实际上我也没见过，但我们可以通过trigger_error 函数模拟出来</p><h3 id="PHP-各种错误的触发"><a href="#PHP-各种错误的触发" class="headerlink" title="PHP 各种错误的触发"></a>PHP 各种错误的触发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">error_repoting(0)</span><br><span class="line">aa</span><br></pre></td></tr></table></figure><p>为什么上述代码还是会抛出parse error， 因为我们在当前脚本中存在着错误，还没有执行error_reporting 就会报错，但有个方法可以让上述代码不报错，就是把 aa 写在另一个文件中，然后require 这个文件 。我们php-fpm 模式的本质，其实就是 php index.php, 所以我们在 index.php 中可以写上很少的代码，至少保证这个index.php 的正确性。</p><p>（可能是因为php是解释性的代码，只会检测require 的文件是否存在，不会检查被包含的该文件正确性，但是会对require 的文件中 require 语句正确性检测，蛮奇怪的,而且require 的文件不存在会抛出两个错误，一个是warning ，一个是fatal error， 这个warning 会被set_error_handle 处理，这个fatal error 不能被捕获， 而且竟然能通过error_reporting 屏蔽，感觉就是严重性介于 文件本身 parse error 和 try catch 捕获的 error 之间）</p><h3 id="关于PHP-异常处理的几个函数"><a href="#关于PHP-异常处理的几个函数" class="headerlink" title="关于PHP 异常处理的几个函数"></a>关于PHP 异常处理的几个函数</h3><ul><li>try catch , 不用做过多的介绍了，老朋友，可以捕获 throw 的所有内容，相当于 php 标准错误的fatal_error, 但不是fatal_error 就等于他，比如 require 的文件错误不存在，就不能被捕获</li></ul><ul><li><p>set_error_handle, 和上面的try catch 互补，try catch 捕获的都是 E_ERROR 级别，对于那些warning ,notice 就靠这个东西来处理了，他有个返回值，当返回false 的时候，错误还是会提交个php 标准错误处理的 （也就是处理错误的流程是先php代码处理，然后php 自身处理， 我觉得php自身处理应该就是日志记录，还有display error 。 php 的错误日志一定要注意位置，很多时候不是php.ini 里面配置的位置，而是虚拟主机 apache  或者 nginx 里面配置的日志位置）</p></li><li><p>set_error_handle要比想象中的强大多了，我们可以在这之中接受 erroNo, erroStr, 封装成 exception 抛出去，那么就会在当时被set_error_handle 捕获的地方抛出 （注意几个常用的 error的数字 ，比如 e_error 1, e_warning, e_notice.  -1 代表 e_all,  0 代表关闭所有的错误报告）（adodb即使开启了错误处理，也只能触发 e_user 级别错误，所以只能被set_error_handle 处理，set_error_handle 再抛出异常，才能被捕获）</p></li><li><p>set_exception_handle, 对于没有用try catch 捕获的错误（注意是没有用！！，而不是不能捕获的，捕获的内容等同于try catch）, 会走到这个里面进行处理，但是这个里面处理后程序就停止了，而try catch 处理之后程序还能接着往下走（ps:其实就我们平常而言，很多时候我们捕获了异常，除非在foreach 中，如果在平时逻辑中，也就直接return 给客户端，停止后面逻辑了）</p></li><li><p>register_shutdown_function， 注册一个程序结束的时候执行的函数，就是无论是崩溃啊，还是正常结束，都在最末尾执行的方法</p></li><li><p>error_get_last, 如果一个错误走到了php标准处理那块，就能通过这个获取错误内容，如果一个错误提前被捕获处理了，那这块就是空的</p></li><li><p>throw new Exception , throw new Error, 通过throw 异常，测试try catch 和 set_exception_handle</p></li><li><p>trigger_error, 对于 warning ，notice 那些错误的触发，测试set_error_handle(当然也可以通过 var_dump 一个不存在的变量来触发)</p><p>​</p><p>tp 所有的异常处理都会走到Error 的 appException 方法中,最后给到 getExceptionHandler方法</p><ol><li>首先最基本的提点try catch 的，会被 set_exception_handle 捕获，包括 \Exception 和 \Throwable, 交给 appException</li><li>warning 和user 级别，会被当做 errorException 抛出，转而到 appExcepiton 当中</li><li>register_shutdown_function , 那些没有被捕获到的错误，通过error_get_last 捕获，然后判断是否要塞入 appException 中</li></ol></li></ul><h3 id="TP-框架中的异常处理"><a href="#TP-框架中的异常处理" class="headerlink" title="TP 框架中的异常处理"></a>TP 框架中的异常处理</h3><p>我们对于异常的处理最好写在代码的最前面，否则error 触发之后，该错误之后的代码都不会生效。</p><p>tp 在base.php 中 Error::register();  ，注册了代码的错误处理。(核心文件 Error.php)</p><p>我们大致测试一下cli 模式下的异常处理</p><ul><li>register</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error_reporting(E_ALL); // php 标准错误处理级别</span><br><span class="line">      set_error_handler([__CLASS__, &apos;appError&apos;]); // 对于warning 级别的处理</span><br><span class="line">      set_exception_handler([__CLASS__, &apos;appException&apos;]); // 用户自定义的try catch , 会在执行完之后停止，但是不会交给php 标准错误处理</span><br><span class="line">      register_shutdown_function([__CLASS__, &apos;appShutdown&apos;]); // 感觉就是只要注册了，不管怎样都会执行</span><br></pre></td></tr></table></figure><ul><li>appError </li></ul><p>接受php 传递过来的参数，生成ErrorException 交给 appException 处理</p><ul><li>appException</li></ul><p>首先判断捕获的异常是error 还是exception， 如果是error ，统一转换成 errorException 处理</p><p>然后获取异常处理类，官方是Handle.php, 因为tp 允许用户重写这个类，如果重写了，需要继承官方的Handle 类，重写的方法是render， 框架会自动调用（为什么要重写这个类呢，因为比如记日志这种统一的方法就不需要重写了，框架会自动调用原先自己的方法）。如果没有重写，单单的给了匿名函数，会把这个匿名函数保存到 handle 的render 属性中，后期执行。如果匿名函数都没有，那就执行官方自己的render 方法</p><ul><li>appShutDown</li></ul><p>如果这个错误没有被处理直接交给了php标准错误，会抛出一个ErrorException, 交给自定义的异常处理，否则就记录下日志就好了</p><ul><li>isFatal</li></ul><p>需要抛出的错误级别</p><ul><li>setExceptionHandle</li></ul><p>设置自定义异常处理级别</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014977430&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面这篇文章写得很好，让我对异常处理除了 try catch 之外有了更深的认识，大致记录一下对php 异常处理的理解以及结合tp框架的源码分析&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>云南</title>
    <link href="http://yoursite.com/2019/08/26/%E4%BA%91%E5%8D%97/"/>
    <id>http://yoursite.com/2019/08/26/云南/</id>
    <published>2019-08-26T07:55:22.000Z</published>
    <updated>2019-08-27T02:55:25.154Z</updated>
    
    <content type="html"><![CDATA[<p>女朋友想让我陪她去洱海，因为上海直达大理的机票太贵啦┭┮﹏┭┮(后来算上住宿, 中间的火车,花的钱差不多)，我决定带着她从昆明，丽江再到大理，最后从大理再回昆明坐飞机回上海。</p><a id="more"></a><ul><li>购买机票</li></ul><p>我是买的早上7点45的飞机票，这个时间段和晚上9 10点的飞机都比较便宜，但不好的就是这么早很难赶到飞机场，再加上如果路途遥远，堵车等元素，很容易误车，然后我惊奇的发现美团上在机场旁边有那种精品酒店，其实就是机场周边的农村盖得房子，提供接送机！！！而且不贵，大概就100来块（当然也有贵的，O(∩_∩)O哈哈~），挺干净，噪音也不大，正常人完全能睡着，酒店阿姨会为你登记送机时间，提前半小时给你打电话，很暖心。</p><ul><li>起飞前的那晚</li></ul><p>这是破蛋25年来第一次带女生出去玩，再加上第一次住这种地方，还有见到女朋友的激动，最最重要的是我每次坐火车或者飞机起码检票前1个小时到目的地，那晚很紧张，没有睡着。后面因为从昆明到丽江，再从丽江到大理，从大理到昆明，这样来回折腾，其实都习惯，哪有那么多的特殊情况，安心睡吧，提前半小时到就好了。</p><ul><li>下飞机</li></ul><p>女票比我先到机场，然后因为天生自带shy属性，我在下飞机之后又在厕所呆了半小时，差点把她气疯了，还好她出门没化妆，在机场打发了一点时间。我们在美团上定的民宿在昆明的五华区，离翠湖公园还有南屏街，云南大学很近，因为担心媳妇嫌弃转车麻烦，我们直接打车过去，相比较重庆50元南山区和渝北区随便跑，80元的车票还是蛮贵的，司机师傅确认了2遍我们是否要开发票被我们说不用后，可能在想这两个瓜娃子是不是钱多了。</p><ul><li>昆明初印象</li></ul><p>昆明这座城市还是蛮破的，可能因为我们在市区的原因，还有时间是8月20日，没有书本中的花城的样子，周围都是破破的，相比较重庆没有那么繁华，现代化</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/1d7a86c5c7cd42a59852d9eba53dc3f.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/4d723356cb20e57a611ca43cddc8685.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/7eefd14ba6a55263a396eb33ee5f132.jpg" width="400"></div></div></div></div><ul><li>玩在昆明</li></ul><p>昆明的景点还是有挺多的，比如翠湖公园，云南大学，南屏街，滇池，海埂公园 （打算去的，可是女朋友嫌弃太晒了，所以我们最后只去了翠湖公园 + 看了场哪吒！！！，翠湖公园很一般，和普通公园差不多），如果时间充足，可以去看一些石林呀，云南名族村，或者11月份之后去，可以在海埂公园喂海鸥。</p><ul><li>吃在昆明</li></ul><p>我们选择了大众点评上的第一家云南菜，云海肴，相比较那么多的好评，其实菜的味道一般般，但价格还是蛮实惠的(民宿老板推荐茄子恰恰)。 我们点了纳西族烤鱼(纳西族是云南这边的主要名族)，鱼腥草(女朋友爱吃，我实在难以下咽), 白切鸡倒上辣椒油(上海的一个味道, 女票爱吃)，还有一个豆尖豆腐汤(豆尖吃不习惯，泥土的味道)，后来想想是因为可能是让女票点菜的原因，没有吃上特色菜，下次就跟着点评上的top走。我们只在昆明呆了1天，所以只吃了3顿饭，其余的两顿中一个是世界级连锁kfc的桶饭，真的难吃，媳妇只是喝了点汤，一个是早餐，昆明的早餐很难找到喝粥的地方，只有米线，我们点了个清汤的和一笼包子，不知道为啥，米线有股臭臭的味道，包子也是皮蛮厚的，华夏大地应该都能吃到。</p><ul><li>昆明总结</li></ul><p>感觉很一般，可能是因为我们去的地方比较少，不推荐住在五华区，也就是市区，这边的景点可能就是翠湖公园</p><ul><li>丽江古城</li></ul><p>从丽江站到丽江古城有公交车可以直达，蛮方便的。相比较之前知乎上写的丽江站有很多黑车拉你去拉市海不骑马不给回，好像是因为政府整治了，丽江站可能是我去过的最干净的一个站，没有任何一家黑车，公交站台比较少，每一站中间距离很大，所以一定不要坐过站，我们住在古城中，在古城停车场下车。古城中有很多客栈，大部分都是木质的房子，不隔音，晚上睡觉的时候时不时有路过宿醉的年轻男女，放声高歌，这都是女票告诉我的，因为男生一般都睡得比较死的哈哈，所以如果你喜欢安静，那就去新城住吧。（ps:不知道是不是女票叫的太大声，客栈老板给我取了个外号，睡哥~^_^。)老板很热心，虽然可能是因为紫外线比较强的原因，皮肤黝黑，但是给我们仔细介绍了古城有哪些景点，大水车，木府（商业化，都是卖茶叶的不推荐），五一街，四方街（酒吧街），狮子山（最高点，可以看到古城全景），忠义市场（水果比较便宜，我们买了，到底便宜不，无从考证，可是没有网上说的日照时间足，甜）。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/73e4d1d3792ad8a7f6a1c030b5c730d.jpg"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/ee30b50aa1af53632c82b26ee3b8a47.jpg"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/889d5d21856799d9982236c9bf14f4b.jpg"></div></div></div></div><ul><li>古城总结</li></ul><p>丽江古城可能是我去过的最好玩的一个古城，古城的地面都是转头，所以行李箱只能拎着！！古城的道路上还有很多狗屎，似乎踩狗屎是这边的一个风俗了，古城里面有个丽江之眼 的观景台，看到的风景和狮子山上差不多。四方街也就是酒吧街很适合拍照，古城中的嘉华鲜花饼是真的好香，袋装的大概32，盒装的56，晚上和女票闹矛盾，如果有时间的一定要去试吃一下。古城的晚上超级多的人，如果怕挤的话，那就白天逛逛，但是肯定没有晚上热闹了，女票买了一个鸡血藤55，原价150，后来在别的地方看到10元三个。陪着女票去了狮子山，她看到一个清吧就钻进去了，点了两杯喝的，一盒瓜子，一盒牦牛肉，175，客栈老板说蛮坑的，但是女票想看夜景呀，后来发现古城的夜景真的好垃圾哦，但也可能我们那个地方不够高，不推荐狮子山上的商业清吧。我们在丽江吃了一顿，滇厨餐厅，还可以，他家的水性杨花（一定要在云南吃水性杨花）很好吃，腊排骨分量太大，两个人吃不完，红豆酸奶味道和别的地方一样，铜锅饭两个人吃刚好，但味道一般，鸡豆凉粉一般，玫瑰糍粑有花的味道，对于我这种很少吃糍粑的人来说一定要点，土豆泥不好吃。</p><ul><li>玉龙雪山</li></ul><p>我们在美团上团了雪山的一日游，320一位，小索道 + 甘海子 + 蓝月谷 + 云杉坪，蛮推荐的，早上八点的时候有师傅来接我们，晚上5点能回到古城。索道一共分成3种，大索道（冰川公园），牦牛坪中索道，云杉坪小索道。当时我们一车8个人，只有我和女票是小索，剩下的都是挑战4680的玉龙雪山，当时害怕死了，以为女票要和我发火，可是后来呢师傅说我们这个季节小索道最好玩，11月到来年2月大索道才好玩，因为现在山顶都是雾，看不到东西，而且没有雪（媳妇夸我功课做得足，嘿嘿），而且大索道需要排队很久。上午的行程就是坐小索道去半山腰，然后徒步去云杉坪，路途很短，中间可能遇到马，可以喂食，所以带点面包或者买个玉米喽，路途的风景就是类似高海拔的林区。栈道的尽头就是云杉坪了，很大的一片草场，有一些牦牛在吃草，还有很多新人在拍照。这边的天气阴晴不定，要随身带着伞，或者纯玩团发的羽绒服，也是可以防雨的。</p><p>小索道的行程一点不紧张，中午有团餐，真的这是我来云南吃的最好吃的一顿（水月阁老山鸡火锅），第一次发现火锅中烫鸡肉能这么好吃，汤汁特别鲜美，泡上米饭，让人欲罢不能，而且可以随便加肉加菜，胃口大的小伙伴们有福了。</p><p>下午我们逛的是蓝月谷，蓝月谷的湖水真的像网上那般蓝绿，但小瀑布处的水又白的那么彻底，从下游走到上游，一路上很多拍婚纱的新人，希望他们的爱情也能永远和这湖水一样纯净，没有杂质，配着远处白云缭绕的玉龙雪山，真的美不胜收。</p><p>逛完蓝月谷之后我们的行程就基本结束了，坐大巴（免费的，都包含在门票中，所以看到大巴就可以随便上）来到入山口，等着纯玩团的小伙伴们集合，一起坐导游师傅的车回古城，沿途路过甘海子，司机会让拍拍照，^_^因为这也算一个景点啦（总共4个），因为太累了，男生们都没有下车，女生会出来走走，其实就是一个大片的小树林。</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/ab5f780b76005a77b433648c5665019.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3f081c8c083faf4ecd9a9854a27c2ac.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/41bec6e937e2f1488d379af8736137b.jpg" width="400"></div></div></div></div><ul><li>大理</li></ul><p>在大理住宿的话，大概有两个主要地方，一个是古城，感觉住宿情况应该类似丽江，但肯定只会比丽江差，因为我们去古城玩的时候会看到很多民宿，真的就是那种农村自建的房屋，肯定看不到海，另一个就是双廊，双廊那边因为紧靠洱海，可以看到海，所以住宿比较贵。我们呢选的是滨海俊园，在大理白族自治州博物馆旁边，那家住宿真的除了甲醛味道，应该是我们这次旅行最满意的地方了，所有可能用到的物品（矿泉水，棉花棒，byt，熨斗，雨伞…）能想到的都有，而且很多小设计很贴心，比如浴室的感控灯，浴室的喷头是对着墙，所以刚开始放水的时候喷不到身上，方便我们调整水温，还有因为云南那边四季如春，loft的房屋基本都没有空调。</p><p>我们在大理一共吃了两顿，一家是遇见小仙女，点了豆腐，汽锅鸡，野生菌，因为媳妇不饿，所以我们店的不多。不太好吃，^_^，豆腐很油，汽锅鸡以为和昨天的老山鸡火锅一样才点的，其实他更像是炖鸡，媳妇比较爱吃。最坑的应该hi那个野山菌了，80元，但味道一般，也不下饭。还有一家是方胖子厨房，我们点的是野山菌火锅，点了三种菌加两个蔬菜，加一个鲜牛肉，锅底中有鸡肉，所以两个人能吃的很饱，同样没有很惊艳，汤汁肯定没有老山鸡鲜美啦（哈哈哈，水月阁老山鸡火锅是我的最爱）</p><ul><li>大理景点</li></ul><p>大理古城：一般，肯定比不上丽江古城，也没有什么景点</p><p>大理白族自治州博物馆：很安静，我对历史没有什么兴趣，但值得一去</p><p>花语牧场： 门票蛮贵的，两个人80，媳妇说就拍了几张照片，我感觉还好，要是有喜欢拍照的朋友，还是可以拍出很多漂亮的照片的</p><p>喜洲古镇：一般，没有逛，牛奶冰棒和喜洲粑粑，可能我们没迟到正宗的，一般</p><p>双廊古镇：一般，但是媳妇吃到她最喜欢的猪大肠，还给她妈买了个银镯子，8元一克，后来发现别的家只用6元</p><p>小普陀：停车费10元，然后就没有啥印象啦</p><p>洱海：如果想环洱海的话最好租车，电瓶车肯定不行，而且挺晒的， 价格大概是 80 vs 500, 小伙伴们自行斟酌</p><p>挖色镇，太阳宫都没怎么去，基本都差不多，我们租了车（媳妇说很难开，500一天，蛮贵的当时感觉，我当时想订的是350，但是看到她发朋友圈就感觉蛮值得，毕竟我想订的那个确实不太好看）</p><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/6db5c67eac68dbbe86ba05ad1799b9d.jpg" width="300"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/d6bdc23ae1d4931cc4797cb65b12019.jpg" width="400"></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/3ba0a21804552d8eb5e01d3221b935c.jpg" width="400"></div></div></div></div><p>上面大概就是这次云南的五日游，总的来说，丽江最好玩，昆明和大理（农村）一般，但也算是圆了女票的一个梦，这就够了吧，拜拜~~</p><p><img src="https://cytuchuang-1256930988.cos.ap-shanghai.myqcloud.com/caec0172307f3ff74e800ddfb501ef0.jpg" width="300"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;女朋友想让我陪她去洱海，因为上海直达大理的机票太贵啦┭┮﹏┭┮(后来算上住宿, 中间的火车,花的钱差不多)，我决定带着她从昆明，丽江再到大理，最后从大理再回昆明坐飞机回上海。&lt;/p&gt;
    
    </summary>
    
      <category term="旅游" scheme="http://yoursite.com/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="旅游" scheme="http://yoursite.com/tags/%E6%97%85%E6%B8%B8/"/>
    
      <category term="云南" scheme="http://yoursite.com/tags/%E4%BA%91%E5%8D%97/"/>
    
  </entry>
  
</feed>
