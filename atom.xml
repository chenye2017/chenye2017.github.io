<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>语法糖的博客</title>
  
  <subtitle>爱动漫，热爱LOL</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-26T06:30:48.453Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>chenye2017</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux搭建git仓库</title>
    <link href="http://yoursite.com/2018/07/24/Linux%E6%90%AD%E5%BB%BAgit%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/2018/07/24/Linux搭建git仓库/</id>
    <published>2018-07-24T11:52:40.000Z</published>
    <updated>2018-07-26T06:30:48.453Z</updated>
    
    <content type="html"><![CDATA[<p>故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。<br><a id="more"></a><br>后来老大希望测试下我写的代码，看看需要哪些参数，给了另一台服务器。<br>刚开始想到直接把修改好的代码打个包放上去，后来想了下不是长久之计，因为我的水平肯定要经常修改代码，不能每次修改下就打包一下，太麻烦了。<br>又想到可以通过配置itbasic服务器上的svn，当svn up 的时候忽略掉特定文件夹的更新，百度了下集中方法，大部分是一下集中情况：windows下忽略文件夹，提交代码的时候忽略掉文件夹，很少有更新代码的时候忽略掉文件夹的解决办法。（有，但自己试验失败）。<br>后来想到不如利用git吧，首先大部分都是我一个人操作，我经常向github提交代码，操作已经很熟悉了，再者毕竟用git也能跟上时代的潮流嘛。</p><p>先来介绍一点基础知识：<br>当我们想下载github上的代码（或者说远程仓库的代码），我们可以通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git clone git@ip地址：git远程仓库的地址</div><div class="line">//例如</div><div class="line">git clone git@github.com:chenye2017/zerg.git</div><div class="line">//当需要下载github上的仓库的时候，直接去这个项目首页，会有个clone or download的选项，注意不要选择use https，因为选了那个每次提交代码额时候都要输入密码</div><div class="line">//winodows用户可以直接下载zip</div><div class="line">git clone git@192.168.56.10:/home/resposity/bbs.git</div></pre></td></tr></table></figure></p><p>新建一个目录，自定义名称<br>进入到这个目录内，执行上述操作，就能把项目目录中的代码下载下来。</p><p>但上面仅仅只是下载项目，我们为了和远程仓库进行联动，我们需要在本地的这个文件夹建造一个git仓库，然后和远程仓库的某个分支比如master进行绑定，当我们修改完成的时候进行代码推送到远程的时候，别人下次再次clone或者pull就能收到我们提交的修改。<br>下面就是创建本地仓库的实例代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">cd dir</div><div class="line">//进入上面执行git clone的文件夹</div><div class="line">git init</div><div class="line">git add.  //把修改的文件夹都添加进来</div><div class="line">git commit -m &apos;init&apos;  //提交到本地代码库</div><div class="line">git remote -v //查看远端仓库</div><div class="line">//如果有远程仓库，可以进行删除</div><div class="line">git remote rm origin</div><div class="line">git remote add origin git@192.168.50.16:/home/resposity/bbs.git //添加远程仓库</div><div class="line">git push origin master  //和远程仓库的master分支绑定，以后提交只需要git push</div><div class="line">git pull origin master //同上，以后使用也只要git push 就好了</div></pre></td></tr></table></figure><p>当我们提交代码的时候肯定是不成功的，提示我们需要输入密码，···而且每次都会提示，怎么办呢，可以通过一个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</div></pre></td></tr></table></figure></p><p>在windows中，生成密钥位置会在C:\Users\admin 下面，这个下面有.ssh文件夹，进去复制末尾是.pua 也就是公钥的文件，粘贴到你的git仓库所在的服务器的git 主目录下，比如我的是 /home/git/.ssh/authorized_keys,粘贴到文件末尾即可，如果还不能提交代码，重启下sshd服务，netstat -antp|grep sshd, kill, /usr/bin/sshd 启动<br>如果还不行，可以查看这篇文章修改下配置 <a href="https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873" target="_blank" rel="external">https://blog.csdn.net/dreamstone_xiaoqw/article/details/78355873</a></p><p>一直提交需要填写密码其实是个很常见的问题，收集了几篇文章，因为之前一直不成功，但后来成功了，但其实不是下面这几个问题，是我对git远程仓库理解出现了问题，所以操作不对.<br><a href="https://www.jianshu.com/p/9dbb1dea5929，" target="_blank" rel="external">https://www.jianshu.com/p/9dbb1dea5929，</a> （文件夹权限），<br><a href="https://ruby-china.org/topics/14182" target="_blank" rel="external">https://ruby-china.org/topics/14182</a> （ssh真的出问题了，需要查看日志）</p><p>最后也是最终的要一步，按理说这应该是第一步的，就是linux上远程创建git仓库。<br>本身应该 1. 创建远程仓库 2 git clone 3. git push<br>这也是我们平时使用github 的主要步骤，但因为这一步最重要所以我放在了最后。</p><p>git创建远程仓库 <a href="http://www.runoob.com/git/git-server.html" target="_blank" rel="external">http://www.runoob.com/git/git-server.html</a> 菜鸟教程上已经说得很清楚了，只是我们需要区别一下两行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git init --bare</div></pre></td></tr></table></figure></p><p>第一个我们经常用到是实例化本地仓库，第二个是创建一个裸库，什么意思呢，就是这个裸库就是我们平时那个 git clone ip地址后的路径，这个仓库装的都是我们的提交记录，本身是并没有代码的，但我们通过git clone能生成最新的代码，以我的服务器为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/home/resposity  //专门用来放远程仓库的文件夹</div><div class="line">/home/resposity/bbs.git  //我的bbs远程代码库</div><div class="line">/home/code/bbs  这是我的服务器上实际项目代码，也是被人访问我的项目的路径</div></pre></td></tr></table></figure></p><p>当我本地修改好了代码（windows下），提交到远程仓库中，然后在服务器的/home/code/bbs (线上项目文件夹)下进行更新git pull最新的代码,别人就能访问到我本机的最新代码了。</p><p>对了，还记的我们当初svn代码更新提交失败，提示svn clean也不行的时候怎么处理的吗，就是清除.svn 下面两张表里面的数据 (通过Navicat建立连接).当时刚开始是不会这种方法的，同事告诉我直接删除.svn这个文件夹，说svn管理这个文件夹都是通过他，现在想起来挺有道理的，但没有试过（以前直接是删除了svn这个软件，然后肯定不成功啦，现在想想这和svn半毛钱的关系都没有撒，但感觉不能删除.svn,因为删除了，那些diff都找不到了）git应该也是通过.git这个文件管理的。</p><p>对了，关于免密码登录，当我们通过命令生成的ssh密钥linux下，一般在这个用户目录下面，比如root用户，在/root/.ssh 下面，我们需要把这个公钥粘贴到需要进行提交的git远程仓库的服务器中git的安装目录下面的ssh的auth···——key，里面，追加在文件末尾，注意着这两个地方文件名虽然类似，但一定要分清把那个粘贴到哪个上面，分清主从关系。</p><p>关于忽略文件夹，编辑.gitignore 文件，在项目根目录下面，因为windows下面不能这样命名文件，可以在linux下面编辑保存，编辑之后这个文件就是untracked形式,以后的提交就不会把这个文件保存在内，即使用了git add.</p><p>但是之前把.idea这个文件夹包含进去了，怎么办呢，git remove -n -r –cached</p><p>–cached  只是git仓库删除了，本地不会删除，-r 类似删除文件夹的时候递归删除， -n 先列出来要删除的文件，真正想删除的时候不要加这个参数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;故事的发生背景：项目前端走了，前端界面没有人修改，只能先做后端，但是没有测试环境，而且这个bbs项目还被包含在itbasic里面，一旦代码提交到svn上，当我想更新服务器上的itbasic代码的时候，我一般直接在根目录下进行svn up来更新代码，这样会把bbs提交到svn上的代码也拉下来，所以本地的代码没法提交。以前我和前端镜像代码对接的时候，一般我都是先更新到svn上，然后前端进行下拉代码测试，当没问题的时候再去服务器上拉取svn的代码。但现在前端寻找不到，如若我更新bbs上代码，必然论坛会崩溃。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网站部署随笔</title>
    <link href="http://yoursite.com/2018/06/20/%E7%BD%91%E7%AB%99%E9%83%A8%E7%BD%B2%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/06/20/网站部署随笔/</id>
    <published>2018-06-20T13:36:20.000Z</published>
    <updated>2018-06-20T14:48:01.622Z</updated>
    
    <content type="html"><![CDATA[<p>618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。</p><a id="more"></a><p>好久之前在阿里云上买过一个域名，29一年，chenye2017.cn,主要这个名字和我的github账号也是一致的，比较好记。当我想绑定域名到服务器上的时候，其实有点担心，我在阿里云上买的域名能绑定到服务器上吗？</p><p>试试吧。首先需要对域名进行实名认证，域名的实名认证其实挺简单的，填下身份证号和联系电话就好了，后面需要备案，这点需要注意的是，我绑定的是京东云，所以需要在京东云上备案。之前对于域名的购买，我的理解是购买一款厂商的产品，但其实不是这样的，试想一下我们购买域名的时候是不是只要先构思一个自己想要的域名，然后查询域名是否在使用，如果没有使用就可以进行购买，这个凭空想象出来的域名厂商不可能提前为我们准备好，他能做的就是通过域名解析器dns把我们的域名注册进世界的万维网当中，当世界中的某个人通过浏览器进行访问的时候，dns能把域名解析成ip地址找到我们的服务器，既然这样，那我们是不是只需要在我们的服务器上搭建一个域名服务，就能不通过购买他的域名，直接使用自己注册的域名就可以了呢？理论上是可以的，但我没有去实践过。</p><p>备案未完成…</p><p>之前帮前端同事部署过一个vue项目，其实和部署一个php项目 极为相似，甚至更简单，都是通过找寻唯一入口文件，因为前端项目都是静态文件，而且apache默认找的文件夹下面的第一个文件就是index.html,所以都不需要进行特殊的设置（php的话因为要找index.php,所以要做更多的设置），唯一需要注意的就是前段项目的很多路径都是绝对路径，他本质上是相对网站的根目录来的，也就是默认项目部署在网站的根目录下，如果网站没有部署在根目录下，比如itbasic bbs，需要我对引入的静态资源路径进行适当的修改。比如给需要找的静态资源建立个软链接ln -s ,到新的静态资源目录下。</p><p>因为之前是根据网上教程搭建的hexo，其实不懂他的实现原理。</p><p>而且在教程的开始，就说了要使用node，对于我这种js都不好的人，看到node，首先就觉的完了。其实很多前端项目用到node，并不是用到nodejs的语法，而是用nodejs搭建了一个web服务，承载前端项目，然自己置身于一个联网的状态中，就能发出类似ajax这样的联网请求，因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是<a href="http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。" target="_blank" rel="external">http://开头了们可以进行ajax请求。因为当我们保存在本地的html在浏览器中打开的时候是file://开头的，这是默认禁止进行ajax请求的，但当我们使用node的时候，页面的路径就是http://开头了们可以进行ajax请求。</a></p><p>我看了下上传到github上的文件夹，和我本地的项目代码结构还是有挺大区别的，我的理解就是把本地代码进行了打包，打包好的文件上传到github上了（类似vue代码的发布），上传到github上的文件夹全是静态目录结构，我惊喜的发现了index.html,于是大胆的假设了下如果把那个目录放在我的站点根目录下，是否也能进行访问了呢，我就不用通过chenye2017.github.io去访问，而是通过我自己的站点去访问呢，毕竟服务器在国内，访问速度也比较快。</p><p>结果是成功的，印证了我的假设。</p><p>在网站部署的时候还遇到了几个问题，比如源码编译apache2.4,在之前还需要安装apr,apr-util,之类的文件，apache2.4的改文件访问权限和之前的apache还不一样，还有文件夹名字结尾不能有空格，否则识别不出来，加载vhost.conf,启动apache失败，修改server localhost之类的apache配置文件，还有apachectl restart开始不管用，需要自己手动配置脚本····</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;618买了个网易云，2g内存1m带宽1核40g的存储，123一年，挺便宜的，相比较阿里云ecs和网易蜂巢还有腾讯云，之前同事有买过国外的vps搭建梯子，但在国内，vps这种的也就只能搭建梯子使用，如果想生活中用来玩玩，那是不利于个人的身心健康发展的，因为毕竟服务器架在国外，通过控制台或者xshell进行连接的时候真的有种想死的感觉，输入命令和幻灯片一样，但国外的vps好像是可以按照使用时间来计费的，国内的一般都是年。当初以为云服务器除了ecs就是vps，其实这两个只是云服务器中比较出名的，一个是国内一个是国外，像腾讯云叫什么cloud，这些名字只是厂商给她们产品取得，并不是专有名词。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>无限递归</title>
    <link href="http://yoursite.com/2018/06/13/%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2018/06/13/无限递归/</id>
    <published>2018-06-13T08:00:30.000Z</published>
    <updated>2018-06-13T09:15:47.145Z</updated>
    
    <content type="html"><![CDATA[<p>无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。</p><a id="more"></a><p>以部门举例，我们在使用的过程中，需要找到这个部门的相关父级部门（子孙树），或者我们需要知道某个部门是否属于某个部门，我们既可以用家谱树去实现，也可以用子孙树去实现，用子孙树去实现的一个好处就是，当我们知道父级节点，一次性求出这个父级节点的所有子孙，通过判断子节点是否在这个父级节点的子孙中，就能知道是否满足条件。但如果我们通过家谱树，我们需要每次根据子节点，去求一次家谱，然后来判断家谱树中是否有这个父级节点存在，来判断是否符合条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">$address = array(</div><div class="line">    array(&apos;id&apos;=&gt;1  , &apos;address&apos;=&gt;&apos;安徽&apos; , &apos;parent_id&apos; =&gt; 0),</div><div class="line">    array(&apos;id&apos;=&gt;2  , &apos;address&apos;=&gt;&apos;江苏&apos; , &apos;parent_id&apos; =&gt; 0),</div><div class="line">    array(&apos;id&apos;=&gt;3  , &apos;address&apos;=&gt;&apos;合肥&apos; , &apos;parent_id&apos; =&gt; 1),</div><div class="line">    array(&apos;id&apos;=&gt;4  , &apos;address&apos;=&gt;&apos;庐阳区&apos; , &apos;parent_id&apos; =&gt; 3),</div><div class="line">    array(&apos;id&apos;=&gt;5  , &apos;address&apos;=&gt;&apos;大杨镇&apos; , &apos;parent_id&apos; =&gt; 4),</div><div class="line">    array(&apos;id&apos;=&gt;6  , &apos;address&apos;=&gt;&apos;南京&apos; , &apos;parent_id&apos; =&gt; 2),</div><div class="line">    array(&apos;id&apos;=&gt;7  , &apos;address&apos;=&gt;&apos;玄武区&apos; , &apos;parent_id&apos; =&gt; 6),</div><div class="line">    array(&apos;id&apos;=&gt;8  , &apos;address&apos;=&gt;&apos;梅园新村街道&apos;, &apos;parent_id&apos; =&gt; 7),</div><div class="line">    array(&apos;id&apos;=&gt;9  , &apos;address&apos;=&gt;&apos;上海&apos; , &apos;parent_id&apos; =&gt; 0),</div><div class="line">    array(&apos;id&apos;=&gt;10 , &apos;address&apos;=&gt;&apos;黄浦区&apos; , &apos;parent_id&apos; =&gt; 9),</div><div class="line">    array(&apos;id&apos;=&gt;11 , &apos;address&apos;=&gt;&apos;外滩&apos; , &apos;parent_id&apos; =&gt; 10),</div><div class="line">    array(&apos;id&apos;=&gt;12 , &apos;address&apos;=&gt;&apos;安庆&apos; , &apos;parent_id&apos; =&gt; 1)</div><div class="line">    );</div><div class="line"></div><div class="line">function test($data, $pid)</div><div class="line">&#123;</div><div class="line">    static $arr = [];</div><div class="line">    foreach ($data as $key=&gt;$value) &#123;</div><div class="line">        if ($value[&apos;id&apos;] == $pid) &#123;</div><div class="line">            $arr[] = $value;</div><div class="line">            test($data, $value[&apos;parent_id&apos;]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $arr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var_dump(test($address, 4));</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">庐阳区，合肥，安徽</div></pre></td></tr></table></figure><p>子孙树的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function test1($data, $id, $level = 1)</div><div class="line">&#123;</div><div class="line">    static $arr = [];</div><div class="line">    foreach ($data as $key=&gt;$value) &#123;</div><div class="line">        if ($value[&apos;parent_id&apos;] == $id) &#123;</div><div class="line">            $value[&apos;level&apos;] = $level;</div><div class="line">            $arr[] = $value;</div><div class="line">            test1($data, $value[&apos;id&apos;], $level + 1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $arr;</div><div class="line">&#125;</div><div class="line">//level主要用来显示是几级的儿子</div></pre></td></tr></table></figure><p>还记得我们在大学学习数据结构的时候，因为递归对于效率有影响，所以经常需要把递归改成迭代，上述家谱树容易修改，子孙树需要用到栈，自己不是很理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function test2($data, $pid)</div><div class="line">&#123;</div><div class="line">    static $arr = [];</div><div class="line">    while ($pid != 0) &#123;</div><div class="line">        foreach($data as $key=&gt;$value) &#123;</div><div class="line">            if ($value[&apos;id&apos;] == $pid) &#123;</div><div class="line">                $arr[] = $value;</div><div class="line">                $pid = $value[&apos;parent_id&apos;];</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return $arr;</div><div class="line">&#125;</div><div class="line">var_dump(test2($address, 4));</div><div class="line">//迭代和递归的转换主要就是靠迭代找到那个停止往上找的条件</div></pre></td></tr></table></figure><p>大致就是上面这些，像面包屑导航，不要看着从左到右，其实他也是一棵家谱树，因为他从始至终就只有一棵树。</p><p>还有就是移动各个部门位置问题：</p><p>想象一下，一棵树，我把某个分支截取下来放到另一个分支上是很正常的事情，但问题是有时候，我会出现把父亲节点的父亲设置成自己的子节点，这样树枝就断了，这样是不可取的，除此之外，任意移动都是可以的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无线递归用到的地方还是蛮多的，如果是我们itbasic上的话，那就是部门之间的关系，支撑体系下面有战略中心，战略中心下面有数据部，如果设计数据表维持这之间的关系，还有bbs，如何维护评论之间的关系（其实像laravel的论坛，他的评论关系都是从上往下一条线的，只是在评论的开头有@人的标志，我们的论坛是分为1级评论和多级，除了1级之外的评论都是在1级评论的后面按照1条线排列，没有显示主从关系），当我们需要获取这个评论的顶级的时候，我们就需要用到无线递归的知识。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域 cookie</title>
    <link href="http://yoursite.com/2018/06/06/%E8%B7%A8%E5%9F%9F-cookie/"/>
    <id>http://yoursite.com/2018/06/06/跨域-cookie/</id>
    <published>2018-06-06T10:30:54.000Z</published>
    <updated>2018-06-06T12:20:16.767Z</updated>
    
    <content type="html"><![CDATA[<p>cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。</p><a id="more"></a><p>cookie,对于传统的lamp架构，在服务器端想获取可以通过$_COOKIE[]数组获取到，但是对于swoole这种自己搭建web服务的东西，只能通过request请求获取，其实lamp里面本质也是这样，也是把apache或者nginx获取到的请求内容放到了php的\$_COOKIE里面，类似的\$_SERVER, \$_GET,这些在swoole里面都是永不了得，你可以把http-&gt;request-&gt;get 的值在请求到来的时候给与\$_GET数组，这样就能在swoole搭建的web服务里面和普通的lamp架构一样使用\$__GET数组了。正因为swoole的这些特性，像如果在swoole里面使用session登录机制需要自己去实现，还有对于一些框架的集成，因为外部传入的参数不在那些数组中了，所以需要对框架进行修改，让框架能获取到对应的参数，保证框架的运行，比如：swoole集成slime框架(swoole在客户端设置cookie也得用它自带的方法而不是setcookie)。</p><p>回归正题，通过上述，我们也只cookie是一个数组，那其中哪把钥匙是用来打开session的呢，答案是PHPSESSID,这个值是可以设定的，在php.ini,或者通过php的session函数来获取到。</p><p>对于session，我觉得他更像是一个模块的扩展，他不仅仅是提供一系列的简单的函数，这些函数其实还有具体的活动的封装。比如开启session的时候，session_start(),他做的东西有很多，首先检测客户端是否有 phpsessid，如果没有，通过函数setcookie，在客户端种植，其实底层就是通过在返回的header头信息中加入set-cookie，如果已经有phpsessid，会通过寻找客户端对应的session，获取里面的信息。那问题又来了，这个phpsessid的cookie是怎么传送给服务端的呢，我不记得我有加入这个cookie啊，一般情况下，在发送http请求的时候，默认都会带上浏览器的cookie。如果禁用了还可以通过url传递哦，话说从url中获取phpsessid也是在session_start()函数中实现的，可见这个函数的复杂性，和普通的函数还是不一样的，里面有具体的逻辑。</p><p>对于cookie的设置，也是有跨域问题的，a.test.com下的cookie,在b.test.com下面不能获取到，但是如果在test.com下面就能获取到了，为什么呢？看看跨域吧。不信？你可以设置下，在/path页面下设置另一个path的cookie，然后去对应的path下刷新，看是否有，答案是肯定有的啦。所以cookie的设定。path是不影响的。</p><p>既然能设定，自然就能删除，设定和删除可以归为一类操作（直接把过期时间设定成当前时间-100就可以删除了，注意cookie有max-age存在的时间和expire过期时间之分，php的setcookie设定的时间是expire时间，所以需要在过期时间+time()!!之前就犯了这个错误）</p><p>其实php的setcookie也能验证这点。在控制器中调用setcookie，如果不传path，默认是当前path，但也可以加path,比如/。</p><p>但需要注意的是不同path下面不能相互读取!!!怎么试验呢，可以在chrom的application下面写,然后在当前path写同一个域名下的另一个path，刷新cookie，发现另一个页面下面的有这个设置的cookie，请求的时候也能带上，但是自己这个设定页面没有，所以有时候如果setcookie没错误，但也没出现cookie，可以考虑下是不是设置路径错误了，虽然设置上了，但是看不见。这种情况特别容易出现在前后端分离的情况下，前端在80端口下，后端在8080端口下，后端api设定cookie是装在了8080那个域名下面，所以你无论怎么刷新前端页面都不会有这个cookie，但是没关系，当你请求后端接口的时候，请求会自动加上！！但要注意，请求的时候，http请求只能把他当前能看到的cookie带上，对于他看不见的肯定不会带上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cookie，对于传统的php开发web必不可少，为什么呢，因为http是无状态协议，为了让浏览器在不同的tab页面记住我这个人，我们通过让同一个浏览器在访问同一个网址的时候都使用同一个钥匙，这个钥匙就是cookie，这个钥匙能打开服务器端特定的箱子，就是session，这个session里面保存了完整的用户信息，这样就能让浏览器记住我的不同tab页对应的是哪一个人了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="http://yoursite.com/2018/06/06/%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/06/06/跨域/</id>
    <published>2018-06-06T09:34:20.000Z</published>
    <updated>2018-06-06T13:55:05.333Z</updated>
    
    <content type="html"><![CDATA[<p>跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。</p><a id="more"></a><p>关于浏览器同源策略的原因，可以网上查看各种资料，阮一峰的博客是个很好的选择。</p><p>什么时候会出现跨域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">http://www.example.com/dir2/other.html：同源</div><div class="line">http://example.com/dir/other.html：不同源（域名不同）</div><div class="line">http://v2.www.example.com/dir/other.html：不同源（域名不同）</div><div class="line">http://www.example.com:81/dir/other.html：不同源（端口不同）</div><div class="line">组成一个域名（协议号：//ip地址：端口号）三者任意一个不同就会出现跨域</div></pre></td></tr></table></figure><p>如果解决跨域呢，自己主要了解的有两种，分别是cors和jsonp,自己平时用的主要是cors。</p><p>cors可以让后端代码不用做过多的变动，只需要对返回的内容多添加些头部信息即可。</p><p>jsonp主要是通过script，img标签这类不存在跨域，回忆一下，是不是通过img加载过百度的图片，通过script的src加载过cdn上的jquery。</p><p>通过script返回的内容因为在script标签内部，所以可以执行script代码，所以当我们传给后端我们定义好的方法名，然后让他们把我们需要的数据放进去，再返回来，类似 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">showData(&#123;&quot;1&quot;:&quot;boy&quot;&#125;);</div></pre></td></tr></table></figure><p>上面的返回结果在script代码中自动执行，就能得到我们想要的结果（需要注意的是传入的数据必须是json类型哦，毕竟后端和js是不同的语言类型，然后我们只需要在showData里面对json数据进行转换成js能识别的数据即可）。</p><p>对于jsonp，我用的比较少，因为很多时候不想特别写专门用来跨域的api接口，所以如果要用jsonp，后端逻辑代码需要更改（百度php如何配合jsnop完成数据传输）。</p><p>对于前端，像jquery有对jsonp的封装，可以自定义函数，然后传入，返回的数据会先走定义的函数，然后来到success函数里面，注意success传入的参数data是不包括后端返回的内容中的函数，而是函数的参数们。</p><p>juqery默认传的自定义函数名称是jquery带一长串数字，具体的用法可以百度查看，我没咋用过。</p><p>还有哦，jsonp只能支持get请求。</p><p>鉴于上面诸多的麻烦，我用的主要是cors。</p><p>首先我们需要知道浏览器将跨域请求分成了简单请求和非简单请求，什么是非简单请求，就是那些不是get post（请求方式）,返回头信息中加入token这类自定义的东西，就是非简单请求，一般情况下，我们的请求都是非简单请求，毕竟简单请求content-type 好像都不能是json类型。</p><p>对于非简单请求，会先在正式请求之前发送一个options请求，当有跨域请求的时候，我们可以看下Chrome的控制面板，很清楚的能看到。对于返回信息，我们需要加以下头信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;); //允许的ip</div><div class="line">$response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;); //允许的方法</div><div class="line">$response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type, token&apos;);</div><div class="line">//自定义的头部信息</div></pre></td></tr></table></figure><p>大致只需要做这些处理，一般像php，只需要在router的 end（返回具体信息）之前加上上面的信息就可以了。</p><p>像node，或者swoole都在启动web服务的文件处加上即可。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域这个问题其实前端很容易碰到，为什么呢?因为前端一直用浏览器啊，浏览器可以看做一个http客户端，前端和http打交道主要用的就是这个客户端，但如果后端和http打交道，一般只能使用curl这类工具，又因为浏览器的同源策略才产生了跨域，换句话说跨域的时候，后端对前端的数据进行了处理，并返回了对应的数据，但是浏览器检测到了跨域，所以把数据屏蔽了，这才产生了跨域，所以前端相比后端会更容易碰到跨域问题。那前端就一定会碰到跨域问题吗，并不是这样。比如之前我在做itbasic的时候一直没有碰到这个问题，那是为什么呢？我的前端脚本和后端api服务都在80这个端口下，也就是说域是一直一样的，所以不会产生，但在当下，前后端分离，很多时候，前后端在不同的web服务下，比如我们那个bbs，前端静态页面由apache提供，端口8080，后端api是swoole提供，端口56735，这样前端肯定就遇到跨域问题啦。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP opcache</title>
    <link href="http://yoursite.com/2018/05/25/PHP-opcache/"/>
    <id>http://yoursite.com/2018/05/25/PHP-opcache/</id>
    <published>2018-05-25T07:38:57.000Z</published>
    <updated>2018-05-25T08:02:29.564Z</updated>
    
    <content type="html"><![CDATA[<p>opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。</p><a id="more"></a><p>原理：大概的意思就是把php的脚本一次性全存入内存中，然后每次读取脚本直接从这里面取，而不用每个连接都读取一份脚本。</p><p>但这样就存在修改数据后服务器识别不到，可以配置参数，多少秒服务器检查一次，但一般生产环境直接把配置成0，就是间隔时间是0，单位是s，然后停止检查，而开发环境参数配置成1，一直检查，这样就不会存在修改文件，没有效果了。</p><p>还可以手动清除，必须脚本中写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">opcache_reset()</div></pre></td></tr></table></figure><p>但需要注意的就是不同模式下储存脚本是在不同的内存空间中，比如cli下执行脚本文件，和通过浏览器这种mod_php清除是不一样的，所以浏览器访问的话就通过浏览器的方式去执行脚本吧。</p><p>当然，如果和我们swoole那样，每次修改代码后重启web服务器，那是根本不存在这种情况的。</p><p>话说偶然间发现代码的不同方式发布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1.类似前端代码那种，每次新代码的发布都会重新打个包，然后把站点目录通过软连接指向这个新包</div><div class="line">2.我们现在用的，通过在服务器上更新svn上的代码，来发布新的代码</div></pre></td></tr></table></figure><p>首先运行环境是php7.014,线上环境是php5.6,效果不是十分明显，还有opcache_reset() byte-code不是十分好用。</p><p>首先得开启这个扩展，在phpinfo中查找opcache或者 php -m 中查找opcache，其实直接php -m就好了，会有个很显眼的ZendOpcache,</p><p>安装方法就是因为默认编译的时候大部分都有–enable-opcache,或者phpinfo页面上可以看见编译的参数，直接在php.ini 里面开启zend_extension=opcahce.so就好了，或者下载文件源码编译。</p><p>或者重新编译一下php（这个忘记了）</p><p>或者可以像pgsql那样去php源码包里面找源文件进行编译？这样可行吗，没有试过。</p><p>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">opcache.validate_timestamps=1 //是否检测修改</div><div class="line">opcache.revalidate_freq=0//单位时间</div><div class="line">opcache.memory_consumption=64  //memory_consumption 这个参数很好理解，代表这块内存区开辟的大小，另外需要注意不同 PHP SAPI 内存区不是共享的，就是说同一个 PHP 文件，运行在命令行模式或者 PHP-FPM 模式下，对应的 byte-code 会存储在不同的内存区中。</div><div class="line">opcache.max_accelerated_files=4000 //如果命中率不搞，可以适当提升这个值，直到1。</div><div class="line">opcache.opcache.fast_shutdown=1  //modern php上面说这个写1就可以了</div></pre></td></tr></table></figure><p>（opcache_get_configuration()和 and opcache_get_status()）获取配置信息和运行信息，比如了解那些文件被缓存了、使用了多少内存、内存命中率等等。</p><p>感觉就是基于这两个函数出了两个opcache的项目，一个是单页面，一个比较复杂</p><p>1.<a href="https://github.com/PeeHaa/OpCacheGUI" target="_blank" rel="external">PeeHaa / OpCacheGUI</a></p><p>2.<a href="https://github.com/rlerdorf/opcache-status" target="_blank" rel="external">rlerdorf / opcache-status</a></p><p>单页面的部署直接放在网站根目录下就好了，就理解成phpadmin那种网点就好了，利用的就是php的函数获取php的运行环境，然后可视化展示出来</p><p>opcache_invalidate()，这个函数就是更新特定的文件缓存，没去试验过，因为项目小啦，直接重启web server。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;opcache是什么东西，我也不知道，我只知道开启他能加速我接口的返回速度。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP yield</title>
    <link href="http://yoursite.com/2018/05/25/PHP-yield/"/>
    <id>http://yoursite.com/2018/05/25/PHP-yield/</id>
    <published>2018-05-25T05:55:52.000Z</published>
    <updated>2018-05-25T06:51:23.789Z</updated>
    
    <content type="html"><![CDATA[<p>yield，生成器，自己感觉还是挺重要的，因为php在读取大文件的时候经常会有内存溢出的错误，其实yield还会涉及spl，这部分内容自己目前了解的还不是十分清楚，所以，暂时就把yield的作用归类于放置变量过大在内存中占用本大空间，导致内存溢出吧。</p><a id="more"></a><p>关于yield这种数据类型，还有迭代器，还有collection，都是能用foreach进行循环遍历的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function productNum($length)</div><div class="line">&#123;</div><div class="line"> $data = [];</div><div class="line">  for ($i=0; $i&lt; $length; $i++)&#123;</div><div class="line">     $data[] = $i;</div><div class="line">&#125;</div><div class="line"> return $data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$data = productNum($100000000);</div><div class="line">foreach ($data as $key=&gt;$value) &#123;</div><div class="line">  var_dump($value);</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>用php执行上端代码会报出超出分配给php的内存错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function productNum($length)</div><div class="line">&#123;</div><div class="line"> //$data = [];</div><div class="line">  for ($i=0; $i&lt; $length; $i++)&#123;</div><div class="line">     //$data[] = $i;</div><div class="line">     yield $i;</div><div class="line">&#125;</div><div class="line"> //return $data;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$data = productNum($100000000);</div><div class="line">foreach ($data as $key=&gt;$value) &#123;</div><div class="line">  var_dump($value);</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>能执行成功，其实这个时候打印$data变量，可以看出来他是一个类。</p><p>每次foreach 去$data中取数据，上面的那个for循环就会执行一次，再次输出一个变量\$i。</p><p>so，如果使用yield的内容，每次也得循环使用吗？</p><p>yield定义的内容不能有返回。</p><p>下面写一个读取文件，再往另一个文件中写入内容的例子，其实这个例子不具有实际价值，其实就是一个copy文件，用shell_exec执行linux命令就可以，或者file_get_contents,file_put_contents这样就好了，使用yield分多次，唯一可以想到的好处就是控制对内存占用的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function getContent($file)</div><div class="line">&#123;</div><div class="line">  $res = fopen($file);</div><div class="line">  while (feof($resource) === false ) &#123;</div><div class="line">         yield fgets($resource);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$res = fopen(&apos;/home/itbasic/3.pdf&apos;, &apos;a&apos;);</div><div class="line">foreach ($content as $c_key=&gt;$c_value) &#123;</div><div class="line">    fwrite($res, $c_value);</div><div class="line">&#125;</div><div class="line">fclose($res);</div><div class="line">echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;;  //使用: 362640B</div></pre></td></tr></table></figure><p>用传统方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$res = file_get_contents($file);</div><div class="line">file_put_contents(&apos;/home/itbasic/1.pdf&apos;, $res);</div><div class="line">echo &quot;使用: &quot;.memory_get_usage().&quot;B\n&quot;; //使用: 39875608B</div></pre></td></tr></table></figure><p>显然超过一个数量级，yield就是把一个结果集分批的给你，你什么时候问他要下一个结果集，他什么时候给你。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yield，生成器，自己感觉还是挺重要的，因为php在读取大文件的时候经常会有内存溢出的错误，其实yield还会涉及spl，这部分内容自己目前了解的还不是十分清楚，所以，暂时就把yield的作用归类于放置变量过大在内存中占用本大空间，导致内存溢出吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架学习0</title>
    <link href="http://yoursite.com/2018/05/21/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A00/"/>
    <id>http://yoursite.com/2018/05/21/框架学习0/</id>
    <published>2018-05-21T15:17:51.000Z</published>
    <updated>2018-05-21T15:28:27.580Z</updated>
    
    <content type="html"><![CDATA[<p>想了下，还是把框架的基础知识也记录下来。</p><a id="more"></a><p>首先我们需要认识到框架也是一个脚本，不要因为现代的框架都是oop而忽略了面向过程。框架的入口文件其实可以看做框架的处理文件，就是一个php文件，只是因为框架把对于问题的处理发送到内部的面向对象库中去了，所以我们才会忽略框架本身的面向过程，这就经常会让小伙伴不知道比如记录用户的访问信息，如果不写在登录接口中应该写在哪呢。</p><p>框架中对于常量的定义，对于辅助函数的定义（没有用命名空间，类似原生php函数的使用）我们经常只是在框架定义好的文件中添加，但忽略了为什么在这个地方写就能这样使用，其实本质上都是因为在入口文件出有include 这个文件才会这样。</p><p>一般入口文件只写一些文件加载，像返回数据的处理之类的一般写在route之中，我们那个bbs写在了入口文件中，添加返回头信息啊之类的，感觉也还行。对于异常的捕获处理一般也写在最外层的入口文件处，这样很暴力，这样每当我们有错误的时候想立刻终止可以通过马上抛出异常，而不用执行到脚本的末尾。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想了下，还是把框架的基础知识也记录下来。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>框架学习1</title>
    <link href="http://yoursite.com/2018/05/21/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/"/>
    <id>http://yoursite.com/2018/05/21/框架学习1/</id>
    <published>2018-05-21T14:38:24.000Z</published>
    <updated>2018-05-24T04:02:43.426Z</updated>
    
    <content type="html"><![CDATA[<p>对于框架源码的学习，可以帮助我们以后快速学习一个框架的使用，虽然同样的效果同样可以使用多学习几个框架，比如你把tp学完你学习laravel和yii发现很多时候都是一样的，但这仅限于你对框架的使用，增删改查的使用，当你想去修改一个框架的时候（不包括把框架中常量提取出来放在一个文件中，给框架增加一个validate等等这种情况）而是类似于把框架原来的隐式路由改成显式路由这种情况，如果你没有动手搭建过框架，你会不知所措。</p><p>我们这里对于框架的搭建还不是从头到尾写一个框架这种情况，composer（php的包管理工具，类似前端的npm），我们可以像拼接乐高积木那样搭建一个框架，那用什么来充当积木间的凹槽呢，我觉得命名空间可以充当凹槽之一。</p><a id="more"></a><p>命名空间在我的理解中就是把项目代码看做一个文件夹，然后名称是/,然后下面的各个文件夹名称就是命名空间，为了区分不同文件夹下的相同文件夹名称，我们需要把文件夹名称的路径记录下来。如果我的文件放在文件夹中的目录结构比较深，那么外层的文件夹名称是否可以不要呢，答案是肯定的，我觉得这也是文件夹相对于使用路径的好处之一。</p><p>上文说到了composer，我们要怎么使用这个工具呢。在项目的根目录下（注意不是网站的根目录下，网站的根目录往往是入口文件的根目录）执行composer install，linux下需要时php composer.phar install,他会找composer.json文件，第一次可能没有，我们可以通过composer require xxx/xxxx 来安装一个依赖，这时候会多出composer.json , composer.lock, vendor 目录，我们在入口文件出只需要include  vendor/autoload.php, 就能使用vendor中的依赖了。我们项目中自定义的文件夹也可以通过composer 的autoload来实现自动加载。php的psr-4和psr-0都有对命名空间的规定，但是0废弃了，现在大家都是用4，比较下0和4，比如 \controller\test.php,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">namespace controller;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//psr-0</div><div class="line">&#123;</div><div class="line">  &apos;autoload&apos; : &#123;</div><div class="line">  &apos;controller//&apos; : &apos;&apos;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line">//psr-4</div><div class="line">&#123;</div><div class="line">  &apos;autoload&apos; : &#123;</div><div class="line">  &apos;controller//&apos; : &apos;controller&apos;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>psr-0会把规定的路径再拼上命名空间当做相对路径去文件夹下找，而psr-4会直接把规定的路径当做命名空间去寻找，上面的例子只是针对简单的一层命名空间，还是看不出什么效果，多层的更容易看出0是多么的脑残。</p><p>还有当注册了controller文件夹，controller的子文件夹的命名空间默认注册。</p><p>我们在修改命名空间的时候只需要修改composer.json文件就可以了，对于composer的具体怎么加载的其实不用管的，他应用这么广泛，一般不会出现什么问题。</p><p>todo:</p><p>use 的时候命名空间顶层不用加\,但是new的时候如果顶层写要加\，不是十分理解。</p><p>来自modern php</p><ol><li>首先use 的时候默认的是来自绝对，默认会在前面加上\</li><li>同一个命名空间下的类相互引用，不用引入命名空间，比如我同一个controller下面代码的相互使用</li><li>xxx/xxxx,这种的一般第一个 xxx是厂商的命名空间，顶层命名空间，比较重要，第二个xxxx是子命名空间。</li><li>仅仅use 其实默认用了as取别名，只是类名和别名一样</li><li>Exception默认是php自带的，应该在顶层命名空间下，用\，如果使用的时候不加，他会默认在当前命名空间下寻找，会出现错误</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于框架源码的学习，可以帮助我们以后快速学习一个框架的使用，虽然同样的效果同样可以使用多学习几个框架，比如你把tp学完你学习laravel和yii发现很多时候都是一样的，但这仅限于你对框架的使用，增删改查的使用，当你想去修改一个框架的时候（不包括把框架中常量提取出来放在一个文件中，给框架增加一个validate等等这种情况）而是类似于把框架原来的隐式路由改成显式路由这种情况，如果你没有动手搭建过框架，你会不知所措。&lt;/p&gt;
&lt;p&gt;我们这里对于框架的搭建还不是从头到尾写一个框架这种情况，composer（php的包管理工具，类似前端的npm），我们可以像拼接乐高积木那样搭建一个框架，那用什么来充当积木间的凹槽呢，我觉得命名空间可以充当凹槽之一。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>cookie和session的思考</title>
    <link href="http://yoursite.com/2018/05/18/cookie%E5%92%8Csession%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2018/05/18/cookie和session的思考/</id>
    <published>2018-05-18T09:38:47.000Z</published>
    <updated>2018-05-21T10:30:31.308Z</updated>
    
    <content type="html"><![CDATA[<p>最近新开了一个bbs的项目，因为也有登录和退出，但问题来了，和大多数的公司内部项目一样，如果每个项目都有自己的登录名和密码，都得注册，每次去不同的项目用户都需要进行登录，估计用户会疯吧。其实这个问题很久之前就遇到过，当时是别的部门的项目希望通过我们这边保存的用户信息进行登录，老大的想法是写一个接口给他们使用，但是如果项目越来越多，每次写接口肯定不太合适，那位同事和我说过单点登录，趁着这次机会，自己也了解了下。</p><a id="more"></a><p>首先是 /的理解。</p><p>关于相对路径和绝对路径，一般的解释是以/开头的就是绝对路径，以./开头的就是相对路径，没有这个开头的其实也是相对路径。</p><p>这个在linux中是绝对正确的, /这个在服务器中指代的就是/目录。</p><p>但这个理论也用在前端代码中，难道我们src = ‘/assets/xxx’,是去服务器根目录下assets目录下查找文件吗，显然这个理论是不正确的，所以这个/在前端代码中的意思是网站的根目录，对！！比如这个前端网站是itbasic.datatom.com,那么这个/指代的就是apache里面配置的root文件夹，所以前端代码中的这个/是由apache或者nginx等之类的web server 部署的时候决定的。</p><p>todo:</p><p>itbasic中view文件夹不在/目录下，但是里面引用的文件相对路径却是相对/路径的，这是个很奇怪的问题。</p><p>php中有个函数setcookie,这是个在客户端种植cookie的函数，比如我们为了维持http的有状态，所以使用了session机制，通过在客户端的记录phpsessid ，然后服务器端（我用的是apache 的模块加载，默认是放在/tmp目录下）sess_(phpsessid)这个文件，这个文件中会保存你想让这个连接保存的相关信息。</p><p>那什么时候服务器端会在客户端记录phpsessid呢，是在start_session() ，这个函数调用的时候，php已经为我们封装好了对应的方法，注意setcookie，本质上是通过给浏览器头部发送消息，可以看下你调用setcookie这个方法的response，他的返回头中会有set-cookie，我的理解是如果想要返回头信息，在这之前不能有任何的输出，所以才会在start_session()之前不能有任何的输出。</p><p>setcookie函数可以看下，默认是在 当前文件所在路径下种植cookie，可以改成/,就可以在根域名下种植了，根域名下种植的好处就是下面的所有文件都能访问和删除这个cookie，如果你是在某个文件下种植的，只有当前文件才能放访问到，比如/bbs/dist,只有这个路径下的文件才能访问到。</p><p>还有放在/下的好处就是，/就在发送请求的时候他会自动的放在请求头部信息中，但是 如果你是放在/bbs/dist下面，他只会在请求/bbs/dist下的时候会携带，当访问/home之类的时候就不会携带。</p><p>还有个问题是关于重定向的，之前遇到的重定向就是爬取页面的时候会返回304，其实还有别的作用，比如cookie的种植。当今时代，api盛行，感觉这就是我忽略重定向的原因，我曾想着通过请求接口的方式进行setcookie，但好像是失败的，只能通过header（）这种方式。</p><p>关于单点登录：</p><p>使用场景：其实是一个很常见的情况，公司有很多系统，但用户基本信息只用一个就好了，虽然可以通过在各个系统中通过读取同一个数据库中的同一个表来实现登录，但如果每次用户使用公司的各个系统都得登录，这种体验真是太差了，最简单的方法，如果是在相同的域名下，可以通过在根域名下种植一个cookie信息，然后每次登录检测这个信息，这样其他域名也能检测到，这样就实现了统一登录和注销。</p><p>其实itbasic就是用的这个原理，所有的同一个域名下都可以使用这个原理，itbasic稍有不同就是登录原理的不同，一个是用cookie，一个用的是token。</p><p>其实最方便扩展的还是单点登录，对于单点登录就是独立出一个登录系统，虽然各个界面都有自己的登录，但每次登录之后都会在中间系统注册一下，然后每次登录都会去中间系统检测下是否登录，如果登录了，就不用再登录了，如果没有登录，首先在自己的系统中实现登录，再去中间系统中保存已登录状态。注销的时候也是，首先在中间系统中实现注销，然后遍历删除各个子系统中的登录状态。</p><p>单点登录因为没有去实现，所以理解还不是很深刻，只知道中间的登录系统最好用https。</p><p>还有对于session，传统的是以文件的形式保存，遇到的一个bug就是itbasic服务器内容满了，导致session写入一直失败，而bbs中token的作用类似session，但是他是放在redis中存储的，就不会有这个问题，感觉这也是session用redis和memcahe实现的好处之一，而不用file实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近新开了一个bbs的项目，因为也有登录和退出，但问题来了，和大多数的公司内部项目一样，如果每个项目都有自己的登录名和密码，都得注册，每次去不同的项目用户都需要进行登录，估计用户会疯吧。其实这个问题很久之前就遇到过，当时是别的部门的项目希望通过我们这边保存的用户信息进行登录，老大的想法是写一个接口给他们使用，但是如果项目越来越多，每次写接口肯定不太合适，那位同事和我说过单点登录，趁着这次机会，自己也了解了下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>验证器</title>
    <link href="http://yoursite.com/2018/04/25/%E9%AA%8C%E8%AF%81%E5%99%A8/"/>
    <id>http://yoursite.com/2018/04/25/验证器/</id>
    <published>2018-04-25T12:01:08.000Z</published>
    <updated>2018-04-25T12:25:45.119Z</updated>
    
    <content type="html"><![CDATA[<p>验证器应该是我们在使用TP,Laravel这些框架的时候经常遇到的,英文名Validate,为什么要验证器呢？数据验证应该是所有web api的第一步，通过校验前端数据的是否合法，来进行数据的接下来的操作，如果数据不合法，直接退回给前端，而不用执行。</p><a id="more"></a><p>Laravel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//验证数据的正确性</div><div class="line">        $this-&gt;validate($request, [</div><div class="line">           &apos;name&apos;=&gt;&apos;required|max:50&apos;,</div><div class="line">            &apos;email&apos;=&gt;&apos;required|email|unique:users|max:255&apos;,</div><div class="line">            &apos;password&apos;=&gt;&apos;required|confirmed|min:6&apos;</div><div class="line">        ]);</div></pre></td></tr></table></figure><p>TP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">protected $rule = [</div><div class="line">        &apos;name&apos; =&gt; &apos;require|isNotEmpty&apos;,</div><div class="line">        &apos;mobile&apos; =&gt; &apos;require|isMobile&apos;,</div><div class="line">        &apos;province&apos; =&gt; &apos;require|isNotEmpty&apos;,</div><div class="line">        &apos;city&apos; =&gt; &apos;require|isNotEmpty&apos;,</div><div class="line">        &apos;country&apos; =&gt; &apos;require|isNotEmpty&apos;,</div><div class="line">        &apos;detail&apos; =&gt; &apos;require|isNotEmpty&apos;</div><div class="line">    ];</div><div class="line"></div><div class="line">$result = $this-&gt;batch()-&gt;check($param);</div></pre></td></tr></table></figure><p>其实两个很类似，就是通过传入验证条件和接受到的参数，来进行对应规则的验证.</p><p>自己</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">namespace Libs;</div><div class="line"></div><div class="line">use Framework\Exception\ClientException;</div><div class="line">use Framework\Exception\ServerException;</div><div class="line"></div><div class="line">class Validate</div><div class="line">&#123;</div><div class="line">    static $res = true;</div><div class="line">    static $errMsg = &apos;&apos;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param $arr, 传入的验证规则</div><div class="line">     * @param $params, 请求的数据</div><div class="line">     * @throws ClientException</div><div class="line">     */</div><div class="line">    public static function validate($arr, $params)</div><div class="line">    &#123;</div><div class="line">        foreach ($arr as $a_key=&gt;$a_value) &#123;</div><div class="line">            $funcArr = explode(&apos;|&apos;, $a_value);</div><div class="line">            foreach ($funcArr as $f_key=&gt;$f_value) &#123;</div><div class="line">                if(is_callable([__CLASS__, $f_value])) &#123;</div><div class="line">                    call_user_func_array([__CLASS__, $f_value], [$a_key, $params]);</div><div class="line">                &#125; else &#123;</div><div class="line">                    throw new ServerException(&apos;&apos;, &apos;你的验证函数名不存在啦&apos;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if(self::$res == false) &#123;</div><div class="line">            throw new ClientException(&apos;&apos;, self::$errMsg);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static function required($key, $arr)</div><div class="line">    &#123;</div><div class="line">        if (!key_exists($key, $arr)) &#123;</div><div class="line">            self::$res = false;</div><div class="line">            self::$errMsg .= $key.&apos;不存在 | &apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    public function __call($name, $arguments)</div><div class="line">    &#123;</div><div class="line">        throw new ServerException(&apos;&apos;, &apos;你的验证函数名不存在啦&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>controller调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$validate = [&apos;comment_id&apos;=&gt;&apos;required|test&apos; ,&apos;sex&apos;=&gt;&apos;required&apos;];</div><div class="line">Validate::validate($validate, static::params());</div></pre></td></tr></table></figure><p>需要注意的点是：</p><ol><li>上面验证器的使用过程中并不是检测到错误就立刻返回，而是检测出所有的错误再返回，所以我定义了两个static用来存储数据，当标志位是false的时候再把存储的错误信息一起返回。</li><li>is_callable函数的使用，验证函数是否能执行，如果是类中，[‘类名’， ‘方法名’]， 都是字符串，注意这个类名用__CLASS__,之前我直接写的Validate，这样肯定是不行的，同理call_user_func_array这个也是，相比较于call_user_func,这个是后面传入函数中的参数要以array的形式，如果是非静态函数，就传入类名，静态的话要传入对象哦，$this,或者new一个对象吧。<a href="https://my.oschina.net/codespring/blog/535355" target="_blank" rel="external">call_user_func_array</a> <a href="http://www.111cn.net/phper/php-function/95406.htm" target="_blank" rel="external">is_callable</a></li><li>需要注意static的使用，用的self哦，一般的使用用的this(都是在类中)，在类的外面的话，static 是 类名::,非static用的是 object-&gt;func.</li><li>__call 是类中不存在这个方法的时候调用会自动执行，传入的两个参数第一个是调用的方法名，第二个参数是参数.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;验证器应该是我们在使用TP,Laravel这些框架的时候经常遇到的,英文名Validate,为什么要验证器呢？数据验证应该是所有web api的第一步，通过校验前端数据的是否合法，来进行数据的接下来的操作，如果数据不合法，直接退回给前端，而不用执行。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="WEB" scheme="http://yoursite.com/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>MIME TYPE的作用</title>
    <link href="http://yoursite.com/2018/04/23/MIME-TYPE%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://yoursite.com/2018/04/23/MIME-TYPE的作用/</id>
    <published>2018-04-23T13:44:00.000Z</published>
    <updated>2018-04-23T15:12:46.144Z</updated>
    
    <content type="html"><![CDATA[<p>其实本来不用单独写这篇文章的，可以放在http协议中，因为他本来就是关联这个http请求和返回信息中的content type，但其实用的还挺多，主要就是上传文件这块和php不借助插件而是通过输出html表格元素让页面按照excel来解析的方式生成excel。</p><a id="more"></a><blockquote><p>一、</p><p>首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。<br>媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的，例如:<br>Content-Type: text/HTML<br>表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。<br>通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。<br>XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。(现在不用xml，而是用json，一般在返回头中都有)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;);</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>注意这个content type，不仅在response中有，在request中也有，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;application/x-www-form-urlencoded（使用HTTP的POST方法提交的表单）</div><div class="line">&gt;multipart/form-data（同上，但主要用于表单提交时伴随文件上传的场合）</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>上面的两种应该是我们平时最常见到的，一种是普通的表单提交，一种是当表单中有上传文件的时候进行的提交方式中content type的设置(好像默认的表单提交就是第一种，不用设置，只有上传的时候需要特殊设置，像我们itbasic上面，大部分时候用的是ajax进行提交，而不是表单，content type在ajax中应该封装成了text/json)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&lt;form action=&quot;http://192.168.33.10:56732/bbs/login/test&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</div><div class="line">&gt;&lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;</div><div class="line">&gt;&lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;</div><div class="line">&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot;&gt;&lt;br&gt;</div><div class="line">&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;</div><div class="line">&gt;&lt;/form&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。</p></blockquote><p>更详细的介绍<a href="https://www.cnblogs.com/jsean/articles/1610265.html" target="_blank" rel="external">https://www.cnblogs.com/jsean/articles/1610265.html</a></p><p>因为这篇文章复制有很多重复的部分（▄█▀█●），复制下来改很麻烦。</p><p>认识的几点就是：服务器端要存储文件后缀名和mime type的对应关系，我是这样理解的，虽然在linux下文件后缀名并没有什么卵用，感觉这都是content type的作用，但在windows下起了很大的作用啊，在服务器端保存文件的使用，需要通过content type对应的mime type 转换成文件后缀名，然后保存（虽然感觉直接读上传的文件名就可以了，感觉也许是兼容那些没有文件后缀名的情况吧，linux？）</p><p>response 里面content type的作用很明显是通知客户端怎么解析这个文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实本来不用单独写这篇文章的，可以放在http协议中，因为他本来就是关联这个http请求和返回信息中的content type，但其实用的还挺多，主要就是上传文件这块和php不借助插件而是通过输出html表格元素让页面按照excel来解析的方式生成excel。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://yoursite.com/2018/04/23/Redis/"/>
    <id>http://yoursite.com/2018/04/23/Redis/</id>
    <published>2018-04-23T12:54:46.000Z</published>
    <updated>2018-04-23T13:28:44.120Z</updated>
    
    <content type="html"><![CDATA[<p>缓存，对于现代web很重要，首先他比较快嘛，因为是在内存中的，像很多功能也是通过缓存来实现的，比如点赞功能之类的，记录下常用的redis命令。因为是写php的，所以举得例子大部分还是以php的redis扩展为参照，其实大部分都一样。（没有系统的学习，大致浏览了下菜鸟教程上的redis教程）</p><a id="more"></a><p>安装</p><p>常见知识点：</p><p>端口号：6379</p><p>密码：可以设置，也可以不设置。itbasic上没有设置，但只允许本机才能连接服务器上的redis。</p><p>启动：安装目录下的redis-server,最好后台挂起，要不然这个cmd就没法用了</p><p>连接： 安装目录下的redis-cli </p><p>常见数据类型：1.string 2.hash 3. 4. 5</p><p>通用命令：</p><p>keys * : 获取所有的key</p><p>string：get(),根据key值获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class \Lib\Redis extends \Redis  //因为这个继承于php自带的扩展，所以命名空间在\下</div><div class="line">&#123;</div><div class="line">  public function __construct()</div><div class="line">  &#123;</div><div class="line">   建立连接</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$redis = new \Lib\Redis();</div><div class="line">$redis-&gt;get($key);</div></pre></td></tr></table></figure><p>set,设置值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$redis-&gt;set($key, $value,)</div></pre></td></tr></table></figure><p>hash: hash类型不能像string的set方法中设置系统key的过期时间，可以通过调用expire来设置时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$redis-&gt;expire($key, 7*24*60*60);</div></pre></td></tr></table></figure><p>hset: 设置hash的filed的值,这个key意思就是这个hash对象的唯一标识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$redis-&gt;hset($key, $filed, $value)</div></pre></td></tr></table></figure><p>hmset: 给这个对象进行赋值, $arr是关联数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$redis-&gt;hmset($key, $arr)</div></pre></td></tr></table></figure><p>hgetall: 获取这个hash对象所有的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$redis-&gt;hgetall($key)</div></pre></td></tr></table></figure><p>坑：</p><p>之前很傻，因为接触到redis的时候，听到的好处就是相比较于mecache这种，多了很多的数据类型，memcache这种只有string，然后redis又在原先5中数据类型的基础上增加了表示地理坐标的新的数据类型。当时遇到一个问题就是想一个键值既能对应string，也能对应hash，想有没有这种数据类型。其实当时的思路是完全跑偏的，完全可以通过先构造一个比如token=&gt;string,string=&gt;hash两个类型，第一个是string，第二个是hash，通过token既能得到简单的string，也能得到hash。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;缓存，对于现代web很重要，首先他比较快嘛，因为是在内存中的，像很多功能也是通过缓存来实现的，比如点赞功能之类的，记录下常用的redis命令。因为是写php的，所以举得例子大部分还是以php的redis扩展为参照，其实大部分都一样。（没有系统的学习，大致浏览了下菜鸟教程上的redis教程）&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>异常处理</title>
    <link href="http://yoursite.com/2018/04/19/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/19/异常处理/</id>
    <published>2018-04-19T12:48:39.000Z</published>
    <updated>2018-04-20T10:44:32.810Z</updated>
    
    <content type="html"><![CDATA[<p>异常处理其实是我一直很少接触的，之前是因为异常处理相比较于php的基础知识更高一层，大学时就有个习惯，越到后面的内容看的越少，比如c语言的指针，每学期的专业课，都是只能讲完前面的语法部分，运算符？if？else？for循环？后面就没了。</p><p>但当我学习tp5的时候，发现tp5的所有错误都会以异常的形式抛出，然后在7月老师的指导下，认识到了AOP思想，了解了统一异常处理类的时候，我才逐渐重视了这个东西。</p><a id="more"></a><p>新项目中：因为我希望把每个函数写的尽量短些，虽然以后追踪问题的时候可能会跳来跳去，但如果单单只靠函数的名称就能了解到函数的作用，这将是多么美好的一件事，于是产生了一个问题：一般只有最外层的函数才能决定最终抛给客户端的内容，但如果我们在内部自己调用的函数中也这么写，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public function father()</div><div class="line">&#123;</div><div class="line">  $res = $this-&gt;children();</div><div class="line">  return [</div><div class="line">  &apos;code&apos; =&gt; 200,</div><div class="line">  &apos;msg&apos; =&gt; $res</div><div class="line">]</div><div class="line">&#125;</div><div class="line"></div><div class="line">public function children()</div><div class="line">&#123;</div><div class="line">  return [</div><div class="line">  &apos;code&apos; =&gt; 500,</div><div class="line">  &apos;msg&apos; =&gt; &apos;你有毒&apos;</div><div class="line">]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个样子返回的结果肯定不是我们希望的，你可以说我可以处理啊，但其实如果层次深了之类的，处理是很麻烦的，如果我能立刻把结果给到前端，那该多棒啊，这时候就可以通过抛出异常，最外层统一对异常进行处理，比如抛出异常的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">throw new ControllerException(404, &apos;controller not exist.&apos;);</div></pre></td></tr></table></figure><p>这个ControllerException 是继承于基本的\Exception，php自带的。然后我们在最外层进行捕获</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">date_default_timezone_set(&apos;Asia/Shanghai&apos;);</div><div class="line">include_once(&apos;vendor/autoload.php&apos;);</div><div class="line">include_once &apos;./Libs/Eagles/Document.php&apos;;</div><div class="line"></div><div class="line">define(&apos;SWOOLE_PORT&apos;, 56732);</div><div class="line">define(&apos;SWOOLE_ERROR_LOG&apos;, &apos;/var/log/swoole_error.log&apos;);</div><div class="line"></div><div class="line">define(&apos;EAGLES_SERVER&apos;, &apos;211.144.114.26&apos;);</div><div class="line">define(&apos;EAGLES_PORT&apos;, &apos;17200&apos;);</div><div class="line">// error_reporting(0);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">// http服务的配置</div><div class="line">$http = new swoole_http_server(&quot;0.0.0.0&quot;, SWOOLE_PORT);</div><div class="line">$http-&gt;set([</div><div class="line">    &apos;worker_num&apos; =&gt; 20,             // cpu 6核 默认启动6个, 1-4 倍合适  占用：40M内存*20</div><div class="line">    // &apos;task_worker_num&apos; =&gt; 6,         //开启task功能</div><div class="line">    // &apos;daemonize&apos; =&gt; true,            // 守护进程</div><div class="line">    &apos;log_file&apos; =&gt; SWOOLE_ERROR_LOG,</div><div class="line">    &apos;buffer_output_size&apos; =&gt; 8 * 1024 *1024,        // 8M 缓冲区。占用 8*12M,api接口可最大返回8M的数据内容</div><div class="line">    &apos;package_max_length&apos;=&gt; 5 * 1024 * 1024,         // 最大数据块是5M。上传可上传4M大小文件</div><div class="line">    // 配置静态文件根目录</div><div class="line">    // &apos;enable_static_handler&apos; =&gt; true,</div><div class="line">    // &apos;document_root&apos; =&gt; &apos;/home/projectx/server/upload&apos;</div><div class="line">    // &apos;daemonize&apos; =&gt; true,</div><div class="line">    // &apos;pid_file&apos; =&gt; __DIR__.&apos;/server.pid&apos;</div><div class="line">]);</div><div class="line"></div><div class="line">use Framework\Base\Route as Router;</div><div class="line">use Framework\DB\ConnectionManager as ConnectionManager;</div><div class="line">use Framework\Log\Logger as Logger;</div><div class="line"></div><div class="line">$config = include_once(&apos;config/config.php&apos;);</div><div class="line">Logger::logfile($config[&apos;logfile&apos;]);</div><div class="line"></div><div class="line">ConnectionManager::db_config($config[&apos;db&apos;]);</div><div class="line"></div><div class="line">$http-&gt;on(&apos;request&apos;, function ($request, $response) &#123;</div><div class="line">    try&#123;</div><div class="line">        if ($request-&gt;server[&apos;path_info&apos;] == &apos;/favicon.ico&apos;</div><div class="line">            || $request-&gt;server[&apos;request_uri&apos;] == &apos;/favicon.ico&apos;) &#123;</div><div class="line">            return $response-&gt;end();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        $param = $request-&gt;server[&apos;request_method&apos;] == &apos;POST&apos; ? @$request-&gt;post : @$request-&gt;get;</div><div class="line">        $data = \Libs\Common::getCallData(@$request-&gt;header[&apos;www-authorization&apos;], $request-&gt;header[&apos;host&apos;], $request-&gt;server[&apos;request_uri&apos;], $param, $request-&gt;server[&apos;remote_addr&apos;], $request-&gt;server[&apos;request_method&apos;]);</div><div class="line">        //\Libs\ElasticSearch::setIndexTableDoc(&apos;projectx_log&apos;, &apos;call_log&apos;, $data[&apos;doc_id&apos;], $data[&apos;data&apos;]);</div><div class="line"></div><div class="line">        $allow_method = [&apos;POST&apos;, &apos;GET&apos;, &apos;OPTIONS&apos;];</div><div class="line">        if(!in_array($request-&gt;server[&apos;request_method&apos;], $allow_method))&#123;</div><div class="line">            $response-&gt;status(405);</div><div class="line">            return $response-&gt;end();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //如果需要设置允许所有域名发起的跨域请求，可以使用通配符 *</div><div class="line">        $response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;);</div><div class="line">        $response-&gt;header(&apos;Access-Control-Allow-Methods&apos;, &apos;POST, GET&apos;);</div><div class="line">        $response-&gt;header(&apos;Access-Control-Allow-Headers&apos;, &apos;Origin, X-Requested-With, Content-Type, Accept, www-authorization&apos;);</div><div class="line">    </div><div class="line">        $uri = $request-&gt;server[&apos;request_uri&apos;];</div><div class="line">        $uri = $uri;</div><div class="line">        $res = Router::dispatch($uri, $request, $response);</div><div class="line"></div><div class="line">        @$response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;);</div><div class="line">        @$response-&gt;end(json_encode($res));</div><div class="line">    &#125;catch(\Framework\Exception\ControllerException $ce)&#123;</div><div class="line">        $status = $ce-&gt;getStatusCode();</div><div class="line">        $response-&gt;status($status);</div><div class="line"></div><div class="line">        $errorcode = $ce-&gt;getErrorCode();</div><div class="line">        $msg = $ce-&gt;getMsg();</div><div class="line">        $response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;);</div><div class="line">        $response-&gt;header(&apos;Content-Type&apos;, &apos;application/json&apos;);</div><div class="line">        $response-&gt;end(json_encode([&apos;code&apos;=&gt;$errorcode, &apos;msg&apos;=&gt;$msg]));</div><div class="line">    &#125;catch(\Framework\Exception\RouteException $re)&#123;</div><div class="line">        $status = $re-&gt;getStatusCode();</div><div class="line">        @$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;);</div><div class="line">        @$response-&gt;status($status);</div><div class="line">        @$response-&gt;end();</div><div class="line">    &#125;catch(Exception $e)&#123;</div><div class="line">        @$response-&gt;header(&quot;Access-Control-Allow-Origin&quot;, &apos;*&apos;);</div><div class="line">        @$response-&gt;status(500);</div><div class="line">        @$response-&gt;end(&apos;exceptions:&apos; . $e-&gt;getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">echo &quot;server start listening port:&quot; . SWOOLE_PORT . PHP_EOL;</div><div class="line">$http-&gt;start();</div></pre></td></tr></table></figure><p>看见了嘛，最外层的几个catch就是对他的捕获，注意最大的要写在外面哦，因为前面的如果捕获了，后面的就不会处理了呢。</p><p>其实通过上面的例子我们还能了解到其实一个php项目说到底还是一个脚本，上面代码是我用swoole搭建的webserver时候的启动脚本，其实用swoole能更好的帮助phper理解web是怎么样运行的，当服务器监听到request过来的时候，我们通过这个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Router::dispatch($uri, $request, $response);</div></pre></td></tr></table></figure><p>去执行对应的项目里面的代码，这就是我们平时经常写的工程，大部分用的是面向对象的思想，定义一个类啊，方法啊，因为这里面就像一个仓库，是我们用来取东西的，所以没有那种流程的概念，唯一的流程概念应该在我们这个启动脚本里，这也是我们把try  catch 写在这里面的一个原因（这也是我找php统一异常处理的方法应该定义在哪的时候发现的），后来继续思考了下，感觉不管是我之前做的那个itbasic，还是现在这个bbs，其实都是脚本+类库合在一起的，因为很多时候我们往往都是在写类库，而忽略了脚本的存在（一般都是写好的，很少需要改），甚至把一个项目就当做一个面向对象，而忘记了面向过程的存在，之前群里面有个朋友不知道在哪定义通过哪个搜素引擎查找到自己网站的网上百度的方法，根源也是因为不理解一个项目的脚本到底存在于什么地方。</p><p>其实类比自己接触的两个框架，tp和laravel,为嘛他的入口文件index.php和路由文件分开了呢，:sweat: 其实本该分开，路由是个类库，入口文件是个脚本呢，之所以产生这种坑爹的想法是itbasic的route.php即是入口文件，也是路由类定义的地方。</p><p>观察server.php, 观察config目录，发现set.php 是定义的常量，这样在使用的时候可以直接使用，但是config.php 是返回的数组，项目里面想用这里面的值是不可以直接使用的，那数据库是怎么连接的呢，发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ConnectionManager::db_config($config[&apos;db&apos;]);</div></pre></td></tr></table></figure><p>这个类和普通的类不一样，这个直接在入口文件中就有加载，这个是把config里面的值保存到他的类变量中了，所以在项目里面可以直接使用。</p><p>还有上次那个exception，其实子类继承了父类，父类中变量和子类中变量重名，但他们是各自的，子类继承了父类，用了父类获取自己errorcode的方法，那个其实是获取父类的，而并非是获取子类的，这点要注意。</p><p>子类继承父类的初始化函数的时候不要忘记传参数了哦。</p><p>wait:</p><p>1.异常处理的细节</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;异常处理其实是我一直很少接触的，之前是因为异常处理相比较于php的基础知识更高一层，大学时就有个习惯，越到后面的内容看的越少，比如c语言的指针，每学期的专业课，都是只能讲完前面的语法部分，运算符？if？else？for循环？后面就没了。&lt;/p&gt;
&lt;p&gt;但当我学习tp5的时候，发现tp5的所有错误都会以异常的形式抛出，然后在7月老师的指导下，认识到了AOP思想，了解了统一异常处理类的时候，我才逐渐重视了这个东西。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="异常处理" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>微信开发</title>
    <link href="http://yoursite.com/2018/04/18/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/04/18/微信开发/</id>
    <published>2018-04-18T01:29:49.000Z</published>
    <updated>2018-04-18T01:33:11.936Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="微信" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>postgresql常见问题总结</title>
    <link href="http://yoursite.com/2018/04/17/postgresql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/17/postgresql常见问题总结/</id>
    <published>2018-04-17T07:47:01.000Z</published>
    <updated>2018-04-26T02:14:43.215Z</updated>
    
    <content type="html"><![CDATA[<p>本来是不想写这篇文章的，因为感觉自己对于postgresql理解不够深入，但因为生活中对于postgresql有些问题总是遇到，所以记录下来，方便以后查找。</p><a id="more"></a><p>1.navicate连接postgresql</p><p>第一次建立连接肯定会报错啦</p><p><img src="http://ozys8fka7.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180417155030.png" alt="navicate连接postgresql属性"></p><p>上面初始数据库的意思并不是数据库的名称。毕竟这次连接成功后，里面有一堆的数据库</p><blockquote><p>The server doesn’t grant access to the database: the server reports<br>FATAL: no pg_hba.conf entry for host “192.168.0.123”, user “postgres”, database “postgres” FATAL: no pg_hba.conf entry for host “192.168.0.123”, user “postgres”, database “postgres”</p></blockquote><p>谷歌翻译</p><blockquote><p>服务器不授予对数据库的访问权限：服务器报告<br>FATAL：主机“192.168.0.123”，用户“postgres”，数据库“postgres”没有pg_hba.conf条目FATAL：主机“192.168.0.123”没有pg_hba.conf条目，用户“postgres”，数据库“postgres”</p></blockquote><p>其实字面意思就很容易理解，虽然我还是百度的错误答案。我自己理解就是入口不被允许,就觉办法如下</p><blockquote><p>PostgreSQL数据库为了安全，它不会监听除本地以外的所有连接请求，当用户通过JDBC访问是，会报一些如下的异常：</p><p>org.postgresql.util.PSQLException: FATAL: no pg_hba.conf entry for host</p><p>要解决这个问题，只需要在PostgreSQL数据库的安装目录下找到/data/pg_hba.conf,找到“# IPv4 local connections:”</p><p>在其下加上请求连接的机器IP</p><p>host all all 127.0.0.1/32 md5 //坑爹，那里面对于192.168.23.10当做192.168.23.1</p><p>32是子网掩码的网段；md5是密码验证方法，可以改为trust</p></blockquote><p>一个服务器，有内网ip（类似192.168这些，有外网ip 211.这种，有127.0.0.1 这种，如果要包括所有的，就得用0.0.0.0，感觉如果你访问一个服务器用的是内网ip，应该意思就是你们在同一个局域网中吧。很奇怪的一点是，之前说vagrant会把ssh的22端口映射到host的2222端口，导致了127.0.0.1:2222或者192.168.23.10:22都能访问，其实不太懂这个原理，但好像这是由两个不同的网卡决定的，我好像把itbasic那上面一个网卡禁止了，导致127那种ssh访问不了，感觉就是虽然内网ip和外网ip可以对应同一个端口，但也可以对应不同的端口）</p><p>2.导入导出数据库</p><p>导出：/opt/pgsql/bin/pg_dump -U postgres itbasic &gt; /home/itbasic/itbasic.sql</p><p>pg_dump 是postgresql安装之后的一个命令，-U 指定用户 postgres, itbasic,是数据库名，postgresql好像只能用postgres这个用户执行操作，itbasic这个数据库名一定要指定，还有pg_dump 这个命令所在目录没有加入系统变量的话，一定要加上路径，后面 &gt;/home/itbasic/itbasic.sql,代表数据导出到具体的文件中。</p><p>导出</p><p>数据库的导入必须要先创建这个数据库</p><p>postgresql安装之后的命令会有createdb，但用这个创建数据库感觉挺麻烦，直接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1. /opt/pgsql/bin/pgsql -U postgres itbasic  //进入pgsql 客户端</div><div class="line">2. create database project x   //创建数据库</div><div class="line">3. \q   //退出pgsql客户端</div><div class="line">4. /opt/pgsql/bin/pgsql -U postgres projectx -f /home/itbasic/projectx.sql   //导入数据库</div></pre></td></tr></table></figure><p>3.导入导出表</p><p>导入导出表和导入导出数据库的最大区别是导入导出数据库需要先建立一个数据库，而表则不用，最好还先把这张表删除了</p><p>导出</p><p>/opt/pgsql/bin/pg_dump -U postgres itbasic  -t dt_admin &gt; /home/itbasic/admin.sql</p><p>导入</p><p>/opt/pgsql/bin/psql -U postgres itbasic -f /home/itbasic/admin.sql</p><p>4.数组类型</p><p>array_remove  会把出现的元素全都移除掉，而不是只移除一个   love=array_remove(love, chen.ye)</p><p>array_append   love= array_append(love, chen.ye)</p><p>如果元素不存在，也不会报错，只会接着往下执行</p><p>any()  chenye = any(love)  love这个字段中是否有陈野</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来是不想写这篇文章的，因为感觉自己对于postgresql理解不够深入，但因为生活中对于postgresql有些问题总是遇到，所以记录下来，方便以后查找。&lt;/p&gt;
    
    </summary>
    
      <category term="postgresql" scheme="http://yoursite.com/categories/postgresql/"/>
    
    
      <category term="postgresql" scheme="http://yoursite.com/tags/postgresql/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>apache简单配置</title>
    <link href="http://yoursite.com/2018/04/16/apache%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/04/16/apache简单配置/</id>
    <published>2018-04-16T13:38:54.000Z</published>
    <updated>2018-04-17T01:22:55.117Z</updated>
    
    <content type="html"><![CDATA[<p>关于apache的配置文件。不管是xampp安装的lamp环境，还是自己在linux下面搭建的lamp环境，之前关于apache的配置都是直接copy网上的，用的虚拟域名，本质是还是不够理解的，关于.htaccess 也只是刚开始学习tp的时候看到过，后来因为配置虚拟域名能解决问题，就没有过多的了解这个.htaccess了。</p><a id="more"></a><p>首先说一下之前遇到的问题。某次，帮助交付的一个同事配置xampp环境，他当时对多站点的配置文件都写在了apache的主配置文件中，httpd.conf,当时因为已经了解了虚拟域名，所以我在同级目录extra下面的httpd-vhost.conf中帮他写了新的配置，当时用的是不同域名分发到不同文件夹下的方式，其实这在实际生活中也是这样的，因为如果靠的是端口号的话，因为web服务默认是80端口，如果用了别的端口号，比如http:\\www.baidu.com:800, 这样访问百度的web服务，这对广大用户是不友好的，因为对于非程序员来说，根本不知道:800是什么。如果不想用域名开进行分发，端口号也是可以的，但为了不让用户去记忆端口号，可以通过nginx来帮忙。比如itbasic.datatom.com和bbs.datatom.com虽然绑定的是同一个服务器，但是通过nginx的转发，到了不同的端口，一个因为是从itbasic.datatom.com+ 80端口来的，所以转发到本服务器的8080端口，一个是从bbs.datatom.com+80端口来的，所以到了8081端口。我就是通过上述两种方式之一的域名不同来帮那个同事写的vhost配置的，可是呢，当我输入域名的时候，他虽然能访问，但是访问的还是之前他的一个网站，fuck！！！算了，配置文件写的这么乱，我就没找原因了，直接帮他copy了以前主配置文件里面写的一个站点配置。</p><p>其实后来我差不多知道原因了，大概是直接在主配置文件里面写了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">ServerName localhost:80</div><div class="line">DocumentRoot &quot;F:/www&quot;</div><div class="line">&lt;Directory &quot;F:/www&quot;&gt;</div><div class="line">    #</div><div class="line">    # Possible values for the Options directive are &quot;None&quot;, &quot;All&quot;,</div><div class="line">    # or any combination of:</div><div class="line">    #   Indexes Includes FollowSymLinks SymLinksifOwnerMatch ExecCGI MultiViews</div><div class="line">    #</div><div class="line">    # Note that &quot;MultiViews&quot; must be named *explicitly* --- &quot;Options All&quot;</div><div class="line">    # doesn&apos;t give it to you.</div><div class="line">    #</div><div class="line">    # The Options directive is both complicated and important.  Please see</div><div class="line">    # http://httpd.apache.org/docs/2.4/mod/core.html#options</div><div class="line">    # for more information.</div><div class="line">    #</div><div class="line">    Options Indexes FollowSymLinks Includes ExecCGI</div><div class="line"></div><div class="line">    #</div><div class="line">    # AllowOverride controls what directives may be placed in .htaccess files.</div><div class="line">    # It can be &quot;All&quot;, &quot;None&quot;, or any combination of the keywords:</div><div class="line">    #   AllowOverride FileInfo AuthConfig Limit</div><div class="line">    #</div><div class="line">    AllowOverride All</div><div class="line"></div><div class="line">    #</div><div class="line">    # Controls who can get stuff from this server.</div><div class="line">    #</div><div class="line">    Require all granted</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure><p>问题的关键就是那个server name，因为是localhost：80，但凡是host（windows下）里面127.0.0.1 用的80端口，统一转发到这个目录下，造成了上述结果。其实itbasic的服务器配置上也是这么写的，但之外的那些bbs，51dana用的却是虚拟域名，为啥那个能正常访问呢，在于配置文件上面定义了server name itbasic.datatom.com。其实itbasic那个也是可以通过域名来进行分发的，主要在每个vhost里面加个server name 就可以了。itbasic那个完全也可以不用端口进行转发，完全可以通过域名，在每个vhost里面加上server name就可以了</p><p>先说一下关于vhost的配置方法吧</p><p>打开apache的配置文件 htppd.cnf。分别打开重写扩展和虚拟主机扩展：</p><blockquote><p>LoadModule rewrite_module modules/mod_rewrite.so 这句前面的 注释 # 去掉</p><p>Include conf/extra/httpd-vhosts.conf 这句前面的 注释 # 去掉</p></blockquote><p>但现在一般apache都是默认开启的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;VirtualHost *:80&gt;   //包裹的内容代表虚拟主机，端口号80</div><div class="line">    DocumentRoot &quot;D:/wamp/www/testphp/&quot;  //项目的根目录</div><div class="line">    ServerName php.iyangyi.com   //域名</div><div class="line">    ServerAlias www.pptv.cn #可省略  //这个是我们的虚拟域名的别名，可以不要，他的出现场景就是我们希望另外一个域名也往这个目录下调整。比如 www.pptv.cn 我们也希望跳到这里来，就可以这样做，但是前提是 www.pptv.cn 也要绑定host 127.0.0.1</div><div class="line">    ServerAdmin stefan321@qq.com #可省略  //这里填 服务器管理员的邮箱，也可以不要，当服务器出现故障后，如果提前有配置邮箱的话，会往这个邮箱发邮件，或者是显示在网页的错误信息当中。一般我们可以不填。</div><div class="line">    ErrorLog logs/dev-error.log #可省略  //当访问出现错误的时候，就会记录到这里，注意：logs/dev-error.log 这个文件路径是apache的安装目录下的logs 目录 。可以不要。</div><div class="line">    CustomLog logs/dev-access.log common #可省略 //这里填 访问日志，用来记录每一次的请求访问，可以不要。注意：logs/dev-access.log 这个文件路径是apache的安装目录下的logs 目录 。记住：路径后面加common。</div><div class="line">    ErrorDocument 404 logs/404.html #可省略 //这里填 403,404等错误信息调整页面，用来访问出现404页面等情况时的错误页面展示，比较有用，也可以不要。注意：/404.html 这个文件路径是项目的根目录，不是apache的目录。</div><div class="line">    &lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt;</div><div class="line">        Options Indexes FollowSymLinks</div><div class="line">        AllowOverride All</div><div class="line">        Order Allow,Deny</div><div class="line">        Allow from all</div><div class="line">        RewriteEngine on</div><div class="line">        RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</div><div class="line">        RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</div><div class="line">        RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]</div><div class="line">    &lt;/Directory&gt;</div><div class="line">&lt;/VirtualHost&gt;</div></pre></td></tr></table></figure><p>一般配置的时候，上面写了可省略的都不会配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt;</div></pre></td></tr></table></figure><p>是最重要的一步了，这里也是填本项目的路径，然后所有的<code>rewrite</code>规则都是在里面完成。所以这个是很重要的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Options Indexes FollowSymLinks</div></pre></td></tr></table></figure><p>作用我访问php.iyangyi.com，如果文件根目录里有 index.html(index.php)，浏览器就会显示 index.html的内容，如果没有 index.html，浏览器就会显示这文件根目录的目录列表，目录列表包括文件根目录下的文件和子目录。</p><p>到底是优先显示index.php还是index.html 有apache的配置决定的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;IfModule dir_module&gt;</div><div class="line">    DirectoryIndex index.html index.htm index.php index.php3  </div><div class="line">&lt;/IfModule&gt;</div></pre></td></tr></table></figure><p>这个是单独写出来的，而不是写在上述标签之内。这个感觉应该是统一定义一个就行了，或者是在vhost里面直接写directoryindx 这个标签，如果没写默认是index.html或者是index.php</p><p>之前遇到一个问题就是public文件夹因为是统一对外开放的嘛，不做处理的话，比如itbasic.datatom.com/userpic,可以访问服务器上public下面这个userpic文件夹，为了不让用户访问，我们可以去掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Options Indexes FollowSymLinks</div></pre></td></tr></table></figure><p>的indexes,用户就不能访问了。</p><p><code>Order Deny,Allow Allow from all</code>这2个一般是组合在一起用。用来<code>设置访问权限</code> ，设置哪些ip可以访问这个域名, 哪些ip禁止访问。</p><p>所以order是设置这2个的组合排序, 不区分大小写，中间用<code>,</code>分开，中间不能有空格。 </p><p>所以order是设置这2个的组合排序, 不区分大小写，中间用<code>,</code>分开，中间不能有空格。<br><code>Order Deny,Allow</code> ：表示设定“先检查禁止设定，没有设定禁止的全部允许”</p><p><code>Order Allow,Deny</code> : 表示设定“先检查允许设定，没有设定允许的全部禁止”</p><p><strong>而且最后的访问结果有第二参数决定！</strong></p><p><code>Deny from All</code> <code>Deny from 127.0.0.1</code> 禁止访问的ip， all 表示全部 </p><p><code>Deny from All</code> <code>Deny from 127.0.0.1</code> 禁止访问的ip， all 表示全部<br><code>Allow from All</code> <code>Allow from 127.0.0.1</code> 允许访问的ip， all 表示全部</p><p>我们看几个他们2个组合的例子。</p><p>这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Order Deny,Allow</div><div class="line">Deny from All</div></pre></td></tr></table></figure><p>表示先检查允许的, 没有允许的全部禁止。但是下却没有Allow，那么就表示是无条件禁止了所有的访问了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Order Deny,Allow</div><div class="line">Deny from all</div><div class="line">Allow from 127.0.0.1</div></pre></td></tr></table></figure><p>上面表示 只允许127.0.0.1访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Order Allow,Deny</div><div class="line">Allow from all</div><div class="line">Deny from 127.0.0.1 192.168.1.51</div></pre></td></tr></table></figure><p>上面表示禁止127.0.0.1和192.168.1.51访问，其他都可以！</p><p>所以这个的组合就可以达到很多的过滤访问效果。</p><p>但现在一般不用那个了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Require all granted</div></pre></td></tr></table></figure><p>才能解决，要么一直都是403。</p><h2 id="RewriteCond-与-RewriteRule-指令格式配置详解"><a href="#RewriteCond-与-RewriteRule-指令格式配置详解" class="headerlink" title="RewriteCond 与 RewriteRule 指令格式配置详解"></a>RewriteCond 与 RewriteRule 指令格式配置详解</h2><p>上面花了大量的时间讲述<code>VirtualHost</code> 里面的一些配置参数的写法和作用，接下来就是rewrite的重点了，3个核心的东西：<strong>RewriteEngine，RewriteCond，RewriteRule</strong></p><p><strong>RewriteEngine</strong> </p><p><strong>RewriteEngine</strong><br>这个是rewrite的<code>总开关</code>，用来开启是否启动url rewrite，要想打开，像这样就可以了：</p><blockquote><p>RewriteEngine on</p></blockquote><p><strong>RewriteCond 和 RewriteRule</strong> </p><p><strong>RewriteCond 和 RewriteRule</strong><br>表示指令定义和匹配一个规则条件，让RewriteRule来重写。说的简单点，RewriteCond就像我们程序中的if语句一样，表示如果符合某个或某几个条件则执行RewriteCond下面紧邻的RewriteRule语句，这就是RewriteCond最原始、基础的功能。</p><p>先看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RewriteEngine on</div><div class="line">RewriteCond  %&#123;HTTP_USER_AGENT&#125;  ^Mozilla//5/.0.*</div><div class="line">RewriteRule  index.php            index.m.php</div></pre></td></tr></table></figure><p>上面的匹配规则就是：如果匹配到http请求中HTTP_USER_AGENT 是 Mozilla//5/.0.* 开头的，也就是用FireFox浏览器访问index.php这个文件的时候，会自动让你访问到index.m.php这个文件。</p><p><strong>RewriteCond 和 RewriteRule 是上下对应的关系。可以有1个或者好几个RewriteCond来匹配一个RewriteRule</strong></p><p>RewriteCond一般是这样使用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RewriteCond %&#123;XXXXXXX&#125; + 正则匹配条件</div></pre></td></tr></table></figure><p>那么RewriteCond可以匹配什么样的数据请求呢？ </p><p>那么RewriteCond可以匹配什么样的数据请求呢？<br>它的使用方式是：<code>RewriteCond %{NAME_OF_VARIABLE} REGX</code> FLAG</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RewriteCond %&#123;HTTP_REFERER&#125; (www.test.cn)</div><div class="line">RewriteCond %&#123;HTTP_USER_AGENT&#125;  ^Mozilla//5/.0.*</div><div class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</div></pre></td></tr></table></figure><p>上面是常见的3种最常见使用最多的<code>HTTP头连接与请求</code>匹配。</p><p><strong>HTTP_REFERER</strong> </p><p><strong>HTTP_REFERER</strong><br>这个匹配访问者的地址，php中$_REQUREST中也有这个，当我们需要判断或者限制访问的来源的时候，就可以用它。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RewriteCond %&#123;HTTP_REFERER&#125; (www.test.cn)</div><div class="line">RewriteRule (.*)$ test.php</div></pre></td></tr></table></figure><p>上面语句的作用是如果你访问的上一个页面的主机地址是www.test.cn，则无论你当前访问的是哪个页面，都会跳转到对test.php的访问。</p><p>再比如，也可以利用 HTTP_REFERER <code>防倒链</code>，就是限制别人网站使用我网站的图片。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RewriteCond %&#123;HTTP_REFERER&#125; !^$ [NC]</div><div class="line">RewriteCond %&#123;HTTP_REFERER&#125; !ww.iyangyi.com [NC]</div><div class="line">RewriteRule \.(jpg|gif) http://image.baidu.com/ [R,NC,L]</div></pre></td></tr></table></figure><p>NC nocase的意思，忽略大小写。第一句呢，是必须要有域名，第一句就是看域名如果不是 www.iyangyi.com 的，当访问.jpg或者.gif文件时候，就都会自动跳转到 <a href="http://image.baidu.com/" target="_blank" rel="external">http://image.baidu.com/</a> 上，很好的达到了防盗链的要求。</p><p><strong>REQUEST_FILENAME</strong> </p><p><strong>REQUEST_FILENAME</strong><br>这个基本是用的最多的，以为url重写是用的最多的，它是匹配当前访问的域名文件，那哪一块属于REQUEST_FILENAME 呢？是url 除了host域名外的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.rainleaves.com/html/1569.html?replytocom=265</div></pre></td></tr></table></figure><p>这个url，那么 REQUEST_FILENAME 就是 <code>html/1569.html?replytocom=265</code></p><p>看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</div><div class="line">RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</div><div class="line">RewriteRule ^room/video/(\d+)\.html web/index\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L]</div></pre></td></tr></table></figure><p><code>-d</code> 是否是一个目录. 判断TestString是否不是一个目录可以这样: <code>!-d</code> </p><p><code>-d</code> 是否是一个目录. 判断TestString是否不是一个目录可以这样: <code>!-d</code><br><code>-f</code> 是否是一个文件. 判断TestString是否不是一个文件可以这样: <code>!-f</code></p><p>这两句语句<code>RewriteCond</code>的意思是请求的文件或路径是不存在的，如果文件或路径存在将返回已经存在的文件或路径。一般是这样结合在一起用的。</p><p>上面<code>RewriteRule</code>正则的意思是以 room开头的 room/video/123.html 这样子，变成 web/index.php?c=room&amp;a=video&amp;r=123</p><p><code>$1</code> 表示匹配到的第一个参数。</p><h2 id="RewriteRule-写法和规则"><a href="#RewriteRule-写法和规则" class="headerlink" title="RewriteRule 写法和规则"></a>RewriteRule 写法和规则</h2><p>RewriteRule是配合RewriteCond一起使用，可以说，RewriteRule是RewriteCond成功匹配后的执行结果，所以，它是很重要的。</p><p>来看一下 <code>RewriteRule</code>的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RewriteRule Pattern Substitution [flags]</div></pre></td></tr></table></figure><p><code>Pattern</code>是一个正则匹配。<code>Substitution</code>是匹配的替换 <code>[flags]</code>是一些参数限制；</p><p>我们看几个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RewriteRule ^room/video/(\d+)\.html web/index\.php?c=room&amp;a=video&amp;r=$1 [QSA,NC,L]</div></pre></td></tr></table></figure><p>意思是 以 room开头的 room/video/123.html 这样子，变成 web/index.php?c=room&amp;a=video&amp;r=123</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RewriteRule \.(jpg|gif) http://image.baidu.com/ [R,NC,L]</div></pre></td></tr></table></figure><p>意思是以为是访问.jpg或者gif的文件，都会调整到 <a href="http://image.baidu.com/" target="_blank" rel="external">http://image.baidu.com</a></p><p>所以，掌握正则级是关键所在了。以后，我会专门搞一个正则的篇章来学习下。</p><p>我们再看看<code>[flags]</code>是什么意思？</p><p>因为它太多了。我就挑几个最常用的来说说吧。</p><p><code>[QSA]</code> qsappend(追加查询字符串)的意思，次标记强制重写引擎在已有的替换字符串中追加一个查询字符串，而不是简单的替换。如果需要通过重写规则在请求串中增加信息，就可以使用这个标记。上面那个<code>room</code>的例子，就必须用它。</p><p><code>NC</code> nocase(忽略大小写)的意思，它使Pattern忽略大小写，也就是在Pattern与当前URL匹配时，”A-Z”和”a-z”没有区别。这个一般也会加上，因为我们的url本身就不区分大小写的。</p><p><code>R</code> redirect(强制重定向)的意思，适合匹配Patter后，Substitution是一个http地址url的情况，就调整出去了。上面那个调整到image.baidu.com的例子，就必须也用它。</p><p><code>L</code> last(结尾规则)的意思，就是已经匹配到了，就立即停止，不再匹配下面的Rule了，类似于编程语言中的<code>break</code>语法，跳出去了。</p><p>其他的一些具体的语法，可以参考以下资料：</p><p><a href="http://www.skygq.com/2011/02/21/apache%E4%B8%ADrewritecond%E8%A7%84%E5%88%99%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D%E8%BD%AC/" target="_blank" rel="external">http://www.skygq.com/2011/02/21/apache%E4%B8%ADrewritecond%E8%A7%84%E5%88%99%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D%E8%BD%AC/</a></p><p><a href="http://www.2cto.com/os/201201/116040.html" target="_blank" rel="external">http://www.2cto.com/os/201201/116040.html</a></p><p><a href="http://www.cnblogs.com/adforce/archive/2012/11/23/2784664.html" target="_blank" rel="external">http://www.cnblogs.com/adforce/archive/2012/11/23/2784664.html</a></p><h2 id="htaccess文件的使用"><a href="#htaccess文件的使用" class="headerlink" title=".htaccess文件的使用"></a>.htaccess文件的使用</h2><p><code>.htaccess</code>文件是啥呢？我们前面说了这么多的配置和修改，都是针对于apache的配置文件来修改的。.htaccess文件就是它的一个替代品。为啥呢？因为你每次修改apache的配置文件，都必须重启apache服务器，很麻烦不说，有些共享apache的服务器，你还没权限修改和重启apache。所以，.htaccess文件就应运而生了。（不用重启apache,是真的挺方便的）</p><p><code>.htaccess</code>分布式配置文件。它文件名字比较奇怪，没有文件名，只有一个文件后缀就是<code>.htaccess</code>。所以一般在windows下还没法新建这个文件，因为windows不允许文件名是空的，比较蛋疼。但是我相信你总归会有办法新建这个文件的。（在linux下新建一个，下载到windows中呗）</p><p><code>.htaccess</code>同时是一个针对目录的配置，你可以把它放到项目的根目录下，那么它就多整个项目其效果，如果你把它放到一个单独的子目录下，那么它就对这个子目录其效果了。</p><p><strong>.htaccess</strong>文件如何生效呢。上面讲配置的时候，我讲过了<code>AllowOverride All</code>这个配置，它就是启动<code>.htaccess</code>文件是否可以使用的。<code>AllowOverrideAll</code>表示可以。<code>AllowOverride None</code>表示禁止使用。还是蛮简单的。</p><p><strong>那.htaccess文件里的语法是怎么写额呢？</strong></p><p>其实和上面说的一模一样的写法。可以完全的搬过来用。没问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> &lt;Directory &quot;D:/wamp/www/testphp/&quot;&gt;</div><div class="line">    Options Indexes FollowSymLinks</div><div class="line">    AllowOverride All</div><div class="line">    Order Allow,Deny</div><div class="line">    Allow from all</div><div class="line">    RewriteEngine on</div><div class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</div><div class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</div><div class="line">    RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure><p>上面的apache的<code>`里的这一块就可以完全的搬到</code>.htaccess`文件中来，且效果一模一样。</p><p>上面就是vhost文件里面的配置的大致写法，其实httpd.conf里面也是这么写的，毕竟vhost最后还是包含到主配置文件里面。</p><p>documentroot 其实自己一直好奇为啥和directory参数一样其实本质上该项目文件夹下只有这个document root能访问，所以重写规则也好，针对的都是这个document root，导致了二者之间的相同。</p><p>有一点要注意的就是，如果通过开不同的端口号转发到不同的文件夹，需要早配置文件的开头写上Listen 127.0.0.1：8080 这样，开启端口号。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于apache的配置文件。不管是xampp安装的lamp环境，还是自己在linux下面搭建的lamp环境，之前关于apache的配置都是直接copy网上的，用的虚拟域名，本质是还是不够理解的，关于.htaccess 也只是刚开始学习tp的时候看到过，后来因为配置虚拟域名能解决问题，就没有过多的了解这个.htaccess了。&lt;/p&gt;
    
    </summary>
    
      <category term="apache" scheme="http://yoursite.com/categories/apache/"/>
    
    
      <category term="apache" scheme="http://yoursite.com/tags/apache/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="框架" scheme="http://yoursite.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Laravel ORM</title>
    <link href="http://yoursite.com/2018/03/30/Laravel-ORM/"/>
    <id>http://yoursite.com/2018/03/30/Laravel-ORM/</id>
    <published>2018-03-30T03:30:05.000Z</published>
    <updated>2018-03-30T07:57:06.921Z</updated>
    
    <content type="html"><![CDATA[<p>orm并不是一个新兴的概念，他出现很久了，只是刚开始学习的自己并没有接触到，他能帮我们少写很多代码，让我们能以更面向对象的方式来处理关于数据库的操作。</p><a id="more"></a><p>Eloquent 是laravel的orm，我们通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php artisan make:model User</div></pre></td></tr></table></figure><p>生成的类虽然是继承Model，但本质上都是继承这个Eloquent，他把我们每张表看做一个类，表里面的数据看做一个实例，我们对其进行操作的时候，更类似于面向对象的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$user = User::find(1);</div><div class="line">$user-&gt;name = &apos;cy&apos;;</div><div class="line">$user-&gt;city = &apos;shanghai&apos;;</div><div class="line">$user-&gt;save();</div></pre></td></tr></table></figure><p>更便于理解。</p><p>生成的model很简单，大致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"></div><div class="line">class Article extends \Eloquent &#123;</div><div class="line"></div><div class="line">protected $fillable = [];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个fillable里面就是可以批量操作的字段，批量操作在我之前的文章里面有提到过，我觉得更通俗的理解是可更新的字段。只需要继承一下 Eloquent 类，就可以干 ‘first() find() where() orderBy()’ 等非常非常多的事情，这就是面向对象的强大威力。</p><p>通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php artisan tinker</div></pre></td></tr></table></figure><p>可以开启一个交互环境进行orm的调试，其实我感觉不止是orm，别的代码也都是可以执行的，只是方便了orm的打印操作，能很方便的看到执行结果。有一点需要注意的就是tinker是基于当前代码的，如果代码重新修改来了，我们需要重启tinker来加载新的代码。</p><p>还有我们会利用composer安装laravel-debugbar，来进行orm的调试，当我发现在别的项目中使用不了这个插件的时候，我改变了对composer的看法，他安装的东西更类似于代码，而不是软件，我们如果要在不同的项目中也使用这个插件，我们同样需要在另一个项目目录线面进行composer安装</p><p>介绍几个常用的函数</p><ul><li><p>find()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">User::find(1)</div><div class="line">App\User &#123;#764</div><div class="line">     id: 1,</div><div class="line">     name: &quot;cy&quot;,</div><div class="line">     email: &quot;1967196626@qq.com&quot;,</div><div class="line">     created_at: &quot;2018-03-30 01:42:40&quot;,</div><div class="line">     updated_at: &quot;2018-03-30 01:59:51&quot;,</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>这个1是主键</p></li></ul><ul><li><p>first()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">User::where(&apos;id&apos;, &apos;&gt;&apos;, 1)-&gt;first()</div><div class="line">App\User &#123;#771</div><div class="line">     id: 2,</div><div class="line">     name: &quot;Bella Lebsack&quot;,</div><div class="line">     email: &quot;cristobal58@example.net&quot;,</div><div class="line">     created_at: &quot;2018-03-30 01:59:51&quot;,</div><div class="line">     updated_at: &quot;2018-03-30 01:59:51&quot;,</div><div class="line">   &#125;</div></pre></td></tr></table></figure><p>上面两个获取的内容都是对象，可以直接使用</p></li><li><p>get()  获取的是一个collection</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> User::where(&apos;id&apos;, &apos;&gt;&apos;, 1)-&gt;where(&apos;id&apos;, &apos;&lt;&apos;, 3)-&gt;get()</div><div class="line">=&gt; Illuminate\Database\Eloquent\Collection &#123;#773</div><div class="line">     all: [</div><div class="line">       App\User &#123;#778</div><div class="line">         id: 2,</div><div class="line">         name: &quot;Bella Lebsack&quot;,</div><div class="line">         email: &quot;cristobal58@example.net&quot;,</div><div class="line">         created_at: &quot;2018-03-30 01:59:51&quot;,</div><div class="line">         updated_at: &quot;2018-03-30 01:59:51&quot;,</div><div class="line">       &#125;,</div><div class="line">     ],</div><div class="line">   &#125;</div></pre></td></tr></table></figure></li><li><p>all() 获取的是一个collection</p></li></ul><p>​    all的使用好像不能加条件</p><p>​    上面的collection可以通过toArray() 方法转换成数组，但其实我们平时用的时候没用toArray也是可以的</p><p>上面需要注意的点就是：</p><ol><li>所有的中间方法如 ‘where()’ ‘orderBy()’ 等都能够同时支持 ‘静态’ 和 ‘非静态链式’ 两种方式调用，即 ‘Article::where()…’ 和 ‘Article::….-&gt;where()’。</li><li>所有的 ‘非固定用法’ 的调用最后都需要一个操作来 ‘收尾’，本片教程中有两个 ‘收尾操作’：’-&gt;get()’ 和 ‘-&gt;first()’。</li><li>每一个继承了 Eloquent 的类都有两个 ‘固定用法’ ‘Article::find($number)’ ‘Article::all()’，前者会得到一个带有数据库中取出来值的对象，后者会得到一个包含整个数据库的对象合集。</li></ol><p>Builder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Article::where(&apos;id&apos;, &apos;&gt;&apos;, 10)-&gt;where(&apos;id&apos;, &apos;&lt;&apos;, 20)-&gt;orderBy(&apos;updated_at&apos;, &apos;desc&apos;)-&gt;get();</div></pre></td></tr></table></figure><p>这段代码的 <code>::where()-&gt;where()-&gt;orderBy()</code> 就是Builder。用面向对象的方法来理解，可以总结成一句话：创建一个对象，并不断修改它的属性，最后用一个操作来触发数据库操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User::orderBy(&apos;id&apos;, &apos;desc&apos;);</div><div class="line">=&gt; Illuminate\Database\Eloquent\Builder &#123;#817&#125;</div></pre></td></tr></table></figure><p>这个get() 就是那个最后的方法。</p><p>值的思考的一个问题</p><blockquote><p>如果直接用 :: 来访问某个 function，无论这个 function 是否为 static，构造函数 __construct() 都不会被调用，那么创建对象是如何实现的呢？请看：<a href="https://github.com/illuminate/database/blob/master/Eloquent/Model.php#L3354" target="_blank" rel="external">https://github.com/illuminate/database/blob/master/Eloquent/Model.php#L3354</a></p></blockquote><p>所谓 “终结者” 方法，指的是在 N 个中间操作流方法对某个 Eloquent 对象进行加工以后，触发最终的数据库查询操作，得到返回值。</p><p><code>first()</code> <code>get()</code> <code>paginate()</code> <code>count()</code> <code>delete()</code> 是用的比较多的一些 “终结者” 方法，他们会在中间操作流的最后出现，把 SQL 打给数据库，得到返回数据，经过加工返回一个 Article 对象或者一群 Article 对象的集合。</p><p>all() 方法好像不是，因为all() 好像不能跟着条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> User::orderBy(&apos;id&apos;, &apos;desc&apos;)-&gt;all();</div><div class="line">BadMethodCallException with message &apos;Call to undefined method Illuminate\Database\Query\Builder::all()</div></pre></td></tr></table></figure><p>关系</p><p>1 对 1 关系</p><p>做了个试验，发现如果通过传统的生成迁移文件，生成model，进行数据填充真的挺麻烦的，不如在数据库中快速建表来的容易</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public function hasOne1()</div><div class="line">    &#123;</div><div class="line">        return $this-&gt;hasOne(TestOneToOne::class, &apos;user_id&apos;, &apos;id&apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public function belongsTo1()</div><div class="line">    &#123;</div><div class="line">        return $this-&gt;belongsTo(TestOneToOne::class, &apos;id&apos;, &apos;user_id&apos;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>这是User 中的两个方法</p><p>User::with(‘hasOne1’)-&gt;find(1)</p><p>User::with(‘belongsTo1’)-&gt;find(1)</p><p>获取的数据是一样的，说一下我的记忆方法。hasOne 的时候，对方表中的字段在前面，belongsTo的时候自己表中的数据在前面。（我一般喜欢用with表示模型的结合）</p><p>还有第一个参数注意一下，话说这个::class出现好久了，而我却很少用，真的很方便哦。</p><p>还有默认的orm模型名称都是表名的单数，这个是一定要注意的哦。除非自己重新定义。（many 都能识别成功manies,牛逼）</p><p>1对多</p><p>这个时候的belongsTo 只有一种了，和上面的一样，hasMany() 和上面也类似。值的注意的一点就是那个表::with就成主体了，还有一点的就是使用with的时候并不是和我们传统的那种使用left join，而是先计算出主表，再根据主表中的数据，就算从表中对应数据in() 这个集合中，我不能理解的一点就是这样通过in，怎么完成了数据的连接。</p><p>多对多</p><p>这个时候经常需要第三张表来存储数据，值的注意的一点就是第三张表往往不需要生成model。</p><p>第三张表值记录对应关系，感觉默认的就是主键id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public function belongsToMany1()</div><div class="line">    &#123;</div><div class="line">        return $this-&gt;belongsToMany(\App\User::class, &apos;test_many_to_many&apos;, &apos;user_id&apos;, &apos;test_id&apos;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>上面是一种我的粉丝，比如我是users 表中的一员，我的粉丝也是这张表中的数据，注意存储数据关系的表不要用::class，因为不存在这个class，还有如果要加where条件，里面的条件用调用主题的字段，比如users中的字段id。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;orm并不是一个新兴的概念，他出现很久了，只是刚开始学习的自己并没有接触到，他能帮我们少写很多代码，让我们能以更面向对象的方式来处理关于数据库的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="Laravel" scheme="http://yoursite.com/categories/Laravel/"/>
    
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
      <category term="orm" scheme="http://yoursite.com/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 数据填充</title>
    <link href="http://yoursite.com/2018/03/30/Laravel-%E6%95%B0%E6%8D%AE%E5%A1%AB%E5%85%85/"/>
    <id>http://yoursite.com/2018/03/30/Laravel-数据填充/</id>
    <published>2018-03-30T02:01:03.000Z</published>
    <updated>2018-03-30T06:41:23.787Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个phper，Laravel的学习是必不可少的，可是这个框架的学习成本还是挺大的，有些东西现在可能不明白，但至少记录下来，慢慢的成长。</p><a id="more"></a><p>在laravel的学习中，感觉挺好用的相比较于我们现在，数据填充是一个很不错的功能，能生成一大堆假的数据把页面填充起来，让他更有实际的样子。</p><p>数据填充，和数据库相关，自然去database下面。seeds目录，databaseseeder,这个文件主要是让我们在运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php artisan db:seed</div></pre></td></tr></table></figure><p>的时候，执行哪些数据填充的文件，其参数可以让我们执行哪些填充文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public function run()</div><div class="line">    &#123;</div><div class="line">        // $this-&gt;call(UsersTableSeeder::class);</div><div class="line">        Model::unguard();</div><div class="line">        $this-&gt;call(UsersTableSeeder::class);</div><div class="line">        Model::reguard();</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>上面就是基础的database seeder 里面的内容，前面两个主要是接触限制（官方叫批量赋值，就是默认model里面只有fileable的字段可以填充，为什么要规定这个呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public function create(Request $req)</div><div class="line">&#123;</div><div class="line">$this-validate($req, [</div><div class="line">  &apos;name&apos; =&gt; &apos;required|min:5&apos;,</div><div class="line">  &apos;password&apos; =&gt; &apos;required|confirmed&apos;</div><div class="line">  ···</div><div class="line">])</div><div class="line">$name = $req-&gt;name;</div><div class="line">$password = $req-&gt;password;</div><div class="line">User::create(compact(&apos;name&apos;, &apos;password&apos;));</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这样填充数据太麻烦了，比如我之前在itbasic上面填充数据，一个合同二十多个字段，这样往方法里面插入，一般这样</p><pre><code>public function create(Request $req){  $this-validate($req, [  &apos;name&apos; =&gt; &apos;required|min:5&apos;,          &apos;password&apos; =&gt; &apos;required|confirmed&apos;          ···  ])  User::create($req-&gt;all());}</code></pre><p>req的all方法获取的是一个关联数组，可是这样插入会导致一个问题，比如现在的表的字段的越来越规范了，比如admin字段 is_admin,这样当用户传入is_admin  1， 就完了，所以设置批量赋值，用来规定哪些字段可以传入，哪些字段不可以传入，filable 代表可以传入的，guard 代表这些不能传入。</p><p>当我们进行数据填充的时候，可能不需要字段限制，所以才会有了开始的解除限制和后面的开启限制。</p><p>接下来就是种子文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php artisan make:seeder UsersTableSeeder</div></pre></td></tr></table></figure><p>也是只有一个run方法，这个UsersTableSeeder,只是命名规范，其实并不用，因为我们在写run方法的时候，就是在写普通的插入语句</p><pre><code>public function run(){  DB::table(&apos;articles&apos;)-&gt;delete();  for ($i=0; $i &lt; 10; $i++) {      \App\Article::create([          &apos;title&apos;   =&gt; &apos;Title &apos;.$i,          &apos;body&apos;    =&gt; &apos;Body &apos;.$i,          &apos;user_id&apos; =&gt; 1,      ]);  }}</code></pre><p>这种方法就太没有意义了，因为我们可以通过写一个接口，来进行插入，我们希望的是更真实的数据，laravel中一般使用的用工厂模式生成批量化的对象，然后进行数据填充。</p><p>查看database 下面的factory文件夹，</p><pre><code>factory-&gt;define(App\User::class, function(Faker faker) {  static $password;  return [      &apos;name&apos; =&gt; $faker-&gt;name,      &apos;email&apos; =&gt; $faker-&gt;unique()-&gt;safeEmail,      &apos;password&apos; =&gt; $password ?: $password = bcrypt(&apos;secret&apos;),      &apos;remember_token&apos; =&gt; str_random(10),  ];});</code></pre><p>这里面只是定一个一个model对象，然后在seeder里面批量化的生成这个对象<br>    public function run()<br>    {<br>        //<br>        factory(App\User::class)-&gt;times(50)-&gt;create();<br>        $user = App\User::find(1);<br>        $user-&gt;name = ‘cy’;<br>        $user-&gt;email = ‘1967196626@qq.com’;<br>        $user-&gt;password = bcrypt(‘123456’);<br>        $user-&gt;save();<br>    }<br>综上：</p><ol><li>通过factory ，定义批量化的实例对象。</li><li>通过seeder 去实例化生成对象，然后插入数据库中。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个phper，Laravel的学习是必不可少的，可是这个框架的学习成本还是挺大的，有些东西现在可能不明白，但至少记录下来，慢慢的成长。&lt;/p&gt;
    
    </summary>
    
      <category term="Laravel" scheme="http://yoursite.com/categories/Laravel/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>PHP闭包</title>
    <link href="http://yoursite.com/2018/03/26/PHP%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/03/26/PHP闭包/</id>
    <published>2018-03-26T14:10:03.000Z</published>
    <updated>2018-05-25T10:10:54.613Z</updated>
    
    <content type="html"><![CDATA[<p>咱是写PHP的，可是PHP的很多特性咱都不是很熟，比如trait，闭包，咱不能只局限于表单的操作，不能只局限于面向过程的写法，记录下来那些年很少接触的特性。就从PHP的 <strong>闭包</strong> 开始咯<br><a id="more"></a></p><p>第一次接触闭包还是在js中，后来是在python中，最后才是php中！！!深刻的怀疑我是不是做php的。<br>php中闭包和js中还是不一样的，php中把匿名函数和闭包混为一谈，这让开始只知道js闭包的我好蛋疼，因为比如array_map 中经常写的回调（注意回调只是一种动作，匿名函数闭包或者是自定义函数只是实现回调的不同方法），还有最近很火的swoole，因为是异步的嘛，所以写了大量的回调函数，所以也属于闭包 ，虽然js和php的闭包有些不同但本质上还是封装函数的运行环境。<br>js:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function out() &#123;</div><div class="line">        var a = 1;</div><div class="line">        var b = function(name) &#123;</div><div class="line">            console.log(a);</div><div class="line">            console.log(name)</div><div class="line">        &#125;</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    var a = 2;</div><div class="line">    var name = &apos;cy&apos;;</div><div class="line">    var c= out();</div><div class="line">    c(name);</div></pre></td></tr></table></figure></p><p>上面这段代码虽然简单，但是包含了几个重要的知识点：</p><ol><li>js的闭包主要是靠两层函数的嵌套，然后通过调用外层的函数返回内层的函数，内层的函数可以调用外层函数中的变量，内层函数的执行可以通过后来调用的时候传入参数。</li></ol><p>php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class Foo</div><div class="line">&#123;</div><div class="line">    public function __call($method, $args)</div><div class="line">    &#123;</div><div class="line">        if(is_callable([$this, $method])) &#123;</div><div class="line">            return call_user_func_array($this-&gt;$method, $args);</div><div class="line">        &#125;</div><div class="line">        // else throw exception</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj = new Foo(&apos;Sam&apos;);</div><div class="line">$obj-&gt;say = function () &#123;</div><div class="line">    return &apos;Hello World&apos;;</div><div class="line">&#125;;</div><div class="line">echo($obj-&gt;say());</div></pre></td></tr></table></figure></p><p>当执行的say() 方法不存在的时候会自动执行<strong>call方法，然后method 传入是say方法，这里面args 因为是空，所以自动传入为空。<br>is_callable 方法判断这个$obj 实例中是否有这个方法，因为后面有定义$obj-&gt;say ,所以会自动调用。<br>call_user_func_array 会把前面这个$this-&gt;method 执行，后面args是传入的参数，相比较js就多了</strong>call() 部分。<br>上面还有一点没体现出来就是，闭包可以引用的变量是自己定义时候的父亲变量，js中可以直接在函数中使用，但是php中要用use关键字引入。</p><p>后来的php<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">class Foo</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj = new Foo(&apos;Sam&apos;);</div><div class="line">$obj-&gt;say = function () &#123;</div><div class="line">    return &apos;Hello World&apos;;</div><div class="line">&#125;;</div><div class="line">echo($obj-&gt;say-&gt;__invoke());</div></pre></td></tr></table></figure></p><p>因为php的闭包都是一个closure类，而invoke 是这个类除了（construct 不能实例化，bind bindto 绑定方法之外的一个方法）。<br>但是这个类中不能使用this关键字，主要是这个this指代的是closure自身，因为js中this关键字老变，虽然这都被别人诟病，但相比较于php，他还需要手动绑定呢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">class Foo</div><div class="line">&#123;</div><div class="line">    private $name;</div><div class="line"></div><div class="line">    function __construct($name)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj = new Foo(&apos;Sam&apos;);</div><div class="line"></div><div class="line">$cl = function() &#123;</div><div class="line">    return &quot;Hello &quot; . $this-&gt;name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">$cl = $cl-&gt;bindTo($obj, $obj);</div><div class="line">echo($cl());</div></pre></td></tr></table></figure></p><blockquote><p>我們不再執著該closure一定要動態成為 $obj的method，但要存取$obj property的目標不變，程式也不變，一樣使用$this。<br>假如我們能將$obj以手動注入的方式，讓closure內部的$this改指向$obj，我們就能達到如JavaScript的效果了。<br>$cl = $cl-&gt;bindTo($obj, $obj);<br>bindTo()如同__invoke()一樣，是closure物件內建的method，它的目的就是讓我們能手動注入一個物件，讓closure物件的$this指向手動注入的物件$obj。<br>因為在closure中我們有$this-&gt;name，經過bindTo()去手動注入 $obj後，$this已經改指向$obj，所以$this-&gt;name就相當於$obj-&gt;name。<br>根據bindTo()文件 :<br>若要讓closure物件只能存取其他物件的public變數，只傳第1個參數即可。<br>若要讓closure物件存取其他物件的private或protected變數，就要傳第2個參數。<br>bindTo()對於第2個參數的要求不嚴，有幾種傳法 :<br>傳進欲存取物件的class名稱，是字串。<br>傳進欲存取的物件也可以，bindTo()會自動得知該物件的class名稱。<br>在此就一併傳進與第一個參數相同的$obj。<br>echo($cl());<br>因為$obj已經透過bindTo() 手動注入進$cl()，此時$this已經指向$obj，所以執行$cl()就可順利存$obj的property</p></blockquote><p>Modern PHP<br>中对php闭包的重要方法bindTo的解释(注意闭包closure的bindTo方法本身是三个参数的，但因为第一个参数是闭包自身，所以经常$this-&gt;bindTo(arg1,arg2)这样去掉用）。</p><p>接下来我们来看看bindTo方法，通过该方法，我们可以把闭包的内部状态绑定到其他对象上。这里bindTo方法的第二个参数显得尤为重要，其作用是指定绑定闭包的那个对象所属的PHP类，这样，闭包就可以在其他地方访问绑定闭包的对象中受保护和私有的成员变量。<br>你会发现，PHP框架经常使用bindTo方法把路由URL映射到匿名回调函数上，框架会把匿名回调函数绑定到应用对象上，这样在匿名函数中就可以使用$this关键字引用重要的应用对象：<br>class App {<br>    protected $routes = [];<br>    protected $responseStatus = ‘200 OK’;<br>    protected $responseContentType = ‘text/html’;<br>    protected $responseBody = ‘Hello World’;</p><pre><code>public function addRoute($path, $callback) {    $this-&gt;routes[$path] = $callback-&gt;bindTo($this, __CLASS__);}public function dispatch($path) {    foreach ($this-&gt;routes as $routePath =&gt; $callback) {        if( $routePath === $path) {            $callback();        }    }    header(&apos;HTTP/1.1 &apos; . $this-&gt;responseStatus);    header(&apos;Content-Type: &apos; . $this-&gt;responseContentType);    header(&apos;Content-Length: &apos; . mb_strlen($this-&gt;responseBody));    echo $this-&gt;responseBody;}</code></pre><p>}<br>这里我们需要重点关注addRoute方法，这个方法的参数分别是一个路由路径和一个路由回调，dispatch方法的参数是当前HTTP请求的路径，它会调用匹配的路由回调。第9行是重点所在，我们将路由回调绑定到了当前的App实例上。这么做能够在回调函数中处理App实例的状态：<br>$app = new App();<br>$app-&gt;addRoute(‘/user’, function(){<br>    $this-&gt;responseContentType = ‘application/json;charset=utf8’;<br>    $this-&gt;responseBody = ‘世界你好’;<br>});<br>$app-&gt;dispatch(‘/user’)</p><p>总结一下，闭包的bindTo方法的根本原因是闭包中$this关键字指向了自己，而不是指向某一个对象。</p><p>Laravel<br>中对闭包的使用<br>IoC 容器<br>匿名函数可以从父作用域继承变量，而这个父作用域是定义该闭包的函数（不一定是调用它的函数）。<br>利用这个特性，我们可以实现一个简单的控制反转IoC容器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">class Container</div><div class="line">&#123;</div><div class="line">    protected static $bindings;</div><div class="line"> </div><div class="line">    public static function bind($abstract, Closure $concrete)</div><div class="line">    &#123;</div><div class="line">        static::$bindings[$abstract] = $concrete; </div><div class="line">        //如果还需要container自身的一些方法的话</div><div class="line">        //可以这么写： static::$bindings[$abstract] = $concrete-&gt;bindto($this, $this);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static function make($abstract)</div><div class="line">    &#123;</div><div class="line">        return call_user_func(static::$bindings[$abstract]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">class talk</div><div class="line">&#123;</div><div class="line">    public function greet($target)</div><div class="line">    &#123;</div><div class="line">        echo &apos;Hello &apos; . $target-&gt;getName();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class A</div><div class="line">&#123;</div><div class="line">    public function getName()</div><div class="line">    &#123;</div><div class="line">        return &apos;World&apos;;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 创建一个talk类的实例</div><div class="line">$talk = new talk();</div><div class="line"> </div><div class="line">// 将A类绑定至容器，命名为foo</div><div class="line">Container::bind(&apos;foo&apos;, function() &#123;</div><div class="line">    return new A;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 通过容器取出实例</div><div class="line">$talk-&gt;greet(Container::make(&apos;foo&apos;)); // Hello World</div></pre></td></tr></table></figure></p><p>上述例子中，只有在通过make方法获取实例的时候，实例才被创建，这样使得我们可以实现容器。<br>在Laravel框架底层也大量使用了闭包以及bindTo方法，利用好闭包可以实现更多的高级特性如事件触发等。</p><p>laravel中的控制反转还不是很熟，以后多了解下</p><p>今天说一下对于闭包的重新认识：</p><p>首先是array_map里面的内容。array_map 用到了闭包的知识，函数作用：通过对传入的数组进行自定义的函数处理，传入的数组多少个，自定义的函数接受的参数就要多少个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">array_map(function($i, $z) &#123;</div><div class="line">  var_dump($i+$z);</div><div class="line">&#125;, [1,2,3], [2,3,4]);</div></pre></td></tr></table></figure><p>但如果我们想传入额外的参数呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$z = 100;</div><div class="line">array_map(function($i, $z) use ($z) &#123;</div><div class="line">  var_dump($i+$z);</div><div class="line">&#125;, [1,2,3], [2,3,4]);</div></pre></td></tr></table></figure><p>通过use</p><p>这和我之前看到的内容都是一致的，只是这次我希望不要把这个use和bindto绑定的参数作用弄混淆了，bindto的目的是修改closure类里面this对象.</p><p>对了php的闭包很类似于js的万物皆是对象的概念，function也是对象</p><p>对的php中的匿名函数，也就是闭包，他也是对象，他是closure类的实例</p><p>但和js不同之处，php的对象不能改变，所以匿名函数中的this指向的是closure这个实例，这个实例除了——invoke和 bind（静态方法）bindto() 一无所有</p><p>但是我们可以通过bind，我的理解是让两个实例互相拥有对方的属性，其实不是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Foo</div><div class="line">&#123;</div><div class="line">    private $name;</div><div class="line"></div><div class="line">    function __construct($name)</div><div class="line">    &#123;</div><div class="line">        $this-&gt;name = $name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">$obj = new Foo(&apos;Sam&apos;);</div><div class="line"></div><div class="line">$cl = function() &#123;</div><div class="line">   var_dump($this instanceof Closure); //false</div><div class="line">   var_dump($this instanceof Foo); //true</div><div class="line">    return &quot;Hello &quot; . $this-&gt;name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">$cl = $cl-&gt;bindTo($obj, $obj);</div><div class="line">echo($cl());</div></pre></td></tr></table></figure><p>zzz,感觉绑定之后这个closure的实例就有了家的感觉，就变成了那个被绑定的类了。</p><p>很多时候我们会纠结bindto和bind的区别···其实很简单，一个是静态类，需要::去调用，一个是类的方法，需要自身去调用</p><p>$c = function() {</p><p>};</p><p>$c-&gt;bindto();</p><p>or  Closure::bind($c, , ,);</p><p>so就是多了个参数而已。</p><p>还有bindto的两个参数，主要还是第一个参数是具体的实例，第二个参数就是扩大第一个参数的类的使用权限问题。但仅仅在于扩大原始的不能访问的protected和private，并不扩大注入对象没有关系的或者说注入对象所在类不能访问到的变量。</p><p>还有很重要的一点，我们在使用闭包的时候，function（）{}，这种只是定义了一个变量，并没有使用，我们想使用的换，比逊function() {} (),这样，或者是 function（）{} -&gt;<strong>invoke();这个可以理解成 function（）{}  是一个对象，当我们调用他的时候就自动触发了Closure类里面的\</strong>invoke方法，所以上述是等价的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;咱是写PHP的，可是PHP的很多特性咱都不是很熟，比如trait，闭包，咱不能只局限于表单的操作，不能只局限于面向过程的写法，记录下来那些年很少接触的特性。就从PHP的 &lt;strong&gt;闭包&lt;/strong&gt; 开始咯&lt;br&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="闭包" scheme="http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
</feed>
